'use strict';
var Comunica = function(e) {
  var t = {};

  function r(n) {
    if (t[n]) return t[n].exports;
    var i = t[n] = {
      i: n,
      l: !1,
      exports: {}
    };
    return e[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports
  }
  return r.m = e, r.c = t, r.d = function(e, t, n) {
    r.o(e, t) || Object.defineProperty(e, t, {
      enumerable: !0,
      get: n
    })
  }, r.r = function(e) {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(e, "__esModule", {
      value: !0
    })
  }, r.t = function(e, t) {
    if (1 & t && (e = r(e)), 8 & t) return e;
    if (4 & t && "object" == typeof e && e && e.__esModule) return e;
    var n = Object.create(null);
    if (r.r(n), Object.defineProperty(n, "default", {
      enumerable: !0,
      value: e
    }), 2 & t && "string" != typeof e)
      for (var i in e) r.d(n, i, function(t) {
        return e[t]
      }.bind(null, i));
    return n
  }, r.n = function(e) {
    var t = e && e.__esModule ? function() {
      return e.default
    } : function() {
      return e
    };
    return r.d(t, "a", t), t
  }, r.o = function(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
  }, r.p = "", r(r.s = 190)
}([function(e, t, r) {
  "use strict";
  (function(e) {
    var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
        void 0 === n && (n = r), Object.defineProperty(e, n, {
          enumerable: !0,
          get: function() {
            return t[r]
          }
        })
      } : function(e, t, r, n) {
        void 0 === n && (n = r), e[n] = t[r]
      }),
      i = this && this.__exportStar || function(e, t) {
        for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
      };
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), void 0 !== e && e.env.COMUNICA_DEBUG || (Error.stackTraceLimit = !1), i(r(92), t), i(r(194), t), i(r(195), t), i(r(196), t), i(r(93), t), i(r(197), t)
  }).call(this, r(8))
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(94), t), i(r(111), t), i(r(217), t), i(r(95), t)
}, function(e, t, r) {
  e.exports = i;
  var n = r(22).EventEmitter;

  function i() {
    n.call(this)
  }
  r(12)(i, n), i.Readable = r(71), i.Writable = r(224), i.Duplex = r(225), i.Transform = r(226), i.PassThrough = r(227), i.Stream = i, i.prototype.pipe = function(e, t) {
    var r = this;

    function i(t) {
      e.writable && !1 === e.write(t) && r.pause && r.pause()
    }

    function a() {
      r.readable && r.resume && r.resume()
    }
    r.on("data", i), e.on("drain", a), e._isStdio || t && !1 === t.end || (r.on("end", o), r.on("close", u));
    var s = !1;

    function o() {
      s || (s = !0, e.end())
    }

    function u() {
      s || (s = !0, "function" == typeof e.destroy && e.destroy())
    }

    function c(e) {
      if (l(), 0 === n.listenerCount(this, "error")) throw e
    }

    function l() {
      r.removeListener("data", i), e.removeListener("drain", a), r.removeListener("end", o), r.removeListener("close", u), r.removeListener("error", c), e.removeListener("error", c), r.removeListener("end", l), r.removeListener("close", l), e.removeListener("close", l)
    }
    return r.on("error", c), e.on("error", c), r.on("end", l), r.on("close", l), e.on("close", l), e.emit("pipe", r), e
  }
}, function(e, t, r) {
  "use strict";
  r.r(t), r.d(t, "scheduleTask", (function() {
    return s
  })), r.d(t, "getTaskScheduler", (function() {
    return o
  })), r.d(t, "setTaskScheduler", (function() {
    return u
  })), r.d(t, "INIT", (function() {
    return c
  })), r.d(t, "OPEN", (function() {
    return l
  })), r.d(t, "CLOSING", (function() {
    return h
  })), r.d(t, "CLOSED", (function() {
    return d
  })), r.d(t, "ENDED", (function() {
    return p
  })), r.d(t, "DESTROYED", (function() {
    return f
  })), r.d(t, "AsyncIterator", (function() {
    return g
  })), r.d(t, "EmptyIterator", (function() {
    return _
  })), r.d(t, "SingletonIterator", (function() {
    return v
  })), r.d(t, "ArrayIterator", (function() {
    return w
  })), r.d(t, "IntegerIterator", (function() {
    return S
  })), r.d(t, "BufferedIterator", (function() {
    return T
  })), r.d(t, "TransformIterator", (function() {
    return E
  })), r.d(t, "SimpleTransformIterator", (function() {
    return R
  })), r.d(t, "MultiTransformIterator", (function() {
    return I
  })), r.d(t, "UnionIterator", (function() {
    return N
  })), r.d(t, "ClonedIterator", (function() {
    return C
  })), r.d(t, "wrap", (function() {
    return j
  })), r.d(t, "empty", (function() {
    return k
  })), r.d(t, "single", (function() {
    return L
  })), r.d(t, "fromArray", (function() {
    return M
  })), r.d(t, "union", (function() {
    return F
  })), r.d(t, "range", (function() {
    return B
  }));
  var n = r(22);
  const i = Promise.resolve(void 0);
  let a = function() {
    const e = "function" == typeof queueMicrotask ? queueMicrotask : e => i.then(e);
    if ("undefined" == typeof window) return e;
    let t = 0;
    return r => {
      ++t < 100 ? e(r) : setTimeout(r, t = 0)
    }
  }();

  function s(e) {
    a(e)
  }

  function o() {
    return a
  }

  function u(e) {
    a = e
  }
  const c = 1,
    l = 2,
    h = 4,
    d = 8,
    p = 16,
    f = 32;
  class g extends n.EventEmitter {
    constructor(e = l) {
      super(), this._readable = !1, this._state = e, this.on("newListener", m)
    }
    _changeState(e, t = !1) {
      const r = e > this._state && this._state < p;
      return r && (this._state = e, e === p && (t ? a(() => this.emit("end")) : this.emit("end"))), r
    }
    read() {
      return null
    }
    forEach(e, t) {
      this.on("data", t ? e.bind(t) : e)
    }
    close() {
      this._changeState(d) && this._endAsync()
    }
    destroy(e) {
      this.done || this._destroy(e, t => {
        (e = e || t) && this.emit("error", e), this._end(!0)
      })
    }
    _destroy(e, t) {
      t()
    }
    _end(e = !1) {
      this._changeState(e ? f : p) && (this._readable = !1, this.removeAllListeners("readable"), this.removeAllListeners("data"), this.removeAllListeners("end"))
    }
    _endAsync() {
      a(() => this._end())
    }
    get readable() {
      return this._readable
    }
    set readable(e) {
      e = Boolean(e) && !this.done, this._readable !== e && (this._readable = e, e && a(() => this.emit("readable")))
    }
    get closed() {
      return this._state >= h
    }
    get ended() {
      return this._state === p
    }
    get destroyed() {
      return this._state === f
    }
    get done() {
      return this._state >= p
    }
    toString() {
      const e = this._toStringDetails();
      return `[${this.constructor.name}${e?" "+e:""}]`
    }
    _toStringDetails() {
      return ""
    }
    getProperty(e, t) {
      const r = this._properties;
      if (!t) return r && r[e];
      if (r && e in r) a(() => t(r[e]));
      else {
        let r;
        (r = this._propertyCallbacks) || (this._propertyCallbacks = r = Object.create(null)), e in r ? r[e].push(t) : r[e] = [t]
      }
    }
    setProperty(e, t) {
      (this._properties || (this._properties = Object.create(null)))[e] = t;
      const r = this._propertyCallbacks || {},
        n = r[e];
      if (n) {
        for (e in delete r[e], a(() => {
          for (const e of n) e(t)
        }), r) return;
        delete this._propertyCallbacks
      }
    }
    getProperties() {
      const e = this._properties,
        t = {};
      for (const r in e) t[r] = e[r];
      return t
    }
    setProperties(e) {
      for (const t in e) this.setProperty(t, e[t])
    }
    copyProperties(e, t) {
      for (const r of t) e.getProperty(r, e => this.setProperty(r, e))
    }
    transform(e) {
      return new R(this, e)
    }
    map(e, t) {
      return this.transform({
        map: t ? e.bind(t) : e
      })
    }
    filter(e, t) {
      return this.transform({
        filter: t ? e.bind(t) : e
      })
    }
    prepend(e) {
      return this.transform({
        prepend: e
      })
    }
    append(e) {
      return this.transform({
        append: e
      })
    }
    surround(e, t) {
      return this.transform({
        prepend: e,
        append: t
      })
    }
    skip(e) {
      return this.transform({
        offset: e
      })
    }
    take(e) {
      return this.transform({
        limit: e
      })
    }
    range(e, t) {
      return this.transform({
        offset: e,
        limit: Math.max(t - e + 1, 0)
      })
    }
    clone() {
      return new C(this)
    }
  }

  function m(e) {
    "data" === e && (this.removeListener("newListener", m), b(this, "readable", y), this.readable && a(() => y.call(this)))
  }

  function y() {
    let e;
    for (; 0 !== this.listenerCount("data") && null !== (e = this.read());) this.emit("data", e);
    0 !== this.listenerCount("data") || this.done || (this.removeListener("readable", y), b(this, "newListener", m))
  }

  function b(e, t, r) {
    e.listeners(t).includes(r) || e.on(t, r)
  }
  class _ extends g {
    constructor() {
      super(), this._changeState(p, !0)
    }
  }
  class v extends g {
    constructor(e) {
      super(), this._item = e, null === e ? this.close() : this.readable = !0
    }
    read() {
      const e = this._item;
      return this._item = null, this.close(), e
    }
    _toStringDetails() {
      return null === this._item ? "" : `(${this._item})`
    }
  }
  class w extends g {
    constructor(e, {
      autoStart: t = !0
    } = {}) {
      super();
      const r = e ? [...e] : [];
      !1 !== t && 0 === r.length ? this.close() : (this.readable = !0, this._buffer = r)
    }
    read() {
      let e = null;
      const t = this._buffer;
      return t && (0 !== t.length && (e = t.shift()), 0 === t.length && (delete this._buffer, this.close())), e
    }
    _toStringDetails() {
      return `(${this._buffer&&this._buffer.length||0})`
    }
    _destroy(e, t) {
      delete this._buffer, t()
    }
  }
  class S extends g {
    constructor({
                  start: e = 0,
                  step: t = 1,
                  end: r
                } = {}) {
      super(), Number.isFinite(e) && (e = Math.trunc(e)), this._next = e, Number.isFinite(t) && (t = Math.trunc(t)), this._step = t;
      const n = t >= 0,
        i = n ? 1 / 0 : -1 / 0;
      Number.isFinite(r) ? r = Math.trunc(r) : r !== -i && (r = i), this._last = r, !Number.isFinite(e) || (n ? e > r : e < r) ? this.close() : this.readable = !0
    }
    read() {
      if (this.closed) return null;
      const e = this._next,
        t = this._step,
        r = this._last,
        n = this._next += t;
      return (t >= 0 ? n > r : n < r) && this.close(), e
    }
    _toStringDetails() {
      return `(${this._next}...${this._last})`
    }
  }
  class T extends g {
    constructor({
                  maxBufferSize: e = 4,
                  autoStart: t = !0
                } = {}) {
      super(c), this._buffer = [], this._maxBufferSize = 4, this._reading = !0, this._pushedCount = 0, this.maxBufferSize = e, a(() => this._init(t))
    }
    get maxBufferSize() {
      return this._maxBufferSize
    }
    set maxBufferSize(e) {
      e !== 1 / 0 && (e = Number.isFinite(e) ? Math.max(Math.trunc(e), 1) : 4), this._maxBufferSize !== e && (this._maxBufferSize = e, this._state === l && this._fillBuffer())
    }
    _init(e) {
      let t = !1;
      this._reading = !0, this._begin(() => {
        if (t) throw new Error("done callback called multiple times");
        t = !0, this._reading = !1, this._changeState(l), e ? this._fillBufferAsync() : this.readable = !0
      })
    }
    _begin(e) {
      e()
    }
    read() {
      if (this.done) return null;
      const e = this._buffer;
      let t;
      return 0 !== e.length ? t = e.shift() : (t = null, this.readable = !1), !this._reading && e.length < this._maxBufferSize && (this.closed ? e.length || this._endAsync() : this._fillBufferAsync()), t
    }
    _read(e, t) {
      t()
    }
    _push(e) {
      this.done || (this._pushedCount++, this._buffer.push(e), this.readable = !0)
    }
    _fillBuffer() {
      let e;
      this._reading || (this.closed ? this._completeClose() : (e = Math.min(this._maxBufferSize - this._buffer.length, 128)) > 0 && (this._pushedCount = 0, this._reading = !0, this._read(e, () => {
        if (!e) throw new Error("done callback called multiple times");
        e = 0, this._reading = !1, this.closed ? this._completeClose() : this._pushedCount && (this.readable = !0, this._buffer.length < this._maxBufferSize / 2 && this._fillBufferAsync())
      })))
    }
    _fillBufferAsync() {
      this._reading || (this._reading = !0, a(() => {
        this._reading = !1, this._fillBuffer()
      }))
    }
    close() {
      this._reading ? this._changeState(h) : this._completeClose()
    }
    _completeClose() {
      this._changeState(d) && (this._reading = !0, this._flush(() => {
        if (!this._reading) throw new Error("done callback called multiple times");
        this._reading = !1, this._buffer.length || this._endAsync()
      }))
    }
    _destroy(e, t) {
      this._buffer = [], t()
    }
    _flush(e) {
      e()
    }
    _toStringDetails() {
      const e = this._buffer,
        {
          length: t
        } = e;
      return `{${t?`next: ${e[0]}, `:""}buffer: ${t}}`
    }
  }
  class E extends T {
    constructor(e, t = e || {}) {
      super(t), this._boundPush = e => this._push(e), H(e) || (e = t.source), this._sourceStarted = !1 !== t.autoStart, U(e) ? this.source = e : e && (this._createSource = V(e) ? () => e : e, this._sourceStarted && this._loadSourceAsync()), this._optional = Boolean(t.optional), this._destroySource = !1 !== t.destroySource
    }
    get source() {
      return q(this._createSource) && this._loadSourceAsync(), this._source
    }
    set source(e) {
      const t = this._source = this._validateSource(e);
      t._destination = this, t.done ? this.close() : (t.on("end", O), t.on("readable", A), t.on("error", x))
    }
    _loadSourceAsync() {
      q(this._createSource) && (Promise.resolve(this._createSource()).then(e => {
        delete this._createSource, this.source = e, this._fillBuffer()
      }, e => this.emit("error", e)), this._createSource = null)
    }
    _validateSource(e, t = !1) {
      if (this._source || void 0 !== this._createSource) throw new Error("The source cannot be changed after it has been set");
      if (!e || !q(e.read) || !q(e.on)) throw new Error("Invalid source: " + e);
      if (!t && e._destination) throw new Error("The source already has a destination");
      return e
    }
    read() {
      return this._sourceStarted || (this._sourceStarted = !0), super.read()
    }
    _read(e, t) {
      const r = () => {
        this._pushedCount < e && !this.closed ? a(() => this._readAndTransform(r, t)) : t()
      };
      this._readAndTransform(r, t)
    }
    _readAndTransform(e, t) {
      let r;
      const n = this.source;
      !n || n.done || null === (r = n.read()) ? t() : this._optional ? this._optionalTransform(r, e) : this._transform(r, e, this._boundPush)
    }
    _optionalTransform(e, t) {
      const r = this._pushedCount;
      this._transform(e, () => {
        r === this._pushedCount && this._push(e), t()
      }, this._boundPush)
    }
    _transform(e, t, r) {
      r(e), t()
    }
    _closeWhenDone() {
      this.close()
    }
    _end(e) {
      const t = this._source;
      t && (t.removeListener("end", O), t.removeListener("error", x), t.removeListener("readable", A), delete t._destination, this._destroySource && t.destroy()), super._end(e)
    }
  }

  function x(e) {
    this._destination.emit("error", e)
  }

  function O() {
    this._destination._closeWhenDone()
  }

  function A() {
    !1 !== this._destination._sourceStarted && this._destination._fillBuffer()
  }
  class R extends E {
    constructor(e, t) {
      if (super(e, t), this._offset = 0, this._limit = 1 / 0, this._filter = e => !0, t = t || (H(e) ? null : e)) {
        const e = q(t) ? t : t.transform,
          {
            limit: r,
            offset: n,
            filter: i,
            map: a,
            prepend: s,
            append: o
          } = t;
        n === 1 / 0 || r === -1 / 0 ? this._limit = 0 : (Number.isFinite(n) && (this._offset = Math.max(Math.trunc(n), 0)), Number.isFinite(r) && (this._limit = Math.max(Math.trunc(r), 0)), q(i) && (this._filter = i), q(a) && (this._map = a), this._transform = q(e) ? e : null), s && (this._prepender = U(s) ? s : M(s)), o && (this._appender = U(o) ? o : M(o))
      }
    }
    _read(e, t) {
      const r = () => this._readAndTransformSimple(e, n, t);

      function n() {
        a(r)
      }
      this._readAndTransformSimple(e, n, t)
    }
    _readAndTransformSimple(e, t, r) {
      let n;
      const {
        source: i
      } = this;
      if (i && !i.done) {
        for (0 === this._limit && this.close(); !this.closed && this._pushedCount < e && null !== (n = i.read());) {
          if (!this._filter(n) || 0 !== this._offset && this._offset--) continue;
          const e = void 0 === this._map ? n : this._map(n);
          if (null === e) this._optional && this._push(n);
          else {
            if (q(this._transform)) return void(this._optional ? this._optionalTransform(e, t) : this._transform(e, t, this._boundPush));
            this._push(e)
          }
          0 == --this._limit && this.close()
        }
        r()
      } else r()
    }
    _begin(e) {
      this._insert(this._prepender, e), delete this._prepender
    }
    _flush(e) {
      this._insert(this._appender, e), delete this._appender
    }
    _insert(e, t) {
      const r = e => this._push(e);
      !e || e.done ? t() : (e.on("data", r), e.on("end", (function n() {
        e.removeListener("data", r), e.removeListener("end", n), t()
      })))
    }
  }
  class I extends E {
    constructor(e, t) {
      if (super(e, t), this._transformerQueue = [], t) {
        const e = q(t) ? t : t.multiTransform;
        e && (this._createTransformer = e)
      }
    }
    _read(e, t) {
      const r = this._transformerQueue,
        n = this._optional;
      let i, a;
      for (;
        (i = r[0]) && i.transformer.done;) {
        n && null !== i.item && (e--, this._push(i.item)), r.shift();
        const {
          transformer: t
        } = i;
        t.removeListener("end", A), t.removeListener("readable", A), t.removeListener("error", x)
      }
      const {
        source: s
      } = this;
      for (; s && !s.done && r.length < this.maxBufferSize && (a = s.read(), null !== a);) {
        const e = this._createTransformer(a) || new _;
        e._destination = this, e.on("end", A), e.on("readable", A), e.on("error", x), r.push({
          transformer: e,
          item: a
        })
      }
      if (i = r[0], i) {
        const {
          transformer: t
        } = i;
        for (; e-- > 0 && null !== (a = t.read());) this._push(a), n && (i.item = null)
      } else s && s.done && this.close();
      t()
    }
    _createTransformer(e) {
      return new v(e)
    }
    _closeWhenDone() {
      this._transformerQueue.length || this.close()
    }
  }
  class N extends T {
    constructor(e, t = {}) {
      super(t), this._sources = [], this._currentSource = -1;
      const r = !1 !== t.autoStart;
      if (U(e)) e.on("error", e => this.emit("error", e)), this._pending = {
        sources: e
      }, r && this._loadSources();
      else if (Array.isArray(e) && e.length > 0)
        for (const t of e) this._addSource(t);
      else r && this.close()
    }
    _loadSources() {
      const e = this._pending.sources;
      delete this._pending.sources, e.done ? (delete this._pending, this.close()) : (e.on("data", e => {
        this._addSource(e), this._fillBufferAsync()
      }), e.on("end", () => {
        delete this._pending, this._fillBuffer()
      }))
    }
    _addSource(e) {
      e.done || (this._sources.push(e), e._destination = this, e.on("error", x), e.on("readable", A), e.on("end", P))
    }
    _removeEmptySources() {
      this._sources = this._sources.filter((e, t) => (e.done && t <= this._currentSource && this._currentSource--, !e.done)), this._fillBuffer()
    }
    _read(e, t) {
      var r;
      (null === (r = this._pending) || void 0 === r ? void 0 : r.sources) && this._loadSources();
      let n, i = 0;
      for (; i !== (i = e);)
        for (let t = 0; t < this._sources.length && e > 0; t++) {
          this._currentSource = (this._currentSource + 1) % this._sources.length;
          null !== (n = this._sources[this._currentSource].read()) && (e--, this._push(n))
        }
      this._pending || 0 !== this._sources.length || this.close(), t()
    }
  }

  function P() {
    this._destination._removeEmptySources()
  }
  class C extends E {
    constructor(e) {
      super(e, {
        autoStart: !1
      }), this._readPosition = 0, this._reading = !1
    }
    _init() {}
    close() {
      g.prototype.close.call(this)
    }
    get source() {
      return super.source
    }
    set source(e) {
      const t = this._source = this._validateSource(e),
        r = t && t._destination || (t._destination = new D(t));
      r.endsAt(0) ? this.close() : (r.register(this), null !== r.readAt(0) && (this.readable = !0));
      const n = this._propertyCallbacks;
      for (const e in n) {
        const t = n[e];
        for (const r of t) this._getSourceProperty(e, r)
      }
    }
    _validateSource(e, t = !1) {
      const r = e && e._destination;
      return super._validateSource(e, !r || r instanceof D)
    }
    getProperty(e, t) {
      const {
        source: r
      } = this, n = this._properties, i = n && e in n;
      if (!t) return i ? n && n[e] : r && r.getProperty(e);
      super.getProperty(e, t), r && !i && this._getSourceProperty(e, t)
    }
    _getSourceProperty(e, t) {
      this.source.getProperty(e, r => {
        this._properties && e in this._properties || t(r)
      })
    }
    getProperties() {
      const e = this.source ? this.source.getProperties() : {},
        t = this._properties;
      for (const r in t) e[r] = t[r];
      return e
    }
    _toStringDetails() {
      return `{source: ${this.source?this.source.toString():"none"}}`
    }
    read() {
      const e = this.source;
      let t = null;
      if (!this.done && e) {
        const r = e._destination;
        null !== (t = r.readAt(this._readPosition)) ? this._readPosition++ : this.readable = !1, r.endsAt(this._readPosition) && this.close()
      }
      return t
    }
    _end(e) {
      const t = this.source,
        r = null == t ? void 0 : t._destination;
      r && r.unregister(this), T.prototype._end.call(this, e)
    }
  }
  class D {
    constructor(e) {
      if (this._clones = null, this._history = [], this._source = e, !e.done) {
        const t = () => {
            for (const e of this._clones) e.readable = !0
          },
          r = e => {
            for (const t of this._clones) t.emit("error", e)
          },
          n = () => {
            for (const e of this._clones) e._readPosition === this._history.length && e.close();
            this._clones = null, e.removeListener("end", n), e.removeListener("error", r), e.removeListener("readable", t)
          };
        this._clones = [], e.on("end", n), e.on("error", r), e.on("readable", t)
      }
    }
    register(e) {
      null !== this._clones && this._clones.push(e)
    }
    unregister(e) {
      null !== this._clones && (this._clones = this._clones.filter(t => t !== e))
    }
    readAt(e) {
      let t = null;
      return e < this._history.length ? t = this._history[e] : this._source.done || null === (t = this._source.read()) || (this._history[e] = t), t
    }
    endsAt(e) {
      return this._source.done && this._history.length === e
    }
  }

  function j(e, t) {
    return new E(e, t)
  }

  function k() {
    return new _
  }

  function L(e) {
    return new v(e)
  }

  function M(e) {
    return new w(e)
  }

  function F(e) {
    return new N(e)
  }

  function B(e, t, r) {
    return new S({
      start: e,
      end: t,
      step: r
    })
  }

  function q(e) {
    return "function" == typeof e
  }

  function U(e) {
    return e && "function" == typeof e.on
  }

  function V(e) {
    return e && "function" == typeof e.then
  }

  function H(e) {
    return e && (U(e) || V(e) || q(e))
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.termToString = t.stringToTerm = t.stringQuadToQuad = t.quadToStringQuad = t.getLiteralValue = t.getLiteralType = t.getLiteralLanguage = void 0;
  const n = r(198);
  Object.defineProperty(t, "getLiteralLanguage", {
    enumerable: !0,
    get: function() {
      return n.getLiteralLanguage
    }
  }), Object.defineProperty(t, "getLiteralType", {
    enumerable: !0,
    get: function() {
      return n.getLiteralType
    }
  }), Object.defineProperty(t, "getLiteralValue", {
    enumerable: !0,
    get: function() {
      return n.getLiteralValue
    }
  }), Object.defineProperty(t, "quadToStringQuad", {
    enumerable: !0,
    get: function() {
      return n.quadToStringQuad
    }
  }), Object.defineProperty(t, "stringQuadToQuad", {
    enumerable: !0,
    get: function() {
      return n.stringQuadToQuad
    }
  }), Object.defineProperty(t, "stringToTerm", {
    enumerable: !0,
    get: function() {
      return n.stringToTerm
    }
  }), Object.defineProperty(t, "termToString", {
    enumerable: !0,
    get: function() {
      return n.termToString
    }
  })
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(96), t), i(r(199), t), i(r(97), t), i(r(98), t), i(r(68), t), i(r(99), t), i(r(100), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Util = t.toSparqlJs = t.toSparql = t.Factory = t.Algebra = t.translate = void 0;
  const n = r(200);
  t.translate = n.default;
  const i = r(52);
  t.Algebra = i;
  const a = r(53);
  t.Factory = a.default;
  const s = r(216);
  Object.defineProperty(t, "toSparql", {
    enumerable: !0,
    get: function() {
      return s.toSparql
    }
  }), Object.defineProperty(t, "toSparqlJs", {
    enumerable: !0,
    get: function() {
      return s.toSparqlJs
    }
  });
  const o = r(70);
  t.Util = o.default
}, function(e, t, r) {
  "use strict";
  var n = "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    i = "http://www.w3.org/2001/XMLSchema#",
    a = "http://www.w3.org/2000/10/swap/";
  t.a = {
    xsd: {
      decimal: i + "decimal",
      boolean: i + "boolean",
      double: i + "double",
      integer: i + "integer",
      string: i + "string"
    },
    rdf: {
      type: n + "type",
      nil: n + "nil",
      first: n + "first",
      rest: n + "rest",
      langString: n + "langString"
    },
    owl: {
      sameAs: "http://www.w3.org/2002/07/owl#sameAs"
    },
    r: {
      forSome: a + "reify#forSome",
      forAll: a + "reify#forAll"
    },
    log: {
      implies: a + "log#implies"
    }
  }
}, function(e, t) {
  var r, n, i = e.exports = {};

  function a() {
    throw new Error("setTimeout has not been defined")
  }

  function s() {
    throw new Error("clearTimeout has not been defined")
  }

  function o(e) {
    if (r === setTimeout) return setTimeout(e, 0);
    if ((r === a || !r) && setTimeout) return r = setTimeout, setTimeout(e, 0);
    try {
      return r(e, 0)
    } catch (t) {
      try {
        return r.call(null, e, 0)
      } catch (t) {
        return r.call(this, e, 0)
      }
    }
  }! function() {
    try {
      r = "function" == typeof setTimeout ? setTimeout : a
    } catch (e) {
      r = a
    }
    try {
      n = "function" == typeof clearTimeout ? clearTimeout : s
    } catch (e) {
      n = s
    }
  }();
  var u, c = [],
    l = !1,
    h = -1;

  function d() {
    l && u && (l = !1, u.length ? c = u.concat(c) : h = -1, c.length && p())
  }

  function p() {
    if (!l) {
      var e = o(d);
      l = !0;
      for (var t = c.length; t;) {
        for (u = c, c = []; ++h < t;) u && u[h].run();
        h = -1, t = c.length
      }
      u = null, l = !1,
        function(e) {
          if (n === clearTimeout) return clearTimeout(e);
          if ((n === s || !n) && clearTimeout) return n = clearTimeout, clearTimeout(e);
          try {
            n(e)
          } catch (t) {
            try {
              return n.call(null, e)
            } catch (t) {
              return n.call(this, e)
            }
          }
        }(e)
    }
  }

  function f(e, t) {
    this.fun = e, this.array = t
  }

  function g() {}
  i.nextTick = function(e) {
    var t = new Array(arguments.length - 1);
    if (arguments.length > 1)
      for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
    c.push(new f(e, t)), 1 !== c.length || l || o(p)
  }, f.prototype.run = function() {
    this.fun.apply(null, this.array)
  }, i.title = "browser", i.browser = !0, i.env = {}, i.argv = [], i.version = "", i.versions = {}, i.on = g, i.addListener = g, i.once = g, i.off = g, i.removeListener = g, i.removeAllListeners = g, i.emit = g, i.prependListener = g, i.prependOnceListener = g, i.listeners = function(e) {
    return []
  }, i.binding = function(e) {
    throw new Error("process.binding is not supported")
  }, i.cwd = function() {
    return "/"
  }, i.chdir = function(e) {
    throw new Error("process.chdir is not supported")
  }, i.umask = function() {
    return 0
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(149), t), i(r(47), t), i(r(150), t), i(r(333), t), i(r(334), t), i(r(152), t), i(r(83), t)
}, function(e, t) {
  var r;
  r = function() {
    return this
  }();
  try {
    r = r || new Function("return this")()
  } catch (e) {
    "object" == typeof window && (r = window)
  }
  e.exports = r
}, function(e, t, r) {
  "use strict";
  (function(e) {
    /*!
         * The buffer module from node.js, for the browser.
         *
         * @author   Feross Aboukhadijeh <http://feross.org>
         * @license  MIT
         */
    var n = r(202),
      i = r(203),
      a = r(103);

    function s() {
      return u.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823
    }

    function o(e, t) {
      if (s() < t) throw new RangeError("Invalid typed array length");
      return u.TYPED_ARRAY_SUPPORT ? (e = new Uint8Array(t)).__proto__ = u.prototype : (null === e && (e = new u(t)), e.length = t), e
    }

    function u(e, t, r) {
      if (!(u.TYPED_ARRAY_SUPPORT || this instanceof u)) return new u(e, t, r);
      if ("number" == typeof e) {
        if ("string" == typeof t) throw new Error("If encoding is specified then the first argument must be a string");
        return h(this, e)
      }
      return c(this, e, t, r)
    }

    function c(e, t, r, n) {
      if ("number" == typeof t) throw new TypeError('"value" argument must not be a number');
      return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer ? function(e, t, r, n) {
        if (t.byteLength, r < 0 || t.byteLength < r) throw new RangeError("'offset' is out of bounds");
        if (t.byteLength < r + (n || 0)) throw new RangeError("'length' is out of bounds");
        t = void 0 === r && void 0 === n ? new Uint8Array(t) : void 0 === n ? new Uint8Array(t, r) : new Uint8Array(t, r, n);
        u.TYPED_ARRAY_SUPPORT ? (e = t).__proto__ = u.prototype : e = d(e, t);
        return e
      }(e, t, r, n) : "string" == typeof t ? function(e, t, r) {
        "string" == typeof r && "" !== r || (r = "utf8");
        if (!u.isEncoding(r)) throw new TypeError('"encoding" must be a valid string encoding');
        var n = 0 | f(t, r),
          i = (e = o(e, n)).write(t, r);
        i !== n && (e = e.slice(0, i));
        return e
      }(e, t, r) : function(e, t) {
        if (u.isBuffer(t)) {
          var r = 0 | p(t.length);
          return 0 === (e = o(e, r)).length || t.copy(e, 0, 0, r), e
        }
        if (t) {
          if ("undefined" != typeof ArrayBuffer && t.buffer instanceof ArrayBuffer || "length" in t) return "number" != typeof t.length || (n = t.length) != n ? o(e, 0) : d(e, t);
          if ("Buffer" === t.type && a(t.data)) return d(e, t.data)
        }
        var n;
        throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")
      }(e, t)
    }

    function l(e) {
      if ("number" != typeof e) throw new TypeError('"size" argument must be a number');
      if (e < 0) throw new RangeError('"size" argument must not be negative')
    }

    function h(e, t) {
      if (l(t), e = o(e, t < 0 ? 0 : 0 | p(t)), !u.TYPED_ARRAY_SUPPORT)
        for (var r = 0; r < t; ++r) e[r] = 0;
      return e
    }

    function d(e, t) {
      var r = t.length < 0 ? 0 : 0 | p(t.length);
      e = o(e, r);
      for (var n = 0; n < r; n += 1) e[n] = 255 & t[n];
      return e
    }

    function p(e) {
      if (e >= s()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s().toString(16) + " bytes");
      return 0 | e
    }

    function f(e, t) {
      if (u.isBuffer(e)) return e.length;
      if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)) return e.byteLength;
      "string" != typeof e && (e = "" + e);
      var r = e.length;
      if (0 === r) return 0;
      for (var n = !1;;) switch (t) {
        case "ascii":
        case "latin1":
        case "binary":
          return r;
        case "utf8":
        case "utf-8":
        case void 0:
          return q(e).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return 2 * r;
        case "hex":
          return r >>> 1;
        case "base64":
          return U(e).length;
        default:
          if (n) return q(e).length;
          t = ("" + t).toLowerCase(), n = !0
      }
    }

    function g(e, t, r) {
      var n = !1;
      if ((void 0 === t || t < 0) && (t = 0), t > this.length) return "";
      if ((void 0 === r || r > this.length) && (r = this.length), r <= 0) return "";
      if ((r >>>= 0) <= (t >>>= 0)) return "";
      for (e || (e = "utf8");;) switch (e) {
        case "hex":
          return I(this, t, r);
        case "utf8":
        case "utf-8":
          return O(this, t, r);
        case "ascii":
          return A(this, t, r);
        case "latin1":
        case "binary":
          return R(this, t, r);
        case "base64":
          return x(this, t, r);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return N(this, t, r);
        default:
          if (n) throw new TypeError("Unknown encoding: " + e);
          e = (e + "").toLowerCase(), n = !0
      }
    }

    function m(e, t, r) {
      var n = e[t];
      e[t] = e[r], e[r] = n
    }

    function y(e, t, r, n, i) {
      if (0 === e.length) return -1;
      if ("string" == typeof r ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : r < -2147483648 && (r = -2147483648), r = +r, isNaN(r) && (r = i ? 0 : e.length - 1), r < 0 && (r = e.length + r), r >= e.length) {
        if (i) return -1;
        r = e.length - 1
      } else if (r < 0) {
        if (!i) return -1;
        r = 0
      }
      if ("string" == typeof t && (t = u.from(t, n)), u.isBuffer(t)) return 0 === t.length ? -1 : b(e, t, r, n, i);
      if ("number" == typeof t) return t &= 255, u.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(e, t, r) : Uint8Array.prototype.lastIndexOf.call(e, t, r) : b(e, [t], r, n, i);
      throw new TypeError("val must be string, number or Buffer")
    }

    function b(e, t, r, n, i) {
      var a, s = 1,
        o = e.length,
        u = t.length;
      if (void 0 !== n && ("ucs2" === (n = String(n).toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
        if (e.length < 2 || t.length < 2) return -1;
        s = 2, o /= 2, u /= 2, r /= 2
      }

      function c(e, t) {
        return 1 === s ? e[t] : e.readUInt16BE(t * s)
      }
      if (i) {
        var l = -1;
        for (a = r; a < o; a++)
          if (c(e, a) === c(t, -1 === l ? 0 : a - l)) {
            if (-1 === l && (l = a), a - l + 1 === u) return l * s
          } else -1 !== l && (a -= a - l), l = -1
      } else
        for (r + u > o && (r = o - u), a = r; a >= 0; a--) {
          for (var h = !0, d = 0; d < u; d++)
            if (c(e, a + d) !== c(t, d)) {
              h = !1;
              break
            } if (h) return a
        }
      return -1
    }

    function _(e, t, r, n) {
      r = Number(r) || 0;
      var i = e.length - r;
      n ? (n = Number(n)) > i && (n = i) : n = i;
      var a = t.length;
      if (a % 2 != 0) throw new TypeError("Invalid hex string");
      n > a / 2 && (n = a / 2);
      for (var s = 0; s < n; ++s) {
        var o = parseInt(t.substr(2 * s, 2), 16);
        if (isNaN(o)) return s;
        e[r + s] = o
      }
      return s
    }

    function v(e, t, r, n) {
      return V(q(t, e.length - r), e, r, n)
    }

    function w(e, t, r, n) {
      return V(function(e) {
        for (var t = [], r = 0; r < e.length; ++r) t.push(255 & e.charCodeAt(r));
        return t
      }(t), e, r, n)
    }

    function S(e, t, r, n) {
      return w(e, t, r, n)
    }

    function T(e, t, r, n) {
      return V(U(t), e, r, n)
    }

    function E(e, t, r, n) {
      return V(function(e, t) {
        for (var r, n, i, a = [], s = 0; s < e.length && !((t -= 2) < 0); ++s) r = e.charCodeAt(s), n = r >> 8, i = r % 256, a.push(i), a.push(n);
        return a
      }(t, e.length - r), e, r, n)
    }

    function x(e, t, r) {
      return 0 === t && r === e.length ? n.fromByteArray(e) : n.fromByteArray(e.slice(t, r))
    }

    function O(e, t, r) {
      r = Math.min(e.length, r);
      for (var n = [], i = t; i < r;) {
        var a, s, o, u, c = e[i],
          l = null,
          h = c > 239 ? 4 : c > 223 ? 3 : c > 191 ? 2 : 1;
        if (i + h <= r) switch (h) {
          case 1:
            c < 128 && (l = c);
            break;
          case 2:
            128 == (192 & (a = e[i + 1])) && (u = (31 & c) << 6 | 63 & a) > 127 && (l = u);
            break;
          case 3:
            a = e[i + 1], s = e[i + 2], 128 == (192 & a) && 128 == (192 & s) && (u = (15 & c) << 12 | (63 & a) << 6 | 63 & s) > 2047 && (u < 55296 || u > 57343) && (l = u);
            break;
          case 4:
            a = e[i + 1], s = e[i + 2], o = e[i + 3], 128 == (192 & a) && 128 == (192 & s) && 128 == (192 & o) && (u = (15 & c) << 18 | (63 & a) << 12 | (63 & s) << 6 | 63 & o) > 65535 && u < 1114112 && (l = u)
        }
        null === l ? (l = 65533, h = 1) : l > 65535 && (l -= 65536, n.push(l >>> 10 & 1023 | 55296), l = 56320 | 1023 & l), n.push(l), i += h
      }
      return function(e) {
        var t = e.length;
        if (t <= 4096) return String.fromCharCode.apply(String, e);
        var r = "",
          n = 0;
        for (; n < t;) r += String.fromCharCode.apply(String, e.slice(n, n += 4096));
        return r
      }(n)
    }
    t.Buffer = u, t.SlowBuffer = function(e) {
      +e != e && (e = 0);
      return u.alloc(+e)
    }, t.INSPECT_MAX_BYTES = 50, u.TYPED_ARRAY_SUPPORT = void 0 !== e.TYPED_ARRAY_SUPPORT ? e.TYPED_ARRAY_SUPPORT : function() {
      try {
        var e = new Uint8Array(1);
        return e.__proto__ = {
          __proto__: Uint8Array.prototype,
          foo: function() {
            return 42
          }
        }, 42 === e.foo() && "function" == typeof e.subarray && 0 === e.subarray(1, 1).byteLength
      } catch (e) {
        return !1
      }
    }(), t.kMaxLength = s(), u.poolSize = 8192, u._augment = function(e) {
      return e.__proto__ = u.prototype, e
    }, u.from = function(e, t, r) {
      return c(null, e, t, r)
    }, u.TYPED_ARRAY_SUPPORT && (u.prototype.__proto__ = Uint8Array.prototype, u.__proto__ = Uint8Array, "undefined" != typeof Symbol && Symbol.species && u[Symbol.species] === u && Object.defineProperty(u, Symbol.species, {
      value: null,
      configurable: !0
    })), u.alloc = function(e, t, r) {
      return function(e, t, r, n) {
        return l(t), t <= 0 ? o(e, t) : void 0 !== r ? "string" == typeof n ? o(e, t).fill(r, n) : o(e, t).fill(r) : o(e, t)
      }(null, e, t, r)
    }, u.allocUnsafe = function(e) {
      return h(null, e)
    }, u.allocUnsafeSlow = function(e) {
      return h(null, e)
    }, u.isBuffer = function(e) {
      return !(null == e || !e._isBuffer)
    }, u.compare = function(e, t) {
      if (!u.isBuffer(e) || !u.isBuffer(t)) throw new TypeError("Arguments must be Buffers");
      if (e === t) return 0;
      for (var r = e.length, n = t.length, i = 0, a = Math.min(r, n); i < a; ++i)
        if (e[i] !== t[i]) {
          r = e[i], n = t[i];
          break
        } return r < n ? -1 : n < r ? 1 : 0
    }, u.isEncoding = function(e) {
      switch (String(e).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1
      }
    }, u.concat = function(e, t) {
      if (!a(e)) throw new TypeError('"list" argument must be an Array of Buffers');
      if (0 === e.length) return u.alloc(0);
      var r;
      if (void 0 === t)
        for (t = 0, r = 0; r < e.length; ++r) t += e[r].length;
      var n = u.allocUnsafe(t),
        i = 0;
      for (r = 0; r < e.length; ++r) {
        var s = e[r];
        if (!u.isBuffer(s)) throw new TypeError('"list" argument must be an Array of Buffers');
        s.copy(n, i), i += s.length
      }
      return n
    }, u.byteLength = f, u.prototype._isBuffer = !0, u.prototype.swap16 = function() {
      var e = this.length;
      if (e % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var t = 0; t < e; t += 2) m(this, t, t + 1);
      return this
    }, u.prototype.swap32 = function() {
      var e = this.length;
      if (e % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var t = 0; t < e; t += 4) m(this, t, t + 3), m(this, t + 1, t + 2);
      return this
    }, u.prototype.swap64 = function() {
      var e = this.length;
      if (e % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var t = 0; t < e; t += 8) m(this, t, t + 7), m(this, t + 1, t + 6), m(this, t + 2, t + 5), m(this, t + 3, t + 4);
      return this
    }, u.prototype.toString = function() {
      var e = 0 | this.length;
      return 0 === e ? "" : 0 === arguments.length ? O(this, 0, e) : g.apply(this, arguments)
    }, u.prototype.equals = function(e) {
      if (!u.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
      return this === e || 0 === u.compare(this, e)
    }, u.prototype.inspect = function() {
      var e = "",
        r = t.INSPECT_MAX_BYTES;
      return this.length > 0 && (e = this.toString("hex", 0, r).match(/.{2}/g).join(" "), this.length > r && (e += " ... ")), "<Buffer " + e + ">"
    }, u.prototype.compare = function(e, t, r, n, i) {
      if (!u.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
      if (void 0 === t && (t = 0), void 0 === r && (r = e ? e.length : 0), void 0 === n && (n = 0), void 0 === i && (i = this.length), t < 0 || r > e.length || n < 0 || i > this.length) throw new RangeError("out of range index");
      if (n >= i && t >= r) return 0;
      if (n >= i) return -1;
      if (t >= r) return 1;
      if (this === e) return 0;
      for (var a = (i >>>= 0) - (n >>>= 0), s = (r >>>= 0) - (t >>>= 0), o = Math.min(a, s), c = this.slice(n, i), l = e.slice(t, r), h = 0; h < o; ++h)
        if (c[h] !== l[h]) {
          a = c[h], s = l[h];
          break
        } return a < s ? -1 : s < a ? 1 : 0
    }, u.prototype.includes = function(e, t, r) {
      return -1 !== this.indexOf(e, t, r)
    }, u.prototype.indexOf = function(e, t, r) {
      return y(this, e, t, r, !0)
    }, u.prototype.lastIndexOf = function(e, t, r) {
      return y(this, e, t, r, !1)
    }, u.prototype.write = function(e, t, r, n) {
      if (void 0 === t) n = "utf8", r = this.length, t = 0;
      else if (void 0 === r && "string" == typeof t) n = t, r = this.length, t = 0;
      else {
        if (!isFinite(t)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        t |= 0, isFinite(r) ? (r |= 0, void 0 === n && (n = "utf8")) : (n = r, r = void 0)
      }
      var i = this.length - t;
      if ((void 0 === r || r > i) && (r = i), e.length > 0 && (r < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
      n || (n = "utf8");
      for (var a = !1;;) switch (n) {
        case "hex":
          return _(this, e, t, r);
        case "utf8":
        case "utf-8":
          return v(this, e, t, r);
        case "ascii":
          return w(this, e, t, r);
        case "latin1":
        case "binary":
          return S(this, e, t, r);
        case "base64":
          return T(this, e, t, r);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return E(this, e, t, r);
        default:
          if (a) throw new TypeError("Unknown encoding: " + n);
          n = ("" + n).toLowerCase(), a = !0
      }
    }, u.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    };

    function A(e, t, r) {
      var n = "";
      r = Math.min(e.length, r);
      for (var i = t; i < r; ++i) n += String.fromCharCode(127 & e[i]);
      return n
    }

    function R(e, t, r) {
      var n = "";
      r = Math.min(e.length, r);
      for (var i = t; i < r; ++i) n += String.fromCharCode(e[i]);
      return n
    }

    function I(e, t, r) {
      var n = e.length;
      (!t || t < 0) && (t = 0), (!r || r < 0 || r > n) && (r = n);
      for (var i = "", a = t; a < r; ++a) i += B(e[a]);
      return i
    }

    function N(e, t, r) {
      for (var n = e.slice(t, r), i = "", a = 0; a < n.length; a += 2) i += String.fromCharCode(n[a] + 256 * n[a + 1]);
      return i
    }

    function P(e, t, r) {
      if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
      if (e + t > r) throw new RangeError("Trying to access beyond buffer length")
    }

    function C(e, t, r, n, i, a) {
      if (!u.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (t > i || t < a) throw new RangeError('"value" argument is out of bounds');
      if (r + n > e.length) throw new RangeError("Index out of range")
    }

    function D(e, t, r, n) {
      t < 0 && (t = 65535 + t + 1);
      for (var i = 0, a = Math.min(e.length - r, 2); i < a; ++i) e[r + i] = (t & 255 << 8 * (n ? i : 1 - i)) >>> 8 * (n ? i : 1 - i)
    }

    function j(e, t, r, n) {
      t < 0 && (t = 4294967295 + t + 1);
      for (var i = 0, a = Math.min(e.length - r, 4); i < a; ++i) e[r + i] = t >>> 8 * (n ? i : 3 - i) & 255
    }

    function k(e, t, r, n, i, a) {
      if (r + n > e.length) throw new RangeError("Index out of range");
      if (r < 0) throw new RangeError("Index out of range")
    }

    function L(e, t, r, n, a) {
      return a || k(e, 0, r, 4), i.write(e, t, r, n, 23, 4), r + 4
    }

    function M(e, t, r, n, a) {
      return a || k(e, 0, r, 8), i.write(e, t, r, n, 52, 8), r + 8
    }
    u.prototype.slice = function(e, t) {
      var r, n = this.length;
      if ((e = ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n), (t = void 0 === t ? n : ~~t) < 0 ? (t += n) < 0 && (t = 0) : t > n && (t = n), t < e && (t = e), u.TYPED_ARRAY_SUPPORT)(r = this.subarray(e, t)).__proto__ = u.prototype;
      else {
        var i = t - e;
        r = new u(i, void 0);
        for (var a = 0; a < i; ++a) r[a] = this[a + e]
      }
      return r
    }, u.prototype.readUIntLE = function(e, t, r) {
      e |= 0, t |= 0, r || P(e, t, this.length);
      for (var n = this[e], i = 1, a = 0; ++a < t && (i *= 256);) n += this[e + a] * i;
      return n
    }, u.prototype.readUIntBE = function(e, t, r) {
      e |= 0, t |= 0, r || P(e, t, this.length);
      for (var n = this[e + --t], i = 1; t > 0 && (i *= 256);) n += this[e + --t] * i;
      return n
    }, u.prototype.readUInt8 = function(e, t) {
      return t || P(e, 1, this.length), this[e]
    }, u.prototype.readUInt16LE = function(e, t) {
      return t || P(e, 2, this.length), this[e] | this[e + 1] << 8
    }, u.prototype.readUInt16BE = function(e, t) {
      return t || P(e, 2, this.length), this[e] << 8 | this[e + 1]
    }, u.prototype.readUInt32LE = function(e, t) {
      return t || P(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + 16777216 * this[e + 3]
    }, u.prototype.readUInt32BE = function(e, t) {
      return t || P(e, 4, this.length), 16777216 * this[e] + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3])
    }, u.prototype.readIntLE = function(e, t, r) {
      e |= 0, t |= 0, r || P(e, t, this.length);
      for (var n = this[e], i = 1, a = 0; ++a < t && (i *= 256);) n += this[e + a] * i;
      return n >= (i *= 128) && (n -= Math.pow(2, 8 * t)), n
    }, u.prototype.readIntBE = function(e, t, r) {
      e |= 0, t |= 0, r || P(e, t, this.length);
      for (var n = t, i = 1, a = this[e + --n]; n > 0 && (i *= 256);) a += this[e + --n] * i;
      return a >= (i *= 128) && (a -= Math.pow(2, 8 * t)), a
    }, u.prototype.readInt8 = function(e, t) {
      return t || P(e, 1, this.length), 128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
    }, u.prototype.readInt16LE = function(e, t) {
      t || P(e, 2, this.length);
      var r = this[e] | this[e + 1] << 8;
      return 32768 & r ? 4294901760 | r : r
    }, u.prototype.readInt16BE = function(e, t) {
      t || P(e, 2, this.length);
      var r = this[e + 1] | this[e] << 8;
      return 32768 & r ? 4294901760 | r : r
    }, u.prototype.readInt32LE = function(e, t) {
      return t || P(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24
    }, u.prototype.readInt32BE = function(e, t) {
      return t || P(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]
    }, u.prototype.readFloatLE = function(e, t) {
      return t || P(e, 4, this.length), i.read(this, e, !0, 23, 4)
    }, u.prototype.readFloatBE = function(e, t) {
      return t || P(e, 4, this.length), i.read(this, e, !1, 23, 4)
    }, u.prototype.readDoubleLE = function(e, t) {
      return t || P(e, 8, this.length), i.read(this, e, !0, 52, 8)
    }, u.prototype.readDoubleBE = function(e, t) {
      return t || P(e, 8, this.length), i.read(this, e, !1, 52, 8)
    }, u.prototype.writeUIntLE = function(e, t, r, n) {
      (e = +e, t |= 0, r |= 0, n) || C(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
      var i = 1,
        a = 0;
      for (this[t] = 255 & e; ++a < r && (i *= 256);) this[t + a] = e / i & 255;
      return t + r
    }, u.prototype.writeUIntBE = function(e, t, r, n) {
      (e = +e, t |= 0, r |= 0, n) || C(this, e, t, r, Math.pow(2, 8 * r) - 1, 0);
      var i = r - 1,
        a = 1;
      for (this[t + i] = 255 & e; --i >= 0 && (a *= 256);) this[t + i] = e / a & 255;
      return t + r
    }, u.prototype.writeUInt8 = function(e, t, r) {
      return e = +e, t |= 0, r || C(this, e, t, 1, 255, 0), u.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = 255 & e, t + 1
    }, u.prototype.writeUInt16LE = function(e, t, r) {
      return e = +e, t |= 0, r || C(this, e, t, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : D(this, e, t, !0), t + 2
    }, u.prototype.writeUInt16BE = function(e, t, r) {
      return e = +e, t |= 0, r || C(this, e, t, 2, 65535, 0), u.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : D(this, e, t, !1), t + 2
    }, u.prototype.writeUInt32LE = function(e, t, r) {
      return e = +e, t |= 0, r || C(this, e, t, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = 255 & e) : j(this, e, t, !0), t + 4
    }, u.prototype.writeUInt32BE = function(e, t, r) {
      return e = +e, t |= 0, r || C(this, e, t, 4, 4294967295, 0), u.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : j(this, e, t, !1), t + 4
    }, u.prototype.writeIntLE = function(e, t, r, n) {
      if (e = +e, t |= 0, !n) {
        var i = Math.pow(2, 8 * r - 1);
        C(this, e, t, r, i - 1, -i)
      }
      var a = 0,
        s = 1,
        o = 0;
      for (this[t] = 255 & e; ++a < r && (s *= 256);) e < 0 && 0 === o && 0 !== this[t + a - 1] && (o = 1), this[t + a] = (e / s >> 0) - o & 255;
      return t + r
    }, u.prototype.writeIntBE = function(e, t, r, n) {
      if (e = +e, t |= 0, !n) {
        var i = Math.pow(2, 8 * r - 1);
        C(this, e, t, r, i - 1, -i)
      }
      var a = r - 1,
        s = 1,
        o = 0;
      for (this[t + a] = 255 & e; --a >= 0 && (s *= 256);) e < 0 && 0 === o && 0 !== this[t + a + 1] && (o = 1), this[t + a] = (e / s >> 0) - o & 255;
      return t + r
    }, u.prototype.writeInt8 = function(e, t, r) {
      return e = +e, t |= 0, r || C(this, e, t, 1, 127, -128), u.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = 255 & e, t + 1
    }, u.prototype.writeInt16LE = function(e, t, r) {
      return e = +e, t |= 0, r || C(this, e, t, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8) : D(this, e, t, !0), t + 2
    }, u.prototype.writeInt16BE = function(e, t, r) {
      return e = +e, t |= 0, r || C(this, e, t, 2, 32767, -32768), u.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = 255 & e) : D(this, e, t, !1), t + 2
    }, u.prototype.writeInt32LE = function(e, t, r) {
      return e = +e, t |= 0, r || C(this, e, t, 4, 2147483647, -2147483648), u.TYPED_ARRAY_SUPPORT ? (this[t] = 255 & e, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : j(this, e, t, !0), t + 4
    }, u.prototype.writeInt32BE = function(e, t, r) {
      return e = +e, t |= 0, r || C(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), u.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = 255 & e) : j(this, e, t, !1), t + 4
    }, u.prototype.writeFloatLE = function(e, t, r) {
      return L(this, e, t, !0, r)
    }, u.prototype.writeFloatBE = function(e, t, r) {
      return L(this, e, t, !1, r)
    }, u.prototype.writeDoubleLE = function(e, t, r) {
      return M(this, e, t, !0, r)
    }, u.prototype.writeDoubleBE = function(e, t, r) {
      return M(this, e, t, !1, r)
    }, u.prototype.copy = function(e, t, r, n) {
      if (r || (r = 0), n || 0 === n || (n = this.length), t >= e.length && (t = e.length), t || (t = 0), n > 0 && n < r && (n = r), n === r) return 0;
      if (0 === e.length || 0 === this.length) return 0;
      if (t < 0) throw new RangeError("targetStart out of bounds");
      if (r < 0 || r >= this.length) throw new RangeError("sourceStart out of bounds");
      if (n < 0) throw new RangeError("sourceEnd out of bounds");
      n > this.length && (n = this.length), e.length - t < n - r && (n = e.length - t + r);
      var i, a = n - r;
      if (this === e && r < t && t < n)
        for (i = a - 1; i >= 0; --i) e[i + t] = this[i + r];
      else if (a < 1e3 || !u.TYPED_ARRAY_SUPPORT)
        for (i = 0; i < a; ++i) e[i + t] = this[i + r];
      else Uint8Array.prototype.set.call(e, this.subarray(r, r + a), t);
      return a
    }, u.prototype.fill = function(e, t, r, n) {
      if ("string" == typeof e) {
        if ("string" == typeof t ? (n = t, t = 0, r = this.length) : "string" == typeof r && (n = r, r = this.length), 1 === e.length) {
          var i = e.charCodeAt(0);
          i < 256 && (e = i)
        }
        if (void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
        if ("string" == typeof n && !u.isEncoding(n)) throw new TypeError("Unknown encoding: " + n)
      } else "number" == typeof e && (e &= 255);
      if (t < 0 || this.length < t || this.length < r) throw new RangeError("Out of range index");
      if (r <= t) return this;
      var a;
      if (t >>>= 0, r = void 0 === r ? this.length : r >>> 0, e || (e = 0), "number" == typeof e)
        for (a = t; a < r; ++a) this[a] = e;
      else {
        var s = u.isBuffer(e) ? e : q(new u(e, n).toString()),
          o = s.length;
        for (a = 0; a < r - t; ++a) this[a + t] = s[a % o]
      }
      return this
    };
    var F = /[^+\/0-9A-Za-z-_]/g;

    function B(e) {
      return e < 16 ? "0" + e.toString(16) : e.toString(16)
    }

    function q(e, t) {
      var r;
      t = t || 1 / 0;
      for (var n = e.length, i = null, a = [], s = 0; s < n; ++s) {
        if ((r = e.charCodeAt(s)) > 55295 && r < 57344) {
          if (!i) {
            if (r > 56319) {
              (t -= 3) > -1 && a.push(239, 191, 189);
              continue
            }
            if (s + 1 === n) {
              (t -= 3) > -1 && a.push(239, 191, 189);
              continue
            }
            i = r;
            continue
          }
          if (r < 56320) {
            (t -= 3) > -1 && a.push(239, 191, 189), i = r;
            continue
          }
          r = 65536 + (i - 55296 << 10 | r - 56320)
        } else i && (t -= 3) > -1 && a.push(239, 191, 189);
        if (i = null, r < 128) {
          if ((t -= 1) < 0) break;
          a.push(r)
        } else if (r < 2048) {
          if ((t -= 2) < 0) break;
          a.push(r >> 6 | 192, 63 & r | 128)
        } else if (r < 65536) {
          if ((t -= 3) < 0) break;
          a.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128)
        } else {
          if (!(r < 1114112)) throw new Error("Invalid code point");
          if ((t -= 4) < 0) break;
          a.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128)
        }
      }
      return a
    }

    function U(e) {
      return n.toByteArray(function(e) {
        if ((e = function(e) {
          return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "")
        }(e).replace(F, "")).length < 2) return "";
        for (; e.length % 4 != 0;) e += "=";
        return e
      }(e))
    }

    function V(e, t, r, n) {
      for (var i = 0; i < n && !(i + r >= t.length || i >= e.length); ++i) t[i + r] = e[i];
      return i
    }
  }).call(this, r(10))
}, function(e, t) {
  "function" == typeof Object.create ? e.exports = function(e, t) {
    t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
      constructor: {
        value: e,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }))
  } : e.exports = function(e, t) {
    if (t) {
      e.super_ = t;
      var r = function() {};
      r.prototype = t.prototype, e.prototype = new r, e.prototype.constructor = e
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }),
    function(e) {
      for (var r in e) t.hasOwnProperty(r) || (t[r] = e[r])
    }(r(279))
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NamedOperators = t.SetFunctions = t.SetFunction = t.Operators = t.SpecialOperators = t.RegularOperators = t.SpecialOperator = t.RegularOperator = t.decategorize = t.type = t.PrimitiveNumericTypes = t.commonTerms = t.DerivedIntegerTypeURLs = t.NumericTypeURLs = t.DerivedIntegerTypeURL = t.NumericTypeURL = t.make = t.TypeURL = t.EVB_ERR_STR = t.FALSE_STR = t.TRUE_STR = void 0;
  const n = r(5),
    i = r(23),
    a = new n.DataFactory;
  var s, o, u;
  t.TRUE_STR = '"true"^^xsd:boolean', t.FALSE_STR = '"false"^^xsd:boolean', t.EVB_ERR_STR = '"not an dateTime"^^xsd:dateTime',
    function(e) {
      e.XSD_ANY_URI = "http://www.w3.org/2001/XMLSchema#anyURI", e.XSD_STRING = "http://www.w3.org/2001/XMLSchema#string", e.RDF_LANG_STRING = "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString", e.XSD_BOOLEAN = "http://www.w3.org/2001/XMLSchema#boolean", e.XSD_DATE_TIME = "http://www.w3.org/2001/XMLSchema#dateTime", e.XSD_DATE = "http://www.w3.org/2001/XMLSchema#date", e.XSD_INTEGER = "http://www.w3.org/2001/XMLSchema#integer", e.XSD_DECIMAL = "http://www.w3.org/2001/XMLSchema#decimal", e.XSD_FLOAT = "http://www.w3.org/2001/XMLSchema#float", e.XSD_DOUBLE = "http://www.w3.org/2001/XMLSchema#double", e.XSD_NON_POSITIVE_INTEGER = "http://www.w3.org/2001/XMLSchema#nonPositiveInteger", e.XSD_NEGATIVE_INTEGER = "http://www.w3.org/2001/XMLSchema#negativeInteger", e.XSD_LONG = "http://www.w3.org/2001/XMLSchema#long", e.XSD_INT = "http://www.w3.org/2001/XMLSchema#int", e.XSD_SHORT = "http://www.w3.org/2001/XMLSchema#short", e.XSD_BYTE = "http://www.w3.org/2001/XMLSchema#byte", e.XSD_NON_NEGATIVE_INTEGER = "http://www.w3.org/2001/XMLSchema#nonNegativeInteger", e.XSD_UNSIGNED_LONG = "http://www.w3.org/2001/XMLSchema#unsignedLong", e.XSD_UNSIGNED_INT = "http://www.w3.org/2001/XMLSchema#unsignedInt", e.XSD_UNSIGNED_SHORT = "http://www.w3.org/2001/XMLSchema#unsignedShort", e.XSD_UNSIGNED_BYTE = "http://www.w3.org/2001/XMLSchema#unsignedByte", e.XSD_POSITIVE_INTEGER = "http://www.w3.org/2001/XMLSchema#positiveInteger", e.XSD_DAYTIME_DURATION = "http://www.w3.org/2001/XMLSchema#dayTimeDuration"
    }(s = t.TypeURL || (t.TypeURL = {})), t.make = function(e) {
    return a.namedNode(e)
  },
    function(e) {
      e.XSD_INTEGER = "http://www.w3.org/2001/XMLSchema#integer", e.XSD_DECIMAL = "http://www.w3.org/2001/XMLSchema#decimal", e.XSD_FLOAT = "http://www.w3.org/2001/XMLSchema#float", e.XSD_DOUBLE = "http://www.w3.org/2001/XMLSchema#double", e.XSD_NON_POSITIVE_INTEGER = "http://www.w3.org/2001/XMLSchema#nonPositiveInteger", e.XSD_NEGATIVE_INTEGER = "http://www.w3.org/2001/XMLSchema#negativeInteger", e.XSD_LONG = "http://www.w3.org/2001/XMLSchema#long", e.XSD_INT = "http://www.w3.org/2001/XMLSchema#int", e.XSD_SHORT = "http://www.w3.org/2001/XMLSchema#short", e.XSD_BYTE = "http://www.w3.org/2001/XMLSchema#byte", e.XSD_NON_NEGATIVE_INTEGER = "http://www.w3.org/2001/XMLSchema#nonNegativeInteger", e.XSD_UNSIGNED_LONG = "http://www.w3.org/2001/XMLSchema#unsignedLong", e.XSD_UNSIGNED_INT = "http://www.w3.org/2001/XMLSchema#unsignedInt", e.XSD_UNSIGNED_SHORT = "http://www.w3.org/2001/XMLSchema#unsignedShort", e.XSD_UNSIGNED_BYTE = "http://www.w3.org/2001/XMLSchema#unsignedByte", e.XSD_POSITIVE_INTEGER = "http://www.w3.org/2001/XMLSchema#positiveInteger"
    }(o = t.NumericTypeURL || (t.NumericTypeURL = {})),
    function(e) {
      e.XSD_NON_POSITIVE_INTEGER = "http://www.w3.org/2001/XMLSchema#nonPositiveInteger", e.XSD_NEGATIVE_INTEGER = "http://www.w3.org/2001/XMLSchema#negativeInteger", e.XSD_LONG = "http://www.w3.org/2001/XMLSchema#long", e.XSD_INT = "http://www.w3.org/2001/XMLSchema#int", e.XSD_SHORT = "http://www.w3.org/2001/XMLSchema#short", e.XSD_BYTE = "http://www.w3.org/2001/XMLSchema#byte", e.XSD_NON_NEGATIVE_INTEGER = "http://www.w3.org/2001/XMLSchema#nonNegativeInteger", e.XSD_UNSIGNED_LONG = "http://www.w3.org/2001/XMLSchema#unsignedLong", e.XSD_UNSIGNED_INT = "http://www.w3.org/2001/XMLSchema#unsignedInt", e.XSD_UNSIGNED_SHORT = "http://www.w3.org/2001/XMLSchema#unsignedShort", e.XSD_UNSIGNED_BYTE = "http://www.w3.org/2001/XMLSchema#unsignedByte", e.XSD_POSITIVE_INTEGER = "http://www.w3.org/2001/XMLSchema#positiveInteger"
    }(u = t.DerivedIntegerTypeURL || (t.DerivedIntegerTypeURL = {})), t.NumericTypeURLs = i.Set(Object.values(o)), t.DerivedIntegerTypeURLs = i.Set(Object.values(u)), t.commonTerms = {
    true: a.literal("true", a.namedNode(s.XSD_BOOLEAN)),
    false: a.literal("false", a.namedNode(s.XSD_BOOLEAN))
  }, t.PrimitiveNumericTypes = i.Set(["integer", "decimal", "float", "double"]), t.type = function(e) {
    switch (e) {
      case null:
      case void 0:
      case "":
      case s.XSD_ANY_URI:
      case s.XSD_STRING:
        return "string";
      case s.RDF_LANG_STRING:
        return "langString";
      case s.XSD_DATE_TIME:
        return "date";
      case s.XSD_BOOLEAN:
        return "boolean";
      case s.XSD_DECIMAL:
        return "decimal";
      case s.XSD_FLOAT:
        return "float";
      case s.XSD_DOUBLE:
        return "double";
      case s.XSD_INTEGER:
      case s.XSD_NON_POSITIVE_INTEGER:
      case s.XSD_NEGATIVE_INTEGER:
      case s.XSD_LONG:
      case s.XSD_INT:
      case s.XSD_SHORT:
      case s.XSD_BYTE:
      case s.XSD_NON_NEGATIVE_INTEGER:
      case s.XSD_UNSIGNED_LONG:
      case s.XSD_UNSIGNED_INT:
      case s.XSD_UNSIGNED_SHORT:
      case s.XSD_UNSIGNED_BYTE:
      case s.XSD_POSITIVE_INTEGER:
        return "integer";
      default:
        return "other"
    }
  };
  const c = i.Map([
    ["integer", s.XSD_INTEGER],
    ["float", s.XSD_FLOAT],
    ["double", s.XSD_DOUBLE],
    ["decimal", s.XSD_DECIMAL]
  ]);
  var l, h, d;
  t.decategorize = function(e) {
    return c.get(e)
  },
    function(e) {
      e.NOT = "!", e.UMINUS = "UMINUS", e.UPLUS = "UPLUS", e.EQUAL = "=", e.NOT_EQUAL = "!=", e.LT = "<", e.GT = ">", e.LTE = "<=", e.GTE = ">=", e.MULTIPLICATION = "*", e.DIVISION = "/", e.ADDITION = "+", e.SUBTRACTION = "-", e.IS_IRI = "isiri", e.IS_BLANK = "isblank", e.IS_LITERAL = "isliteral", e.IS_NUMERIC = "isnumeric", e.STR = "str", e.LANG = "lang", e.DATATYPE = "datatype", e.STRDT = "strdt", e.STRLANG = "strlang", e.UUID = "uuid", e.STRUUID = "struuid", e.STRLEN = "strlen", e.SUBSTR = "substr", e.UCASE = "ucase", e.LCASE = "lcase", e.STRSTARTS = "strstarts", e.STRENDS = "strends", e.CONTAINS = "contains", e.STRBEFORE = "strbefore", e.STRAFTER = "strafter", e.ENCODE_FOR_URI = "encode_for_uri", e.LANG_MATCHES = "langmatches", e.REGEX = "regex", e.REPLACE = "replace", e.ABS = "abs", e.ROUND = "round", e.CEIL = "ceil", e.FLOOR = "floor", e.RAND = "rand", e.YEAR = "year", e.MONTH = "month", e.DAY = "day", e.HOURS = "hours", e.MINUTES = "minutes", e.SECONDS = "seconds", e.TIMEZONE = "timezone", e.TZ = "tz", e.MD5 = "md5", e.SHA1 = "sha1", e.SHA256 = "sha256", e.SHA384 = "sha384", e.SHA512 = "sha512"
    }(l = t.RegularOperator || (t.RegularOperator = {})),
    function(e) {
      e.BOUND = "bound", e.IF = "if", e.COALESCE = "coalesce", e.LOGICAL_OR = "||", e.LOGICAL_AND = "&&", e.SAME_TERM = "sameterm", e.IN = "in", e.NOT_IN = "notin", e.CONCAT = "concat", e.NOW = "now", e.IRI = "iri", e.URI = "uri", e.BNODE = "BNODE"
    }(h = t.SpecialOperator || (t.SpecialOperator = {})), t.RegularOperators = i.Set(Object.values(l)), t.SpecialOperators = i.Set(Object.values(h)), t.Operators = t.RegularOperators.union(t.SpecialOperators),
    function(e) {
      e.COUNT = "count", e.SUM = "sum", e.MIN = "min", e.MAX = "max", e.AVG = "avg", e.GROUP_CONCAT = "group_concat", e.SAMPLE = "sample"
    }(d = t.SetFunction || (t.SetFunction = {})), t.SetFunctions = i.Set(Object.values(d)), t.NamedOperators = i.Set([s.XSD_STRING, s.XSD_FLOAT, s.XSD_DOUBLE, s.XSD_DECIMAL, s.XSD_INTEGER, s.XSD_DATE_TIME, s.XSD_DATE, s.XSD_BOOLEAN])
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(228), t), i(r(230), t)
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(259), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeValueHandlerAdapter = void 0;
  t.NodeValueHandlerAdapter = class {
    constructor(e, t, r) {
      this.targetKind = e, this.util = t, this.settings = r
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  const n = r(417);
  t.collectNamedTerms = n.collectNamedTerms, t.everyTerms = n.everyTerms, t.filterQuadTermNames = n.filterQuadTermNames, t.filterTerms = n.filterTerms, t.forEachTerms = n.forEachTerms, t.getNamedTerms = n.getNamedTerms, t.getTerms = n.getTerms, t.getTermsNested = n.getTermsNested, t.mapTerms = n.mapTerms, t.matchPattern = n.matchPattern, t.matchPatternComplete = n.matchPatternComplete, t.QUAD_TERM_NAMES = n.QUAD_TERM_NAMES, t.reduceTerms = n.reduceTerms, t.someTerms = n.someTerms, t.TRIPLE_TERM_NAMES = n.TRIPLE_TERM_NAMES;
  const i = r(418);
  t.getBlankNodes = i.getBlankNodes, t.getDefaultGraphs = i.getDefaultGraphs, t.getLiterals = i.getLiterals, t.getNamedNodes = i.getNamedNodes, t.getTermsOfType = i.getTermsOfType, t.getVariables = i.getVariables, t.TERM_TYPES = i.TERM_TYPES, t.uniqTerms = i.uniqTerms
}, function(e, t, r) {
  "use strict";
  var n = r(49),
    i = r(12);

  function a(e, t) {
    return 55296 == (64512 & e.charCodeAt(t)) && (!(t < 0 || t + 1 >= e.length) && 56320 == (64512 & e.charCodeAt(t + 1)))
  }

  function s(e) {
    return (e >>> 24 | e >>> 8 & 65280 | e << 8 & 16711680 | (255 & e) << 24) >>> 0
  }

  function o(e) {
    return 1 === e.length ? "0" + e : e
  }

  function u(e) {
    return 7 === e.length ? "0" + e : 6 === e.length ? "00" + e : 5 === e.length ? "000" + e : 4 === e.length ? "0000" + e : 3 === e.length ? "00000" + e : 2 === e.length ? "000000" + e : 1 === e.length ? "0000000" + e : e
  }
  t.inherits = i, t.toArray = function(e, t) {
    if (Array.isArray(e)) return e.slice();
    if (!e) return [];
    var r = [];
    if ("string" == typeof e)
      if (t) {
        if ("hex" === t)
          for ((e = e.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (e = "0" + e), i = 0; i < e.length; i += 2) r.push(parseInt(e[i] + e[i + 1], 16))
      } else
        for (var n = 0, i = 0; i < e.length; i++) {
          var s = e.charCodeAt(i);
          s < 128 ? r[n++] = s : s < 2048 ? (r[n++] = s >> 6 | 192, r[n++] = 63 & s | 128) : a(e, i) ? (s = 65536 + ((1023 & s) << 10) + (1023 & e.charCodeAt(++i)), r[n++] = s >> 18 | 240, r[n++] = s >> 12 & 63 | 128, r[n++] = s >> 6 & 63 | 128, r[n++] = 63 & s | 128) : (r[n++] = s >> 12 | 224, r[n++] = s >> 6 & 63 | 128, r[n++] = 63 & s | 128)
        } else
      for (i = 0; i < e.length; i++) r[i] = 0 | e[i];
    return r
  }, t.toHex = function(e) {
    for (var t = "", r = 0; r < e.length; r++) t += o(e[r].toString(16));
    return t
  }, t.htonl = s, t.toHex32 = function(e, t) {
    for (var r = "", n = 0; n < e.length; n++) {
      var i = e[n];
      "little" === t && (i = s(i)), r += u(i.toString(16))
    }
    return r
  }, t.zero2 = o, t.zero8 = u, t.join32 = function(e, t, r, i) {
    var a = r - t;
    n(a % 4 == 0);
    for (var s = new Array(a / 4), o = 0, u = t; o < s.length; o++, u += 4) {
      var c;
      c = "big" === i ? e[u] << 24 | e[u + 1] << 16 | e[u + 2] << 8 | e[u + 3] : e[u + 3] << 24 | e[u + 2] << 16 | e[u + 1] << 8 | e[u], s[o] = c >>> 0
    }
    return s
  }, t.split32 = function(e, t) {
    for (var r = new Array(4 * e.length), n = 0, i = 0; n < e.length; n++, i += 4) {
      var a = e[n];
      "big" === t ? (r[i] = a >>> 24, r[i + 1] = a >>> 16 & 255, r[i + 2] = a >>> 8 & 255, r[i + 3] = 255 & a) : (r[i + 3] = a >>> 24, r[i + 2] = a >>> 16 & 255, r[i + 1] = a >>> 8 & 255, r[i] = 255 & a)
    }
    return r
  }, t.rotr32 = function(e, t) {
    return e >>> t | e << 32 - t
  }, t.rotl32 = function(e, t) {
    return e << t | e >>> 32 - t
  }, t.sum32 = function(e, t) {
    return e + t >>> 0
  }, t.sum32_3 = function(e, t, r) {
    return e + t + r >>> 0
  }, t.sum32_4 = function(e, t, r, n) {
    return e + t + r + n >>> 0
  }, t.sum32_5 = function(e, t, r, n, i) {
    return e + t + r + n + i >>> 0
  }, t.sum64 = function(e, t, r, n) {
    var i = e[t],
      a = n + e[t + 1] >>> 0,
      s = (a < n ? 1 : 0) + r + i;
    e[t] = s >>> 0, e[t + 1] = a
  }, t.sum64_hi = function(e, t, r, n) {
    return (t + n >>> 0 < t ? 1 : 0) + e + r >>> 0
  }, t.sum64_lo = function(e, t, r, n) {
    return t + n >>> 0
  }, t.sum64_4_hi = function(e, t, r, n, i, a, s, o) {
    var u = 0,
      c = t;
    return u += (c = c + n >>> 0) < t ? 1 : 0, u += (c = c + a >>> 0) < a ? 1 : 0, e + r + i + s + (u += (c = c + o >>> 0) < o ? 1 : 0) >>> 0
  }, t.sum64_4_lo = function(e, t, r, n, i, a, s, o) {
    return t + n + a + o >>> 0
  }, t.sum64_5_hi = function(e, t, r, n, i, a, s, o, u, c) {
    var l = 0,
      h = t;
    return l += (h = h + n >>> 0) < t ? 1 : 0, l += (h = h + a >>> 0) < a ? 1 : 0, l += (h = h + o >>> 0) < o ? 1 : 0, e + r + i + s + u + (l += (h = h + c >>> 0) < c ? 1 : 0) >>> 0
  }, t.sum64_5_lo = function(e, t, r, n, i, a, s, o, u, c) {
    return t + n + a + o + c >>> 0
  }, t.rotr64_hi = function(e, t, r) {
    return (t << 32 - r | e >>> r) >>> 0
  }, t.rotr64_lo = function(e, t, r) {
    return (e << 32 - r | t >>> r) >>> 0
  }, t.shr64_hi = function(e, t, r) {
    return e >>> r
  }, t.shr64_lo = function(e, t, r) {
    return (e << 32 - r | t >>> r) >>> 0
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NoExistenceHook = t.NoAggregator = t.UnknownNamedOperator = t.UnknownOperator = t.InvalidTermType = t.InvalidExpressionType = t.InvalidExpression = t.InvalidArity = t.UnimplementedError = t.UnexpectedError = t.EmptyAggregateError = t.IncompatibleLanguageOperation = t.InvalidTimezoneCall = t.CastError = t.InvalidArgumentTypes = t.InError = t.CoalesceError = t.RDFEqualTypeError = t.EBVCoercionError = t.UnboundVariableError = t.InvalidLexicalForm = t.isExpressionError = t.ExpressionError = void 0;
  class n extends Error {}
  t.ExpressionError = n, t.isExpressionError = function(e) {
    return e instanceof n
  };
  t.InvalidLexicalForm = class extends n {
    constructor(e) {
      super(`Invalid lexical form '${f(e)}'`), this.arg = e
    }
  };
  t.UnboundVariableError = class extends n {
    constructor(e, t) {
      super(`Unbound variable '${f(e)}'`), this.variable = e, this.bindings = t
    }
  };
  t.EBVCoercionError = class extends n {
    constructor(e) {
      super(`Cannot coerce term to EBV '${f(e)}'`), this.arg = e
    }
  };
  t.RDFEqualTypeError = class extends n {
    constructor(e) {
      super("Equality test for literals with unsupported datatypes"), this.args = e
    }
  };
  t.CoalesceError = class extends n {
    constructor(e) {
      super("All COALESCE arguments threw errors"), this.errors = e
    }
  };
  t.InError = class extends n {
    constructor(e) {
      super("Some argument to IN errorred and none where equal. " + e.map(e => `(${e.toString()}) `).join("and ")), this.errors = e
    }
  };
  t.InvalidArgumentTypes = class extends n {
    constructor(e, t) {
      super(`Argument types not valid for operator: '${f(t)}' with '${f(e)}`), this.args = e, this.op = t
    }
  };
  t.CastError = class extends n {
    constructor(e, t) {
      super(`Invalid cast: '${f(e)}' to '${f(t)}'`), this.arg = e
    }
  };
  t.InvalidTimezoneCall = class extends n {
    constructor(e) {
      super(`TIMEZONE call on ${e} which has no timezone`), this.dateString = e
    }
  };
  t.IncompatibleLanguageOperation = class extends n {
    constructor(e, t) {
      super(`Operation on incompatible language literals '${f(e)}' and '${f(t)}'`), this.arg1 = e, this.arg2 = t
    }
  };
  t.EmptyAggregateError = class extends n {
    constructor() {
      super("Empty aggregate expression")
    }
  };
  class i extends Error {
    constructor(e, t) {
      super(`Programmer Error '${e}'`), this.payload = t
    }
  }
  t.UnexpectedError = i;
  class a extends Error {
    constructor(e) {
      super(`Unimplemented feature '${e}!'`)
    }
  }
  t.UnimplementedError = a;
  class s extends Error {
    constructor(e, t) {
      super(`The number of args does not match the arity of the operator '${f(t)}'.`), this.args = e, this.op = t
    }
  }
  t.InvalidArity = s;
  class o extends Error {
    constructor(e) {
      super(`Invalid SPARQL Expression '${f(e)}'`)
    }
  }
  t.InvalidExpression = o;
  class u extends Error {
    constructor(e) {
      super(`Invalid expression type for SPARQL Expression '${f(e)}'`), this.expr = e
    }
  }
  t.InvalidExpressionType = u;
  class c extends Error {
    constructor(e) {
      super(`Invalid term type for term '${f(e)}'`), this.term = e
    }
  }
  t.InvalidTermType = c;
  class l extends Error {
    constructor(e) {
      super("Unknown operator: '" + f(e))
    }
  }
  t.UnknownOperator = l;
  class h extends Error {
    constructor(e) {
      super(`Unknown named operator: '${f(e)}'`)
    }
  }
  t.UnknownNamedOperator = h;
  class d extends Error {
    constructor(e) {
      super(`Aggregate expression ${f(e)} found, but no aggregate hook provided.`)
    }
  }
  t.NoAggregator = d;
  class p extends Error {
    constructor() {
      super("EXISTS found, but no existence hook provided.")
    }
  }

  function f(e) {
    return JSON.stringify(e)
  }
  t.NoExistenceHook = p
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(112), t), i(r(218), t)
}, function(e, t, r) {
  "use strict";
  var n, i = "object" == typeof Reflect ? Reflect : null,
    a = i && "function" == typeof i.apply ? i.apply : function(e, t, r) {
      return Function.prototype.apply.call(e, t, r)
    };
  n = i && "function" == typeof i.ownKeys ? i.ownKeys : Object.getOwnPropertySymbols ? function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e))
  } : function(e) {
    return Object.getOwnPropertyNames(e)
  };
  var s = Number.isNaN || function(e) {
    return e != e
  };

  function o() {
    o.init.call(this)
  }
  e.exports = o, e.exports.once = function(e, t) {
    return new Promise((function(r, n) {
      function i() {
        void 0 !== a && e.removeListener("error", a), r([].slice.call(arguments))
      }
      var a;
      "error" !== t && (a = function(r) {
        e.removeListener(t, i), n(r)
      }, e.once("error", a)), e.once(t, i)
    }))
  }, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
  var u = 10;

  function c(e) {
    if ("function" != typeof e) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e)
  }

  function l(e) {
    return void 0 === e._maxListeners ? o.defaultMaxListeners : e._maxListeners
  }

  function h(e, t, r, n) {
    var i, a, s, o;
    if (c(r), void 0 === (a = e._events) ? (a = e._events = Object.create(null), e._eventsCount = 0) : (void 0 !== a.newListener && (e.emit("newListener", t, r.listener ? r.listener : r), a = e._events), s = a[t]), void 0 === s) s = a[t] = r, ++e._eventsCount;
    else if ("function" == typeof s ? s = a[t] = n ? [r, s] : [s, r] : n ? s.unshift(r) : s.push(r), (i = l(e)) > 0 && s.length > i && !s.warned) {
      s.warned = !0;
      var u = new Error("Possible EventEmitter memory leak detected. " + s.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      u.name = "MaxListenersExceededWarning", u.emitter = e, u.type = t, u.count = s.length, o = u, console && console.warn && console.warn(o)
    }
    return e
  }

  function d() {
    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
  }

  function p(e, t, r) {
    var n = {
        fired: !1,
        wrapFn: void 0,
        target: e,
        type: t,
        listener: r
      },
      i = d.bind(n);
    return i.listener = r, n.wrapFn = i, i
  }

  function f(e, t, r) {
    var n = e._events;
    if (void 0 === n) return [];
    var i = n[t];
    return void 0 === i ? [] : "function" == typeof i ? r ? [i.listener || i] : [i] : r ? function(e) {
      for (var t = new Array(e.length), r = 0; r < t.length; ++r) t[r] = e[r].listener || e[r];
      return t
    }(i) : m(i, i.length)
  }

  function g(e) {
    var t = this._events;
    if (void 0 !== t) {
      var r = t[e];
      if ("function" == typeof r) return 1;
      if (void 0 !== r) return r.length
    }
    return 0
  }

  function m(e, t) {
    for (var r = new Array(t), n = 0; n < t; ++n) r[n] = e[n];
    return r
  }
  Object.defineProperty(o, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return u
    },
    set: function(e) {
      if ("number" != typeof e || e < 0 || s(e)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
      u = e
    }
  }), o.init = function() {
    void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0
  }, o.prototype.setMaxListeners = function(e) {
    if ("number" != typeof e || e < 0 || s(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this
  }, o.prototype.getMaxListeners = function() {
    return l(this)
  }, o.prototype.emit = function(e) {
    for (var t = [], r = 1; r < arguments.length; r++) t.push(arguments[r]);
    var n = "error" === e,
      i = this._events;
    if (void 0 !== i) n = n && void 0 === i.error;
    else if (!n) return !1;
    if (n) {
      var s;
      if (t.length > 0 && (s = t[0]), s instanceof Error) throw s;
      var o = new Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
      throw o.context = s, o
    }
    var u = i[e];
    if (void 0 === u) return !1;
    if ("function" == typeof u) a(u, this, t);
    else {
      var c = u.length,
        l = m(u, c);
      for (r = 0; r < c; ++r) a(l[r], this, t)
    }
    return !0
  }, o.prototype.addListener = function(e, t) {
    return h(this, e, t, !1)
  }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(e, t) {
    return h(this, e, t, !0)
  }, o.prototype.once = function(e, t) {
    return c(t), this.on(e, p(this, e, t)), this
  }, o.prototype.prependOnceListener = function(e, t) {
    return c(t), this.prependListener(e, p(this, e, t)), this
  }, o.prototype.removeListener = function(e, t) {
    var r, n, i, a, s;
    if (c(t), void 0 === (n = this._events)) return this;
    if (void 0 === (r = n[e])) return this;
    if (r === t || r.listener === t) 0 == --this._eventsCount ? this._events = Object.create(null) : (delete n[e], n.removeListener && this.emit("removeListener", e, r.listener || t));
    else if ("function" != typeof r) {
      for (i = -1, a = r.length - 1; a >= 0; a--)
        if (r[a] === t || r[a].listener === t) {
          s = r[a].listener, i = a;
          break
        } if (i < 0) return this;
      0 === i ? r.shift() : function(e, t) {
        for (; t + 1 < e.length; t++) e[t] = e[t + 1];
        e.pop()
      }(r, i), 1 === r.length && (n[e] = r[0]), void 0 !== n.removeListener && this.emit("removeListener", e, s || t)
    }
    return this
  }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(e) {
    var t, r, n;
    if (void 0 === (r = this._events)) return this;
    if (void 0 === r.removeListener) return 0 === arguments.length ? (this._events = Object.create(null), this._eventsCount = 0) : void 0 !== r[e] && (0 == --this._eventsCount ? this._events = Object.create(null) : delete r[e]), this;
    if (0 === arguments.length) {
      var i, a = Object.keys(r);
      for (n = 0; n < a.length; ++n) "removeListener" !== (i = a[n]) && this.removeAllListeners(i);
      return this.removeAllListeners("removeListener"), this._events = Object.create(null), this._eventsCount = 0, this
    }
    if ("function" == typeof(t = r[e])) this.removeListener(e, t);
    else if (void 0 !== t)
      for (n = t.length - 1; n >= 0; n--) this.removeListener(e, t[n]);
    return this
  }, o.prototype.listeners = function(e) {
    return f(this, e, !0)
  }, o.prototype.rawListeners = function(e) {
    return f(this, e, !1)
  }, o.listenerCount = function(e, t) {
    return "function" == typeof e.listenerCount ? e.listenerCount(t) : g.call(e, t)
  }, o.prototype.listenerCount = g, o.prototype.eventNames = function() {
    return this._eventsCount > 0 ? n(this._events) : []
  }
}, function(e, t, r) {
  e.exports = function() {
    "use strict";
    var e = Array.prototype.slice;

    function t(e, t) {
      t && (e.prototype = Object.create(t.prototype)), e.prototype.constructor = e
    }

    function r(e) {
      return s(e) ? e : V(e)
    }

    function n(e) {
      return o(e) ? e : H(e)
    }

    function i(e) {
      return u(e) ? e : G(e)
    }

    function a(e) {
      return s(e) && !c(e) ? e : z(e)
    }

    function s(e) {
      return !(!e || !e[h])
    }

    function o(e) {
      return !(!e || !e[d])
    }

    function u(e) {
      return !(!e || !e[p])
    }

    function c(e) {
      return o(e) || u(e)
    }

    function l(e) {
      return !(!e || !e[f])
    }
    t(n, r), t(i, r), t(a, r), r.isIterable = s, r.isKeyed = o, r.isIndexed = u, r.isAssociative = c, r.isOrdered = l, r.Keyed = n, r.Indexed = i, r.Set = a;
    var h = "@@__IMMUTABLE_ITERABLE__@@",
      d = "@@__IMMUTABLE_KEYED__@@",
      p = "@@__IMMUTABLE_INDEXED__@@",
      f = "@@__IMMUTABLE_ORDERED__@@",
      g = {},
      m = {
        value: !1
      },
      y = {
        value: !1
      };

    function b(e) {
      return e.value = !1, e
    }

    function _(e) {
      e && (e.value = !0)
    }

    function v() {}

    function w(e, t) {
      t = t || 0;
      for (var r = Math.max(0, e.length - t), n = new Array(r), i = 0; i < r; i++) n[i] = e[i + t];
      return n
    }

    function S(e) {
      return void 0 === e.size && (e.size = e.__iterate(E)), e.size
    }

    function T(e, t) {
      if ("number" != typeof t) {
        var r = t >>> 0;
        if ("" + r !== t || 4294967295 === r) return NaN;
        t = r
      }
      return t < 0 ? S(e) + t : t
    }

    function E() {
      return !0
    }

    function x(e, t, r) {
      return (0 === e || void 0 !== r && e <= -r) && (void 0 === t || void 0 !== r && t >= r)
    }

    function O(e, t) {
      return R(e, t, 0)
    }

    function A(e, t) {
      return R(e, t, t)
    }

    function R(e, t, r) {
      return void 0 === e ? r : e < 0 ? Math.max(0, t + e) : void 0 === t ? e : Math.min(t, e)
    }
    var I, N, P, C = "function" == typeof Symbol && Symbol.iterator,
      D = C || "@@iterator";

    function j(e) {
      this.next = e
    }

    function k(e, t, r, n) {
      var i = 0 === e ? t : 1 === e ? r : [t, r];
      return n ? n.value = i : n = {
        value: i,
        done: !1
      }, n
    }

    function L() {
      return {
        value: void 0,
        done: !0
      }
    }

    function M(e) {
      return !!q(e)
    }

    function F(e) {
      return e && "function" == typeof e.next
    }

    function B(e) {
      var t = q(e);
      return t && t.call(e)
    }

    function q(e) {
      var t = e && (C && e[C] || e["@@iterator"]);
      if ("function" == typeof t) return t
    }

    function U(e) {
      return e && "number" == typeof e.length
    }

    function V(e) {
      return null == e ? W() : s(e) ? e.toSeq() : function(e) {
        var t = ee(e) || "object" == typeof e && new X(e);
        if (!t) throw new TypeError("Expected Array or iterable object of values, or keyed object: " + e);
        return t
      }(e)
    }

    function H(e) {
      return null == e ? W().toKeyedSeq() : s(e) ? o(e) ? e.toSeq() : e.fromEntrySeq() : K(e)
    }

    function G(e) {
      return null == e ? W() : s(e) ? o(e) ? e.entrySeq() : e.toIndexedSeq() : Z(e)
    }

    function z(e) {
      return (null == e ? W() : s(e) ? o(e) ? e.entrySeq() : e : Z(e)).toSetSeq()
    }

    function Q(e) {
      this._array = e, this.size = e.length
    }

    function X(e) {
      var t = Object.keys(e);
      this._object = e, this._keys = t, this.size = t.length
    }

    function $(e) {
      this._iterable = e, this.size = e.length || e.size
    }

    function Y(e) {
      this._iterator = e, this._iteratorCache = []
    }

    function J(e) {
      return !(!e || !e["@@__IMMUTABLE_SEQ__@@"])
    }

    function W() {
      return I || (I = new Q([]))
    }

    function K(e) {
      var t = Array.isArray(e) ? new Q(e).fromEntrySeq() : F(e) ? new Y(e).fromEntrySeq() : M(e) ? new $(e).fromEntrySeq() : "object" == typeof e ? new X(e) : void 0;
      if (!t) throw new TypeError("Expected Array or iterable object of [k, v] entries, or keyed object: " + e);
      return t
    }

    function Z(e) {
      var t = ee(e);
      if (!t) throw new TypeError("Expected Array or iterable object of values: " + e);
      return t
    }

    function ee(e) {
      return U(e) ? new Q(e) : F(e) ? new Y(e) : M(e) ? new $(e) : void 0
    }

    function te(e, t, r, n) {
      var i = e._cache;
      if (i) {
        for (var a = i.length - 1, s = 0; s <= a; s++) {
          var o = i[r ? a - s : s];
          if (!1 === t(o[1], n ? o[0] : s, e)) return s + 1
        }
        return s
      }
      return e.__iterateUncached(t, r)
    }

    function re(e, t, r, n) {
      var i = e._cache;
      if (i) {
        var a = i.length - 1,
          s = 0;
        return new j((function() {
          var e = i[r ? a - s : s];
          return s++ > a ? {
            value: void 0,
            done: !0
          } : k(t, n ? e[0] : s - 1, e[1])
        }))
      }
      return e.__iteratorUncached(t, r)
    }

    function ne(e, t) {
      return t ? function e(t, r, n, i) {
        return Array.isArray(r) ? t.call(i, n, G(r).map((function(n, i) {
          return e(t, n, i, r)
        }))) : ae(r) ? t.call(i, n, H(r).map((function(n, i) {
          return e(t, n, i, r)
        }))) : r
      }(t, e, "", {
        "": e
      }) : ie(e)
    }

    function ie(e) {
      return Array.isArray(e) ? G(e).map(ie).toList() : ae(e) ? H(e).map(ie).toMap() : e
    }

    function ae(e) {
      return e && (e.constructor === Object || void 0 === e.constructor)
    }

    function se(e, t) {
      if (e === t || e != e && t != t) return !0;
      if (!e || !t) return !1;
      if ("function" == typeof e.valueOf && "function" == typeof t.valueOf) {
        if ((e = e.valueOf()) === (t = t.valueOf()) || e != e && t != t) return !0;
        if (!e || !t) return !1
      }
      return !("function" != typeof e.equals || "function" != typeof t.equals || !e.equals(t))
    }

    function oe(e, t) {
      if (e === t) return !0;
      if (!s(t) || void 0 !== e.size && void 0 !== t.size && e.size !== t.size || void 0 !== e.__hash && void 0 !== t.__hash && e.__hash !== t.__hash || o(e) !== o(t) || u(e) !== u(t) || l(e) !== l(t)) return !1;
      if (0 === e.size && 0 === t.size) return !0;
      var r = !c(e);
      if (l(e)) {
        var n = e.entries();
        return t.every((function(e, t) {
          var i = n.next().value;
          return i && se(i[1], e) && (r || se(i[0], t))
        })) && n.next().done
      }
      var i = !1;
      if (void 0 === e.size)
        if (void 0 === t.size) "function" == typeof e.cacheResult && e.cacheResult();
        else {
          i = !0;
          var a = e;
          e = t, t = a
        } var h = !0,
        d = t.__iterate((function(t, n) {
          if (r ? !e.has(t) : i ? !se(t, e.get(n, g)) : !se(e.get(n, g), t)) return h = !1, !1
        }));
      return h && e.size === d
    }

    function ue(e, t) {
      if (!(this instanceof ue)) return new ue(e, t);
      if (this._value = e, this.size = void 0 === t ? 1 / 0 : Math.max(0, t), 0 === this.size) {
        if (N) return N;
        N = this
      }
    }

    function ce(e, t) {
      if (!e) throw new Error(t)
    }

    function le(e, t, r) {
      if (!(this instanceof le)) return new le(e, t, r);
      if (ce(0 !== r, "Cannot step a Range by 0"), e = e || 0, void 0 === t && (t = 1 / 0), r = void 0 === r ? 1 : Math.abs(r), t < e && (r = -r), this._start = e, this._end = t, this._step = r, this.size = Math.max(0, Math.ceil((t - e) / r - 1) + 1), 0 === this.size) {
        if (P) return P;
        P = this
      }
    }

    function he() {
      throw TypeError("Abstract")
    }

    function de() {}

    function pe() {}

    function fe() {}
    j.prototype.toString = function() {
      return "[Iterator]"
    }, j.KEYS = 0, j.VALUES = 1, j.ENTRIES = 2, j.prototype.inspect = j.prototype.toSource = function() {
      return this.toString()
    }, j.prototype[D] = function() {
      return this
    }, t(V, r), V.of = function() {
      return V(arguments)
    }, V.prototype.toSeq = function() {
      return this
    }, V.prototype.toString = function() {
      return this.__toString("Seq {", "}")
    }, V.prototype.cacheResult = function() {
      return !this._cache && this.__iterateUncached && (this._cache = this.entrySeq().toArray(), this.size = this._cache.length), this
    }, V.prototype.__iterate = function(e, t) {
      return te(this, e, t, !0)
    }, V.prototype.__iterator = function(e, t) {
      return re(this, e, t, !0)
    }, t(H, V), H.prototype.toKeyedSeq = function() {
      return this
    }, t(G, V), G.of = function() {
      return G(arguments)
    }, G.prototype.toIndexedSeq = function() {
      return this
    }, G.prototype.toString = function() {
      return this.__toString("Seq [", "]")
    }, G.prototype.__iterate = function(e, t) {
      return te(this, e, t, !1)
    }, G.prototype.__iterator = function(e, t) {
      return re(this, e, t, !1)
    }, t(z, V), z.of = function() {
      return z(arguments)
    }, z.prototype.toSetSeq = function() {
      return this
    }, V.isSeq = J, V.Keyed = H, V.Set = z, V.Indexed = G, V.prototype["@@__IMMUTABLE_SEQ__@@"] = !0, t(Q, G), Q.prototype.get = function(e, t) {
      return this.has(e) ? this._array[T(this, e)] : t
    }, Q.prototype.__iterate = function(e, t) {
      for (var r = this._array, n = r.length - 1, i = 0; i <= n; i++)
        if (!1 === e(r[t ? n - i : i], i, this)) return i + 1;
      return i
    }, Q.prototype.__iterator = function(e, t) {
      var r = this._array,
        n = r.length - 1,
        i = 0;
      return new j((function() {
        return i > n ? {
          value: void 0,
          done: !0
        } : k(e, i, r[t ? n - i++ : i++])
      }))
    }, t(X, H), X.prototype.get = function(e, t) {
      return void 0 === t || this.has(e) ? this._object[e] : t
    }, X.prototype.has = function(e) {
      return this._object.hasOwnProperty(e)
    }, X.prototype.__iterate = function(e, t) {
      for (var r = this._object, n = this._keys, i = n.length - 1, a = 0; a <= i; a++) {
        var s = n[t ? i - a : a];
        if (!1 === e(r[s], s, this)) return a + 1
      }
      return a
    }, X.prototype.__iterator = function(e, t) {
      var r = this._object,
        n = this._keys,
        i = n.length - 1,
        a = 0;
      return new j((function() {
        var s = n[t ? i - a : a];
        return a++ > i ? {
          value: void 0,
          done: !0
        } : k(e, s, r[s])
      }))
    }, X.prototype[f] = !0, t($, G), $.prototype.__iterateUncached = function(e, t) {
      if (t) return this.cacheResult().__iterate(e, t);
      var r = B(this._iterable),
        n = 0;
      if (F(r))
        for (var i; !(i = r.next()).done && !1 !== e(i.value, n++, this););
      return n
    }, $.prototype.__iteratorUncached = function(e, t) {
      if (t) return this.cacheResult().__iterator(e, t);
      var r = B(this._iterable);
      if (!F(r)) return new j(L);
      var n = 0;
      return new j((function() {
        var t = r.next();
        return t.done ? t : k(e, n++, t.value)
      }))
    }, t(Y, G), Y.prototype.__iterateUncached = function(e, t) {
      if (t) return this.cacheResult().__iterate(e, t);
      for (var r, n = this._iterator, i = this._iteratorCache, a = 0; a < i.length;)
        if (!1 === e(i[a], a++, this)) return a;
      for (; !(r = n.next()).done;) {
        var s = r.value;
        if (i[a] = s, !1 === e(s, a++, this)) break
      }
      return a
    }, Y.prototype.__iteratorUncached = function(e, t) {
      if (t) return this.cacheResult().__iterator(e, t);
      var r = this._iterator,
        n = this._iteratorCache,
        i = 0;
      return new j((function() {
        if (i >= n.length) {
          var t = r.next();
          if (t.done) return t;
          n[i] = t.value
        }
        return k(e, i, n[i++])
      }))
    }, t(ue, G), ue.prototype.toString = function() {
      return 0 === this.size ? "Repeat []" : "Repeat [ " + this._value + " " + this.size + " times ]"
    }, ue.prototype.get = function(e, t) {
      return this.has(e) ? this._value : t
    }, ue.prototype.includes = function(e) {
      return se(this._value, e)
    }, ue.prototype.slice = function(e, t) {
      var r = this.size;
      return x(e, t, r) ? this : new ue(this._value, A(t, r) - O(e, r))
    }, ue.prototype.reverse = function() {
      return this
    }, ue.prototype.indexOf = function(e) {
      return se(this._value, e) ? 0 : -1
    }, ue.prototype.lastIndexOf = function(e) {
      return se(this._value, e) ? this.size : -1
    }, ue.prototype.__iterate = function(e, t) {
      for (var r = 0; r < this.size; r++)
        if (!1 === e(this._value, r, this)) return r + 1;
      return r
    }, ue.prototype.__iterator = function(e, t) {
      var r = this,
        n = 0;
      return new j((function() {
        return n < r.size ? k(e, n++, r._value) : {
          value: void 0,
          done: !0
        }
      }))
    }, ue.prototype.equals = function(e) {
      return e instanceof ue ? se(this._value, e._value) : oe(e)
    }, t(le, G), le.prototype.toString = function() {
      return 0 === this.size ? "Range []" : "Range [ " + this._start + "..." + this._end + (1 !== this._step ? " by " + this._step : "") + " ]"
    }, le.prototype.get = function(e, t) {
      return this.has(e) ? this._start + T(this, e) * this._step : t
    }, le.prototype.includes = function(e) {
      var t = (e - this._start) / this._step;
      return t >= 0 && t < this.size && t === Math.floor(t)
    }, le.prototype.slice = function(e, t) {
      return x(e, t, this.size) ? this : (e = O(e, this.size), (t = A(t, this.size)) <= e ? new le(0, 0) : new le(this.get(e, this._end), this.get(t, this._end), this._step))
    }, le.prototype.indexOf = function(e) {
      var t = e - this._start;
      if (t % this._step == 0) {
        var r = t / this._step;
        if (r >= 0 && r < this.size) return r
      }
      return -1
    }, le.prototype.lastIndexOf = function(e) {
      return this.indexOf(e)
    }, le.prototype.__iterate = function(e, t) {
      for (var r = this.size - 1, n = this._step, i = t ? this._start + r * n : this._start, a = 0; a <= r; a++) {
        if (!1 === e(i, a, this)) return a + 1;
        i += t ? -n : n
      }
      return a
    }, le.prototype.__iterator = function(e, t) {
      var r = this.size - 1,
        n = this._step,
        i = t ? this._start + r * n : this._start,
        a = 0;
      return new j((function() {
        var s = i;
        return i += t ? -n : n, a > r ? {
          value: void 0,
          done: !0
        } : k(e, a++, s)
      }))
    }, le.prototype.equals = function(e) {
      return e instanceof le ? this._start === e._start && this._end === e._end && this._step === e._step : oe(this, e)
    }, t(he, r), t(de, he), t(pe, he), t(fe, he), he.Keyed = de, he.Indexed = pe, he.Set = fe;
    var ge = "function" == typeof Math.imul && -2 === Math.imul(4294967295, 2) ? Math.imul : function(e, t) {
      var r = 65535 & (e |= 0),
        n = 65535 & (t |= 0);
      return r * n + ((e >>> 16) * n + r * (t >>> 16) << 16 >>> 0) | 0
    };

    function me(e) {
      return e >>> 1 & 1073741824 | 3221225471 & e
    }

    function ye(e) {
      if (!1 === e || null == e) return 0;
      if ("function" == typeof e.valueOf && (!1 === (e = e.valueOf()) || null == e)) return 0;
      if (!0 === e) return 1;
      var t = typeof e;
      if ("number" === t) {
        if (e != e || e === 1 / 0) return 0;
        var r = 0 | e;
        for (r !== e && (r ^= 4294967295 * e); e > 4294967295;) r ^= e /= 4294967295;
        return me(r)
      }
      if ("string" === t) return e.length > xe ? function(e) {
        var t = Re[e];
        return void 0 === t && (t = be(e), Ae === Oe && (Ae = 0, Re = {}), Ae++, Re[e] = t), t
      }(e) : be(e);
      if ("function" == typeof e.hashCode) return e.hashCode();
      if ("object" === t) return function(e) {
        var t;
        if (Se && void 0 !== (t = _e.get(e))) return t;
        if (void 0 !== (t = e[Ee])) return t;
        if (!we) {
          if (void 0 !== (t = e.propertyIsEnumerable && e.propertyIsEnumerable[Ee])) return t;
          if (void 0 !== (t = function(e) {
            if (e && e.nodeType > 0) switch (e.nodeType) {
              case 1:
                return e.uniqueID;
              case 9:
                return e.documentElement && e.documentElement.uniqueID
            }
          }(e))) return t
        }
        if (t = ++Te, 1073741824 & Te && (Te = 0), Se) _e.set(e, t);
        else {
          if (void 0 !== ve && !1 === ve(e)) throw new Error("Non-extensible objects are not allowed as keys.");
          if (we) Object.defineProperty(e, Ee, {
            enumerable: !1,
            configurable: !1,
            writable: !1,
            value: t
          });
          else if (void 0 !== e.propertyIsEnumerable && e.propertyIsEnumerable === e.constructor.prototype.propertyIsEnumerable) e.propertyIsEnumerable = function() {
            return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments)
          }, e.propertyIsEnumerable[Ee] = t;
          else {
            if (void 0 === e.nodeType) throw new Error("Unable to set a non-enumerable property on object.");
            e[Ee] = t
          }
        }
        return t
      }(e);
      if ("function" == typeof e.toString) return be(e.toString());
      throw new Error("Value type " + t + " cannot be hashed.")
    }

    function be(e) {
      for (var t = 0, r = 0; r < e.length; r++) t = 31 * t + e.charCodeAt(r) | 0;
      return me(t)
    }
    var _e, ve = Object.isExtensible,
      we = function() {
        try {
          return Object.defineProperty({}, "@", {}), !0
        } catch (e) {
          return !1
        }
      }(),
      Se = "function" == typeof WeakMap;
    Se && (_e = new WeakMap);
    var Te = 0,
      Ee = "__immutablehash__";
    "function" == typeof Symbol && (Ee = Symbol(Ee));
    var xe = 16,
      Oe = 255,
      Ae = 0,
      Re = {};

    function Ie(e) {
      ce(e !== 1 / 0, "Cannot perform this action with an infinite size.")
    }

    function Ne(e) {
      return null == e ? Ge() : Pe(e) && !l(e) ? e : Ge().withMutations((function(t) {
        var r = n(e);
        Ie(r.size), r.forEach((function(e, r) {
          return t.set(r, e)
        }))
      }))
    }

    function Pe(e) {
      return !(!e || !e[De])
    }
    t(Ne, de), Ne.of = function() {
      var t = e.call(arguments, 0);
      return Ge().withMutations((function(e) {
        for (var r = 0; r < t.length; r += 2) {
          if (r + 1 >= t.length) throw new Error("Missing value for key: " + t[r]);
          e.set(t[r], t[r + 1])
        }
      }))
    }, Ne.prototype.toString = function() {
      return this.__toString("Map {", "}")
    }, Ne.prototype.get = function(e, t) {
      return this._root ? this._root.get(0, void 0, e, t) : t
    }, Ne.prototype.set = function(e, t) {
      return ze(this, e, t)
    }, Ne.prototype.setIn = function(e, t) {
      return this.updateIn(e, g, (function() {
        return t
      }))
    }, Ne.prototype.remove = function(e) {
      return ze(this, e, g)
    }, Ne.prototype.deleteIn = function(e) {
      return this.updateIn(e, (function() {
        return g
      }))
    }, Ne.prototype.update = function(e, t, r) {
      return 1 === arguments.length ? e(this) : this.updateIn([e], t, r)
    }, Ne.prototype.updateIn = function(e, t, r) {
      r || (r = t, t = void 0);
      var n = function e(t, r, n, i) {
        var a = t === g,
          s = r.next();
        if (s.done) {
          var o = a ? n : t,
            u = i(o);
          return u === o ? t : u
        }
        ce(a || t && t.set, "invalid keyPath");
        var c = s.value,
          l = a ? g : t.get(c, g),
          h = e(l, r, n, i);
        return h === l ? t : h === g ? t.remove(c) : (a ? Ge() : t).set(c, h)
      }(this, Yt(e), t, r);
      return n === g ? void 0 : n
    }, Ne.prototype.clear = function() {
      return 0 === this.size ? this : this.__ownerID ? (this.size = 0, this._root = null, this.__hash = void 0, this.__altered = !0, this) : Ge()
    }, Ne.prototype.merge = function() {
      return Ye(this, void 0, arguments)
    }, Ne.prototype.mergeWith = function(t) {
      var r = e.call(arguments, 1);
      return Ye(this, t, r)
    }, Ne.prototype.mergeIn = function(t) {
      var r = e.call(arguments, 1);
      return this.updateIn(t, Ge(), (function(e) {
        return "function" == typeof e.merge ? e.merge.apply(e, r) : r[r.length - 1]
      }))
    }, Ne.prototype.mergeDeep = function() {
      return Ye(this, Je, arguments)
    }, Ne.prototype.mergeDeepWith = function(t) {
      var r = e.call(arguments, 1);
      return Ye(this, We(t), r)
    }, Ne.prototype.mergeDeepIn = function(t) {
      var r = e.call(arguments, 1);
      return this.updateIn(t, Ge(), (function(e) {
        return "function" == typeof e.mergeDeep ? e.mergeDeep.apply(e, r) : r[r.length - 1]
      }))
    }, Ne.prototype.sort = function(e) {
      return wt(Ft(this, e))
    }, Ne.prototype.sortBy = function(e, t) {
      return wt(Ft(this, t, e))
    }, Ne.prototype.withMutations = function(e) {
      var t = this.asMutable();
      return e(t), t.wasAltered() ? t.__ensureOwner(this.__ownerID) : this
    }, Ne.prototype.asMutable = function() {
      return this.__ownerID ? this : this.__ensureOwner(new v)
    }, Ne.prototype.asImmutable = function() {
      return this.__ensureOwner()
    }, Ne.prototype.wasAltered = function() {
      return this.__altered
    }, Ne.prototype.__iterator = function(e, t) {
      return new qe(this, e, t)
    }, Ne.prototype.__iterate = function(e, t) {
      var r = this,
        n = 0;
      return this._root && this._root.iterate((function(t) {
        return n++, e(t[1], t[0], r)
      }), t), n
    }, Ne.prototype.__ensureOwner = function(e) {
      return e === this.__ownerID ? this : e ? He(this.size, this._root, e, this.__hash) : (this.__ownerID = e, this.__altered = !1, this)
    }, Ne.isMap = Pe;
    var Ce, De = "@@__IMMUTABLE_MAP__@@",
      je = Ne.prototype;

    function ke(e, t) {
      this.ownerID = e, this.entries = t
    }

    function Le(e, t, r) {
      this.ownerID = e, this.bitmap = t, this.nodes = r
    }

    function Me(e, t, r) {
      this.ownerID = e, this.count = t, this.nodes = r
    }

    function Fe(e, t, r) {
      this.ownerID = e, this.keyHash = t, this.entries = r
    }

    function Be(e, t, r) {
      this.ownerID = e, this.keyHash = t, this.entry = r
    }

    function qe(e, t, r) {
      this._type = t, this._reverse = r, this._stack = e._root && Ve(e._root)
    }

    function Ue(e, t) {
      return k(e, t[0], t[1])
    }

    function Ve(e, t) {
      return {
        node: e,
        index: 0,
        __prev: t
      }
    }

    function He(e, t, r, n) {
      var i = Object.create(je);
      return i.size = e, i._root = t, i.__ownerID = r, i.__hash = n, i.__altered = !1, i
    }

    function Ge() {
      return Ce || (Ce = He(0))
    }

    function ze(e, t, r) {
      var n, i;
      if (e._root) {
        var a = b(m),
          s = b(y);
        if (n = Qe(e._root, e.__ownerID, 0, void 0, t, r, a, s), !s.value) return e;
        i = e.size + (a.value ? r === g ? -1 : 1 : 0)
      } else {
        if (r === g) return e;
        i = 1, n = new ke(e.__ownerID, [
          [t, r]
        ])
      }
      return e.__ownerID ? (e.size = i, e._root = n, e.__hash = void 0, e.__altered = !0, e) : n ? He(i, n) : Ge()
    }

    function Qe(e, t, r, n, i, a, s, o) {
      return e ? e.update(t, r, n, i, a, s, o) : a === g ? e : (_(o), _(s), new Be(t, n, [i, a]))
    }

    function Xe(e) {
      return e.constructor === Be || e.constructor === Fe
    }

    function $e(e, t, r, n, i) {
      if (e.keyHash === n) return new Fe(t, n, [e.entry, i]);
      var a, s = 31 & (0 === r ? e.keyHash : e.keyHash >>> r),
        o = 31 & (0 === r ? n : n >>> r);
      return new Le(t, 1 << s | 1 << o, s === o ? [$e(e, t, r + 5, n, i)] : (a = new Be(t, n, i), s < o ? [e, a] : [a, e]))
    }

    function Ye(e, t, r) {
      for (var i = [], a = 0; a < r.length; a++) {
        var o = r[a],
          u = n(o);
        s(o) || (u = u.map((function(e) {
          return ne(e)
        }))), i.push(u)
      }
      return Ke(e, t, i)
    }

    function Je(e, t, r) {
      return e && e.mergeDeep && s(t) ? e.mergeDeep(t) : se(e, t) ? e : t
    }

    function We(e) {
      return function(t, r, n) {
        if (t && t.mergeDeepWith && s(r)) return t.mergeDeepWith(e, r);
        var i = e(t, r, n);
        return se(t, i) ? t : i
      }
    }

    function Ke(e, t, r) {
      return 0 === (r = r.filter((function(e) {
        return 0 !== e.size
      }))).length ? e : 0 !== e.size || e.__ownerID || 1 !== r.length ? e.withMutations((function(e) {
        for (var n = t ? function(r, n) {
          e.update(n, g, (function(e) {
            return e === g ? r : t(e, r, n)
          }))
        } : function(t, r) {
          e.set(r, t)
        }, i = 0; i < r.length; i++) r[i].forEach(n)
      })) : e.constructor(r[0])
    }

    function Ze(e) {
      return e = (e = (858993459 & (e -= e >> 1 & 1431655765)) + (e >> 2 & 858993459)) + (e >> 4) & 252645135, e += e >> 8, 127 & (e += e >> 16)
    }

    function et(e, t, r, n) {
      var i = n ? e : w(e);
      return i[t] = r, i
    }
    je[De] = !0, je.delete = je.remove, je.removeIn = je.deleteIn, ke.prototype.get = function(e, t, r, n) {
      for (var i = this.entries, a = 0, s = i.length; a < s; a++)
        if (se(r, i[a][0])) return i[a][1];
      return n
    }, ke.prototype.update = function(e, t, r, n, i, a, s) {
      for (var o = i === g, u = this.entries, c = 0, l = u.length; c < l && !se(n, u[c][0]); c++);
      var h = c < l;
      if (h ? u[c][1] === i : o) return this;
      if (_(s), (o || !h) && _(a), !o || 1 !== u.length) {
        if (!h && !o && u.length >= tt) return function(e, t, r, n) {
          e || (e = new v);
          for (var i = new Be(e, ye(r), [r, n]), a = 0; a < t.length; a++) {
            var s = t[a];
            i = i.update(e, 0, void 0, s[0], s[1])
          }
          return i
        }(e, u, n, i);
        var d = e && e === this.ownerID,
          p = d ? u : w(u);
        return h ? o ? c === l - 1 ? p.pop() : p[c] = p.pop() : p[c] = [n, i] : p.push([n, i]), d ? (this.entries = p, this) : new ke(e, p)
      }
    }, Le.prototype.get = function(e, t, r, n) {
      void 0 === t && (t = ye(r));
      var i = 1 << (31 & (0 === e ? t : t >>> e)),
        a = this.bitmap;
      return 0 == (a & i) ? n : this.nodes[Ze(a & i - 1)].get(e + 5, t, r, n)
    }, Le.prototype.update = function(e, t, r, n, i, a, s) {
      void 0 === r && (r = ye(n));
      var o = 31 & (0 === t ? r : r >>> t),
        u = 1 << o,
        c = this.bitmap,
        l = 0 != (c & u);
      if (!l && i === g) return this;
      var h = Ze(c & u - 1),
        d = this.nodes,
        p = l ? d[h] : void 0,
        f = Qe(p, e, t + 5, r, n, i, a, s);
      if (f === p) return this;
      if (!l && f && d.length >= rt) return function(e, t, r, n, i) {
        for (var a = 0, s = new Array(32), o = 0; 0 !== r; o++, r >>>= 1) s[o] = 1 & r ? t[a++] : void 0;
        return s[n] = i, new Me(e, a + 1, s)
      }(e, d, c, o, f);
      if (l && !f && 2 === d.length && Xe(d[1 ^ h])) return d[1 ^ h];
      if (l && f && 1 === d.length && Xe(f)) return f;
      var m = e && e === this.ownerID,
        y = l ? f ? c : c ^ u : c | u,
        b = l ? f ? et(d, h, f, m) : function(e, t, r) {
          var n = e.length - 1;
          if (r && t === n) return e.pop(), e;
          for (var i = new Array(n), a = 0, s = 0; s < n; s++) s === t && (a = 1), i[s] = e[s + a];
          return i
        }(d, h, m) : function(e, t, r, n) {
          var i = e.length + 1;
          if (n && t + 1 === i) return e[t] = r, e;
          for (var a = new Array(i), s = 0, o = 0; o < i; o++) o === t ? (a[o] = r, s = -1) : a[o] = e[o + s];
          return a
        }(d, h, f, m);
      return m ? (this.bitmap = y, this.nodes = b, this) : new Le(e, y, b)
    }, Me.prototype.get = function(e, t, r, n) {
      void 0 === t && (t = ye(r));
      var i = 31 & (0 === e ? t : t >>> e),
        a = this.nodes[i];
      return a ? a.get(e + 5, t, r, n) : n
    }, Me.prototype.update = function(e, t, r, n, i, a, s) {
      void 0 === r && (r = ye(n));
      var o = 31 & (0 === t ? r : r >>> t),
        u = i === g,
        c = this.nodes,
        l = c[o];
      if (u && !l) return this;
      var h = Qe(l, e, t + 5, r, n, i, a, s);
      if (h === l) return this;
      var d = this.count;
      if (l) {
        if (!h && --d < nt) return function(e, t, r, n) {
          for (var i = 0, a = 0, s = new Array(r), o = 0, u = 1, c = t.length; o < c; o++, u <<= 1) {
            var l = t[o];
            void 0 !== l && o !== n && (i |= u, s[a++] = l)
          }
          return new Le(e, i, s)
        }(e, c, d, o)
      } else d++;
      var p = e && e === this.ownerID,
        f = et(c, o, h, p);
      return p ? (this.count = d, this.nodes = f, this) : new Me(e, d, f)
    }, Fe.prototype.get = function(e, t, r, n) {
      for (var i = this.entries, a = 0, s = i.length; a < s; a++)
        if (se(r, i[a][0])) return i[a][1];
      return n
    }, Fe.prototype.update = function(e, t, r, n, i, a, s) {
      void 0 === r && (r = ye(n));
      var o = i === g;
      if (r !== this.keyHash) return o ? this : (_(s), _(a), $e(this, e, t, r, [n, i]));
      for (var u = this.entries, c = 0, l = u.length; c < l && !se(n, u[c][0]); c++);
      var h = c < l;
      if (h ? u[c][1] === i : o) return this;
      if (_(s), (o || !h) && _(a), o && 2 === l) return new Be(e, this.keyHash, u[1 ^ c]);
      var d = e && e === this.ownerID,
        p = d ? u : w(u);
      return h ? o ? c === l - 1 ? p.pop() : p[c] = p.pop() : p[c] = [n, i] : p.push([n, i]), d ? (this.entries = p, this) : new Fe(e, this.keyHash, p)
    }, Be.prototype.get = function(e, t, r, n) {
      return se(r, this.entry[0]) ? this.entry[1] : n
    }, Be.prototype.update = function(e, t, r, n, i, a, s) {
      var o = i === g,
        u = se(n, this.entry[0]);
      return (u ? i === this.entry[1] : o) ? this : (_(s), o ? void _(a) : u ? e && e === this.ownerID ? (this.entry[1] = i, this) : new Be(e, this.keyHash, [n, i]) : (_(a), $e(this, e, t, ye(n), [n, i])))
    }, ke.prototype.iterate = Fe.prototype.iterate = function(e, t) {
      for (var r = this.entries, n = 0, i = r.length - 1; n <= i; n++)
        if (!1 === e(r[t ? i - n : n])) return !1
    }, Le.prototype.iterate = Me.prototype.iterate = function(e, t) {
      for (var r = this.nodes, n = 0, i = r.length - 1; n <= i; n++) {
        var a = r[t ? i - n : n];
        if (a && !1 === a.iterate(e, t)) return !1
      }
    }, Be.prototype.iterate = function(e, t) {
      return e(this.entry)
    }, t(qe, j), qe.prototype.next = function() {
      for (var e = this._type, t = this._stack; t;) {
        var r, n = t.node,
          i = t.index++;
        if (n.entry) {
          if (0 === i) return Ue(e, n.entry)
        } else if (n.entries) {
          if (i <= (r = n.entries.length - 1)) return Ue(e, n.entries[this._reverse ? r - i : i])
        } else if (i <= (r = n.nodes.length - 1)) {
          var a = n.nodes[this._reverse ? r - i : i];
          if (a) {
            if (a.entry) return Ue(e, a.entry);
            t = this._stack = Ve(a, t)
          }
          continue
        }
        t = this._stack = this._stack.__prev
      }
      return {
        value: void 0,
        done: !0
      }
    };
    var tt = 8,
      rt = 16,
      nt = 8;

    function it(e) {
      var t = ft();
      if (null == e) return t;
      if (at(e)) return e;
      var r = i(e),
        n = r.size;
      return 0 === n ? t : (Ie(n), n > 0 && n < 32 ? pt(0, n, 5, null, new ut(r.toArray())) : t.withMutations((function(e) {
        e.setSize(n), r.forEach((function(t, r) {
          return e.set(r, t)
        }))
      })))
    }

    function at(e) {
      return !(!e || !e[st])
    }
    t(it, pe), it.of = function() {
      return this(arguments)
    }, it.prototype.toString = function() {
      return this.__toString("List [", "]")
    }, it.prototype.get = function(e, t) {
      if ((e = T(this, e)) >= 0 && e < this.size) {
        var r = yt(this, e += this._origin);
        return r && r.array[31 & e]
      }
      return t
    }, it.prototype.set = function(e, t) {
      return function(e, t, r) {
        if ((t = T(e, t)) != t) return e;
        if (t >= e.size || t < 0) return e.withMutations((function(e) {
          t < 0 ? bt(e, t).set(0, r) : bt(e, 0, t + 1).set(t, r)
        }));
        t += e._origin;
        var n = e._tail,
          i = e._root,
          a = b(y);
        return t >= vt(e._capacity) ? n = gt(n, e.__ownerID, 0, t, r, a) : i = gt(i, e.__ownerID, e._level, t, r, a), a.value ? e.__ownerID ? (e._root = i, e._tail = n, e.__hash = void 0, e.__altered = !0, e) : pt(e._origin, e._capacity, e._level, i, n) : e
      }(this, e, t)
    }, it.prototype.remove = function(e) {
      return this.has(e) ? 0 === e ? this.shift() : e === this.size - 1 ? this.pop() : this.splice(e, 1) : this
    }, it.prototype.insert = function(e, t) {
      return this.splice(e, 0, t)
    }, it.prototype.clear = function() {
      return 0 === this.size ? this : this.__ownerID ? (this.size = this._origin = this._capacity = 0, this._level = 5, this._root = this._tail = null, this.__hash = void 0, this.__altered = !0, this) : ft()
    }, it.prototype.push = function() {
      var e = arguments,
        t = this.size;
      return this.withMutations((function(r) {
        bt(r, 0, t + e.length);
        for (var n = 0; n < e.length; n++) r.set(t + n, e[n])
      }))
    }, it.prototype.pop = function() {
      return bt(this, 0, -1)
    }, it.prototype.unshift = function() {
      var e = arguments;
      return this.withMutations((function(t) {
        bt(t, -e.length);
        for (var r = 0; r < e.length; r++) t.set(r, e[r])
      }))
    }, it.prototype.shift = function() {
      return bt(this, 1)
    }, it.prototype.merge = function() {
      return _t(this, void 0, arguments)
    }, it.prototype.mergeWith = function(t) {
      var r = e.call(arguments, 1);
      return _t(this, t, r)
    }, it.prototype.mergeDeep = function() {
      return _t(this, Je, arguments)
    }, it.prototype.mergeDeepWith = function(t) {
      var r = e.call(arguments, 1);
      return _t(this, We(t), r)
    }, it.prototype.setSize = function(e) {
      return bt(this, 0, e)
    }, it.prototype.slice = function(e, t) {
      var r = this.size;
      return x(e, t, r) ? this : bt(this, O(e, r), A(t, r))
    }, it.prototype.__iterator = function(e, t) {
      var r = 0,
        n = dt(this, t);
      return new j((function() {
        var t = n();
        return t === ht ? {
          value: void 0,
          done: !0
        } : k(e, r++, t)
      }))
    }, it.prototype.__iterate = function(e, t) {
      for (var r, n = 0, i = dt(this, t);
           (r = i()) !== ht && !1 !== e(r, n++, this););
      return n
    }, it.prototype.__ensureOwner = function(e) {
      return e === this.__ownerID ? this : e ? pt(this._origin, this._capacity, this._level, this._root, this._tail, e, this.__hash) : (this.__ownerID = e, this)
    }, it.isList = at;
    var st = "@@__IMMUTABLE_LIST__@@",
      ot = it.prototype;

    function ut(e, t) {
      this.array = e, this.ownerID = t
    }
    ot[st] = !0, ot.delete = ot.remove, ot.setIn = je.setIn, ot.deleteIn = ot.removeIn = je.removeIn, ot.update = je.update, ot.updateIn = je.updateIn, ot.mergeIn = je.mergeIn, ot.mergeDeepIn = je.mergeDeepIn, ot.withMutations = je.withMutations, ot.asMutable = je.asMutable, ot.asImmutable = je.asImmutable, ot.wasAltered = je.wasAltered, ut.prototype.removeBefore = function(e, t, r) {
      if (r === t ? 1 << t : 0 === this.array.length) return this;
      var n = r >>> t & 31;
      if (n >= this.array.length) return new ut([], e);
      var i, a = 0 === n;
      if (t > 0) {
        var s = this.array[n];
        if ((i = s && s.removeBefore(e, t - 5, r)) === s && a) return this
      }
      if (a && !i) return this;
      var o = mt(this, e);
      if (!a)
        for (var u = 0; u < n; u++) o.array[u] = void 0;
      return i && (o.array[n] = i), o
    }, ut.prototype.removeAfter = function(e, t, r) {
      if (r === (t ? 1 << t : 0) || 0 === this.array.length) return this;
      var n, i = r - 1 >>> t & 31;
      if (i >= this.array.length) return this;
      if (t > 0) {
        var a = this.array[i];
        if ((n = a && a.removeAfter(e, t - 5, r)) === a && i === this.array.length - 1) return this
      }
      var s = mt(this, e);
      return s.array.splice(i + 1), n && (s.array[i] = n), s
    };
    var ct, lt, ht = {};

    function dt(e, t) {
      var r = e._origin,
        n = e._capacity,
        i = vt(n),
        a = e._tail;
      return s(e._root, e._level, 0);

      function s(e, o, u) {
        return 0 === o ? function(e, s) {
          var o = s === i ? a && a.array : e && e.array,
            u = s > r ? 0 : r - s,
            c = n - s;
          return c > 32 && (c = 32),
            function() {
              if (u === c) return ht;
              var e = t ? --c : u++;
              return o && o[e]
            }
        }(e, u) : function(e, i, a) {
          var o, u = e && e.array,
            c = a > r ? 0 : r - a >> i,
            l = 1 + (n - a >> i);
          return l > 32 && (l = 32),
            function() {
              for (;;) {
                if (o) {
                  var e = o();
                  if (e !== ht) return e;
                  o = null
                }
                if (c === l) return ht;
                var r = t ? --l : c++;
                o = s(u && u[r], i - 5, a + (r << i))
              }
            }
        }(e, o, u)
      }
    }

    function pt(e, t, r, n, i, a, s) {
      var o = Object.create(ot);
      return o.size = t - e, o._origin = e, o._capacity = t, o._level = r, o._root = n, o._tail = i, o.__ownerID = a, o.__hash = s, o.__altered = !1, o
    }

    function ft() {
      return ct || (ct = pt(0, 0, 5))
    }

    function gt(e, t, r, n, i, a) {
      var s, o = n >>> r & 31,
        u = e && o < e.array.length;
      if (!u && void 0 === i) return e;
      if (r > 0) {
        var c = e && e.array[o],
          l = gt(c, t, r - 5, n, i, a);
        return l === c ? e : ((s = mt(e, t)).array[o] = l, s)
      }
      return u && e.array[o] === i ? e : (_(a), s = mt(e, t), void 0 === i && o === s.array.length - 1 ? s.array.pop() : s.array[o] = i, s)
    }

    function mt(e, t) {
      return t && e && t === e.ownerID ? e : new ut(e ? e.array.slice() : [], t)
    }

    function yt(e, t) {
      if (t >= vt(e._capacity)) return e._tail;
      if (t < 1 << e._level + 5) {
        for (var r = e._root, n = e._level; r && n > 0;) r = r.array[t >>> n & 31], n -= 5;
        return r
      }
    }

    function bt(e, t, r) {
      void 0 !== t && (t |= 0), void 0 !== r && (r |= 0);
      var n = e.__ownerID || new v,
        i = e._origin,
        a = e._capacity,
        s = i + t,
        o = void 0 === r ? a : r < 0 ? a + r : i + r;
      if (s === i && o === a) return e;
      if (s >= o) return e.clear();
      for (var u = e._level, c = e._root, l = 0; s + l < 0;) c = new ut(c && c.array.length ? [void 0, c] : [], n), l += 1 << (u += 5);
      l && (s += l, i += l, o += l, a += l);
      for (var h = vt(a), d = vt(o); d >= 1 << u + 5;) c = new ut(c && c.array.length ? [c] : [], n), u += 5;
      var p = e._tail,
        f = d < h ? yt(e, o - 1) : d > h ? new ut([], n) : p;
      if (p && d > h && s < a && p.array.length) {
        for (var g = c = mt(c, n), m = u; m > 5; m -= 5) {
          var y = h >>> m & 31;
          g = g.array[y] = mt(g.array[y], n)
        }
        g.array[h >>> 5 & 31] = p
      }
      if (o < a && (f = f && f.removeAfter(n, 0, o)), s >= d) s -= d, o -= d, u = 5, c = null, f = f && f.removeBefore(n, 0, s);
      else if (s > i || d < h) {
        for (l = 0; c;) {
          var b = s >>> u & 31;
          if (b !== d >>> u & 31) break;
          b && (l += (1 << u) * b), u -= 5, c = c.array[b]
        }
        c && s > i && (c = c.removeBefore(n, u, s - l)), c && d < h && (c = c.removeAfter(n, u, d - l)), l && (s -= l, o -= l)
      }
      return e.__ownerID ? (e.size = o - s, e._origin = s, e._capacity = o, e._level = u, e._root = c, e._tail = f, e.__hash = void 0, e.__altered = !0, e) : pt(s, o, u, c, f)
    }

    function _t(e, t, r) {
      for (var n = [], a = 0, o = 0; o < r.length; o++) {
        var u = r[o],
          c = i(u);
        c.size > a && (a = c.size), s(u) || (c = c.map((function(e) {
          return ne(e)
        }))), n.push(c)
      }
      return a > e.size && (e = e.setSize(a)), Ke(e, t, n)
    }

    function vt(e) {
      return e < 32 ? 0 : e - 1 >>> 5 << 5
    }

    function wt(e) {
      return null == e ? Et() : St(e) ? e : Et().withMutations((function(t) {
        var r = n(e);
        Ie(r.size), r.forEach((function(e, r) {
          return t.set(r, e)
        }))
      }))
    }

    function St(e) {
      return Pe(e) && l(e)
    }

    function Tt(e, t, r, n) {
      var i = Object.create(wt.prototype);
      return i.size = e ? e.size : 0, i._map = e, i._list = t, i.__ownerID = r, i.__hash = n, i
    }

    function Et() {
      return lt || (lt = Tt(Ge(), ft()))
    }

    function xt(e, t, r) {
      var n, i, a = e._map,
        s = e._list,
        o = a.get(t),
        u = void 0 !== o;
      if (r === g) {
        if (!u) return e;
        s.size >= 32 && s.size >= 2 * a.size ? (n = (i = s.filter((function(e, t) {
          return void 0 !== e && o !== t
        }))).toKeyedSeq().map((function(e) {
          return e[0]
        })).flip().toMap(), e.__ownerID && (n.__ownerID = i.__ownerID = e.__ownerID)) : (n = a.remove(t), i = o === s.size - 1 ? s.pop() : s.set(o, void 0))
      } else if (u) {
        if (r === s.get(o)[1]) return e;
        n = a, i = s.set(o, [t, r])
      } else n = a.set(t, s.size), i = s.set(s.size, [t, r]);
      return e.__ownerID ? (e.size = n.size, e._map = n, e._list = i, e.__hash = void 0, e) : Tt(n, i)
    }

    function Ot(e, t) {
      this._iter = e, this._useKeys = t, this.size = e.size
    }

    function At(e) {
      this._iter = e, this.size = e.size
    }

    function Rt(e) {
      this._iter = e, this.size = e.size
    }

    function It(e) {
      this._iter = e, this.size = e.size
    }

    function Nt(e) {
      var t = Qt(e);
      return t._iter = e, t.size = e.size, t.flip = function() {
        return e
      }, t.reverse = function() {
        var t = e.reverse.apply(this);
        return t.flip = function() {
          return e.reverse()
        }, t
      }, t.has = function(t) {
        return e.includes(t)
      }, t.includes = function(t) {
        return e.has(t)
      }, t.cacheResult = Xt, t.__iterateUncached = function(t, r) {
        var n = this;
        return e.__iterate((function(e, r) {
          return !1 !== t(r, e, n)
        }), r)
      }, t.__iteratorUncached = function(t, r) {
        if (2 === t) {
          var n = e.__iterator(t, r);
          return new j((function() {
            var e = n.next();
            if (!e.done) {
              var t = e.value[0];
              e.value[0] = e.value[1], e.value[1] = t
            }
            return e
          }))
        }
        return e.__iterator(1 === t ? 0 : 1, r)
      }, t
    }

    function Pt(e, t, r) {
      var n = Qt(e);
      return n.size = e.size, n.has = function(t) {
        return e.has(t)
      }, n.get = function(n, i) {
        var a = e.get(n, g);
        return a === g ? i : t.call(r, a, n, e)
      }, n.__iterateUncached = function(n, i) {
        var a = this;
        return e.__iterate((function(e, i, s) {
          return !1 !== n(t.call(r, e, i, s), i, a)
        }), i)
      }, n.__iteratorUncached = function(n, i) {
        var a = e.__iterator(2, i);
        return new j((function() {
          var i = a.next();
          if (i.done) return i;
          var s = i.value,
            o = s[0];
          return k(n, o, t.call(r, s[1], o, e), i)
        }))
      }, n
    }

    function Ct(e, t) {
      var r = Qt(e);
      return r._iter = e, r.size = e.size, r.reverse = function() {
        return e
      }, e.flip && (r.flip = function() {
        var t = Nt(e);
        return t.reverse = function() {
          return e.flip()
        }, t
      }), r.get = function(r, n) {
        return e.get(t ? r : -1 - r, n)
      }, r.has = function(r) {
        return e.has(t ? r : -1 - r)
      }, r.includes = function(t) {
        return e.includes(t)
      }, r.cacheResult = Xt, r.__iterate = function(t, r) {
        var n = this;
        return e.__iterate((function(e, r) {
          return t(e, r, n)
        }), !r)
      }, r.__iterator = function(t, r) {
        return e.__iterator(t, !r)
      }, r
    }

    function Dt(e, t, r, n) {
      var i = Qt(e);
      return n && (i.has = function(n) {
        var i = e.get(n, g);
        return i !== g && !!t.call(r, i, n, e)
      }, i.get = function(n, i) {
        var a = e.get(n, g);
        return a !== g && t.call(r, a, n, e) ? a : i
      }), i.__iterateUncached = function(i, a) {
        var s = this,
          o = 0;
        return e.__iterate((function(e, a, u) {
          if (t.call(r, e, a, u)) return o++, i(e, n ? a : o - 1, s)
        }), a), o
      }, i.__iteratorUncached = function(i, a) {
        var s = e.__iterator(2, a),
          o = 0;
        return new j((function() {
          for (;;) {
            var a = s.next();
            if (a.done) return a;
            var u = a.value,
              c = u[0],
              l = u[1];
            if (t.call(r, l, c, e)) return k(i, n ? c : o++, l, a)
          }
        }))
      }, i
    }

    function jt(e, t, r, n) {
      var i = e.size;
      if (void 0 !== t && (t |= 0), void 0 !== r && (r === 1 / 0 ? r = i : r |= 0), x(t, r, i)) return e;
      var a = O(t, i),
        s = A(r, i);
      if (a != a || s != s) return jt(e.toSeq().cacheResult(), t, r, n);
      var o, u = s - a;
      u == u && (o = u < 0 ? 0 : u);
      var c = Qt(e);
      return c.size = 0 === o ? o : e.size && o || void 0, !n && J(e) && o >= 0 && (c.get = function(t, r) {
        return (t = T(this, t)) >= 0 && t < o ? e.get(t + a, r) : r
      }), c.__iterateUncached = function(t, r) {
        var i = this;
        if (0 === o) return 0;
        if (r) return this.cacheResult().__iterate(t, r);
        var s = 0,
          u = !0,
          c = 0;
        return e.__iterate((function(e, r) {
          if (!u || !(u = s++ < a)) return c++, !1 !== t(e, n ? r : c - 1, i) && c !== o
        })), c
      }, c.__iteratorUncached = function(t, r) {
        if (0 !== o && r) return this.cacheResult().__iterator(t, r);
        var i = 0 !== o && e.__iterator(t, r),
          s = 0,
          u = 0;
        return new j((function() {
          for (; s++ < a;) i.next();
          if (++u > o) return {
            value: void 0,
            done: !0
          };
          var e = i.next();
          return n || 1 === t ? e : k(t, u - 1, 0 === t ? void 0 : e.value[1], e)
        }))
      }, c
    }

    function kt(e, t, r, n) {
      var i = Qt(e);
      return i.__iterateUncached = function(i, a) {
        var s = this;
        if (a) return this.cacheResult().__iterate(i, a);
        var o = !0,
          u = 0;
        return e.__iterate((function(e, a, c) {
          if (!o || !(o = t.call(r, e, a, c))) return u++, i(e, n ? a : u - 1, s)
        })), u
      }, i.__iteratorUncached = function(i, a) {
        var s = this;
        if (a) return this.cacheResult().__iterator(i, a);
        var o = e.__iterator(2, a),
          u = !0,
          c = 0;
        return new j((function() {
          var e, a, l;
          do {
            if ((e = o.next()).done) return n || 1 === i ? e : k(i, c++, 0 === i ? void 0 : e.value[1], e);
            var h = e.value;
            a = h[0], l = h[1], u && (u = t.call(r, l, a, s))
          } while (u);
          return 2 === i ? e : k(i, a, l, e)
        }))
      }, i
    }

    function Lt(e, t) {
      var r = o(e),
        i = [e].concat(t).map((function(e) {
          return s(e) ? r && (e = n(e)) : e = r ? K(e) : Z(Array.isArray(e) ? e : [e]), e
        })).filter((function(e) {
          return 0 !== e.size
        }));
      if (0 === i.length) return e;
      if (1 === i.length) {
        var a = i[0];
        if (a === e || r && o(a) || u(e) && u(a)) return a
      }
      var c = new Q(i);
      return r ? c = c.toKeyedSeq() : u(e) || (c = c.toSetSeq()), (c = c.flatten(!0)).size = i.reduce((function(e, t) {
        if (void 0 !== e) {
          var r = t.size;
          if (void 0 !== r) return e + r
        }
      }), 0), c
    }

    function Mt(e, t, r) {
      var n = Qt(e);
      return n.__iterateUncached = function(n, i) {
        var a = 0,
          o = !1;
        return function e(u, c) {
          var l = this;
          u.__iterate((function(i, u) {
            return (!t || c < t) && s(i) ? e(i, c + 1) : !1 === n(i, r ? u : a++, l) && (o = !0), !o
          }), i)
        }(e, 0), a
      }, n.__iteratorUncached = function(n, i) {
        var a = e.__iterator(n, i),
          o = [],
          u = 0;
        return new j((function() {
          for (; a;) {
            var e = a.next();
            if (!1 === e.done) {
              var c = e.value;
              if (2 === n && (c = c[1]), t && !(o.length < t) || !s(c)) return r ? e : k(n, u++, c, e);
              o.push(a), a = c.__iterator(n, i)
            } else a = o.pop()
          }
          return {
            value: void 0,
            done: !0
          }
        }))
      }, n
    }

    function Ft(e, t, r) {
      t || (t = $t);
      var n = o(e),
        i = 0,
        a = e.toSeq().map((function(t, n) {
          return [n, t, i++, r ? r(t, n, e) : t]
        })).toArray();
      return a.sort((function(e, r) {
        return t(e[3], r[3]) || e[2] - r[2]
      })).forEach(n ? function(e, t) {
        a[t].length = 2
      } : function(e, t) {
        a[t] = e[1]
      }), n ? H(a) : u(e) ? G(a) : z(a)
    }

    function Bt(e, t, r) {
      if (t || (t = $t), r) {
        var n = e.toSeq().map((function(t, n) {
          return [t, r(t, n, e)]
        })).reduce((function(e, r) {
          return qt(t, e[1], r[1]) ? r : e
        }));
        return n && n[0]
      }
      return e.reduce((function(e, r) {
        return qt(t, e, r) ? r : e
      }))
    }

    function qt(e, t, r) {
      var n = e(r, t);
      return 0 === n && r !== t && (null == r || r != r) || n > 0
    }

    function Ut(e, t, n) {
      var i = Qt(e);
      return i.size = new Q(n).map((function(e) {
        return e.size
      })).min(), i.__iterate = function(e, t) {
        for (var r, n = this.__iterator(1, t), i = 0; !(r = n.next()).done && !1 !== e(r.value, i++, this););
        return i
      }, i.__iteratorUncached = function(e, i) {
        var a = n.map((function(e) {
            return e = r(e), B(i ? e.reverse() : e)
          })),
          s = 0,
          o = !1;
        return new j((function() {
          var r;
          return o || (r = a.map((function(e) {
            return e.next()
          })), o = r.some((function(e) {
            return e.done
          }))), o ? {
            value: void 0,
            done: !0
          } : k(e, s++, t.apply(null, r.map((function(e) {
            return e.value
          }))))
        }))
      }, i
    }

    function Vt(e, t) {
      return J(e) ? t : e.constructor(t)
    }

    function Ht(e) {
      if (e !== Object(e)) throw new TypeError("Expected [K, V] tuple: " + e)
    }

    function Gt(e) {
      return Ie(e.size), S(e)
    }

    function zt(e) {
      return o(e) ? n : u(e) ? i : a
    }

    function Qt(e) {
      return Object.create((o(e) ? H : u(e) ? G : z).prototype)
    }

    function Xt() {
      return this._iter.cacheResult ? (this._iter.cacheResult(), this.size = this._iter.size, this) : V.prototype.cacheResult.call(this)
    }

    function $t(e, t) {
      return e > t ? 1 : e < t ? -1 : 0
    }

    function Yt(e) {
      var t = B(e);
      if (!t) {
        if (!U(e)) throw new TypeError("Expected iterable or array-like: " + e);
        t = B(r(e))
      }
      return t
    }

    function Jt(e, t) {
      var r, n = function(a) {
          if (a instanceof n) return a;
          if (!(this instanceof n)) return new n(a);
          if (!r) {
            r = !0;
            var s = Object.keys(e);
            ! function(e, t) {
              try {
                t.forEach(er.bind(void 0, e))
              } catch (e) {}
            }(i, s), i.size = s.length, i._name = t, i._keys = s, i._defaultValues = e
          }
          this._map = Ne(a)
        },
        i = n.prototype = Object.create(Wt);
      return i.constructor = n, n
    }
    t(wt, Ne), wt.of = function() {
      return this(arguments)
    }, wt.prototype.toString = function() {
      return this.__toString("OrderedMap {", "}")
    }, wt.prototype.get = function(e, t) {
      var r = this._map.get(e);
      return void 0 !== r ? this._list.get(r)[1] : t
    }, wt.prototype.clear = function() {
      return 0 === this.size ? this : this.__ownerID ? (this.size = 0, this._map.clear(), this._list.clear(), this) : Et()
    }, wt.prototype.set = function(e, t) {
      return xt(this, e, t)
    }, wt.prototype.remove = function(e) {
      return xt(this, e, g)
    }, wt.prototype.wasAltered = function() {
      return this._map.wasAltered() || this._list.wasAltered()
    }, wt.prototype.__iterate = function(e, t) {
      var r = this;
      return this._list.__iterate((function(t) {
        return t && e(t[1], t[0], r)
      }), t)
    }, wt.prototype.__iterator = function(e, t) {
      return this._list.fromEntrySeq().__iterator(e, t)
    }, wt.prototype.__ensureOwner = function(e) {
      if (e === this.__ownerID) return this;
      var t = this._map.__ensureOwner(e),
        r = this._list.__ensureOwner(e);
      return e ? Tt(t, r, e, this.__hash) : (this.__ownerID = e, this._map = t, this._list = r, this)
    }, wt.isOrderedMap = St, wt.prototype[f] = !0, wt.prototype.delete = wt.prototype.remove, t(Ot, H), Ot.prototype.get = function(e, t) {
      return this._iter.get(e, t)
    }, Ot.prototype.has = function(e) {
      return this._iter.has(e)
    }, Ot.prototype.valueSeq = function() {
      return this._iter.valueSeq()
    }, Ot.prototype.reverse = function() {
      var e = this,
        t = Ct(this, !0);
      return this._useKeys || (t.valueSeq = function() {
        return e._iter.toSeq().reverse()
      }), t
    }, Ot.prototype.map = function(e, t) {
      var r = this,
        n = Pt(this, e, t);
      return this._useKeys || (n.valueSeq = function() {
        return r._iter.toSeq().map(e, t)
      }), n
    }, Ot.prototype.__iterate = function(e, t) {
      var r, n = this;
      return this._iter.__iterate(this._useKeys ? function(t, r) {
        return e(t, r, n)
      } : (r = t ? Gt(this) : 0, function(i) {
        return e(i, t ? --r : r++, n)
      }), t)
    }, Ot.prototype.__iterator = function(e, t) {
      if (this._useKeys) return this._iter.__iterator(e, t);
      var r = this._iter.__iterator(1, t),
        n = t ? Gt(this) : 0;
      return new j((function() {
        var i = r.next();
        return i.done ? i : k(e, t ? --n : n++, i.value, i)
      }))
    }, Ot.prototype[f] = !0, t(At, G), At.prototype.includes = function(e) {
      return this._iter.includes(e)
    }, At.prototype.__iterate = function(e, t) {
      var r = this,
        n = 0;
      return this._iter.__iterate((function(t) {
        return e(t, n++, r)
      }), t)
    }, At.prototype.__iterator = function(e, t) {
      var r = this._iter.__iterator(1, t),
        n = 0;
      return new j((function() {
        var t = r.next();
        return t.done ? t : k(e, n++, t.value, t)
      }))
    }, t(Rt, z), Rt.prototype.has = function(e) {
      return this._iter.includes(e)
    }, Rt.prototype.__iterate = function(e, t) {
      var r = this;
      return this._iter.__iterate((function(t) {
        return e(t, t, r)
      }), t)
    }, Rt.prototype.__iterator = function(e, t) {
      var r = this._iter.__iterator(1, t);
      return new j((function() {
        var t = r.next();
        return t.done ? t : k(e, t.value, t.value, t)
      }))
    }, t(It, H), It.prototype.entrySeq = function() {
      return this._iter.toSeq()
    }, It.prototype.__iterate = function(e, t) {
      var r = this;
      return this._iter.__iterate((function(t) {
        if (t) {
          Ht(t);
          var n = s(t);
          return e(n ? t.get(1) : t[1], n ? t.get(0) : t[0], r)
        }
      }), t)
    }, It.prototype.__iterator = function(e, t) {
      var r = this._iter.__iterator(1, t);
      return new j((function() {
        for (;;) {
          var t = r.next();
          if (t.done) return t;
          var n = t.value;
          if (n) {
            Ht(n);
            var i = s(n);
            return k(e, i ? n.get(0) : n[0], i ? n.get(1) : n[1], t)
          }
        }
      }))
    }, At.prototype.cacheResult = Ot.prototype.cacheResult = Rt.prototype.cacheResult = It.prototype.cacheResult = Xt, t(Jt, de), Jt.prototype.toString = function() {
      return this.__toString(Zt(this) + " {", "}")
    }, Jt.prototype.has = function(e) {
      return this._defaultValues.hasOwnProperty(e)
    }, Jt.prototype.get = function(e, t) {
      if (!this.has(e)) return t;
      var r = this._defaultValues[e];
      return this._map ? this._map.get(e, r) : r
    }, Jt.prototype.clear = function() {
      if (this.__ownerID) return this._map && this._map.clear(), this;
      var e = this.constructor;
      return e._empty || (e._empty = Kt(this, Ge()))
    }, Jt.prototype.set = function(e, t) {
      if (!this.has(e)) throw new Error('Cannot set unknown key "' + e + '" on ' + Zt(this));
      if (this._map && !this._map.has(e) && t === this._defaultValues[e]) return this;
      var r = this._map && this._map.set(e, t);
      return this.__ownerID || r === this._map ? this : Kt(this, r)
    }, Jt.prototype.remove = function(e) {
      if (!this.has(e)) return this;
      var t = this._map && this._map.remove(e);
      return this.__ownerID || t === this._map ? this : Kt(this, t)
    }, Jt.prototype.wasAltered = function() {
      return this._map.wasAltered()
    }, Jt.prototype.__iterator = function(e, t) {
      var r = this;
      return n(this._defaultValues).map((function(e, t) {
        return r.get(t)
      })).__iterator(e, t)
    }, Jt.prototype.__iterate = function(e, t) {
      var r = this;
      return n(this._defaultValues).map((function(e, t) {
        return r.get(t)
      })).__iterate(e, t)
    }, Jt.prototype.__ensureOwner = function(e) {
      if (e === this.__ownerID) return this;
      var t = this._map && this._map.__ensureOwner(e);
      return e ? Kt(this, t, e) : (this.__ownerID = e, this._map = t, this)
    };
    var Wt = Jt.prototype;

    function Kt(e, t, r) {
      var n = Object.create(Object.getPrototypeOf(e));
      return n._map = t, n.__ownerID = r, n
    }

    function Zt(e) {
      return e._name || e.constructor.name || "Record"
    }

    function er(e, t) {
      Object.defineProperty(e, t, {
        get: function() {
          return this.get(t)
        },
        set: function(e) {
          ce(this.__ownerID, "Cannot set on an immutable record."), this.set(t, e)
        }
      })
    }

    function tr(e) {
      return null == e ? ur() : rr(e) && !l(e) ? e : ur().withMutations((function(t) {
        var r = a(e);
        Ie(r.size), r.forEach((function(e) {
          return t.add(e)
        }))
      }))
    }

    function rr(e) {
      return !(!e || !e[ir])
    }
    Wt.delete = Wt.remove, Wt.deleteIn = Wt.removeIn = je.removeIn, Wt.merge = je.merge, Wt.mergeWith = je.mergeWith, Wt.mergeIn = je.mergeIn, Wt.mergeDeep = je.mergeDeep, Wt.mergeDeepWith = je.mergeDeepWith, Wt.mergeDeepIn = je.mergeDeepIn, Wt.setIn = je.setIn, Wt.update = je.update, Wt.updateIn = je.updateIn, Wt.withMutations = je.withMutations, Wt.asMutable = je.asMutable, Wt.asImmutable = je.asImmutable, t(tr, fe), tr.of = function() {
      return this(arguments)
    }, tr.fromKeys = function(e) {
      return this(n(e).keySeq())
    }, tr.prototype.toString = function() {
      return this.__toString("Set {", "}")
    }, tr.prototype.has = function(e) {
      return this._map.has(e)
    }, tr.prototype.add = function(e) {
      return sr(this, this._map.set(e, !0))
    }, tr.prototype.remove = function(e) {
      return sr(this, this._map.remove(e))
    }, tr.prototype.clear = function() {
      return sr(this, this._map.clear())
    }, tr.prototype.union = function() {
      var t = e.call(arguments, 0);
      return 0 === (t = t.filter((function(e) {
        return 0 !== e.size
      }))).length ? this : 0 !== this.size || this.__ownerID || 1 !== t.length ? this.withMutations((function(e) {
        for (var r = 0; r < t.length; r++) a(t[r]).forEach((function(t) {
          return e.add(t)
        }))
      })) : this.constructor(t[0])
    }, tr.prototype.intersect = function() {
      var t = e.call(arguments, 0);
      if (0 === t.length) return this;
      t = t.map((function(e) {
        return a(e)
      }));
      var r = this;
      return this.withMutations((function(e) {
        r.forEach((function(r) {
          t.every((function(e) {
            return e.includes(r)
          })) || e.remove(r)
        }))
      }))
    }, tr.prototype.subtract = function() {
      var t = e.call(arguments, 0);
      if (0 === t.length) return this;
      t = t.map((function(e) {
        return a(e)
      }));
      var r = this;
      return this.withMutations((function(e) {
        r.forEach((function(r) {
          t.some((function(e) {
            return e.includes(r)
          })) && e.remove(r)
        }))
      }))
    }, tr.prototype.merge = function() {
      return this.union.apply(this, arguments)
    }, tr.prototype.mergeWith = function(t) {
      var r = e.call(arguments, 1);
      return this.union.apply(this, r)
    }, tr.prototype.sort = function(e) {
      return cr(Ft(this, e))
    }, tr.prototype.sortBy = function(e, t) {
      return cr(Ft(this, t, e))
    }, tr.prototype.wasAltered = function() {
      return this._map.wasAltered()
    }, tr.prototype.__iterate = function(e, t) {
      var r = this;
      return this._map.__iterate((function(t, n) {
        return e(n, n, r)
      }), t)
    }, tr.prototype.__iterator = function(e, t) {
      return this._map.map((function(e, t) {
        return t
      })).__iterator(e, t)
    }, tr.prototype.__ensureOwner = function(e) {
      if (e === this.__ownerID) return this;
      var t = this._map.__ensureOwner(e);
      return e ? this.__make(t, e) : (this.__ownerID = e, this._map = t, this)
    }, tr.isSet = rr;
    var nr, ir = "@@__IMMUTABLE_SET__@@",
      ar = tr.prototype;

    function sr(e, t) {
      return e.__ownerID ? (e.size = t.size, e._map = t, e) : t === e._map ? e : 0 === t.size ? e.__empty() : e.__make(t)
    }

    function or(e, t) {
      var r = Object.create(ar);
      return r.size = e ? e.size : 0, r._map = e, r.__ownerID = t, r
    }

    function ur() {
      return nr || (nr = or(Ge()))
    }

    function cr(e) {
      return null == e ? fr() : lr(e) ? e : fr().withMutations((function(t) {
        var r = a(e);
        Ie(r.size), r.forEach((function(e) {
          return t.add(e)
        }))
      }))
    }

    function lr(e) {
      return rr(e) && l(e)
    }
    ar[ir] = !0, ar.delete = ar.remove, ar.mergeDeep = ar.merge, ar.mergeDeepWith = ar.mergeWith, ar.withMutations = je.withMutations, ar.asMutable = je.asMutable, ar.asImmutable = je.asImmutable, ar.__empty = ur, ar.__make = or, t(cr, tr), cr.of = function() {
      return this(arguments)
    }, cr.fromKeys = function(e) {
      return this(n(e).keySeq())
    }, cr.prototype.toString = function() {
      return this.__toString("OrderedSet {", "}")
    }, cr.isOrderedSet = lr;
    var hr, dr = cr.prototype;

    function pr(e, t) {
      var r = Object.create(dr);
      return r.size = e ? e.size : 0, r._map = e, r.__ownerID = t, r
    }

    function fr() {
      return hr || (hr = pr(Et()))
    }

    function gr(e) {
      return null == e ? wr() : mr(e) ? e : wr().unshiftAll(e)
    }

    function mr(e) {
      return !(!e || !e[br])
    }
    dr[f] = !0, dr.__empty = fr, dr.__make = pr, t(gr, pe), gr.of = function() {
      return this(arguments)
    }, gr.prototype.toString = function() {
      return this.__toString("Stack [", "]")
    }, gr.prototype.get = function(e, t) {
      var r = this._head;
      for (e = T(this, e); r && e--;) r = r.next;
      return r ? r.value : t
    }, gr.prototype.peek = function() {
      return this._head && this._head.value
    }, gr.prototype.push = function() {
      if (0 === arguments.length) return this;
      for (var e = this.size + arguments.length, t = this._head, r = arguments.length - 1; r >= 0; r--) t = {
        value: arguments[r],
        next: t
      };
      return this.__ownerID ? (this.size = e, this._head = t, this.__hash = void 0, this.__altered = !0, this) : vr(e, t)
    }, gr.prototype.pushAll = function(e) {
      if (0 === (e = i(e)).size) return this;
      Ie(e.size);
      var t = this.size,
        r = this._head;
      return e.reverse().forEach((function(e) {
        t++, r = {
          value: e,
          next: r
        }
      })), this.__ownerID ? (this.size = t, this._head = r, this.__hash = void 0, this.__altered = !0, this) : vr(t, r)
    }, gr.prototype.pop = function() {
      return this.slice(1)
    }, gr.prototype.unshift = function() {
      return this.push.apply(this, arguments)
    }, gr.prototype.unshiftAll = function(e) {
      return this.pushAll(e)
    }, gr.prototype.shift = function() {
      return this.pop.apply(this, arguments)
    }, gr.prototype.clear = function() {
      return 0 === this.size ? this : this.__ownerID ? (this.size = 0, this._head = void 0, this.__hash = void 0, this.__altered = !0, this) : wr()
    }, gr.prototype.slice = function(e, t) {
      if (x(e, t, this.size)) return this;
      var r = O(e, this.size);
      if (A(t, this.size) !== this.size) return pe.prototype.slice.call(this, e, t);
      for (var n = this.size - r, i = this._head; r--;) i = i.next;
      return this.__ownerID ? (this.size = n, this._head = i, this.__hash = void 0, this.__altered = !0, this) : vr(n, i)
    }, gr.prototype.__ensureOwner = function(e) {
      return e === this.__ownerID ? this : e ? vr(this.size, this._head, e, this.__hash) : (this.__ownerID = e, this.__altered = !1, this)
    }, gr.prototype.__iterate = function(e, t) {
      if (t) return this.reverse().__iterate(e);
      for (var r = 0, n = this._head; n && !1 !== e(n.value, r++, this);) n = n.next;
      return r
    }, gr.prototype.__iterator = function(e, t) {
      if (t) return this.reverse().__iterator(e);
      var r = 0,
        n = this._head;
      return new j((function() {
        if (n) {
          var t = n.value;
          return n = n.next, k(e, r++, t)
        }
        return {
          value: void 0,
          done: !0
        }
      }))
    }, gr.isStack = mr;
    var yr, br = "@@__IMMUTABLE_STACK__@@",
      _r = gr.prototype;

    function vr(e, t, r, n) {
      var i = Object.create(_r);
      return i.size = e, i._head = t, i.__ownerID = r, i.__hash = n, i.__altered = !1, i
    }

    function wr() {
      return yr || (yr = vr(0))
    }

    function Sr(e, t) {
      var r = function(r) {
        e.prototype[r] = t[r]
      };
      return Object.keys(t).forEach(r), Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(t).forEach(r), e
    }
    _r[br] = !0, _r.withMutations = je.withMutations, _r.asMutable = je.asMutable, _r.asImmutable = je.asImmutable, _r.wasAltered = je.wasAltered, r.Iterator = j, Sr(r, {
      toArray: function() {
        Ie(this.size);
        var e = new Array(this.size || 0);
        return this.valueSeq().__iterate((function(t, r) {
          e[r] = t
        })), e
      },
      toIndexedSeq: function() {
        return new At(this)
      },
      toJS: function() {
        return this.toSeq().map((function(e) {
          return e && "function" == typeof e.toJS ? e.toJS() : e
        })).__toJS()
      },
      toJSON: function() {
        return this.toSeq().map((function(e) {
          return e && "function" == typeof e.toJSON ? e.toJSON() : e
        })).__toJS()
      },
      toKeyedSeq: function() {
        return new Ot(this, !0)
      },
      toMap: function() {
        return Ne(this.toKeyedSeq())
      },
      toObject: function() {
        Ie(this.size);
        var e = {};
        return this.__iterate((function(t, r) {
          e[r] = t
        })), e
      },
      toOrderedMap: function() {
        return wt(this.toKeyedSeq())
      },
      toOrderedSet: function() {
        return cr(o(this) ? this.valueSeq() : this)
      },
      toSet: function() {
        return tr(o(this) ? this.valueSeq() : this)
      },
      toSetSeq: function() {
        return new Rt(this)
      },
      toSeq: function() {
        return u(this) ? this.toIndexedSeq() : o(this) ? this.toKeyedSeq() : this.toSetSeq()
      },
      toStack: function() {
        return gr(o(this) ? this.valueSeq() : this)
      },
      toList: function() {
        return it(o(this) ? this.valueSeq() : this)
      },
      toString: function() {
        return "[Iterable]"
      },
      __toString: function(e, t) {
        return 0 === this.size ? e + t : e + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + t
      },
      concat: function() {
        var t = e.call(arguments, 0);
        return Vt(this, Lt(this, t))
      },
      includes: function(e) {
        return this.some((function(t) {
          return se(t, e)
        }))
      },
      entries: function() {
        return this.__iterator(2)
      },
      every: function(e, t) {
        Ie(this.size);
        var r = !0;
        return this.__iterate((function(n, i, a) {
          if (!e.call(t, n, i, a)) return r = !1, !1
        })), r
      },
      filter: function(e, t) {
        return Vt(this, Dt(this, e, t, !0))
      },
      find: function(e, t, r) {
        var n = this.findEntry(e, t);
        return n ? n[1] : r
      },
      forEach: function(e, t) {
        return Ie(this.size), this.__iterate(t ? e.bind(t) : e)
      },
      join: function(e) {
        Ie(this.size), e = void 0 !== e ? "" + e : ",";
        var t = "",
          r = !0;
        return this.__iterate((function(n) {
          r ? r = !1 : t += e, t += null != n ? n.toString() : ""
        })), t
      },
      keys: function() {
        return this.__iterator(0)
      },
      map: function(e, t) {
        return Vt(this, Pt(this, e, t))
      },
      reduce: function(e, t, r) {
        var n, i;
        return Ie(this.size), arguments.length < 2 ? i = !0 : n = t, this.__iterate((function(t, a, s) {
          i ? (i = !1, n = t) : n = e.call(r, n, t, a, s)
        })), n
      },
      reduceRight: function(e, t, r) {
        var n = this.toKeyedSeq().reverse();
        return n.reduce.apply(n, arguments)
      },
      reverse: function() {
        return Vt(this, Ct(this, !0))
      },
      slice: function(e, t) {
        return Vt(this, jt(this, e, t, !0))
      },
      some: function(e, t) {
        return !this.every(Ar(e), t)
      },
      sort: function(e) {
        return Vt(this, Ft(this, e))
      },
      values: function() {
        return this.__iterator(1)
      },
      butLast: function() {
        return this.slice(0, -1)
      },
      isEmpty: function() {
        return void 0 !== this.size ? 0 === this.size : !this.some((function() {
          return !0
        }))
      },
      count: function(e, t) {
        return S(e ? this.toSeq().filter(e, t) : this)
      },
      countBy: function(e, t) {
        return function(e, t, r) {
          var n = Ne().asMutable();
          return e.__iterate((function(i, a) {
            n.update(t.call(r, i, a, e), 0, (function(e) {
              return e + 1
            }))
          })), n.asImmutable()
        }(this, e, t)
      },
      equals: function(e) {
        return oe(this, e)
      },
      entrySeq: function() {
        var e = this;
        if (e._cache) return new Q(e._cache);
        var t = e.toSeq().map(Or).toIndexedSeq();
        return t.fromEntrySeq = function() {
          return e.toSeq()
        }, t
      },
      filterNot: function(e, t) {
        return this.filter(Ar(e), t)
      },
      findEntry: function(e, t, r) {
        var n = r;
        return this.__iterate((function(r, i, a) {
          if (e.call(t, r, i, a)) return n = [i, r], !1
        })), n
      },
      findKey: function(e, t) {
        var r = this.findEntry(e, t);
        return r && r[0]
      },
      findLast: function(e, t, r) {
        return this.toKeyedSeq().reverse().find(e, t, r)
      },
      findLastEntry: function(e, t, r) {
        return this.toKeyedSeq().reverse().findEntry(e, t, r)
      },
      findLastKey: function(e, t) {
        return this.toKeyedSeq().reverse().findKey(e, t)
      },
      first: function() {
        return this.find(E)
      },
      flatMap: function(e, t) {
        return Vt(this, function(e, t, r) {
          var n = zt(e);
          return e.toSeq().map((function(i, a) {
            return n(t.call(r, i, a, e))
          })).flatten(!0)
        }(this, e, t))
      },
      flatten: function(e) {
        return Vt(this, Mt(this, e, !0))
      },
      fromEntrySeq: function() {
        return new It(this)
      },
      get: function(e, t) {
        return this.find((function(t, r) {
          return se(r, e)
        }), void 0, t)
      },
      getIn: function(e, t) {
        for (var r, n = this, i = Yt(e); !(r = i.next()).done;) {
          var a = r.value;
          if ((n = n && n.get ? n.get(a, g) : g) === g) return t
        }
        return n
      },
      groupBy: function(e, t) {
        return function(e, t, r) {
          var n = o(e),
            i = (l(e) ? wt() : Ne()).asMutable();
          e.__iterate((function(a, s) {
            i.update(t.call(r, a, s, e), (function(e) {
              return (e = e || []).push(n ? [s, a] : a), e
            }))
          }));
          var a = zt(e);
          return i.map((function(t) {
            return Vt(e, a(t))
          }))
        }(this, e, t)
      },
      has: function(e) {
        return this.get(e, g) !== g
      },
      hasIn: function(e) {
        return this.getIn(e, g) !== g
      },
      isSubset: function(e) {
        return e = "function" == typeof e.includes ? e : r(e), this.every((function(t) {
          return e.includes(t)
        }))
      },
      isSuperset: function(e) {
        return (e = "function" == typeof e.isSubset ? e : r(e)).isSubset(this)
      },
      keyOf: function(e) {
        return this.findKey((function(t) {
          return se(t, e)
        }))
      },
      keySeq: function() {
        return this.toSeq().map(xr).toIndexedSeq()
      },
      last: function() {
        return this.toSeq().reverse().first()
      },
      lastKeyOf: function(e) {
        return this.toKeyedSeq().reverse().keyOf(e)
      },
      max: function(e) {
        return Bt(this, e)
      },
      maxBy: function(e, t) {
        return Bt(this, t, e)
      },
      min: function(e) {
        return Bt(this, e ? Rr(e) : Pr)
      },
      minBy: function(e, t) {
        return Bt(this, t ? Rr(t) : Pr, e)
      },
      rest: function() {
        return this.slice(1)
      },
      skip: function(e) {
        return this.slice(Math.max(0, e))
      },
      skipLast: function(e) {
        return Vt(this, this.toSeq().reverse().skip(e).reverse())
      },
      skipWhile: function(e, t) {
        return Vt(this, kt(this, e, t, !0))
      },
      skipUntil: function(e, t) {
        return this.skipWhile(Ar(e), t)
      },
      sortBy: function(e, t) {
        return Vt(this, Ft(this, t, e))
      },
      take: function(e) {
        return this.slice(0, Math.max(0, e))
      },
      takeLast: function(e) {
        return Vt(this, this.toSeq().reverse().take(e).reverse())
      },
      takeWhile: function(e, t) {
        return Vt(this, function(e, t, r) {
          var n = Qt(e);
          return n.__iterateUncached = function(n, i) {
            var a = this;
            if (i) return this.cacheResult().__iterate(n, i);
            var s = 0;
            return e.__iterate((function(e, i, o) {
              return t.call(r, e, i, o) && ++s && n(e, i, a)
            })), s
          }, n.__iteratorUncached = function(n, i) {
            var a = this;
            if (i) return this.cacheResult().__iterator(n, i);
            var s = e.__iterator(2, i),
              o = !0;
            return new j((function() {
              if (!o) return {
                value: void 0,
                done: !0
              };
              var e = s.next();
              if (e.done) return e;
              var i = e.value,
                u = i[0],
                c = i[1];
              return t.call(r, c, u, a) ? 2 === n ? e : k(n, u, c, e) : (o = !1, {
                value: void 0,
                done: !0
              })
            }))
          }, n
        }(this, e, t))
      },
      takeUntil: function(e, t) {
        return this.takeWhile(Ar(e), t)
      },
      valueSeq: function() {
        return this.toIndexedSeq()
      },
      hashCode: function() {
        return this.__hash || (this.__hash = function(e) {
          if (e.size === 1 / 0) return 0;
          var t = l(e),
            r = o(e),
            n = t ? 1 : 0;
          return function(e, t) {
            return t = ge(t, 3432918353), t = ge(t << 15 | t >>> -15, 461845907), t = ge(t << 13 | t >>> -13, 5), t = ge((t = (t + 3864292196 | 0) ^ e) ^ t >>> 16, 2246822507), t = me((t = ge(t ^ t >>> 13, 3266489909)) ^ t >>> 16)
          }(e.__iterate(r ? t ? function(e, t) {
            n = 31 * n + Cr(ye(e), ye(t)) | 0
          } : function(e, t) {
            n = n + Cr(ye(e), ye(t)) | 0
          } : t ? function(e) {
            n = 31 * n + ye(e) | 0
          } : function(e) {
            n = n + ye(e) | 0
          }), n)
        }(this))
      }
    });
    var Tr = r.prototype;
    Tr[h] = !0, Tr[D] = Tr.values, Tr.__toJS = Tr.toArray, Tr.__toStringMapper = Ir, Tr.inspect = Tr.toSource = function() {
      return this.toString()
    }, Tr.chain = Tr.flatMap, Tr.contains = Tr.includes, Sr(n, {
      flip: function() {
        return Vt(this, Nt(this))
      },
      mapEntries: function(e, t) {
        var r = this,
          n = 0;
        return Vt(this, this.toSeq().map((function(i, a) {
          return e.call(t, [a, i], n++, r)
        })).fromEntrySeq())
      },
      mapKeys: function(e, t) {
        var r = this;
        return Vt(this, this.toSeq().flip().map((function(n, i) {
          return e.call(t, n, i, r)
        })).flip())
      }
    });
    var Er = n.prototype;

    function xr(e, t) {
      return t
    }

    function Or(e, t) {
      return [t, e]
    }

    function Ar(e) {
      return function() {
        return !e.apply(this, arguments)
      }
    }

    function Rr(e) {
      return function() {
        return -e.apply(this, arguments)
      }
    }

    function Ir(e) {
      return "string" == typeof e ? JSON.stringify(e) : String(e)
    }

    function Nr() {
      return w(arguments)
    }

    function Pr(e, t) {
      return e < t ? 1 : e > t ? -1 : 0
    }

    function Cr(e, t) {
      return e ^ t + 2654435769 + (e << 6) + (e >> 2) | 0
    }
    return Er[d] = !0, Er[D] = Tr.entries, Er.__toJS = Tr.toObject, Er.__toStringMapper = function(e, t) {
      return JSON.stringify(t) + ": " + Ir(e)
    }, Sr(i, {
      toKeyedSeq: function() {
        return new Ot(this, !1)
      },
      filter: function(e, t) {
        return Vt(this, Dt(this, e, t, !1))
      },
      findIndex: function(e, t) {
        var r = this.findEntry(e, t);
        return r ? r[0] : -1
      },
      indexOf: function(e) {
        var t = this.keyOf(e);
        return void 0 === t ? -1 : t
      },
      lastIndexOf: function(e) {
        var t = this.lastKeyOf(e);
        return void 0 === t ? -1 : t
      },
      reverse: function() {
        return Vt(this, Ct(this, !1))
      },
      slice: function(e, t) {
        return Vt(this, jt(this, e, t, !1))
      },
      splice: function(e, t) {
        var r = arguments.length;
        if (t = Math.max(0 | t, 0), 0 === r || 2 === r && !t) return this;
        e = O(e, e < 0 ? this.count() : this.size);
        var n = this.slice(0, e);
        return Vt(this, 1 === r ? n : n.concat(w(arguments, 2), this.slice(e + t)))
      },
      findLastIndex: function(e, t) {
        var r = this.findLastEntry(e, t);
        return r ? r[0] : -1
      },
      first: function() {
        return this.get(0)
      },
      flatten: function(e) {
        return Vt(this, Mt(this, e, !1))
      },
      get: function(e, t) {
        return (e = T(this, e)) < 0 || this.size === 1 / 0 || void 0 !== this.size && e > this.size ? t : this.find((function(t, r) {
          return r === e
        }), void 0, t)
      },
      has: function(e) {
        return (e = T(this, e)) >= 0 && (void 0 !== this.size ? this.size === 1 / 0 || e < this.size : -1 !== this.indexOf(e))
      },
      interpose: function(e) {
        return Vt(this, function(e, t) {
          var r = Qt(e);
          return r.size = e.size && 2 * e.size - 1, r.__iterateUncached = function(r, n) {
            var i = this,
              a = 0;
            return e.__iterate((function(e, n) {
              return (!a || !1 !== r(t, a++, i)) && !1 !== r(e, a++, i)
            }), n), a
          }, r.__iteratorUncached = function(r, n) {
            var i, a = e.__iterator(1, n),
              s = 0;
            return new j((function() {
              return (!i || s % 2) && (i = a.next()).done ? i : s % 2 ? k(r, s++, t) : k(r, s++, i.value, i)
            }))
          }, r
        }(this, e))
      },
      interleave: function() {
        var e = [this].concat(w(arguments)),
          t = Ut(this.toSeq(), G.of, e),
          r = t.flatten(!0);
        return t.size && (r.size = t.size * e.length), Vt(this, r)
      },
      keySeq: function() {
        return le(0, this.size)
      },
      last: function() {
        return this.get(-1)
      },
      skipWhile: function(e, t) {
        return Vt(this, kt(this, e, t, !1))
      },
      zip: function() {
        var e = [this].concat(w(arguments));
        return Vt(this, Ut(this, Nr, e))
      },
      zipWith: function(e) {
        var t = w(arguments);
        return t[0] = this, Vt(this, Ut(this, e, t))
      }
    }), i.prototype[p] = !0, i.prototype[f] = !0, Sr(a, {
      get: function(e, t) {
        return this.has(e) ? e : t
      },
      includes: function(e) {
        return this.has(e)
      },
      keySeq: function() {
        return this.valueSeq()
      }
    }), a.prototype.has = Tr.includes, a.prototype.contains = a.prototype.includes, Sr(H, n.prototype), Sr(G, i.prototype), Sr(z, a.prototype), Sr(de, n.prototype), Sr(pe, i.prototype), Sr(fe, a.prototype), {
      Iterable: r,
      Seq: V,
      Collection: he,
      Map: Ne,
      OrderedMap: wt,
      List: it,
      Stack: gr,
      Set: tr,
      OrderedSet: cr,
      Record: Jt,
      Range: le,
      Repeat: ue,
      is: se,
      fromJS: ne
    }
  }()
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ExpressionType = void 0,
    function(e) {
      e.Aggregate = "aggregate", e.Existence = "existence", e.Named = "named", e.Operator = "operator", e.SpecialOperator = "specialOperator", e.Term = "term", e.Variable = "variable"
    }(t.ExpressionType || (t.ExpressionType = {}))
}, function(e, t, r) {
  "use strict";
  var n = r(54),
    i = Object.keys || function(e) {
      var t = [];
      for (var r in e) t.push(r);
      return t
    };
  e.exports = h;
  var a = Object.create(r(43));
  a.inherits = r(12);
  var s = r(115),
    o = r(73);
  a.inherits(h, s);
  for (var u = i(o.prototype), c = 0; c < u.length; c++) {
    var l = u[c];
    h.prototype[l] || (h.prototype[l] = o.prototype[l])
  }

  function h(e) {
    if (!(this instanceof h)) return new h(e);
    s.call(this, e), o.call(this, e), e && !1 === e.readable && (this.readable = !1), e && !1 === e.writable && (this.writable = !1), this.allowHalfOpen = !0, e && !1 === e.allowHalfOpen && (this.allowHalfOpen = !1), this.once("end", d)
  }

  function d() {
    this.allowHalfOpen || this._writableState.ended || n.nextTick(p, this)
  }

  function p(e) {
    e.end()
  }
  Object.defineProperty(h.prototype, "writableHighWaterMark", {
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark
    }
  }), Object.defineProperty(h.prototype, "destroyed", {
    get: function() {
      return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed)
    },
    set: function(e) {
      void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e)
    }
  }), h.prototype._destroy = function(e, t) {
    this.push(null), this.end(), n.nextTick(t, e)
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(270), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Util = void 0;
  const n = r(9),
    i = r(5),
    a = r(170),
    s = r(84);
  class o {
    constructor(e) {
      this.parsingContext = e.parsingContext, this.dataFactory = e.dataFactory || new i.DataFactory, this.rdfFirst = this.dataFactory.namedNode(o.RDF + "first"), this.rdfRest = this.dataFactory.namedNode(o.RDF + "rest"), this.rdfNil = this.dataFactory.namedNode(o.RDF + "nil"), this.rdfType = this.dataFactory.namedNode(o.RDF + "type"), this.rdfJson = this.dataFactory.namedNode(o.RDF + "JSON")
    }
    static getContextValue(e, t, r, n) {
      const i = e.getContextRaw()[r];
      if (!i) return n;
      const a = i[t];
      return void 0 === a ? n : a
    }
    static getContextValueContainer(e, t) {
      return o.getContextValue(e, "@container", t, {
        "@set": !0
      })
    }
    static getContextValueType(e, t) {
      const r = o.getContextValue(e, "@type", t, null);
      return "@none" === r ? null : r
    }
    static getContextValueLanguage(e, t) {
      return o.getContextValue(e, "@language", t, e.getContextRaw()["@language"] || null)
    }
    static getContextValueDirection(e, t) {
      return o.getContextValue(e, "@direction", t, e.getContextRaw()["@direction"] || null)
    }
    static isContextValueReverse(e, t) {
      return !!o.getContextValue(e, "@reverse", t, null)
    }
    static getContextValueIndex(e, t) {
      return o.getContextValue(e, "@index", t, e.getContextRaw()["@index"] || null)
    }
    static isPropertyReverse(e, t, r) {
      return "@reverse" === r !== o.isContextValueReverse(e, t)
    }
    static isValidIri(e) {
      return null !== e && n.Util.isValidIri(e)
    }
    static isPrefixArray(e, t) {
      if (e.length > t.length) return !1;
      for (let r = 0; r < e.length; r++)
        if (e[r] !== t[r]) return !1;
      return !0
    }
    async validateValueIndexes(e) {
      if (this.parsingContext.validateValueIndexes) {
        const t = {};
        for (const r of e)
          if (r && "object" == typeof r) {
            const e = r["@id"],
              i = r["@index"];
            if (e && i) {
              const r = t[e];
              if (r && r !== i) throw new n.ErrorCoded("Conflicting @index value for " + e, n.ERROR_CODES.CONFLICTING_INDEXES);
              t[e] = i
            }
          }
      }
    }
    async valueToTerm(e, t, r, i, a) {
      if ("@json" === o.getContextValueType(e, t)) return [this.dataFactory.literal(this.valueToJsonString(r), this.rdfJson)];
      const s = typeof r;
      switch (s) {
        case "object":
          if (null == r) return [];
          if (Array.isArray(r)) return "@list" in o.getContextValueContainer(e, t) ? 0 === r.length ? [this.rdfNil] : this.parsingContext.idStack[i + 1] || [] : (await this.validateValueIndexes(r), []);
          if (e = await this.getContextSelfOrPropertyScoped(e, t), "@context" in r && (e = await this.parsingContext.parseContext(r["@context"], (await this.parsingContext.getContext(a, 0)).getContextRaw())), "@value" in (r = await this.unaliasKeywords(r, a, i, e))) {
            let s, o, u, c, l;
            for (t in r) {
              const e = r[t];
              switch (t) {
                case "@value":
                  s = e;
                  break;
                case "@language":
                  o = e;
                  break;
                case "@direction":
                  u = e;
                  break;
                case "@type":
                  c = e;
                  break;
                case "@index":
                  l = e;
                  break;
                default:
                  throw new n.ErrorCoded(`Unknown value entry '${t}' in @value: ${JSON.stringify(r)}`, n.ERROR_CODES.INVALID_VALUE_OBJECT)
              }
            }
            if ("@json" === await this.unaliasKeyword(c, a, i, !0, e)) return [this.dataFactory.literal(this.valueToJsonString(s), this.rdfJson)];
            if (null === s) return [];
            if ("object" == typeof s) throw new n.ErrorCoded(`The value of an '@value' can not be an object, got '${JSON.stringify(s)}'`, n.ERROR_CODES.INVALID_VALUE_OBJECT_VALUE);
            if (this.parsingContext.validateValueIndexes && l && "string" != typeof l) throw new n.ErrorCoded(`The value of an '@index' must be a string, got '${JSON.stringify(l)}'`, n.ERROR_CODES.INVALID_INDEX_VALUE);
            if (o) {
              if ("string" != typeof s) throw new n.ErrorCoded(`When an '@language' is set, the value of '@value' must be a string, got '${JSON.stringify(s)}'`, n.ERROR_CODES.INVALID_LANGUAGE_TAGGED_VALUE);
              if (!n.ContextParser.validateLanguage(o, this.parsingContext.strictValues, n.ERROR_CODES.INVALID_LANGUAGE_TAGGED_STRING)) return [];
              (this.parsingContext.normalizeLanguageTags || 1 === this.parsingContext.activeProcessingMode) && (o = o.toLowerCase())
            }
            if (u) {
              if ("string" != typeof s) throw new Error(`When an '@direction' is set, the value of '@value' must be a string, got '${JSON.stringify(s)}'`);
              if (!n.ContextParser.validateDirection(u, this.parsingContext.strictValues)) return []
            }
            if (o && u && this.parsingContext.rdfDirection) {
              if (c) throw new n.ErrorCoded(`Can not have '@language', '@direction' and '@type' in a value: '${JSON.stringify(r)}'`, n.ERROR_CODES.INVALID_VALUE_OBJECT);
              return this.nullableTermToArray(this.createLanguageDirectionLiteral(i, s, o, u))
            }
            if (o) {
              if (c) throw new n.ErrorCoded(`Can not have both '@language' and '@type' in a value: '${JSON.stringify(r)}'`, n.ERROR_CODES.INVALID_VALUE_OBJECT);
              return [this.dataFactory.literal(s, o)]
            }
            if (u && this.parsingContext.rdfDirection) {
              if (c) throw new n.ErrorCoded(`Can not have both '@direction' and '@type' in a value: '${JSON.stringify(r)}'`, n.ERROR_CODES.INVALID_VALUE_OBJECT);
              return this.nullableTermToArray(this.createLanguageDirectionLiteral(i, s, o, u))
            }
            if (c) {
              if ("string" != typeof c) throw new n.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(c)}'`, n.ERROR_CODES.INVALID_TYPED_VALUE);
              const t = this.createVocabOrBaseTerm(e, c);
              if (!t) throw new n.ErrorCoded(`Invalid '@type' value, got '${JSON.stringify(c)}'`, n.ERROR_CODES.INVALID_TYPED_VALUE);
              if ("NamedNode" !== t.termType) throw new n.ErrorCoded(`Illegal value type (${t.termType}): ${c}`, n.ERROR_CODES.INVALID_TYPED_VALUE);
              return [this.dataFactory.literal(s, t)]
            }
            return await this.valueToTerm(new n.JsonLdContextNormalized({}), t, s, i, a)
          }
          if ("@set" in r) {
            if (Object.keys(r).length > 1) throw new n.ErrorCoded(`Found illegal neighbouring entries next to @set for key: '${t}'`, n.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);
            return []
          }
          if ("@list" in r) {
            if (Object.keys(r).length > 1) throw new n.ErrorCoded(`Found illegal neighbouring entries next to @list for key: '${t}'`, n.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT);
            const e = r["@list"];
            return Array.isArray(e) ? 0 === e.length ? [this.rdfNil] : this.parsingContext.idStack[i + 1] || [] : await this.valueToTerm(await this.parsingContext.getContext(a), t, e, i - 1, a.slice(0, -1))
          }
          if ("@reverse" in r) return [];
          if ("@graph" in o.getContextValueContainer(await this.parsingContext.getContext(a), t)) {
            const e = this.parsingContext.graphContainerTermStack[i + 1];
            return e ? Object.values(e) : [this.dataFactory.blankNode()]
          }
          return "@id" in r ? (Object.keys(r).length > 1 && (e = await this.parsingContext.getContext(a, 0)), "@context" in r && (e = await this.parsingContext.parseContext(r["@context"], e.getContextRaw())), "@vocab" === r["@type"] ? this.nullableTermToArray(this.createVocabOrBaseTerm(e, r["@id"])) : this.nullableTermToArray(this.resourceToTerm(e, r["@id"]))) : this.parsingContext.emittedStack[i + 1] || r && "object" == typeof r && 0 === Object.keys(r).length ? this.parsingContext.idStack[i + 1] || (this.parsingContext.idStack[i + 1] = [this.dataFactory.blankNode()]) : [];
        case "string":
          return this.nullableTermToArray(this.stringValueToTerm(i, await this.getContextSelfOrPropertyScoped(e, t), t, r, null));
        case "boolean":
          return this.nullableTermToArray(this.stringValueToTerm(i, await this.getContextSelfOrPropertyScoped(e, t), t, Boolean(r).toString(), this.dataFactory.namedNode(o.XSD_BOOLEAN)));
        case "number":
          return this.nullableTermToArray(this.stringValueToTerm(i, await this.getContextSelfOrPropertyScoped(e, t), t, r, this.dataFactory.namedNode(r % 1 == 0 && r < 1e21 ? o.XSD_INTEGER : o.XSD_DOUBLE)));
        default:
          return this.parsingContext.emitError(new Error("Could not determine the RDF type of a " + s)), []
      }
    }
    async getContextSelfOrPropertyScoped(e, t) {
      const r = e.getContextRaw()[t];
      return r && "object" == typeof r && "@context" in r && (e = await this.parsingContext.parseContext(r, e.getContextRaw(), !0)), e
    }
    nullableTermToArray(e) {
      return e ? [e] : []
    }
    predicateToTerm(e, t) {
      const r = e.expandTerm(t, !0, this.parsingContext.getExpandOptions());
      return r ? "_" === r[0] && ":" === r[1] ? this.parsingContext.produceGeneralizedRdf ? this.dataFactory.blankNode(r.substr(2)) : null : o.isValidIri(r) ? this.dataFactory.namedNode(r) : r && this.parsingContext.strictValues ? (this.parsingContext.emitError(new n.ErrorCoded("Invalid predicate IRI: " + r, n.ERROR_CODES.INVALID_IRI_MAPPING)), null) : null : null
    }
    resourceToTerm(e, t) {
      if (t.startsWith("_:")) return this.dataFactory.blankNode(t.substr(2));
      const r = e.expandTerm(t, !1, this.parsingContext.getExpandOptions());
      if (!o.isValidIri(r)) {
        if (!r || !this.parsingContext.strictValues) return null;
        this.parsingContext.emitError(new Error("Invalid resource IRI: " + r))
      }
      return this.dataFactory.namedNode(r)
    }
    createVocabOrBaseTerm(e, t) {
      if (t.startsWith("_:")) return this.dataFactory.blankNode(t.substr(2));
      const r = this.parsingContext.getExpandOptions();
      let n = e.expandTerm(t, !0, r);
      if (n === t && (n = e.expandTerm(t, !1, r)), !o.isValidIri(n)) {
        if (!n || !this.parsingContext.strictValues) return null;
        this.parsingContext.emitError(new Error("Invalid term IRI: " + n))
      }
      return this.dataFactory.namedNode(n)
    }
    intToString(e, t) {
      if ("number" == typeof e) {
        if (Number.isFinite(e)) {
          return !(e % 1 == 0) || t && t.value === o.XSD_DOUBLE ? e.toExponential(15).replace(/(\d)0*e\+?/, "$1E") : Number(e).toString()
        }
        return e > 0 ? "INF" : "-INF"
      }
      return e
    }
    stringValueToTerm(e, t, r, n, i) {
      const a = o.getContextValueType(t, r);
      if (a)
        if ("@id" === a) {
          if (!i) return this.resourceToTerm(t, this.intToString(n, i))
        } else if ("@vocab" === a) {
          if (!i) return this.createVocabOrBaseTerm(t, this.intToString(n, i))
        } else i = this.dataFactory.namedNode(a);
      if (!i) {
        const a = o.getContextValueLanguage(t, r),
          s = o.getContextValueDirection(t, r);
        return s && this.parsingContext.rdfDirection ? this.createLanguageDirectionLiteral(e, this.intToString(n, i), a, s) : this.dataFactory.literal(this.intToString(n, i), a)
      }
      return this.dataFactory.literal(this.intToString(n, i), i)
    }
    createLanguageDirectionLiteral(e, t, r, n) {
      if ("i18n-datatype" === this.parsingContext.rdfDirection) return r || (r = ""), this.dataFactory.literal(t, this.dataFactory.namedNode(`https://www.w3.org/ns/i18n#${r}_${n}`)); {
        const i = this.dataFactory.blankNode(),
          a = this.getDefaultGraph();
        return this.parsingContext.emitQuad(e, this.dataFactory.quad(i, this.dataFactory.namedNode(o.RDF + "value"), this.dataFactory.literal(t), a)), r && this.parsingContext.emitQuad(e, this.dataFactory.quad(i, this.dataFactory.namedNode(o.RDF + "language"), this.dataFactory.literal(r), a)), this.parsingContext.emitQuad(e, this.dataFactory.quad(i, this.dataFactory.namedNode(o.RDF + "direction"), this.dataFactory.literal(n), a)), i
      }
    }
    valueToJsonString(e) {
      return s(e)
    }
    async unaliasKeyword(e, t, r, i, a) {
      if (Number.isInteger(e)) return e;
      if (!i) {
        const e = this.parsingContext.unaliasedKeywordCacheStack[r];
        if (e) return e
      }
      if (!n.Util.isPotentialKeyword(e)) {
        let r = (a = a || await this.parsingContext.getContext(t)).getContextRaw()[e];
        r && "object" == typeof r && (r = r["@id"]), n.Util.isValidKeyword(r) && (e = r)
      }
      return i ? e : this.parsingContext.unaliasedKeywordCacheStack[r] = e
    }
    async unaliasKeywordParent(e, t) {
      return await this.unaliasKeyword(t > 0 && e[t - 1], e, t - 1)
    }
    async unaliasKeywords(e, t, r, n) {
      const i = {};
      for (const a in e) i[await this.unaliasKeyword(a, t, r + 1, !0, n)] = e[a];
      return i
    }
    isLiteral(e) {
      for (let t = e; t >= 0; t--)
        if (this.parsingContext.literalStack[t] || this.parsingContext.jsonLiteralStack[t]) return !0;
      return !1
    }
    async getDepthOffsetGraph(e, t) {
      for (let r = e - 1; r > 0; r--)
        if ("@graph" === await this.unaliasKeyword(t[r], t, r)) {
          const n = (await a.EntryHandlerContainer.getContainerHandler(this.parsingContext, t, r)).containers;
          return a.EntryHandlerContainer.isComplexGraphContainer(n) ? -1 : e - r - 1
        } return -1
    }
    validateReverseSubject(e) {
      if ("Literal" === e.termType) throw new n.ErrorCoded("Found illegal literal in subject position: " + e.value, n.ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE)
    }
    getDefaultGraph() {
      return this.parsingContext.defaultGraph || this.dataFactory.defaultGraph()
    }
    async getGraphContainerValue(e, t) {
      let r = this.getDefaultGraph();
      const {
        containers: n,
        depth: i
      } = await a.EntryHandlerContainer.getContainerHandler(this.parsingContext, e, t);
      if ("@graph" in n) {
        const t = a.EntryHandlerContainer.getContainerGraphIndex(n, i, e),
          s = this.parsingContext.graphContainerTermStack[i];
        if (r = s ? s[t] : null, !r) {
          let a = null;
          if ("@id" in n) {
            const t = await this.getContainerKey(e[i], e, i);
            null !== t && (a = await this.resourceToTerm(await this.parsingContext.getContext(e), t))
          }
          a || (a = this.dataFactory.blankNode()), this.parsingContext.graphContainerTermStack[i] || (this.parsingContext.graphContainerTermStack[i] = {}), r = this.parsingContext.graphContainerTermStack[i][t] = a
        }
      }
      return r
    }
    async getPropertiesDepth(e, t) {
      let r = t;
      for (let n = t - 1; n > 0; n--)
        if ("number" != typeof e[n]) {
          const t = await this.unaliasKeyword(e[n], e, n);
          if ("@reverse" === t) return n;
          if ("@nest" !== t) return r;
          r = n
        } return r
    }
    async getContainerKey(e, t, r) {
      const n = await this.unaliasKeyword(e, t, r);
      return "@none" === n ? null : n
    }
  }
  t.Util = o, o.XSD = "http://www.w3.org/2001/XMLSchema#", o.XSD_BOOLEAN = o.XSD + "boolean", o.XSD_INTEGER = o.XSD + "integer", o.XSD_DOUBLE = o.XSD + "double", o.RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.EntryHandlerKeyword = void 0;
  t.EntryHandlerKeyword = class {
    constructor(e) {
      this.keyword = e
    }
    isPropertyHandler() {
      return !1
    }
    isStackProcessor() {
      return !0
    }
    async validate(e, t, r, n, i) {
      return !1
    }
    async test(e, t, r, n, i) {
      return r === this.keyword
    }
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(187), t)
}, function(e, t, r) {
  var n = r(201).Parser,
    i = r(214),
    a = r(102).Wildcard,
    s = r(41);
  e.exports = {
    Parser: function({
                       prefixes: e,
                       baseIRI: t,
                       factory: r,
                       sparqlStar: i
                     } = {}) {
      var a = {};
      for (var o in e || {}) a[o] = e[o];
      var u = new n;
      return u.parse = function() {
        return n.base = t || "", n.prefixes = Object.create(a), n.factory = r || s.DataFactory, n.sparqlStar = Boolean(i), n.prototype.parse.apply(u, arguments)
      }, u._resetBlanks = n._resetBlanks, u
    },
    Generator: i,
    Wildcard: a
  }
}, function(e, t, r) {
  "use strict";
  var n = {};

  function i(e, t, r) {
    r || (r = Error);
    var i = function(e) {
      var r, n;

      function i(r, n, i) {
        return e.call(this, function(e, r, n) {
          return "string" == typeof t ? t : t(e, r, n)
        }(r, n, i)) || this
      }
      return n = e, (r = i).prototype = Object.create(n.prototype), r.prototype.constructor = r, r.__proto__ = n, i
    }(r);
    i.prototype.name = r.name, i.prototype.code = e, n[e] = i
  }

  function a(e, t) {
    if (Array.isArray(e)) {
      var r = e.length;
      return e = e.map((function(e) {
        return String(e)
      })), r > 2 ? "one of ".concat(t, " ").concat(e.slice(0, r - 1).join(", "), ", or ") + e[r - 1] : 2 === r ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0])
    }
    return "of ".concat(t, " ").concat(String(e))
  }
  i("ERR_INVALID_OPT_VALUE", (function(e, t) {
    return 'The value "' + t + '" is invalid for option "' + e + '"'
  }), TypeError), i("ERR_INVALID_ARG_TYPE", (function(e, t, r) {
    var n, i, s, o;
    if ("string" == typeof t && (i = "not ", t.substr(!s || s < 0 ? 0 : +s, i.length) === i) ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be", function(e, t, r) {
      return (void 0 === r || r > e.length) && (r = e.length), e.substring(r - t.length, r) === t
    }(e, " argument")) o = "The ".concat(e, " ").concat(n, " ").concat(a(t, "type"));
    else {
      var u = function(e, t, r) {
        return "number" != typeof r && (r = 0), !(r + t.length > e.length) && -1 !== e.indexOf(t, r)
      }(e, ".") ? "property" : "argument";
      o = 'The "'.concat(e, '" ').concat(u, " ").concat(n, " ").concat(a(t, "type"))
    }
    return o += ". Received type ".concat(typeof r)
  }), TypeError), i("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), i("ERR_METHOD_NOT_IMPLEMENTED", (function(e) {
    return "The " + e + " method is not implemented"
  })), i("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), i("ERR_STREAM_DESTROYED", (function(e) {
    return "Cannot call " + e + " after a stream was destroyed"
  })), i("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), i("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), i("ERR_STREAM_WRITE_AFTER_END", "write after end"), i("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), i("ERR_UNKNOWN_ENCODING", (function(e) {
    return "Unknown encoding: " + e
  }), TypeError), i("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), e.exports.codes = n
}, function(e, t, r) {
  "use strict";
  (function(t) {
    var n = Object.keys || function(e) {
      var t = [];
      for (var r in e) t.push(r);
      return t
    };
    e.exports = c;
    var i = r(104),
      a = r(108);
    r(12)(c, i);
    for (var s = n(a.prototype), o = 0; o < s.length; o++) {
      var u = s[o];
      c.prototype[u] || (c.prototype[u] = a.prototype[u])
    }

    function c(e) {
      if (!(this instanceof c)) return new c(e);
      i.call(this, e), a.call(this, e), this.allowHalfOpen = !0, e && (!1 === e.readable && (this.readable = !1), !1 === e.writable && (this.writable = !1), !1 === e.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", l)))
    }

    function l() {
      this._writableState.ended || t.nextTick(h, this)
    }

    function h(e) {
      e.end()
    }
    Object.defineProperty(c.prototype, "writableHighWaterMark", {
      enumerable: !1,
      get: function() {
        return this._writableState.highWaterMark
      }
    }), Object.defineProperty(c.prototype, "writableBuffer", {
      enumerable: !1,
      get: function() {
        return this._writableState && this._writableState.getBuffer()
      }
    }), Object.defineProperty(c.prototype, "writableLength", {
      enumerable: !1,
      get: function() {
        return this._writableState.length
      }
    }), Object.defineProperty(c.prototype, "destroyed", {
      enumerable: !1,
      get: function() {
        return void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed && this._writableState.destroyed)
      },
      set: function(e) {
        void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = e, this._writableState.destroyed = e)
      }
    })
  }).call(this, r(8))
}, function(e, t, r) {
  "use strict";
  var n = r(207).Buffer,
    i = n.isEncoding || function(e) {
      switch ((e = "" + e) && e.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return !0;
        default:
          return !1
      }
    };

  function a(e) {
    var t;
    switch (this.encoding = function(e) {
      var t = function(e) {
        if (!e) return "utf8";
        for (var t;;) switch (e) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return e;
          default:
            if (t) return;
            e = ("" + e).toLowerCase(), t = !0
        }
      }(e);
      if ("string" != typeof t && (n.isEncoding === i || !i(e))) throw new Error("Unknown encoding: " + e);
      return t || e
    }(e), this.encoding) {
      case "utf16le":
        this.text = u, this.end = c, t = 4;
        break;
      case "utf8":
        this.fillLast = o, t = 4;
        break;
      case "base64":
        this.text = l, this.end = h, t = 3;
        break;
      default:
        return this.write = d, void(this.end = p)
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(t)
  }

  function s(e) {
    return e <= 127 ? 0 : e >> 5 == 6 ? 2 : e >> 4 == 14 ? 3 : e >> 3 == 30 ? 4 : e >> 6 == 2 ? -1 : -2
  }

  function o(e) {
    var t = this.lastTotal - this.lastNeed,
      r = function(e, t, r) {
        if (128 != (192 & t[0])) return e.lastNeed = 0, "�";
        if (e.lastNeed > 1 && t.length > 1) {
          if (128 != (192 & t[1])) return e.lastNeed = 1, "�";
          if (e.lastNeed > 2 && t.length > 2 && 128 != (192 & t[2])) return e.lastNeed = 2, "�"
        }
      }(this, e);
    return void 0 !== r ? r : this.lastNeed <= e.length ? (e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (e.copy(this.lastChar, t, 0, e.length), void(this.lastNeed -= e.length))
  }

  function u(e, t) {
    if ((e.length - t) % 2 == 0) {
      var r = e.toString("utf16le", t);
      if (r) {
        var n = r.charCodeAt(r.length - 1);
        if (n >= 55296 && n <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], r.slice(0, -1)
      }
      return r
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1)
  }

  function c(e) {
    var t = e && e.length ? this.write(e) : "";
    if (this.lastNeed) {
      var r = this.lastTotal - this.lastNeed;
      return t + this.lastChar.toString("utf16le", 0, r)
    }
    return t
  }

  function l(e, t) {
    var r = (e.length - t) % 3;
    return 0 === r ? e.toString("base64", t) : (this.lastNeed = 3 - r, this.lastTotal = 3, 1 === r ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - r))
  }

  function h(e) {
    var t = e && e.length ? this.write(e) : "";
    return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t
  }

  function d(e) {
    return e.toString(this.encoding)
  }

  function p(e) {
    return e && e.length ? this.write(e) : ""
  }
  t.StringDecoder = a, a.prototype.write = function(e) {
    if (0 === e.length) return "";
    var t, r;
    if (this.lastNeed) {
      if (void 0 === (t = this.fillLast(e))) return "";
      r = this.lastNeed, this.lastNeed = 0
    } else r = 0;
    return r < e.length ? t ? t + this.text(e, r) : this.text(e, r) : t || ""
  }, a.prototype.end = function(e) {
    var t = e && e.length ? this.write(e) : "";
    return this.lastNeed ? t + "�" : t
  }, a.prototype.text = function(e, t) {
    var r = function(e, t, r) {
      var n = t.length - 1;
      if (n < r) return 0;
      var i = s(t[n]);
      if (i >= 0) return i > 0 && (e.lastNeed = i - 1), i;
      if (--n < r || -2 === i) return 0;
      if ((i = s(t[n])) >= 0) return i > 0 && (e.lastNeed = i - 2), i;
      if (--n < r || -2 === i) return 0;
      if ((i = s(t[n])) >= 0) return i > 0 && (2 === i ? i = 0 : e.lastNeed = i - 3), i;
      return 0
    }(this, e, t);
    if (!this.lastNeed) return e.toString("utf8", t);
    this.lastTotal = r;
    var n = e.length - (r - this.lastNeed);
    return e.copy(this.lastChar, 0, n), e.toString("utf8", t, n)
  }, a.prototype.fillLast = function(e) {
    if (this.lastNeed <= e.length) return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(119), t), i(r(229), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  t.Translator = class {
    constructor() {
      this.supportedRdfDatatypes = [], this.fromRdfHandlers = {}, this.toRdfHandlers = {}
    }
    static incorrectRdfDataType(e) {
      throw new Error(`Invalid RDF ${e.datatype.value} value: '${e.value}'`)
    }
    registerHandler(e, t, r) {
      for (const r of t) this.supportedRdfDatatypes.push(r), this.fromRdfHandlers[r.value] = e;
      for (const t of r) {
        let r = this.toRdfHandlers[t];
        r || (this.toRdfHandlers[t] = r = []), r.push(e)
      }
    }
    fromRdf(e, t) {
      const r = this.fromRdfHandlers[e.datatype.value];
      return r ? r.fromRdf(e, t) : e.value
    }
    toRdf(e, t) {
      const r = this.toRdfHandlers[typeof e];
      if (r)
        for (const n of r) {
          const r = n.toRdf(e, t);
          if (r) return r
        }
      throw new Error(`Invalid JavaScript value: '${e}'`)
    }
    getSupportedRdfDatatypes() {
      return this.supportedRdfDatatypes
    }
    getSupportedJavaScriptPrimitives() {
      return Object.keys(this.toRdfHandlers)
    }
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(246), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.hasChildren = t.isComment = t.isText = t.isCDATA = t.isTag = void 0;
  var n = r(59);
  t.isTag = function(e) {
    return n.isTag(e)
  }, t.isCDATA = function(e) {
    return "cdata" === e.type
  }, t.isText = function(e) {
    return "text" === e.type
  }, t.isComment = function(e) {
    return "comment" === e.type
  }, t.hasChildren = function(e) {
    return Object.prototype.hasOwnProperty.call(e, "children")
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.DirectiveNodeHandlerAdapter = void 0;
  t.DirectiveNodeHandlerAdapter = class {
    constructor(e, t, r) {
      this.targetKind = e, this.util = t, this.settings = r
    }
    getDirectiveConditionalValue(e, t) {
      const r = this.util.getArgument(e.arguments, "if");
      if (!r) throw new Error(`The directive ${e.name.value} is missing an if-argument.`);
      const n = this.util.handleNodeValue(r.value, r.name.value, t);
      if (1 !== n.terms.length) throw new Error(`Can not apply the directive ${e.name.value} with a list.`);
      return n.terms[0]
    }
    isDirectiveScopeAll(e) {
      const t = this.util.getArgument(e.arguments, "scope");
      return t && "EnumValue" === t.value.kind && "all" === t.value.value
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.transformExistence = t.transformAggregate = t.transformNamed = t.transformLiteral = t.transformRDFTermUnsafe = t.transformAlgebra = void 0;
  const n = r(4),
    i = r(6),
    a = r(40),
    s = r(14),
    o = r(20),
    u = r(65),
    c = r(89),
    l = r(14);

  function h(e) {
    if (!e) throw new o.InvalidExpression(e);
    const t = i.Algebra.expressionTypes;
    switch (e.expressionType) {
      case t.TERM:
        return d(e);
      case t.OPERATOR:
        return function(e) {
          if (s.SpecialOperators.contains(e.operator)) {
            const t = e.operator,
              r = e.args.map(e => h(e)),
              n = c.specialFunctions.get(t);
            if (!n.checkArity(r)) throw new o.InvalidArity(r, t);
            return new a.SpecialOperator(r, n.applyAsync, n.applySync)
          } {
            if (!s.Operators.contains(e.operator)) throw new o.UnknownOperator(e.operator);
            const t = e.operator,
              r = e.args.map(e => h(e)),
              n = c.regularFunctions.get(t);
            if (! function(e, t) {
              if (t === 1 / 0) return !0;
              if (Array.isArray(t)) return t.indexOf(e.length) >= 0;
              return e.length === t
            }(r, n.arity)) throw new o.InvalidArity(r, t);
            return new a.Operator(r, n.apply)
          }
        }(e);
      case t.NAMED:
        return f(e);
      case t.EXISTENCE:
        return m(e);
      case t.AGGREGATE:
        return g(e);
      case t.WILDCARD:
        return function(e) {
          if (!e.wildcard) throw new o.InvalidExpression(e);
          return new a.NamedNode(e.wildcard.value)
        }(e);
      default:
        throw new o.InvalidExpressionType(e)
    }
  }

  function d(e) {
    if (!e.term) throw new o.InvalidExpression(e);
    switch (e.term.termType) {
      case "Variable":
        return new a.Variable(n.termToString(e.term));
      case "Literal":
        return p(e.term);
      case "NamedNode":
        return new a.NamedNode(e.term.value);
      case "BlankNode":
        return new a.BlankNode(e.term.value);
      default:
        throw new o.InvalidTermType(e)
    }
  }

  function p(e) {
    if (!e.datatype) return e.language ? new a.LangStringLiteral(e.value, e.language) : new a.StringLiteral(e.value);
    switch (e.datatype.value) {
      case null:
      case void 0:
      case "":
        return e.language ? new a.LangStringLiteral(e.value, e.language) : new a.StringLiteral(e.value);
      case l.TypeURL.XSD_STRING:
        return new a.StringLiteral(e.value);
      case l.TypeURL.RDF_LANG_STRING:
        return new a.LangStringLiteral(e.value, e.language);
      case l.TypeURL.XSD_DATE_TIME:
      case l.TypeURL.XSD_DATE: {
        const t = new Date(e.value);
        return isNaN(t.getTime()) ? new a.NonLexicalLiteral(void 0, e.datatype, e.value) : new a.DateTimeLiteral(new Date(e.value), e.value)
      }
      case l.TypeURL.XSD_BOOLEAN:
        return "true" !== e.value && "false" !== e.value && "1" !== e.value && "0" !== e.value ? new a.NonLexicalLiteral(void 0, e.datatype, e.value) : new a.BooleanLiteral("true" === e.value || "1" === e.value, e.value);
      case l.TypeURL.XSD_INTEGER:
      case l.TypeURL.XSD_DECIMAL:
      case l.TypeURL.XSD_NEGATIVE_INTEGER:
      case l.TypeURL.XSD_NON_NEGATIVE_INTEGER:
      case l.TypeURL.XSD_NON_POSITIVE_INTEGER:
      case l.TypeURL.XSD_POSITIVE_INTEGER:
      case l.TypeURL.XSD_LONG:
      case l.TypeURL.XSD_SHORT:
      case l.TypeURL.XSD_BYTE:
      case l.TypeURL.XSD_UNSIGNED_LONG:
      case l.TypeURL.XSD_UNSIGNED_INT:
      case l.TypeURL.XSD_UNSIGNED_SHORT:
      case l.TypeURL.XSD_UNSIGNED_BYTE:
      case l.TypeURL.XSD_INT: {
        const t = u.parseXSDDecimal(e.value);
        return void 0 === t ? new a.NonLexicalLiteral(void 0, e.datatype, e.value) : new a.NumericLiteral(t, e.datatype, e.value)
      }
      case l.TypeURL.XSD_FLOAT:
      case l.TypeURL.XSD_DOUBLE: {
        const t = u.parseXSDFloat(e.value);
        return void 0 === t ? new a.NonLexicalLiteral(void 0, e.datatype, e.value) : new a.NumericLiteral(t, e.datatype, e.value)
      }
      default:
        return new a.Literal(e.value, e.datatype, e.value)
    }
  }

  function f(e) {
    const t = e.name.value;
    if (!s.NamedOperators.contains(t)) throw new o.UnknownNamedOperator(e.name.value);
    const r = e.name.value,
      n = e.args.map(e => h(e)),
      i = c.namedFunctions.get(r);
    return new a.Named(e.name, n, i.apply)
  }

  function g(e) {
    const t = e.aggregator;
    return new a.Aggregate(t, e)
  }

  function m(e) {
    return new a.Existence(e)
  }
  t.transformAlgebra = h, t.transformRDFTermUnsafe = function(e) {
    return d({
      term: e,
      type: "expression",
      expressionType: "term"
    })
  }, t.transformLiteral = p, t.transformNamed = f, t.transformAggregate = g, t.transformExistence = m
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(24), t), i(r(526), t), i(r(527), t), i(r(528), t), i(r(529), t), i(r(530), t), i(r(531), t), i(r(532), t)
}, function(e, t, r) {
  "use strict";
  r.r(t), r.d(t, "Lexer", (function() {
    return i.a
  })), r.d(t, "Parser", (function() {
    return k
  })), r.d(t, "Writer", (function() {
    return z
  })), r.d(t, "Store", (function() {
    return $
  })), r.d(t, "StreamParser", (function() {
    return J
  })), r.d(t, "StreamWriter", (function() {
    return W
  })), r.d(t, "Util", (function() {
    return n
  })), r.d(t, "DataFactory", (function() {
    return w
  })), r.d(t, "Term", (function() {
    return S
  })), r.d(t, "NamedNode", (function() {
    return T
  })), r.d(t, "Literal", (function() {
    return E
  })), r.d(t, "BlankNode", (function() {
    return x
  })), r.d(t, "Variable", (function() {
    return O
  })), r.d(t, "DefaultGraph", (function() {
    return A
  })), r.d(t, "Quad", (function() {
    return N
  })), r.d(t, "Triple", (function() {
    return N
  })), r.d(t, "termFromId", (function() {
    return R
  })), r.d(t, "termToId", (function() {
    return I
  }));
  var n = {};
  r.r(n), r.d(n, "isNamedNode", (function() {
    return s
  })), r.d(n, "isBlankNode", (function() {
    return o
  })), r.d(n, "isLiteral", (function() {
    return u
  })), r.d(n, "isVariable", (function() {
    return c
  })), r.d(n, "isDefaultGraph", (function() {
    return l
  })), r.d(n, "inDefaultGraph", (function() {
    return h
  })), r.d(n, "prefix", (function() {
    return d
  })), r.d(n, "prefixes", (function() {
    return p
  }));
  var i = r(67),
    a = r(7);

  function s(e) {
    return !!e && "NamedNode" === e.termType
  }

  function o(e) {
    return !!e && "BlankNode" === e.termType
  }

  function u(e) {
    return !!e && "Literal" === e.termType
  }

  function c(e) {
    return !!e && "Variable" === e.termType
  }

  function l(e) {
    return !!e && "DefaultGraph" === e.termType
  }

  function h(e) {
    return l(e.graph)
  }

  function d(e, t) {
    return p({
      "": e
    }, t)("")
  }

  function p(e, t) {
    var r = Object.create(null);
    for (var n in e) i(n, e[n]);

    function i(e, n) {
      if ("string" == typeof n) {
        var i = Object.create(null);
        r[e] = function(e) {
          return i[e] || (i[e] = t.namedNode(n + e))
        }
      } else if (!(e in r)) throw new Error("Unknown prefix: " + e);
      return r[e]
    }
    return t = t || w, i
  }
  const {
    rdf: f,
    xsd: g
  } = a.a;
  let m, y = 0;
  const b = /^"(.*".*)(?="[^"]*$)/,
    _ = /^<<("(?:""|[^"])*"[^ ]*|[^ ]+) ("(?:""|[^"])*"[^ ]*|[^ ]+) ("(?:""|[^"])*"[^ ]*|[^ ]+) ?("(?:""|[^"])*"[^ ]*|[^ ]+)?>>$/,
    v = {
      namedNode: function(e) {
        return new T(e)
      },
      blankNode: function(e) {
        return new x(e || "n3-" + y++)
      },
      variable: function(e) {
        return new O(e)
      },
      literal: function(e, t) {
        if ("string" == typeof t) return new E('"' + e + '"@' + t.toLowerCase());
        let r = t ? t.value : "";
        "" === r && ("boolean" == typeof e ? r = g.boolean : "number" == typeof e && (Number.isFinite(e) ? r = Number.isInteger(e) ? g.integer : g.double : (r = g.double, Number.isNaN(e) || (e = e > 0 ? "INF" : "-INF"))));
        return "" === r || r === g.string ? new E('"' + e + '"') : new E('"' + e + '"^^' + r)
      },
      defaultGraph: function() {
        return m
      },
      quad: D,
      triple: D
    };
  var w = v;
  class S {
    constructor(e) {
      this.id = e
    }
    get value() {
      return this.id
    }
    equals(e) {
      return e instanceof S ? this.id === e.id : !!e && this.termType === e.termType && this.value === e.value
    }
    toJSON() {
      return {
        termType: this.termType,
        value: this.value
      }
    }
  }
  class T extends S {
    get termType() {
      return "NamedNode"
    }
  }
  class E extends S {
    get termType() {
      return "Literal"
    }
    get value() {
      return this.id.substring(1, this.id.lastIndexOf('"'))
    }
    get language() {
      var e = this.id,
        t = e.lastIndexOf('"') + 1;
      return t < e.length && "@" === e[t++] ? e.substr(t).toLowerCase() : ""
    }
    get datatype() {
      return new T(this.datatypeString)
    }
    get datatypeString() {
      var e, t = this.id,
        r = t.lastIndexOf('"') + 1;
      return r < t.length && "^" === (e = t[r]) ? t.substr(r + 2) : "@" !== e ? g.string : f.langString
    }
    equals(e) {
      return e instanceof E ? this.id === e.id : !!e && !!e.datatype && this.termType === e.termType && this.value === e.value && this.language === e.language && this.datatype.value === e.datatype.value
    }
    toJSON() {
      return {
        termType: this.termType,
        value: this.value,
        language: this.language,
        datatype: {
          termType: "NamedNode",
          value: this.datatypeString
        }
      }
    }
  }
  class x extends S {
    constructor(e) {
      super("_:" + e)
    }
    get termType() {
      return "BlankNode"
    }
    get value() {
      return this.id.substr(2)
    }
  }
  class O extends S {
    constructor(e) {
      super("?" + e)
    }
    get termType() {
      return "Variable"
    }
    get value() {
      return this.id.substr(1)
    }
  }
  class A extends S {
    constructor() {
      return super(""), m || this
    }
    get termType() {
      return "DefaultGraph"
    }
    equals(e) {
      return this === e || !!e && this.termType === e.termType
    }
  }

  function R(e, t) {
    if (t = t || v, !e) return t.defaultGraph();
    switch (e[0]) {
      case "?":
        return t.variable(e.substr(1));
      case "_":
        return t.blankNode(e.substr(2));
      case '"':
        if (t === v) return new E(e);
        if ('"' === e[e.length - 1]) return t.literal(e.substr(1, e.length - 2));
        var r = e.lastIndexOf('"', e.length - 1);
        return t.literal(e.substr(1, r - 1), "@" === e[r + 1] ? e.substr(r + 2) : t.namedNode(e.substr(r + 3)));
      case "<":
        const n = _.exec(e);
        return t.quad(R(C(n[1]), t), R(C(n[2]), t), R(C(n[3]), t), n[4] && R(C(n[4]), t));
      default:
        return t.namedNode(e)
    }
  }

  function I(e) {
    if ("string" == typeof e) return e;
    if (e instanceof S && "Quad" !== e.termType) return e.id;
    if (!e) return m.id;
    switch (e.termType) {
      case "NamedNode":
        return e.value;
      case "BlankNode":
        return "_:" + e.value;
      case "Variable":
        return "?" + e.value;
      case "DefaultGraph":
        return "";
      case "Literal":
        return '"' + e.value + '"' + (e.language ? "@" + e.language : e.datatype && e.datatype.value !== g.string ? "^^" + e.datatype.value : "");
      case "Quad":
        return `<<${P(I(e.subject))} ${P(I(e.predicate))} ${P(I(e.object))}${l(e.graph)?"":" "+I(e.graph)}>>`;
      default:
        throw new Error("Unexpected termType: " + e.termType)
    }
  }
  m = new A;
  class N extends S {
    constructor(e, t, r, n) {
      super(""), this.subject = e, this.predicate = t, this.object = r, this.graph = n || m
    }
    get termType() {
      return "Quad"
    }
    toJSON() {
      return {
        termType: this.termType,
        subject: this.subject.toJSON(),
        predicate: this.predicate.toJSON(),
        object: this.object.toJSON(),
        graph: this.graph.toJSON()
      }
    }
    equals(e) {
      return !!e && this.subject.equals(e.subject) && this.predicate.equals(e.predicate) && this.object.equals(e.object) && this.graph.equals(e.graph)
    }
  }

  function P(e) {
    return e.replace(b, (e, t) => '"' + t.replace(/"/g, '""'))
  }

  function C(e) {
    return e.replace(b, (e, t) => '"' + t.replace(/""/g, '"'))
  }

  function D(e, t, r, n) {
    return new N(e, t, r, n)
  }
  let j = 0;
  class k {
    constructor(e) {
      this._contextStack = [], this._graph = null, e = e || {}, this._setBase(e.baseIRI), e.factory && M(this, e.factory);
      var t = "string" == typeof e.format ? e.format.match(/\w*$/)[0].toLowerCase() : "",
        r = /turtle/.test(t),
        n = /trig/.test(t),
        a = /triple/.test(t),
        s = /quad/.test(t),
        o = this._n3Mode = /n3/.test(t),
        u = a || s;
      (this._supportsNamedGraphs = !(r || o)) || (this._readPredicateOrNamedGraph = this._readPredicate), this._supportsQuads = !(r || n || a || o), this._supportsRDFStar = "" === t || /star|\*$/.test(t), u && (this._resolveRelativeIRI = function(e) {
        return null
      }), this._blankNodePrefix = "string" != typeof e.blankNodePrefix ? "" : e.blankNodePrefix.replace(/^(?!_:)/, "_:"), this._lexer = e.lexer || new i.a({
        lineMode: u,
        n3: o
      }), this._explicitQuantifiers = !!e.explicitQuantifiers
    }
    static _resetBlankNodePrefix() {
      j = 0
    }
    _setBase(e) {
      if (e) {
        var t = e.indexOf("#");
        t >= 0 && (e = e.substr(0, t)), this._base = e, this._basePath = e.indexOf("/") < 0 ? e : e.replace(/[^\/?]*(?:\?.*)?$/, ""), e = e.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\/\/[^\/]*)?/i), this._baseRoot = e[0], this._baseScheme = e[1]
      } else this._base = "", this._basePath = ""
    }
    _saveContext(e, t, r, n, i) {
      var a = this._n3Mode;
      this._contextStack.push({
        subject: r,
        predicate: n,
        object: i,
        graph: t,
        type: e,
        inverse: !!a && this._inversePredicate,
        blankPrefix: a ? this._prefixes._ : "",
        quantified: a ? this._quantified : null
      }), a && (this._inversePredicate = !1, this._prefixes._ = this._graph ? this._graph.id.substr(2) + "." : ".", this._quantified = Object.create(this._quantified))
    }
    _restoreContext() {
      var e = this._contextStack.pop(),
        t = this._n3Mode;
      this._subject = e.subject, this._predicate = e.predicate, this._object = e.object, this._graph = e.graph, t && (this._inversePredicate = e.inverse, this._prefixes._ = e.blankPrefix, this._quantified = e.quantified)
    }
    _readInTopContext(e) {
      switch (e.type) {
        case "eof":
          return null !== this._graph ? this._error("Unclosed graph", e) : (delete this._prefixes._, this._callback(null, null, this._prefixes));
        case "PREFIX":
          this._sparqlStyle = !0;
        case "@prefix":
          return this._readPrefix;
        case "BASE":
          this._sparqlStyle = !0;
        case "@base":
          return this._readBaseIRI;
        case "{":
          if (this._supportsNamedGraphs) return this._graph = "", this._subject = null, this._readSubject;
        case "GRAPH":
          if (this._supportsNamedGraphs) return this._readNamedGraphLabel;
        default:
          return this._readSubject(e)
      }
    }
    _readEntity(e, t) {
      var r;
      switch (e.type) {
        case "IRI":
        case "typeIRI":
          var n = this._resolveIRI(e.value);
          if (null === n) return this._error("Invalid IRI", e);
          r = this._namedNode(n);
          break;
        case "type":
        case "prefixed":
          var i = this._prefixes[e.prefix];
          if (void 0 === i) return this._error('Undefined prefix "' + e.prefix + ':"', e);
          r = this._namedNode(i + e.value);
          break;
        case "blank":
          r = this._blankNode(this._prefixes[e.prefix] + e.value);
          break;
        case "var":
          r = this._variable(e.value.substr(1));
          break;
        default:
          return this._error("Expected entity but got " + e.type, e)
      }
      return !t && this._n3Mode && r.id in this._quantified && (r = this._quantified[r.id]), r
    }
    _readSubject(e) {
      switch (this._predicate = null, e.type) {
        case "[":
          return this._saveContext("blank", this._graph, this._subject = this._blankNode(), null, null), this._readBlankNodeHead;
        case "(":
          return this._saveContext("list", this._graph, this.RDF_NIL, null, null), this._subject = null, this._readListItem;
        case "{":
          return this._n3Mode ? (this._saveContext("formula", this._graph, this._graph = this._blankNode(), null, null), this._readSubject) : this._error("Unexpected graph", e);
        case "}":
          return this._readPunctuation(e);
        case "@forSome":
          return this._n3Mode ? (this._subject = null, this._predicate = this.N3_FORSOME, this._quantifier = this._blankNode, this._readQuantifierList) : this._error('Unexpected "@forSome"', e);
        case "@forAll":
          return this._n3Mode ? (this._subject = null, this._predicate = this.N3_FORALL, this._quantifier = this._variable, this._readQuantifierList) : this._error('Unexpected "@forAll"', e);
        case "literal":
          if (!this._n3Mode) return this._error("Unexpected literal", e);
          if (0 === e.prefix.length) return this._literalValue = e.value, this._completeSubjectLiteral;
          this._subject = this._literal(e.value, this._namedNode(e.prefix));
          break;
        case "<<":
          return this._supportsRDFStar ? (this._saveContext("<<", this._graph, null, null, null), this._graph = null, this._readSubject) : this._error("Unexpected RDF* syntax", e);
        default:
          if (void 0 === (this._subject = this._readEntity(e))) return;
          if (this._n3Mode) return this._getPathReader(this._readPredicateOrNamedGraph)
      }
      return this._readPredicateOrNamedGraph
    }
    _readPredicate(e) {
      var t = e.type;
      switch (t) {
        case "inverse":
          this._inversePredicate = !0;
        case "abbreviation":
          this._predicate = this.ABBREVIATIONS[e.value];
          break;
        case ".":
        case "]":
        case "}":
          return null === this._predicate ? this._error("Unexpected " + t, e) : (this._subject = null, "]" === t ? this._readBlankNodeTail(e) : this._readPunctuation(e));
        case ";":
          return null !== this._predicate ? this._readPredicate : this._error("Expected predicate but got ;", e);
        case "blank":
          if (!this._n3Mode) return this._error("Disallowed blank node as predicate", e);
        default:
          if (void 0 === (this._predicate = this._readEntity(e))) return
      }
      return this._readObject
    }
    _readObject(e) {
      switch (e.type) {
        case "literal":
          if (0 === e.prefix.length) return this._literalValue = e.value, this._readDataTypeOrLang;
          this._object = this._literal(e.value, this._namedNode(e.prefix));
          break;
        case "[":
          return this._saveContext("blank", this._graph, this._subject, this._predicate, this._subject = this._blankNode()), this._readBlankNodeHead;
        case "(":
          return this._saveContext("list", this._graph, this._subject, this._predicate, this.RDF_NIL), this._subject = null, this._readListItem;
        case "{":
          return this._n3Mode ? (this._saveContext("formula", this._graph, this._subject, this._predicate, this._graph = this._blankNode()), this._readSubject) : this._error("Unexpected graph", e);
        case "<<":
          return this._supportsRDFStar ? (this._saveContext("<<", this._graph, this._subject, this._predicate, null), this._graph = null, this._readSubject) : this._error("Unexpected RDF* syntax", e);
        default:
          if (void 0 === (this._object = this._readEntity(e))) return;
          if (this._n3Mode) return this._getPathReader(this._getContextEndReader())
      }
      return this._getContextEndReader()
    }
    _readPredicateOrNamedGraph(e) {
      return "{" === e.type ? this._readGraph(e) : this._readPredicate(e)
    }
    _readGraph(e) {
      return "{" !== e.type ? this._error("Expected graph but got " + e.type, e) : (this._graph = this._subject, this._subject = null, this._readSubject)
    }
    _readBlankNodeHead(e) {
      return "]" === e.type ? (this._subject = null, this._readBlankNodeTail(e)) : (this._predicate = null, this._readPredicate(e))
    }
    _readBlankNodeTail(e) {
      if ("]" !== e.type) return this._readBlankNodePunctuation(e);
      null !== this._subject && this._emit(this._subject, this._predicate, this._object, this._graph);
      var t = null === this._predicate;
      return this._restoreContext(), null === this._object ? t ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank : this._getContextEndReader()
    }
    _readPredicateAfterBlank(e) {
      switch (e.type) {
        case ".":
        case "}":
          return this._subject = null, this._readPunctuation(e);
        default:
          return this._readPredicate(e)
      }
    }
    _readListItem(e) {
      var t = null,
        r = null,
        n = this._subject,
        i = this._contextStack,
        a = i[i.length - 1],
        s = this._readListItem;
      switch (e.type) {
        case "[":
          this._saveContext("blank", this._graph, r = this._blankNode(), this.RDF_FIRST, this._subject = t = this._blankNode()), s = this._readBlankNodeHead;
          break;
        case "(":
          this._saveContext("list", this._graph, r = this._blankNode(), this.RDF_FIRST, this.RDF_NIL), this._subject = null;
          break;
        case ")":
          if (this._restoreContext(), 0 !== i.length && "list" === i[i.length - 1].type && this._emit(this._subject, this._predicate, this._object, this._graph), null === this._predicate) {
            if (s = this._readPredicate, this._subject === this.RDF_NIL) return s
          } else if (s = this._getContextEndReader(), this._object === this.RDF_NIL) return s;
          r = this.RDF_NIL;
          break;
        case "literal":
          0 === e.prefix.length ? (this._literalValue = e.value, s = this._readListItemDataTypeOrLang) : (t = this._literal(e.value, this._namedNode(e.prefix)), s = this._getContextEndReader());
          break;
        case "{":
          return this._n3Mode ? (this._saveContext("formula", this._graph, this._subject, this._predicate, this._graph = this._blankNode()), this._readSubject) : this._error("Unexpected graph", e);
        default:
          if (void 0 === (t = this._readEntity(e))) return
      }
      if (null === r && (this._subject = r = this._blankNode()), null === n ? null === a.predicate ? a.subject = r : a.object = r : this._emit(n, this.RDF_REST, r, this._graph), null !== t) {
        if (this._n3Mode && ("IRI" === e.type || "prefixed" === e.type)) return this._saveContext("item", this._graph, r, this.RDF_FIRST, t), this._subject = t, this._predicate = null, this._getPathReader(this._readListItem);
        this._emit(r, this.RDF_FIRST, t, this._graph)
      }
      return s
    }
    _readDataTypeOrLang(e) {
      return this._completeObjectLiteral(e, !1)
    }
    _readListItemDataTypeOrLang(e) {
      return this._completeObjectLiteral(e, !0)
    }
    _completeLiteral(e) {
      let t = this._literal(this._literalValue);
      switch (e.type) {
        case "type":
        case "typeIRI":
          var r = this._readEntity(e);
          if (void 0 === r) return;
          t = this._literal(this._literalValue, r), e = null;
          break;
        case "langcode":
          t = this._literal(this._literalValue, e.value), e = null
      }
      return {
        token: e,
        literal: t
      }
    }
    _completeSubjectLiteral(e) {
      return this._subject = this._completeLiteral(e).literal, this._readPredicateOrNamedGraph
    }
    _completeObjectLiteral(e, t) {
      const r = this._completeLiteral(e);
      if (r) return this._object = r.literal, t && this._emit(this._subject, this.RDF_FIRST, this._object, this._graph), null === r.token ? this._getContextEndReader() : (this._readCallback = this._getContextEndReader(), this._readCallback(r.token))
    }
    _readFormulaTail(e) {
      return "}" !== e.type ? this._readPunctuation(e) : (null !== this._subject && this._emit(this._subject, this._predicate, this._object, this._graph), this._restoreContext(), null === this._object ? this._readPredicate : this._getContextEndReader())
    }
    _readPunctuation(e) {
      var t, r = this._subject,
        n = this._graph,
        i = this._inversePredicate;
      switch (e.type) {
        case "}":
          if (null === this._graph) return this._error("Unexpected graph closing", e);
          if (this._n3Mode) return this._readFormulaTail(e);
          this._graph = null;
        case ".":
          this._subject = null, t = this._contextStack.length ? this._readSubject : this._readInTopContext, i && (this._inversePredicate = !1);
          break;
        case ";":
          t = this._readPredicate;
          break;
        case ",":
          t = this._readObject;
          break;
        default:
          if (this._supportsQuads && null === this._graph && void 0 !== (n = this._readEntity(e))) {
            t = this._readQuadPunctuation;
            break
          }
          return this._error('Expected punctuation to follow "' + this._object.id + '"', e)
      }
      if (null !== r) {
        var a = this._predicate,
          s = this._object;
        i ? this._emit(s, a, r, n) : this._emit(r, a, s, n)
      }
      return t
    }
    _readBlankNodePunctuation(e) {
      var t;
      switch (e.type) {
        case ";":
          t = this._readPredicate;
          break;
        case ",":
          t = this._readObject;
          break;
        default:
          return this._error('Expected punctuation to follow "' + this._object.id + '"', e)
      }
      return this._emit(this._subject, this._predicate, this._object, this._graph), t
    }
    _readQuadPunctuation(e) {
      return "." !== e.type ? this._error("Expected dot to follow quad", e) : this._readInTopContext
    }
    _readPrefix(e) {
      return "prefix" !== e.type ? this._error("Expected prefix to follow @prefix", e) : (this._prefix = e.value, this._readPrefixIRI)
    }
    _readPrefixIRI(e) {
      if ("IRI" !== e.type) return this._error('Expected IRI to follow prefix "' + this._prefix + ':"', e);
      var t = this._readEntity(e);
      return this._prefixes[this._prefix] = t.value, this._prefixCallback(this._prefix, t), this._readDeclarationPunctuation
    }
    _readBaseIRI(e) {
      var t = "IRI" === e.type && this._resolveIRI(e.value);
      return t ? (this._setBase(t), this._readDeclarationPunctuation) : this._error("Expected valid IRI to follow base declaration", e)
    }
    _readNamedGraphLabel(e) {
      switch (e.type) {
        case "IRI":
        case "blank":
        case "prefixed":
          return this._readSubject(e), this._readGraph;
        case "[":
          return this._readNamedGraphBlankLabel;
        default:
          return this._error("Invalid graph label", e)
      }
    }
    _readNamedGraphBlankLabel(e) {
      return "]" !== e.type ? this._error("Invalid graph label", e) : (this._subject = this._blankNode(), this._readGraph)
    }
    _readDeclarationPunctuation(e) {
      return this._sparqlStyle ? (this._sparqlStyle = !1, this._readInTopContext(e)) : "." !== e.type ? this._error("Expected declaration to end with a dot", e) : this._readInTopContext
    }
    _readQuantifierList(e) {
      var t;
      switch (e.type) {
        case "IRI":
        case "prefixed":
          if (void 0 !== (t = this._readEntity(e, !0))) break;
        default:
          return this._error("Unexpected " + e.type, e)
      }
      return this._explicitQuantifiers ? (null === this._subject ? this._emit(this._graph || this.DEFAULTGRAPH, this._predicate, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH) : this._emit(this._subject, this.RDF_REST, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH), this._emit(this._subject, this.RDF_FIRST, t, this.QUANTIFIERS_GRAPH)) : this._quantified[t.id] = this._quantifier(this._blankNode().value), this._readQuantifierPunctuation
    }
    _readQuantifierPunctuation(e) {
      return "," === e.type ? this._readQuantifierList : (this._explicitQuantifiers && (this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH), this._subject = null), this._readCallback = this._getContextEndReader(), this._readCallback(e))
    }
    _getPathReader(e) {
      return this._afterPath = e, this._readPath
    }
    _readPath(e) {
      switch (e.type) {
        case "!":
          return this._readForwardPath;
        case "^":
          return this._readBackwardPath;
        default:
          var t = this._contextStack,
            r = t.length && t[t.length - 1];
          if (r && "item" === r.type) {
            var n = this._subject;
            this._restoreContext(), this._emit(this._subject, this.RDF_FIRST, n, this._graph)
          }
          return this._afterPath(e)
      }
    }
    _readForwardPath(e) {
      var t, r, n = this._blankNode();
      if (void 0 !== (r = this._readEntity(e))) return null === this._predicate ? (t = this._subject, this._subject = n) : (t = this._object, this._object = n), this._emit(t, r, n, this._graph), this._readPath
    }
    _readBackwardPath(e) {
      var t, r, n = this._blankNode();
      if (void 0 !== (t = this._readEntity(e))) return null === this._predicate ? (r = this._subject, this._subject = n) : (r = this._object, this._object = n), this._emit(n, t, r, this._graph), this._readPath
    }
    _readRDFStarTailOrGraph(e) {
      return ">>" !== e.type ? this._supportsQuads && null === this._graph && void 0 !== (this._graph = this._readEntity(e)) ? this._readRDFStarTail : this._error('Expected >> to follow "' + this._object.id + '"', e) : this._readRDFStarTail(e)
    }
    _readRDFStarTail(e) {
      if (">>" !== e.type) return this._error("Expected >> but got " + e.type, e);
      const t = this._quad(this._subject, this._predicate, this._object, this._graph || this.DEFAULTGRAPH);
      return this._restoreContext(), null === this._subject ? (this._subject = t, this._readPredicate) : (this._object = t, this._getContextEndReader())
    }
    _getContextEndReader() {
      var e = this._contextStack;
      if (!e.length) return this._readPunctuation;
      switch (e[e.length - 1].type) {
        case "blank":
          return this._readBlankNodeTail;
        case "list":
          return this._readListItem;
        case "formula":
          return this._readFormulaTail;
        case "<<":
          return this._readRDFStarTailOrGraph
      }
    }
    _emit(e, t, r, n) {
      this._callback(null, this._quad(e, t, r, n || this.DEFAULTGRAPH))
    }
    _error(e, t) {
      var r = new Error(e + " on line " + t.line + ".");
      r.context = {
        token: t,
        line: t.line,
        previousToken: this._lexer.previousToken
      }, this._callback(r), this._callback = L
    }
    _resolveIRI(e) {
      return /^[a-z][a-z0-9+.-]*:/i.test(e) ? e : this._resolveRelativeIRI(e)
    }
    _resolveRelativeIRI(e) {
      if (!e.length) return this._base;
      switch (e[0]) {
        case "#":
          return this._base + e;
        case "?":
          return this._base.replace(/(?:\?.*)?$/, e);
        case "/":
          return ("/" === e[1] ? this._baseScheme : this._baseRoot) + this._removeDotSegments(e);
        default:
          return /^[^/:]*:/.test(e) ? null : this._removeDotSegments(this._basePath + e)
      }
    }
    _removeDotSegments(e) {
      if (!/(^|\/)\.\.?($|[/#?])/.test(e)) return e;
      for (var t = "", r = e.length, n = -1, i = -1, a = 0, s = "/"; n < r;) {
        switch (s) {
          case ":":
            if (i < 0 && "/" === e[++n] && "/" === e[++n])
              for (;
                (i = n + 1) < r && "/" !== e[i];) n = i;
            break;
          case "?":
          case "#":
            n = r;
            break;
          case "/":
            if ("." === e[n + 1]) switch (s = e[1 + ++n]) {
              case "/":
                t += e.substring(a, n - 1), a = n + 1;
                break;
              case void 0:
              case "?":
              case "#":
                return t + e.substring(a, n) + e.substr(n + 1);
              case ".":
                if (void 0 === (s = e[1 + ++n]) || "/" === s || "?" === s || "#" === s) {
                  if ((a = (t += e.substring(a, n - 2)).lastIndexOf("/")) >= i && (t = t.substr(0, a)), "/" !== s) return t + "/" + e.substr(n + 1);
                  a = n + 1
                }
            }
        }
        s = e[++n]
      }
      return t + e.substring(a)
    }
    parse(e, t, r) {
      var n = this;
      if (this._readCallback = this._readInTopContext, this._sparqlStyle = !1, this._prefixes = Object.create(null), this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : "b" + j++ + "_", this._prefixCallback = r || L, this._inversePredicate = !1, this._quantified = Object.create(null), !t) {
        var i, a = [];
        if (this._callback = function(e, t) {
          e ? i = e : t && a.push(t)
        }, this._lexer.tokenize(e).every((function(e) {
          return n._readCallback = n._readCallback(e)
        })), i) throw i;
        return a
      }
      this._callback = t, this._lexer.tokenize(e, (function(e, t) {
        null !== e ? (n._callback(e), n._callback = L) : n._readCallback && (n._readCallback = n._readCallback(t))
      }))
    }
  }

  function L() {}

  function M(e, t) {
    var r = t.namedNode;
    e._namedNode = r, e._blankNode = t.blankNode, e._literal = t.literal, e._variable = t.variable, e._quad = t.quad, e.DEFAULTGRAPH = t.defaultGraph(), e.RDF_FIRST = r(a.a.rdf.first), e.RDF_REST = r(a.a.rdf.rest), e.RDF_NIL = r(a.a.rdf.nil), e.N3_FORALL = r(a.a.r.forAll), e.N3_FORSOME = r(a.a.r.forSome), e.ABBREVIATIONS = {
      a: r(a.a.rdf.type),
      "=": r(a.a.owl.sameAs),
      ">": r(a.a.log.implies)
    }, e.QUANTIFIERS_GRAPH = r("urn:n3:quantifiers")
  }
  M(k.prototype, w);
  const F = w.defaultGraph(),
    {
      rdf: B,
      xsd: q
    } = a.a;
  var U = /["\\\t\n\r\b\f\u0000-\u0019\ud800-\udbff]/,
    V = /["\\\t\n\r\b\f\u0000-\u0019]|[\ud800-\udbff][\udc00-\udfff]/g,
    H = {
      "\\": "\\\\",
      '"': '\\"',
      "\t": "\\t",
      "\n": "\\n",
      "\r": "\\r",
      "\b": "\\b",
      "\f": "\\f"
    };
  class G extends S {
    equals() {
      return !1
    }
  }
  class z {
    constructor(e, t) {
      if (this._prefixRegex = /$0^/, e && "function" != typeof e.write && (t = e, e = null), t = t || {}, this._lists = t.lists, e) this._outputStream = e, this._endStream = void 0 === t.end || !!t.end;
      else {
        var r = "";
        this._outputStream = {
          write(e, t, n) {
            r += e, n && n()
          },
          end: function(e) {
            e && e(null, r)
          }
        }, this._endStream = !0
      }
      this._subject = null, /triple|quad/i.test(t.format) ? this._writeQuad = this._writeQuadLine : (this._graph = F, this._prefixIRIs = Object.create(null), t.prefixes && this.addPrefixes(t.prefixes))
    }
    get _inDefaultGraph() {
      return F.equals(this._graph)
    }
    _write(e, t) {
      this._outputStream.write(e, "utf8", t)
    }
    _writeQuad(e, t, r, n, i) {
      try {
        n.equals(this._graph) || (this._write((null === this._subject ? "" : this._inDefaultGraph ? ".\n" : "\n}\n") + (F.equals(n) ? "" : this._encodeIriOrBlank(n) + " {\n")), this._graph = n, this._subject = null), e.equals(this._subject) ? t.equals(this._predicate) ? this._write(", " + this._encodeObject(r), i) : this._write(";\n    " + this._encodePredicate(this._predicate = t) + " " + this._encodeObject(r), i) : this._write((null === this._subject ? "" : ".\n") + this._encodeSubject(this._subject = e) + " " + this._encodePredicate(this._predicate = t) + " " + this._encodeObject(r), i)
      } catch (e) {
        i && i(e)
      }
    }
    _writeQuadLine(e, t, r, n, i) {
      delete this._prefixMatch, this._write(this.quadToString(e, t, r, n), i)
    }
    quadToString(e, t, r, n) {
      return this._encodeSubject(e) + " " + this._encodeIriOrBlank(t) + " " + this._encodeObject(r) + (n && n.value ? " " + this._encodeIriOrBlank(n) + " .\n" : " .\n")
    }
    quadsToString(e) {
      return e.map((function(e) {
        return this.quadToString(e.subject, e.predicate, e.object, e.graph)
      }), this).join("")
    }
    _encodeSubject(e) {
      return "Quad" === e.termType ? this._encodeQuad(e) : this._encodeIriOrBlank(e)
    }
    _encodeIriOrBlank(e) {
      if ("NamedNode" !== e.termType) return this._lists && e.value in this._lists && (e = this.list(this._lists[e.value])), "id" in e ? e.id : "_:" + e.value;
      var t = e.value;
      U.test(t) && (t = t.replace(V, Q));
      var r = this._prefixRegex.exec(t);
      return r ? r[1] ? this._prefixIRIs[r[1]] + r[2] : t : "<" + t + ">"
    }
    _encodeLiteral(e) {
      var t = e.value;
      return U.test(t) && (t = t.replace(V, Q)), e.language ? '"' + t + '"@' + e.language : e.datatype.value !== q.string ? '"' + t + '"^^' + this._encodeIriOrBlank(e.datatype) : '"' + t + '"'
    }
    _encodePredicate(e) {
      return e.value === B.type ? "a" : this._encodeIriOrBlank(e)
    }
    _encodeObject(e) {
      switch (e.termType) {
        case "Quad":
          return this._encodeQuad(e);
        case "Literal":
          return this._encodeLiteral(e);
        default:
          return this._encodeIriOrBlank(e)
      }
    }
    _encodeQuad({
                  subject: e,
                  predicate: t,
                  object: r,
                  graph: n
                }) {
      return `<<${this._encodeSubject(e)} ${this._encodePredicate(t)} ${this._encodeObject(r)}${l(n)?"":" "+this._encodeIriOrBlank(n)}>>`
    }
    _blockedWrite() {
      throw new Error("Cannot write because the writer has been closed.")
    }
    addQuad(e, t, r, n, i) {
      void 0 === r ? this._writeQuad(e.subject, e.predicate, e.object, e.graph, t) : "function" == typeof n ? this._writeQuad(e, t, r, F, n) : this._writeQuad(e, t, r, n || F, i)
    }
    addQuads(e) {
      for (var t = 0; t < e.length; t++) this.addQuad(e[t])
    }
    addPrefix(e, t, r) {
      var n = {};
      n[e] = t, this.addPrefixes(n, r)
    }
    addPrefixes(e, t) {
      var r = this._prefixIRIs,
        n = !1;
      for (var i in e) {
        var a = e[i];
        "string" != typeof a && (a = a.value), n = !0, null !== this._subject && (this._write(this._inDefaultGraph ? ".\n" : "\n}\n"), this._subject = null, this._graph = ""), r[a] = i += ":", this._write("@prefix " + i + " <" + a + ">.\n")
      }
      if (n) {
        var s = "",
          o = "";
        for (var u in r) s += s ? "|" + u : u, o += (o ? "|" : "") + r[u];
        s = s.replace(/[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&"), this._prefixRegex = new RegExp("^(?:" + o + ")[^/]*$|^(" + s + ")([a-zA-Z][\\-_a-zA-Z0-9]*)$")
      }
      this._write(n ? "\n" : "", t)
    }
    blank(e, t) {
      var r, n, i = e;
      switch (void 0 === e ? i = [] : e.termType ? i = [{
        predicate: e,
        object: t
      }] : "length" in e || (i = [e]), n = i.length) {
        case 0:
          return new G("[]");
        case 1:
          if (!((r = i[0]).object instanceof G)) return new G("[ " + this._encodePredicate(r.predicate) + " " + this._encodeObject(r.object) + " ]");
        default:
          for (var a = "[", s = 0; s < n; s++)(r = i[s]).predicate.equals(e) ? a += ", " + this._encodeObject(r.object) : (a += (s ? ";\n  " : "\n  ") + this._encodePredicate(r.predicate) + " " + this._encodeObject(r.object), e = r.predicate);
          return new G(a + "\n]")
      }
    }
    list(e) {
      for (var t = e && e.length || 0, r = new Array(t), n = 0; n < t; n++) r[n] = this._encodeObject(e[n]);
      return new G("(" + r.join(" ") + ")")
    }
    end(e) {
      null !== this._subject && (this._write(this._inDefaultGraph ? ".\n" : "\n}\n"), this._subject = null), this._write = this._blockedWrite;
      var t = e && function(r, n) {
        t = null, e(r, n)
      };
      if (this._endStream) try {
        return this._outputStream.end(t)
      } catch (e) {}
      t && t()
    }
  }

  function Q(e) {
    var t = H[e];
    return void 0 === t && (1 === e.length ? (t = e.charCodeAt(0).toString(16), t = "\\u0000".substr(0, 6 - t.length) + t) : (t = (1024 * (e.charCodeAt(0) - 55296) + e.charCodeAt(1) + 9216).toString(16), t = "\\U00000000".substr(0, 10 - t.length) + t)), t
  }
  var X = r(42);
  class $ {
    constructor(e, t) {
      this._size = 0, this._graphs = Object.create(null), this._id = 0, this._ids = Object.create(null), this._ids["><"] = 0, this._entities = Object.create(null), this._blankNodeIndex = 0, t || !e || e[0] || (t = e, e = null), t = t || {}, this._factory = t.factory || w, e && this.addQuads(e)
    }
    get size() {
      var e = this._size;
      if (null !== e) return e;
      e = 0;
      var t, r, n = this._graphs;
      for (var i in n)
        for (var a in t = n[i].subjects)
          for (var s in r = t[a]) e += Object.keys(r[s]).length;
      return this._size = e
    }
    _addToIndex(e, t, r, n) {
      var i = e[t] || (e[t] = {}),
        a = i[r] || (i[r] = {}),
        s = n in a;
      return s || (a[n] = null), !s
    }
    _removeFromIndex(e, t, r, n) {
      var i, a = e[t],
        s = a[r];
      for (i in delete s[n], s) return;
      for (i in delete a[r], a) return;
      delete e[t]
    }
    _findInIndex(e, t, r, n, i, a, s, o, u, c) {
      var l, h, d, p = !t + !r + !n > 1 ? Object.keys(this._ids) : this._entities;
      for (var f in t && ((l = e, e = {})[t] = l[t]), e) {
        var g = p[f];
        if (h = e[f])
          for (var m in r && ((l = h, h = {})[r] = l[r]), h) {
            var y = p[m];
            if (d = h[m])
              for (var b = (n ? n in d ? [n] : [] : Object.keys(d)), _ = 0; _ < b.length; _++) {
                var v = {
                  subject: null,
                  predicate: null,
                  object: null
                };
                v[i] = R(g, this._factory), v[a] = R(y, this._factory), v[s] = R(p[b[_]], this._factory);
                var w = this._factory.quad(v.subject, v.predicate, v.object, R(o, this._factory));
                if (c) c.push(w);
                else if (u(w)) return !0
              }
          }
      }
      return c
    }
    _loop(e, t) {
      for (var r in e) t(r)
    }
    _loopByKey0(e, t, r) {
      var n, i;
      if (n = e[t])
        for (i in n) r(i)
    }
    _loopByKey1(e, t, r) {
      var n;
      for (n in e) e[n][t] && r(n)
    }
    _loopBy2Keys(e, t, r, n) {
      var i, a, s;
      if ((i = e[t]) && (a = i[r]))
        for (s in a) n(s)
    }
    _countInIndex(e, t, r, n) {
      var i, a, s, o = 0;
      for (var u in t && ((i = e, e = {})[t] = i[t]), e)
        if (a = e[u])
          for (var c in r && ((i = a, a = {})[r] = i[r]), a)(s = a[c]) && (n ? n in s && o++ : o += Object.keys(s).length);
      return o
    }
    _getGraphs(e) {
      if (!Y(e)) return this._graphs;
      var t = {};
      return t[e] = this._graphs[e], t
    }
    _uniqueEntities(e) {
      var t = Object.create(null),
        r = this._entities;
      return function(n) {
        n in t || (t[n] = !0, e(R(r[n])))
      }
    }
    addQuad(e, t, r, n) {
      t || (n = e.graph, r = e.object, t = e.predicate, e = e.subject), e = I(e), t = I(t), r = I(r), n = I(n);
      var i = this._graphs[n];
      i || (i = this._graphs[n] = {
        subjects: {},
        predicates: {},
        objects: {}
      }, Object.freeze(i));
      var a = this._ids,
        s = this._entities;
      e = a[e] || (a[s[++this._id] = e] = this._id), t = a[t] || (a[s[++this._id] = t] = this._id), r = a[r] || (a[s[++this._id] = r] = this._id);
      var o = this._addToIndex(i.subjects, e, t, r);
      return this._addToIndex(i.predicates, t, r, e), this._addToIndex(i.objects, r, e, t), this._size = null, o
    }
    addQuads(e) {
      for (var t = 0; t < e.length; t++) this.addQuad(e[t])
    }
    import(e) {
      var t = this;
      return e.on("data", (function(e) {
        t.addQuad(e)
      })), e
    }
    removeQuad(e, t, r, n) {
      t || (n = e.graph, r = e.object, t = e.predicate, e = e.subject), e = I(e), t = I(t), r = I(r), n = I(n);
      var i, a, s, o = this._ids,
        u = this._graphs;
      if (!((e = o[e]) && (t = o[t]) && (r = o[r]) && (i = u[n]) && (a = i.subjects[e]) && (s = a[t]) && r in s)) return !1;
      for (e in this._removeFromIndex(i.subjects, e, t, r), this._removeFromIndex(i.predicates, t, r, e), this._removeFromIndex(i.objects, r, e, t), null !== this._size && this._size--, i.subjects) return !0;
      return delete u[n], !0
    }
    removeQuads(e) {
      for (var t = 0; t < e.length; t++) this.removeQuad(e[t])
    }
    remove(e) {
      var t = this;
      return e.on("data", (function(e) {
        t.removeQuad(e)
      })), e
    }
    removeMatches(e, t, r, n) {
      return this.remove(this.match(e, t, r, n))
    }
    deleteGraph(e) {
      return this.removeMatches(null, null, null, e)
    }
    getQuads(e, t, r, n) {
      e = e && I(e), t = t && I(t), r = r && I(r), n = n && I(n);
      var i, a, s, o, u = [],
        c = this._getGraphs(n),
        l = this._ids;
      if (Y(e) && !(a = l[e]) || Y(t) && !(s = l[t]) || Y(r) && !(o = l[r])) return u;
      for (var h in c)(i = c[h]) && (a ? o ? this._findInIndex(i.objects, o, a, s, "object", "subject", "predicate", h, null, u) : this._findInIndex(i.subjects, a, s, null, "subject", "predicate", "object", h, null, u) : s ? this._findInIndex(i.predicates, s, o, null, "predicate", "object", "subject", h, null, u) : o ? this._findInIndex(i.objects, o, null, null, "object", "subject", "predicate", h, null, u) : this._findInIndex(i.subjects, null, null, null, "subject", "predicate", "object", h, null, u));
      return u
    }
    match(e, t, r, n) {
      var i = new X.Readable({
        objectMode: !0
      });
      return i._read = () => {
        for (var a of this.getQuads(e, t, r, n)) i.push(a);
        i.push(null)
      }, i
    }
    countQuads(e, t, r, n) {
      e = e && I(e), t = t && I(t), r = r && I(r), n = n && I(n);
      var i, a, s, o, u = 0,
        c = this._getGraphs(n),
        l = this._ids;
      if (Y(e) && !(a = l[e]) || Y(t) && !(s = l[t]) || Y(r) && !(o = l[r])) return 0;
      for (var h in c)(i = c[h]) && (u += e ? r ? this._countInIndex(i.objects, o, a, s) : this._countInIndex(i.subjects, a, s, o) : t ? this._countInIndex(i.predicates, s, o, a) : this._countInIndex(i.objects, o, a, s));
      return u
    }
    forEach(e, t, r, n, i) {
      this.some((function(t) {
        return e(t), !1
      }), t, r, n, i)
    }
    every(e, t, r, n, i) {
      var a = !1,
        s = !this.some((function(t) {
          return a = !0, !e(t)
        }), t, r, n, i);
      return a && s
    }
    some(e, t, r, n, i) {
      t = t && I(t), r = r && I(r), n = n && I(n), i = i && I(i);
      var a, s, o, u, c = this._getGraphs(i),
        l = this._ids;
      if (Y(t) && !(s = l[t]) || Y(r) && !(o = l[r]) || Y(n) && !(u = l[n])) return !1;
      for (var h in c)
        if (a = c[h])
          if (s) {
            if (u) {
              if (this._findInIndex(a.objects, u, s, o, "object", "subject", "predicate", h, e, null)) return !0
            } else if (this._findInIndex(a.subjects, s, o, null, "subject", "predicate", "object", h, e, null)) return !0
          } else if (o) {
            if (this._findInIndex(a.predicates, o, u, null, "predicate", "object", "subject", h, e, null)) return !0
          } else if (u) {
            if (this._findInIndex(a.objects, u, null, null, "object", "subject", "predicate", h, e, null)) return !0
          } else if (this._findInIndex(a.subjects, null, null, null, "subject", "predicate", "object", h, e, null)) return !0;
      return !1
    }
    getSubjects(e, t, r) {
      var n = [];
      return this.forSubjects((function(e) {
        n.push(e)
      }), e, t, r), n
    }
    forSubjects(e, t, r, n) {
      t = t && I(t), r = r && I(r), n = n && I(n);
      var i, a, s, o = this._ids,
        u = this._getGraphs(n);
      if (e = this._uniqueEntities(e), !(Y(t) && !(a = o[t]) || Y(r) && !(s = o[r])))
        for (n in u)(i = u[n]) && (a ? s ? this._loopBy2Keys(i.predicates, a, s, e) : this._loopByKey1(i.subjects, a, e) : s ? this._loopByKey0(i.objects, s, e) : this._loop(i.subjects, e))
    }
    getPredicates(e, t, r) {
      var n = [];
      return this.forPredicates((function(e) {
        n.push(e)
      }), e, t, r), n
    }
    forPredicates(e, t, r, n) {
      t = t && I(t), r = r && I(r), n = n && I(n);
      var i, a, s, o = this._ids,
        u = this._getGraphs(n);
      if (e = this._uniqueEntities(e), !(Y(t) && !(a = o[t]) || Y(r) && !(s = o[r])))
        for (n in u)(i = u[n]) && (a ? s ? this._loopBy2Keys(i.objects, s, a, e) : this._loopByKey0(i.subjects, a, e) : s ? this._loopByKey1(i.predicates, s, e) : this._loop(i.predicates, e))
    }
    getObjects(e, t, r) {
      var n = [];
      return this.forObjects((function(e) {
        n.push(e)
      }), e, t, r), n
    }
    forObjects(e, t, r, n) {
      t = t && I(t), r = r && I(r), n = n && I(n);
      var i, a, s, o = this._ids,
        u = this._getGraphs(n);
      if (e = this._uniqueEntities(e), !(Y(t) && !(a = o[t]) || Y(r) && !(s = o[r])))
        for (n in u)(i = u[n]) && (a ? s ? this._loopBy2Keys(i.subjects, a, s, e) : this._loopByKey1(i.objects, a, e) : s ? this._loopByKey0(i.predicates, s, e) : this._loop(i.objects, e))
    }
    getGraphs(e, t, r) {
      var n = [];
      return this.forGraphs((function(e) {
        n.push(e)
      }), e, t, r), n
    }
    forGraphs(e, t, r, n) {
      for (var i in this._graphs) this.some((function(t) {
        return e(t.graph), !0
      }), t, r, n, i)
    }
    createBlankNode(e) {
      var t, r;
      if (e)
        for (t = e = "_:" + e, r = 1; this._ids[t];) t = e + r++;
      else
        do {
          t = "_:b" + this._blankNodeIndex++
        } while (this._ids[t]);
      return this._ids[t] = ++this._id, this._entities[this._id] = t, this._factory.blankNode(t.substr(2))
    }
    extractLists({
                   remove: e = !1,
                   ignoreErrors: t = !1
                 } = {}) {
      var r = {},
        n = t ? () => !0 : (e, t) => {
          throw new Error(`${e.value} ${t}`)
        },
        i = this.getQuads(null, a.a.rdf.rest, a.a.rdf.nil, null),
        s = e ? [...i] : [];
      return i.forEach(t => {
        for (var i, o, u = [], c = !1, l = t.graph, h = t.subject; h && !c;) {
          var d, p, f = this.getQuads(null, null, h, null),
            g = this.getQuads(h, null, null, null),
            m = null,
            y = null,
            b = null;
          for (d = 0; d < g.length && !c; d++)(p = g[d]).graph.equals(l) ? i ? c = n(h, "has non-list arcs out") : p.predicate.value === a.a.rdf.first ? m ? c = n(h, "has multiple rdf:first arcs") : s.push(m = p) : p.predicate.value === a.a.rdf.rest ? y ? c = n(h, "has multiple rdf:rest arcs") : s.push(y = p) : f.length ? c = n(h, "can't be subject and object") : (i = p, o = "subject") : c = n(h, "not confined to single graph");
          for (d = 0; d < f.length && !c; ++d) p = f[d], i ? c = n(h, "can't have coreferences") : p.predicate.value === a.a.rdf.rest ? b ? c = n(h, "has incoming rdf:rest arcs") : b = p : (i = p, o = "object");
          m ? u.unshift(m.object) : c = n(h, "has no list head"), h = b && b.subject
        }
        c ? e = !1 : i && (r[i[o].value] = u)
      }), e && this.removeQuads(s), r
    }
  }

  function Y(e) {
    return "string" == typeof e || e instanceof String
  }
  class J extends X.Transform {
    constructor(e) {
      super({
        decodeStrings: !0
      }), this._readableState.objectMode = !0;
      var t, r, n = this;
      new k(e).parse({
        on: function(e, n) {
          switch (e) {
            case "data":
              t = n;
              break;
            case "end":
              r = n
          }
        }
      }, (function(e, t) {
        e && n.emit("error", e) || t && n.push(t)
      }), (function(e, t) {
        n.emit("prefix", e, t)
      })), this._transform = function(e, r, n) {
        t(e), n()
      }, this._flush = function(e) {
        r(), e()
      }
    }
    import(e) {
      var t = this;
      return e.on("data", (function(e) {
        t.write(e)
      })), e.on("end", (function() {
        t.end()
      })), e.on("error", (function(e) {
        t.emit("error", e)
      })), this
    }
  }
  class W extends X.Transform {
    constructor(e) {
      super({
        encoding: "utf8"
      }), this._writableState.objectMode = !0;
      var t = this,
        r = this._writer = new z({
          write: function(e, r, n) {
            t.push(e), n && n()
          },
          end: function(e) {
            t.push(null), e && e()
          }
        }, e);
      this._transform = function(e, t, n) {
        r.addQuad(e, n)
      }, this._flush = function(e) {
        r.end(e)
      }
    }
    import(e) {
      var t = this;
      return e.on("data", (function(e) {
        t.write(e)
      })), e.on("end", (function() {
        t.end()
      })), e.on("error", (function(e) {
        t.emit("error", e)
      })), e.on("prefix", (function(e, r) {
        t._writer.addPrefix(e, r)
      })), this
    }
  }
}, function(e, t, r) {
  (t = e.exports = r(104)).Stream = t, t.Readable = t, t.Writable = r(108), t.Duplex = r(32), t.Transform = r(110), t.PassThrough = r(210), t.finished = r(69), t.pipeline = r(211)
}, function(e, t, r) {
  (function(e) {
    function r(e) {
      return Object.prototype.toString.call(e)
    }
    t.isArray = function(e) {
      return Array.isArray ? Array.isArray(e) : "[object Array]" === r(e)
    }, t.isBoolean = function(e) {
      return "boolean" == typeof e
    }, t.isNull = function(e) {
      return null === e
    }, t.isNullOrUndefined = function(e) {
      return null == e
    }, t.isNumber = function(e) {
      return "number" == typeof e
    }, t.isString = function(e) {
      return "string" == typeof e
    }, t.isSymbol = function(e) {
      return "symbol" == typeof e
    }, t.isUndefined = function(e) {
      return void 0 === e
    }, t.isRegExp = function(e) {
      return "[object RegExp]" === r(e)
    }, t.isObject = function(e) {
      return "object" == typeof e && null !== e
    }, t.isDate = function(e) {
      return "[object Date]" === r(e)
    }, t.isError = function(e) {
      return "[object Error]" === r(e) || e instanceof Error
    }, t.isFunction = function(e) {
      return "function" == typeof e
    }, t.isPrimitive = function(e) {
      return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || void 0 === e
    }, t.isBuffer = e.isBuffer
  }).call(this, r(11).Buffer)
}, function(e, t, r) {
  (function(e) {
    var n = void 0 !== e && e || "undefined" != typeof self && self || window,
      i = Function.prototype.apply;

    function a(e, t) {
      this._id = e, this._clearFn = t
    }
    t.setTimeout = function() {
      return new a(i.call(setTimeout, n, arguments), clearTimeout)
    }, t.setInterval = function() {
      return new a(i.call(setInterval, n, arguments), clearInterval)
    }, t.clearTimeout = t.clearInterval = function(e) {
      e && e.close()
    }, a.prototype.unref = a.prototype.ref = function() {}, a.prototype.close = function() {
      this._clearFn.call(n, this._id)
    }, t.enroll = function(e, t) {
      clearTimeout(e._idleTimeoutId), e._idleTimeout = t
    }, t.unenroll = function(e) {
      clearTimeout(e._idleTimeoutId), e._idleTimeout = -1
    }, t._unrefActive = t.active = function(e) {
      clearTimeout(e._idleTimeoutId);
      var t = e._idleTimeout;
      t >= 0 && (e._idleTimeoutId = setTimeout((function() {
        e._onTimeout && e._onTimeout()
      }), t))
    }, r(222), t.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== e && e.setImmediate || this && this.setImmediate, t.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== e && e.clearImmediate || this && this.clearImmediate
  }).call(this, r(10))
}, function(e, t) {
  ! function(e) {
    ! function(t) {
      var r = "URLSearchParams" in e,
        n = "Symbol" in e && "iterator" in Symbol,
        i = "FileReader" in e && "Blob" in e && function() {
          try {
            return new Blob, !0
          } catch (e) {
            return !1
          }
        }(),
        a = "FormData" in e,
        s = "ArrayBuffer" in e;
      if (s) var o = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
        u = ArrayBuffer.isView || function(e) {
          return e && o.indexOf(Object.prototype.toString.call(e)) > -1
        };

      function c(e) {
        if ("string" != typeof e && (e = String(e)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(e)) throw new TypeError("Invalid character in header field name");
        return e.toLowerCase()
      }

      function l(e) {
        return "string" != typeof e && (e = String(e)), e
      }

      function h(e) {
        var t = {
          next: function() {
            var t = e.shift();
            return {
              done: void 0 === t,
              value: t
            }
          }
        };
        return n && (t[Symbol.iterator] = function() {
          return t
        }), t
      }

      function d(e) {
        this.map = {}, e instanceof d ? e.forEach((function(e, t) {
          this.append(t, e)
        }), this) : Array.isArray(e) ? e.forEach((function(e) {
          this.append(e[0], e[1])
        }), this) : e && Object.getOwnPropertyNames(e).forEach((function(t) {
          this.append(t, e[t])
        }), this)
      }

      function p(e) {
        if (e.bodyUsed) return Promise.reject(new TypeError("Already read"));
        e.bodyUsed = !0
      }

      function f(e) {
        return new Promise((function(t, r) {
          e.onload = function() {
            t(e.result)
          }, e.onerror = function() {
            r(e.error)
          }
        }))
      }

      function g(e) {
        var t = new FileReader,
          r = f(t);
        return t.readAsArrayBuffer(e), r
      }

      function m(e) {
        if (e.slice) return e.slice(0);
        var t = new Uint8Array(e.byteLength);
        return t.set(new Uint8Array(e)), t.buffer
      }

      function y() {
        return this.bodyUsed = !1, this._initBody = function(e) {
          var t;
          this._bodyInit = e, e ? "string" == typeof e ? this._bodyText = e : i && Blob.prototype.isPrototypeOf(e) ? this._bodyBlob = e : a && FormData.prototype.isPrototypeOf(e) ? this._bodyFormData = e : r && URLSearchParams.prototype.isPrototypeOf(e) ? this._bodyText = e.toString() : s && i && ((t = e) && DataView.prototype.isPrototypeOf(t)) ? (this._bodyArrayBuffer = m(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : s && (ArrayBuffer.prototype.isPrototypeOf(e) || u(e)) ? this._bodyArrayBuffer = m(e) : this._bodyText = e = Object.prototype.toString.call(e) : this._bodyText = "", this.headers.get("content-type") || ("string" == typeof e ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : r && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
        }, i && (this.blob = function() {
          var e = p(this);
          if (e) return e;
          if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData) throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]))
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? p(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(g)
        }), this.text = function() {
          var e, t, r, n = p(this);
          if (n) return n;
          if (this._bodyBlob) return e = this._bodyBlob, t = new FileReader, r = f(t), t.readAsText(e), r;
          if (this._bodyArrayBuffer) return Promise.resolve(function(e) {
            for (var t = new Uint8Array(e), r = new Array(t.length), n = 0; n < t.length; n++) r[n] = String.fromCharCode(t[n]);
            return r.join("")
          }(this._bodyArrayBuffer));
          if (this._bodyFormData) throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText)
        }, a && (this.formData = function() {
          return this.text().then(v)
        }), this.json = function() {
          return this.text().then(JSON.parse)
        }, this
      }
      d.prototype.append = function(e, t) {
        e = c(e), t = l(t);
        var r = this.map[e];
        this.map[e] = r ? r + ", " + t : t
      }, d.prototype.delete = function(e) {
        delete this.map[c(e)]
      }, d.prototype.get = function(e) {
        return e = c(e), this.has(e) ? this.map[e] : null
      }, d.prototype.has = function(e) {
        return this.map.hasOwnProperty(c(e))
      }, d.prototype.set = function(e, t) {
        this.map[c(e)] = l(t)
      }, d.prototype.forEach = function(e, t) {
        for (var r in this.map) this.map.hasOwnProperty(r) && e.call(t, this.map[r], r, this)
      }, d.prototype.keys = function() {
        var e = [];
        return this.forEach((function(t, r) {
          e.push(r)
        })), h(e)
      }, d.prototype.values = function() {
        var e = [];
        return this.forEach((function(t) {
          e.push(t)
        })), h(e)
      }, d.prototype.entries = function() {
        var e = [];
        return this.forEach((function(t, r) {
          e.push([r, t])
        })), h(e)
      }, n && (d.prototype[Symbol.iterator] = d.prototype.entries);
      var b = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

      function _(e, t) {
        var r, n, i = (t = t || {}).body;
        if (e instanceof _) {
          if (e.bodyUsed) throw new TypeError("Already read");
          this.url = e.url, this.credentials = e.credentials, t.headers || (this.headers = new d(e.headers)), this.method = e.method, this.mode = e.mode, this.signal = e.signal, i || null == e._bodyInit || (i = e._bodyInit, e.bodyUsed = !0)
        } else this.url = String(e);
        if (this.credentials = t.credentials || this.credentials || "same-origin", !t.headers && this.headers || (this.headers = new d(t.headers)), this.method = (r = t.method || this.method || "GET", n = r.toUpperCase(), b.indexOf(n) > -1 ? n : r), this.mode = t.mode || this.mode || null, this.signal = t.signal || this.signal, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && i) throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(i)
      }

      function v(e) {
        var t = new FormData;
        return e.trim().split("&").forEach((function(e) {
          if (e) {
            var r = e.split("="),
              n = r.shift().replace(/\+/g, " "),
              i = r.join("=").replace(/\+/g, " ");
            t.append(decodeURIComponent(n), decodeURIComponent(i))
          }
        })), t
      }

      function w(e, t) {
        t || (t = {}), this.type = "default", this.status = void 0 === t.status ? 200 : t.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in t ? t.statusText : "OK", this.headers = new d(t.headers), this.url = t.url || "", this._initBody(e)
      }
      _.prototype.clone = function() {
        return new _(this, {
          body: this._bodyInit
        })
      }, y.call(_.prototype), y.call(w.prototype), w.prototype.clone = function() {
        return new w(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new d(this.headers),
          url: this.url
        })
      }, w.error = function() {
        var e = new w(null, {
          status: 0,
          statusText: ""
        });
        return e.type = "error", e
      };
      var S = [301, 302, 303, 307, 308];
      w.redirect = function(e, t) {
        if (-1 === S.indexOf(t)) throw new RangeError("Invalid status code");
        return new w(null, {
          status: t,
          headers: {
            location: e
          }
        })
      }, t.DOMException = e.DOMException;
      try {
        new t.DOMException
      } catch (e) {
        t.DOMException = function(e, t) {
          this.message = e, this.name = t;
          var r = Error(e);
          this.stack = r.stack
        }, t.DOMException.prototype = Object.create(Error.prototype), t.DOMException.prototype.constructor = t.DOMException
      }

      function T(e, r) {
        return new Promise((function(n, a) {
          var s = new _(e, r);
          if (s.signal && s.signal.aborted) return a(new t.DOMException("Aborted", "AbortError"));
          var o = new XMLHttpRequest;

          function u() {
            o.abort()
          }
          o.onload = function() {
            var e, t, r = {
              status: o.status,
              statusText: o.statusText,
              headers: (e = o.getAllResponseHeaders() || "", t = new d, e.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach((function(e) {
                var r = e.split(":"),
                  n = r.shift().trim();
                if (n) {
                  var i = r.join(":").trim();
                  t.append(n, i)
                }
              })), t)
            };
            r.url = "responseURL" in o ? o.responseURL : r.headers.get("X-Request-URL");
            var i = "response" in o ? o.response : o.responseText;
            n(new w(i, r))
          }, o.onerror = function() {
            a(new TypeError("Network request failed"))
          }, o.ontimeout = function() {
            a(new TypeError("Network request failed"))
          }, o.onabort = function() {
            a(new t.DOMException("Aborted", "AbortError"))
          }, o.open(s.method, s.url, !0), "include" === s.credentials ? o.withCredentials = !0 : "omit" === s.credentials && (o.withCredentials = !1), "responseType" in o && i && (o.responseType = "blob"), s.headers.forEach((function(e, t) {
            o.setRequestHeader(t, e)
          })), s.signal && (s.signal.addEventListener("abort", u), o.onreadystatechange = function() {
            4 === o.readyState && s.signal.removeEventListener("abort", u)
          }), o.send(void 0 === s._bodyInit ? null : s._bodyInit)
        }))
      }
      T.polyfill = !0, e.fetch || (e.fetch = T, e.Headers = d, e.Request = _, e.Response = w), t.Headers = d, t.Request = _, t.Response = w, t.fetch = T
    }({})
  }("undefined" != typeof self ? self : this)
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(273), t), i(r(274), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ERROR_CODES = t.ErrorCoded = void 0;
  class n extends Error {
    constructor(e, t) {
      super(e), this.code = t
    }
  }
  t.ErrorCoded = n,
    function(e) {
      e.COLLIDING_KEYWORDS = "colliding keywords", e.CONFLICTING_INDEXES = "conflicting indexes", e.CYCLIC_IRI_MAPPING = "cyclic IRI mapping", e.INVALID_ID_VALUE = "invalid @id value", e.INVALID_INDEX_VALUE = "invalid @index value", e.INVALID_NEST_VALUE = "invalid @nest value", e.INVALID_PREFIX_VALUE = "invalid @prefix value", e.INVALID_PROPAGATE_VALUE = "invalid @propagate value", e.INVALID_REVERSE_VALUE = "invalid @reverse value", e.INVALID_IMPORT_VALUE = "invalid @import value", e.INVALID_VERSION_VALUE = "invalid @version value", e.INVALID_BASE_IRI = "invalid base IRI", e.INVALID_CONTAINER_MAPPING = "invalid container mapping", e.INVALID_CONTEXT_ENTRY = "invalid context entry", e.INVALID_CONTEXT_NULLIFICATION = "invalid context nullification", e.INVALID_DEFAULT_LANGUAGE = "invalid default language", e.INVALID_INCLUDED_VALUE = "invalid @included value", e.INVALID_IRI_MAPPING = "invalid IRI mapping", e.INVALID_JSON_LITERAL = "invalid JSON literal", e.INVALID_KEYWORD_ALIAS = "invalid keyword alias", e.INVALID_LANGUAGE_MAP_VALUE = "invalid language map value", e.INVALID_LANGUAGE_MAPPING = "invalid language mapping", e.INVALID_LANGUAGE_TAGGED_STRING = "invalid language-tagged string", e.INVALID_LANGUAGE_TAGGED_VALUE = "invalid language-tagged value", e.INVALID_LOCAL_CONTEXT = "invalid local context", e.INVALID_REMOTE_CONTEXT = "invalid remote context", e.INVALID_REVERSE_PROPERTY = "invalid reverse property", e.INVALID_REVERSE_PROPERTY_MAP = "invalid reverse property map", e.INVALID_REVERSE_PROPERTY_VALUE = "invalid reverse property value", e.INVALID_SCOPED_CONTEXT = "invalid scoped context", e.INVALID_SCRIPT_ELEMENT = "invalid script element", e.INVALID_SET_OR_LIST_OBJECT = "invalid set or list object", e.INVALID_TERM_DEFINITION = "invalid term definition", e.INVALID_TYPE_MAPPING = "invalid type mapping", e.INVALID_TYPE_VALUE = "invalid type value", e.INVALID_TYPED_VALUE = "invalid typed value", e.INVALID_VALUE_OBJECT = "invalid value object", e.INVALID_VALUE_OBJECT_VALUE = "invalid value object value", e.INVALID_VOCAB_MAPPING = "invalid vocab mapping", e.IRI_CONFUSED_WITH_PREFIX = "IRI confused with prefix", e.KEYWORD_REDEFINITION = "keyword redefinition", e.LOADING_DOCUMENT_FAILED = "loading document failed", e.LOADING_REMOTE_CONTEXT_FAILED = "loading remote context failed", e.MULTIPLE_CONTEXT_LINK_HEADERS = "multiple context link headers", e.PROCESSING_MODE_CONFLICT = "processing mode conflict", e.PROTECTED_TERM_REDEFINITION = "protected term redefinition", e.CONTEXT_OVERFLOW = "context overflow", e.INVALID_BASE_DIRECTION = "invalid base direction", e.RECURSIVE_CONTEXT_INCLUSION = "recursive context inclusion", e.INVALID_STREAMING_KEY_ORDER = "invalid streaming key order"
    }(t.ERROR_CODES || (t.ERROR_CODES = {}))
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.SingularizeState = void 0,
    function(e) {
      e[e.SINGLE = 0] = "SINGLE", e[e.PLURAL = 1] = "PLURAL"
    }(t.SingularizeState || (t.SingularizeState = {}))
}, function(e, t) {
  function r(e, t) {
    if (!e) throw new Error(t || "Assertion failed")
  }
  e.exports = r, r.equal = function(e, t, r) {
    if (e != t) throw new Error(r || "Assertion failed: " + e + " != " + t)
  }
}, function(e, t, r) {
  "use strict";
  var n = r(19),
    i = r(49);

  function a() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32
  }
  t.BlockHash = a, a.prototype.update = function(e, t) {
    if (e = n.toArray(e, t), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
      var r = (e = this.pending).length % this._delta8;
      this.pending = e.slice(e.length - r, e.length), 0 === this.pending.length && (this.pending = null), e = n.join32(e, 0, e.length - r, this.endian);
      for (var i = 0; i < e.length; i += this._delta32) this._update(e, i, i + this._delta32)
    }
    return this
  }, a.prototype.digest = function(e) {
    return this.update(this._pad()), i(null === this.pending), this._digest(e)
  }, a.prototype._pad = function() {
    var e = this.pendingTotal,
      t = this._delta8,
      r = t - (e + this.padLength) % t,
      n = new Array(r + this.padLength);
    n[0] = 128;
    for (var i = 1; i < r; i++) n[i] = 0;
    if (e <<= 3, "big" === this.endian) {
      for (var a = 8; a < this.padLength; a++) n[i++] = 0;
      n[i++] = 0, n[i++] = 0, n[i++] = 0, n[i++] = 0, n[i++] = e >>> 24 & 255, n[i++] = e >>> 16 & 255, n[i++] = e >>> 8 & 255, n[i++] = 255 & e
    } else
      for (n[i++] = 255 & e, n[i++] = e >>> 8 & 255, n[i++] = e >>> 16 & 255, n[i++] = e >>> 24 & 255, n[i++] = 0, n[i++] = 0, n[i++] = 0, n[i++] = 0, a = 8; a < this.padLength; a++) n[i++] = 0;
    return n
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.orderTypes = t.isExpressionError = t.ExpressionError = t.AggregateEvaluator = t.SyncEvaluator = t.AsyncEvaluator = void 0;
  var n = r(525);
  Object.defineProperty(t, "AsyncEvaluator", {
    enumerable: !0,
    get: function() {
      return n.AsyncEvaluator
    }
  });
  var i = r(186);
  Object.defineProperty(t, "SyncEvaluator", {
    enumerable: !0,
    get: function() {
      return i.SyncEvaluator
    }
  });
  var a = r(539);
  Object.defineProperty(t, "AggregateEvaluator", {
    enumerable: !0,
    get: function() {
      return a.AggregateEvaluator
    }
  });
  var s = r(20);
  Object.defineProperty(t, "ExpressionError", {
    enumerable: !0,
    get: function() {
      return s.ExpressionError
    }
  }), Object.defineProperty(t, "isExpressionError", {
    enumerable: !0,
    get: function() {
      return s.isExpressionError
    }
  });
  var o = r(540);
  Object.defineProperty(t, "orderTypes", {
    enumerable: !0,
    get: function() {
      return o.orderTypes
    }
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.expressionTypes = t.types = void 0, t.types = Object.freeze({
    ALT: "alt",
    ASK: "ask",
    BGP: "bgp",
    CONSTRUCT: "construct",
    DESC: "desc",
    DESCRIBE: "describe",
    DISTINCT: "distinct",
    EXPRESSION: "expression",
    EXTEND: "extend",
    FILTER: "filter",
    FROM: "from",
    GRAPH: "graph",
    GROUP: "group",
    INV: "inv",
    JOIN: "join",
    LEFT_JOIN: "leftjoin",
    LINK: "link",
    MINUS: "minus",
    NPS: "nps",
    ONE_OR_MORE_PATH: "OneOrMorePath",
    ORDER_BY: "orderby",
    PATH: "path",
    PATTERN: "pattern",
    PROJECT: "project",
    REDUCED: "reduced",
    SEQ: "seq",
    SERVICE: "service",
    SLICE: "slice",
    UNION: "union",
    VALUES: "values",
    ZERO_OR_MORE_PATH: "ZeroOrMorePath",
    ZERO_OR_ONE_PATH: "ZeroOrOnePath",
    COMPOSITE_UPDATE: "compositeupdate",
    DELETE_INSERT: "deleteinsert",
    LOAD: "load",
    CLEAR: "clear",
    CREATE: "create",
    DROP: "drop",
    ADD: "add",
    MOVE: "move",
    COPY: "copy"
  }), t.expressionTypes = Object.freeze({
    AGGREGATE: "aggregate",
    EXISTENCE: "existence",
    NAMED: "named",
    OPERATOR: "operator",
    TERM: "term",
    WILDCARD: "wildcard"
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  const n = r(5),
    i = r(4),
    a = r(30).Wildcard;
  t.default = class {
    constructor(e) {
      this.dataFactory = e || new n.DataFactory, this.stringType = this.createTerm("http://www.w3.org/2001/XMLSchema#string")
    }
    createAlt(e, t) {
      return {
        type: "alt",
        left: e,
        right: t
      }
    }
    createAsk(e) {
      return {
        type: "ask",
        input: e
      }
    }
    createBoundAggregate(e, t, r, n, i) {
      let a = this.createAggregateExpression(t, r, n, i);
      return a.variable = e, a
    }
    createBgp(e) {
      return {
        type: "bgp",
        patterns: e
      }
    }
    createConstruct(e, t) {
      return {
        type: "construct",
        input: e,
        template: t
      }
    }
    createDescribe(e, t) {
      return {
        type: "describe",
        input: e,
        terms: t
      }
    }
    createDistinct(e) {
      return {
        type: "distinct",
        input: e
      }
    }
    createExtend(e, t, r) {
      return {
        type: "extend",
        input: e,
        variable: t,
        expression: r
      }
    }
    createFrom(e, t, r) {
      return {
        type: "from",
        input: e,
        default: t,
        named: r
      }
    }
    createFilter(e, t) {
      return {
        type: "filter",
        input: e,
        expression: t
      }
    }
    createGraph(e, t) {
      return {
        type: "graph",
        input: e,
        name: t
      }
    }
    createGroup(e, t, r) {
      return {
        type: "group",
        input: e,
        variables: t,
        aggregates: r
      }
    }
    createInv(e) {
      return {
        type: "inv",
        path: e
      }
    }
    createJoin(e, t) {
      return {
        type: "join",
        left: e,
        right: t
      }
    }
    createLeftJoin(e, t, r) {
      return r ? {
        type: "leftjoin",
        left: e,
        right: t,
        expression: r
      } : {
        type: "leftjoin",
        left: e,
        right: t
      }
    }
    createLink(e) {
      return {
        type: "link",
        iri: e
      }
    }
    createMinus(e, t) {
      return {
        type: "minus",
        left: e,
        right: t
      }
    }
    createNps(e) {
      return {
        type: "nps",
        iris: e
      }
    }
    createOneOrMorePath(e) {
      return {
        type: "OneOrMorePath",
        path: e
      }
    }
    createOrderBy(e, t) {
      return {
        type: "orderby",
        input: e,
        expressions: t
      }
    }
    createPath(e, t, r, n) {
      return n ? {
        type: "path",
        subject: e,
        predicate: t,
        object: r,
        graph: n
      } : {
        type: "path",
        subject: e,
        predicate: t,
        object: r,
        graph: this.dataFactory.defaultGraph()
      }
    }
    createPattern(e, t, r, n) {
      let i = this.dataFactory.quad(e, t, r, n);
      return i.type = "pattern", i
    }
    createProject(e, t) {
      return {
        type: "project",
        input: e,
        variables: t
      }
    }
    createReduced(e) {
      return {
        type: "reduced",
        input: e
      }
    }
    createSeq(e, t) {
      return {
        type: "seq",
        left: e,
        right: t
      }
    }
    createService(e, t, r) {
      return {
        type: "service",
        input: e,
        name: t,
        silent: r
      }
    }
    createSlice(e, t, r) {
      return void 0 === t && (t = 0), void 0 !== r ? {
        type: "slice",
        input: e,
        start: t,
        length: r
      } : {
        type: "slice",
        input: e,
        start: t
      }
    }
    createUnion(e, t) {
      return {
        type: "union",
        left: e,
        right: t
      }
    }
    createValues(e, t) {
      return {
        type: "values",
        variables: e,
        bindings: t
      }
    }
    createZeroOrMorePath(e) {
      return {
        type: "ZeroOrMorePath",
        path: e
      }
    }
    createZeroOrOnePath(e) {
      return {
        type: "ZeroOrOnePath",
        path: e
      }
    }
    createAggregateExpression(e, t, r, n) {
      return n ? {
        type: "expression",
        expressionType: "aggregate",
        aggregator: e,
        expression: t,
        separator: n,
        distinct: r
      } : {
        type: "expression",
        expressionType: "aggregate",
        aggregator: e,
        expression: t,
        distinct: r
      }
    }
    createExistenceExpression(e, t) {
      return {
        type: "expression",
        expressionType: "existence",
        not: e,
        input: t
      }
    }
    createNamedExpression(e, t) {
      return {
        type: "expression",
        expressionType: "named",
        name: e,
        args: t
      }
    }
    createOperatorExpression(e, t) {
      return {
        type: "expression",
        expressionType: "operator",
        operator: e,
        args: t
      }
    }
    createTermExpression(e) {
      return {
        type: "expression",
        expressionType: "term",
        term: e
      }
    }
    createWildcardExpression() {
      return {
        type: "expression",
        expressionType: "wildcard",
        wildcard: new a
      }
    }
    createTerm(e) {
      return i.stringToTerm(e, this.dataFactory)
    }
    createCompositeUpdate(e) {
      return {
        type: "compositeupdate",
        updates: e
      }
    }
    createDeleteInsert(e, t, r) {
      const n = {
        type: "deleteinsert"
      };
      return e && (n.delete = e), t && (n.insert = t), r && (n.where = r), n
    }
    createLoad(e, t, r) {
      const n = {
        type: "load",
        source: e
      };
      return t && (n.destination = t), this.addSilent(n, r)
    }
    createClear(e, t) {
      return this.addSilent({
        type: "clear",
        source: e
      }, t)
    }
    createCreate(e, t) {
      return this.addSilent({
        type: "create",
        source: e
      }, t)
    }
    createDrop(e, t) {
      return this.addSilent({
        type: "drop",
        source: e
      }, t)
    }
    createAdd(e, t, r) {
      return this.addSilent({
        type: "add",
        source: e,
        destination: t
      }, r)
    }
    createMove(e, t, r) {
      return this.addSilent({
        type: "move",
        source: e,
        destination: t
      }, r)
    }
    createCopy(e, t, r) {
      return this.addSilent({
        type: "copy",
        source: e,
        destination: t
      }, r)
    }
    addSilent(e, t) {
      return t && (e.silent = t), e
    }
  }
}, function(e, t, r) {
  "use strict";
  (function(t) {
    void 0 === t || !t.version || 0 === t.version.indexOf("v0.") || 0 === t.version.indexOf("v1.") && 0 !== t.version.indexOf("v1.8.") ? e.exports = {
      nextTick: function(e, r, n, i) {
        if ("function" != typeof e) throw new TypeError('"callback" argument must be a function');
        var a, s, o = arguments.length;
        switch (o) {
          case 0:
          case 1:
            return t.nextTick(e);
          case 2:
            return t.nextTick((function() {
              e.call(null, r)
            }));
          case 3:
            return t.nextTick((function() {
              e.call(null, r, n)
            }));
          case 4:
            return t.nextTick((function() {
              e.call(null, r, n, i)
            }));
          default:
            for (a = new Array(o - 1), s = 0; s < a.length;) a[s++] = arguments[s];
            return t.nextTick((function() {
              e.apply(null, a)
            }))
        }
      }
    } : e.exports = t
  }).call(this, r(8))
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(262), t)
}, function(e) {
  e.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Abreve":"Ă","abreve":"ă","ac":"∾","acd":"∿","acE":"∾̳","Acirc":"Â","acirc":"â","acute":"´","Acy":"А","acy":"а","AElig":"Æ","aelig":"æ","af":"⁡","Afr":"𝔄","afr":"𝔞","Agrave":"À","agrave":"à","alefsym":"ℵ","aleph":"ℵ","Alpha":"Α","alpha":"α","Amacr":"Ā","amacr":"ā","amalg":"⨿","amp":"&","AMP":"&","andand":"⩕","And":"⩓","and":"∧","andd":"⩜","andslope":"⩘","andv":"⩚","ang":"∠","ange":"⦤","angle":"∠","angmsdaa":"⦨","angmsdab":"⦩","angmsdac":"⦪","angmsdad":"⦫","angmsdae":"⦬","angmsdaf":"⦭","angmsdag":"⦮","angmsdah":"⦯","angmsd":"∡","angrt":"∟","angrtvb":"⊾","angrtvbd":"⦝","angsph":"∢","angst":"Å","angzarr":"⍼","Aogon":"Ą","aogon":"ą","Aopf":"𝔸","aopf":"𝕒","apacir":"⩯","ap":"≈","apE":"⩰","ape":"≊","apid":"≋","apos":"\'","ApplyFunction":"⁡","approx":"≈","approxeq":"≊","Aring":"Å","aring":"å","Ascr":"𝒜","ascr":"𝒶","Assign":"≔","ast":"*","asymp":"≈","asympeq":"≍","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","awconint":"∳","awint":"⨑","backcong":"≌","backepsilon":"϶","backprime":"‵","backsim":"∽","backsimeq":"⋍","Backslash":"∖","Barv":"⫧","barvee":"⊽","barwed":"⌅","Barwed":"⌆","barwedge":"⌅","bbrk":"⎵","bbrktbrk":"⎶","bcong":"≌","Bcy":"Б","bcy":"б","bdquo":"„","becaus":"∵","because":"∵","Because":"∵","bemptyv":"⦰","bepsi":"϶","bernou":"ℬ","Bernoullis":"ℬ","Beta":"Β","beta":"β","beth":"ℶ","between":"≬","Bfr":"𝔅","bfr":"𝔟","bigcap":"⋂","bigcirc":"◯","bigcup":"⋃","bigodot":"⨀","bigoplus":"⨁","bigotimes":"⨂","bigsqcup":"⨆","bigstar":"★","bigtriangledown":"▽","bigtriangleup":"△","biguplus":"⨄","bigvee":"⋁","bigwedge":"⋀","bkarow":"⤍","blacklozenge":"⧫","blacksquare":"▪","blacktriangle":"▴","blacktriangledown":"▾","blacktriangleleft":"◂","blacktriangleright":"▸","blank":"␣","blk12":"▒","blk14":"░","blk34":"▓","block":"█","bne":"=⃥","bnequiv":"≡⃥","bNot":"⫭","bnot":"⌐","Bopf":"𝔹","bopf":"𝕓","bot":"⊥","bottom":"⊥","bowtie":"⋈","boxbox":"⧉","boxdl":"┐","boxdL":"╕","boxDl":"╖","boxDL":"╗","boxdr":"┌","boxdR":"╒","boxDr":"╓","boxDR":"╔","boxh":"─","boxH":"═","boxhd":"┬","boxHd":"╤","boxhD":"╥","boxHD":"╦","boxhu":"┴","boxHu":"╧","boxhU":"╨","boxHU":"╩","boxminus":"⊟","boxplus":"⊞","boxtimes":"⊠","boxul":"┘","boxuL":"╛","boxUl":"╜","boxUL":"╝","boxur":"└","boxuR":"╘","boxUr":"╙","boxUR":"╚","boxv":"│","boxV":"║","boxvh":"┼","boxvH":"╪","boxVh":"╫","boxVH":"╬","boxvl":"┤","boxvL":"╡","boxVl":"╢","boxVL":"╣","boxvr":"├","boxvR":"╞","boxVr":"╟","boxVR":"╠","bprime":"‵","breve":"˘","Breve":"˘","brvbar":"¦","bscr":"𝒷","Bscr":"ℬ","bsemi":"⁏","bsim":"∽","bsime":"⋍","bsolb":"⧅","bsol":"\\\\","bsolhsub":"⟈","bull":"•","bullet":"•","bump":"≎","bumpE":"⪮","bumpe":"≏","Bumpeq":"≎","bumpeq":"≏","Cacute":"Ć","cacute":"ć","capand":"⩄","capbrcup":"⩉","capcap":"⩋","cap":"∩","Cap":"⋒","capcup":"⩇","capdot":"⩀","CapitalDifferentialD":"ⅅ","caps":"∩︀","caret":"⁁","caron":"ˇ","Cayleys":"ℭ","ccaps":"⩍","Ccaron":"Č","ccaron":"č","Ccedil":"Ç","ccedil":"ç","Ccirc":"Ĉ","ccirc":"ĉ","Cconint":"∰","ccups":"⩌","ccupssm":"⩐","Cdot":"Ċ","cdot":"ċ","cedil":"¸","Cedilla":"¸","cemptyv":"⦲","cent":"¢","centerdot":"·","CenterDot":"·","cfr":"𝔠","Cfr":"ℭ","CHcy":"Ч","chcy":"ч","check":"✓","checkmark":"✓","Chi":"Χ","chi":"χ","circ":"ˆ","circeq":"≗","circlearrowleft":"↺","circlearrowright":"↻","circledast":"⊛","circledcirc":"⊚","circleddash":"⊝","CircleDot":"⊙","circledR":"®","circledS":"Ⓢ","CircleMinus":"⊖","CirclePlus":"⊕","CircleTimes":"⊗","cir":"○","cirE":"⧃","cire":"≗","cirfnint":"⨐","cirmid":"⫯","cirscir":"⧂","ClockwiseContourIntegral":"∲","CloseCurlyDoubleQuote":"”","CloseCurlyQuote":"’","clubs":"♣","clubsuit":"♣","colon":":","Colon":"∷","Colone":"⩴","colone":"≔","coloneq":"≔","comma":",","commat":"@","comp":"∁","compfn":"∘","complement":"∁","complexes":"ℂ","cong":"≅","congdot":"⩭","Congruent":"≡","conint":"∮","Conint":"∯","ContourIntegral":"∮","copf":"𝕔","Copf":"ℂ","coprod":"∐","Coproduct":"∐","copy":"©","COPY":"©","copysr":"℗","CounterClockwiseContourIntegral":"∳","crarr":"↵","cross":"✗","Cross":"⨯","Cscr":"𝒞","cscr":"𝒸","csub":"⫏","csube":"⫑","csup":"⫐","csupe":"⫒","ctdot":"⋯","cudarrl":"⤸","cudarrr":"⤵","cuepr":"⋞","cuesc":"⋟","cularr":"↶","cularrp":"⤽","cupbrcap":"⩈","cupcap":"⩆","CupCap":"≍","cup":"∪","Cup":"⋓","cupcup":"⩊","cupdot":"⊍","cupor":"⩅","cups":"∪︀","curarr":"↷","curarrm":"⤼","curlyeqprec":"⋞","curlyeqsucc":"⋟","curlyvee":"⋎","curlywedge":"⋏","curren":"¤","curvearrowleft":"↶","curvearrowright":"↷","cuvee":"⋎","cuwed":"⋏","cwconint":"∲","cwint":"∱","cylcty":"⌭","dagger":"†","Dagger":"‡","daleth":"ℸ","darr":"↓","Darr":"↡","dArr":"⇓","dash":"‐","Dashv":"⫤","dashv":"⊣","dbkarow":"⤏","dblac":"˝","Dcaron":"Ď","dcaron":"ď","Dcy":"Д","dcy":"д","ddagger":"‡","ddarr":"⇊","DD":"ⅅ","dd":"ⅆ","DDotrahd":"⤑","ddotseq":"⩷","deg":"°","Del":"∇","Delta":"Δ","delta":"δ","demptyv":"⦱","dfisht":"⥿","Dfr":"𝔇","dfr":"𝔡","dHar":"⥥","dharl":"⇃","dharr":"⇂","DiacriticalAcute":"´","DiacriticalDot":"˙","DiacriticalDoubleAcute":"˝","DiacriticalGrave":"`","DiacriticalTilde":"˜","diam":"⋄","diamond":"⋄","Diamond":"⋄","diamondsuit":"♦","diams":"♦","die":"¨","DifferentialD":"ⅆ","digamma":"ϝ","disin":"⋲","div":"÷","divide":"÷","divideontimes":"⋇","divonx":"⋇","DJcy":"Ђ","djcy":"ђ","dlcorn":"⌞","dlcrop":"⌍","dollar":"$","Dopf":"𝔻","dopf":"𝕕","Dot":"¨","dot":"˙","DotDot":"⃜","doteq":"≐","doteqdot":"≑","DotEqual":"≐","dotminus":"∸","dotplus":"∔","dotsquare":"⊡","doublebarwedge":"⌆","DoubleContourIntegral":"∯","DoubleDot":"¨","DoubleDownArrow":"⇓","DoubleLeftArrow":"⇐","DoubleLeftRightArrow":"⇔","DoubleLeftTee":"⫤","DoubleLongLeftArrow":"⟸","DoubleLongLeftRightArrow":"⟺","DoubleLongRightArrow":"⟹","DoubleRightArrow":"⇒","DoubleRightTee":"⊨","DoubleUpArrow":"⇑","DoubleUpDownArrow":"⇕","DoubleVerticalBar":"∥","DownArrowBar":"⤓","downarrow":"↓","DownArrow":"↓","Downarrow":"⇓","DownArrowUpArrow":"⇵","DownBreve":"̑","downdownarrows":"⇊","downharpoonleft":"⇃","downharpoonright":"⇂","DownLeftRightVector":"⥐","DownLeftTeeVector":"⥞","DownLeftVectorBar":"⥖","DownLeftVector":"↽","DownRightTeeVector":"⥟","DownRightVectorBar":"⥗","DownRightVector":"⇁","DownTeeArrow":"↧","DownTee":"⊤","drbkarow":"⤐","drcorn":"⌟","drcrop":"⌌","Dscr":"𝒟","dscr":"𝒹","DScy":"Ѕ","dscy":"ѕ","dsol":"⧶","Dstrok":"Đ","dstrok":"đ","dtdot":"⋱","dtri":"▿","dtrif":"▾","duarr":"⇵","duhar":"⥯","dwangle":"⦦","DZcy":"Џ","dzcy":"џ","dzigrarr":"⟿","Eacute":"É","eacute":"é","easter":"⩮","Ecaron":"Ě","ecaron":"ě","Ecirc":"Ê","ecirc":"ê","ecir":"≖","ecolon":"≕","Ecy":"Э","ecy":"э","eDDot":"⩷","Edot":"Ė","edot":"ė","eDot":"≑","ee":"ⅇ","efDot":"≒","Efr":"𝔈","efr":"𝔢","eg":"⪚","Egrave":"È","egrave":"è","egs":"⪖","egsdot":"⪘","el":"⪙","Element":"∈","elinters":"⏧","ell":"ℓ","els":"⪕","elsdot":"⪗","Emacr":"Ē","emacr":"ē","empty":"∅","emptyset":"∅","EmptySmallSquare":"◻","emptyv":"∅","EmptyVerySmallSquare":"▫","emsp13":" ","emsp14":" ","emsp":" ","ENG":"Ŋ","eng":"ŋ","ensp":" ","Eogon":"Ę","eogon":"ę","Eopf":"𝔼","eopf":"𝕖","epar":"⋕","eparsl":"⧣","eplus":"⩱","epsi":"ε","Epsilon":"Ε","epsilon":"ε","epsiv":"ϵ","eqcirc":"≖","eqcolon":"≕","eqsim":"≂","eqslantgtr":"⪖","eqslantless":"⪕","Equal":"⩵","equals":"=","EqualTilde":"≂","equest":"≟","Equilibrium":"⇌","equiv":"≡","equivDD":"⩸","eqvparsl":"⧥","erarr":"⥱","erDot":"≓","escr":"ℯ","Escr":"ℰ","esdot":"≐","Esim":"⩳","esim":"≂","Eta":"Η","eta":"η","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","euro":"€","excl":"!","exist":"∃","Exists":"∃","expectation":"ℰ","exponentiale":"ⅇ","ExponentialE":"ⅇ","fallingdotseq":"≒","Fcy":"Ф","fcy":"ф","female":"♀","ffilig":"ﬃ","fflig":"ﬀ","ffllig":"ﬄ","Ffr":"𝔉","ffr":"𝔣","filig":"ﬁ","FilledSmallSquare":"◼","FilledVerySmallSquare":"▪","fjlig":"fj","flat":"♭","fllig":"ﬂ","fltns":"▱","fnof":"ƒ","Fopf":"𝔽","fopf":"𝕗","forall":"∀","ForAll":"∀","fork":"⋔","forkv":"⫙","Fouriertrf":"ℱ","fpartint":"⨍","frac12":"½","frac13":"⅓","frac14":"¼","frac15":"⅕","frac16":"⅙","frac18":"⅛","frac23":"⅔","frac25":"⅖","frac34":"¾","frac35":"⅗","frac38":"⅜","frac45":"⅘","frac56":"⅚","frac58":"⅝","frac78":"⅞","frasl":"⁄","frown":"⌢","fscr":"𝒻","Fscr":"ℱ","gacute":"ǵ","Gamma":"Γ","gamma":"γ","Gammad":"Ϝ","gammad":"ϝ","gap":"⪆","Gbreve":"Ğ","gbreve":"ğ","Gcedil":"Ģ","Gcirc":"Ĝ","gcirc":"ĝ","Gcy":"Г","gcy":"г","Gdot":"Ġ","gdot":"ġ","ge":"≥","gE":"≧","gEl":"⪌","gel":"⋛","geq":"≥","geqq":"≧","geqslant":"⩾","gescc":"⪩","ges":"⩾","gesdot":"⪀","gesdoto":"⪂","gesdotol":"⪄","gesl":"⋛︀","gesles":"⪔","Gfr":"𝔊","gfr":"𝔤","gg":"≫","Gg":"⋙","ggg":"⋙","gimel":"ℷ","GJcy":"Ѓ","gjcy":"ѓ","gla":"⪥","gl":"≷","glE":"⪒","glj":"⪤","gnap":"⪊","gnapprox":"⪊","gne":"⪈","gnE":"≩","gneq":"⪈","gneqq":"≩","gnsim":"⋧","Gopf":"𝔾","gopf":"𝕘","grave":"`","GreaterEqual":"≥","GreaterEqualLess":"⋛","GreaterFullEqual":"≧","GreaterGreater":"⪢","GreaterLess":"≷","GreaterSlantEqual":"⩾","GreaterTilde":"≳","Gscr":"𝒢","gscr":"ℊ","gsim":"≳","gsime":"⪎","gsiml":"⪐","gtcc":"⪧","gtcir":"⩺","gt":">","GT":">","Gt":"≫","gtdot":"⋗","gtlPar":"⦕","gtquest":"⩼","gtrapprox":"⪆","gtrarr":"⥸","gtrdot":"⋗","gtreqless":"⋛","gtreqqless":"⪌","gtrless":"≷","gtrsim":"≳","gvertneqq":"≩︀","gvnE":"≩︀","Hacek":"ˇ","hairsp":" ","half":"½","hamilt":"ℋ","HARDcy":"Ъ","hardcy":"ъ","harrcir":"⥈","harr":"↔","hArr":"⇔","harrw":"↭","Hat":"^","hbar":"ℏ","Hcirc":"Ĥ","hcirc":"ĥ","hearts":"♥","heartsuit":"♥","hellip":"…","hercon":"⊹","hfr":"𝔥","Hfr":"ℌ","HilbertSpace":"ℋ","hksearow":"⤥","hkswarow":"⤦","hoarr":"⇿","homtht":"∻","hookleftarrow":"↩","hookrightarrow":"↪","hopf":"𝕙","Hopf":"ℍ","horbar":"―","HorizontalLine":"─","hscr":"𝒽","Hscr":"ℋ","hslash":"ℏ","Hstrok":"Ħ","hstrok":"ħ","HumpDownHump":"≎","HumpEqual":"≏","hybull":"⁃","hyphen":"‐","Iacute":"Í","iacute":"í","ic":"⁣","Icirc":"Î","icirc":"î","Icy":"И","icy":"и","Idot":"İ","IEcy":"Е","iecy":"е","iexcl":"¡","iff":"⇔","ifr":"𝔦","Ifr":"ℑ","Igrave":"Ì","igrave":"ì","ii":"ⅈ","iiiint":"⨌","iiint":"∭","iinfin":"⧜","iiota":"℩","IJlig":"Ĳ","ijlig":"ĳ","Imacr":"Ī","imacr":"ī","image":"ℑ","ImaginaryI":"ⅈ","imagline":"ℐ","imagpart":"ℑ","imath":"ı","Im":"ℑ","imof":"⊷","imped":"Ƶ","Implies":"⇒","incare":"℅","in":"∈","infin":"∞","infintie":"⧝","inodot":"ı","intcal":"⊺","int":"∫","Int":"∬","integers":"ℤ","Integral":"∫","intercal":"⊺","Intersection":"⋂","intlarhk":"⨗","intprod":"⨼","InvisibleComma":"⁣","InvisibleTimes":"⁢","IOcy":"Ё","iocy":"ё","Iogon":"Į","iogon":"į","Iopf":"𝕀","iopf":"𝕚","Iota":"Ι","iota":"ι","iprod":"⨼","iquest":"¿","iscr":"𝒾","Iscr":"ℐ","isin":"∈","isindot":"⋵","isinE":"⋹","isins":"⋴","isinsv":"⋳","isinv":"∈","it":"⁢","Itilde":"Ĩ","itilde":"ĩ","Iukcy":"І","iukcy":"і","Iuml":"Ï","iuml":"ï","Jcirc":"Ĵ","jcirc":"ĵ","Jcy":"Й","jcy":"й","Jfr":"𝔍","jfr":"𝔧","jmath":"ȷ","Jopf":"𝕁","jopf":"𝕛","Jscr":"𝒥","jscr":"𝒿","Jsercy":"Ј","jsercy":"ј","Jukcy":"Є","jukcy":"є","Kappa":"Κ","kappa":"κ","kappav":"ϰ","Kcedil":"Ķ","kcedil":"ķ","Kcy":"К","kcy":"к","Kfr":"𝔎","kfr":"𝔨","kgreen":"ĸ","KHcy":"Х","khcy":"х","KJcy":"Ќ","kjcy":"ќ","Kopf":"𝕂","kopf":"𝕜","Kscr":"𝒦","kscr":"𝓀","lAarr":"⇚","Lacute":"Ĺ","lacute":"ĺ","laemptyv":"⦴","lagran":"ℒ","Lambda":"Λ","lambda":"λ","lang":"⟨","Lang":"⟪","langd":"⦑","langle":"⟨","lap":"⪅","Laplacetrf":"ℒ","laquo":"«","larrb":"⇤","larrbfs":"⤟","larr":"←","Larr":"↞","lArr":"⇐","larrfs":"⤝","larrhk":"↩","larrlp":"↫","larrpl":"⤹","larrsim":"⥳","larrtl":"↢","latail":"⤙","lAtail":"⤛","lat":"⪫","late":"⪭","lates":"⪭︀","lbarr":"⤌","lBarr":"⤎","lbbrk":"❲","lbrace":"{","lbrack":"[","lbrke":"⦋","lbrksld":"⦏","lbrkslu":"⦍","Lcaron":"Ľ","lcaron":"ľ","Lcedil":"Ļ","lcedil":"ļ","lceil":"⌈","lcub":"{","Lcy":"Л","lcy":"л","ldca":"⤶","ldquo":"“","ldquor":"„","ldrdhar":"⥧","ldrushar":"⥋","ldsh":"↲","le":"≤","lE":"≦","LeftAngleBracket":"⟨","LeftArrowBar":"⇤","leftarrow":"←","LeftArrow":"←","Leftarrow":"⇐","LeftArrowRightArrow":"⇆","leftarrowtail":"↢","LeftCeiling":"⌈","LeftDoubleBracket":"⟦","LeftDownTeeVector":"⥡","LeftDownVectorBar":"⥙","LeftDownVector":"⇃","LeftFloor":"⌊","leftharpoondown":"↽","leftharpoonup":"↼","leftleftarrows":"⇇","leftrightarrow":"↔","LeftRightArrow":"↔","Leftrightarrow":"⇔","leftrightarrows":"⇆","leftrightharpoons":"⇋","leftrightsquigarrow":"↭","LeftRightVector":"⥎","LeftTeeArrow":"↤","LeftTee":"⊣","LeftTeeVector":"⥚","leftthreetimes":"⋋","LeftTriangleBar":"⧏","LeftTriangle":"⊲","LeftTriangleEqual":"⊴","LeftUpDownVector":"⥑","LeftUpTeeVector":"⥠","LeftUpVectorBar":"⥘","LeftUpVector":"↿","LeftVectorBar":"⥒","LeftVector":"↼","lEg":"⪋","leg":"⋚","leq":"≤","leqq":"≦","leqslant":"⩽","lescc":"⪨","les":"⩽","lesdot":"⩿","lesdoto":"⪁","lesdotor":"⪃","lesg":"⋚︀","lesges":"⪓","lessapprox":"⪅","lessdot":"⋖","lesseqgtr":"⋚","lesseqqgtr":"⪋","LessEqualGreater":"⋚","LessFullEqual":"≦","LessGreater":"≶","lessgtr":"≶","LessLess":"⪡","lesssim":"≲","LessSlantEqual":"⩽","LessTilde":"≲","lfisht":"⥼","lfloor":"⌊","Lfr":"𝔏","lfr":"𝔩","lg":"≶","lgE":"⪑","lHar":"⥢","lhard":"↽","lharu":"↼","lharul":"⥪","lhblk":"▄","LJcy":"Љ","ljcy":"љ","llarr":"⇇","ll":"≪","Ll":"⋘","llcorner":"⌞","Lleftarrow":"⇚","llhard":"⥫","lltri":"◺","Lmidot":"Ŀ","lmidot":"ŀ","lmoustache":"⎰","lmoust":"⎰","lnap":"⪉","lnapprox":"⪉","lne":"⪇","lnE":"≨","lneq":"⪇","lneqq":"≨","lnsim":"⋦","loang":"⟬","loarr":"⇽","lobrk":"⟦","longleftarrow":"⟵","LongLeftArrow":"⟵","Longleftarrow":"⟸","longleftrightarrow":"⟷","LongLeftRightArrow":"⟷","Longleftrightarrow":"⟺","longmapsto":"⟼","longrightarrow":"⟶","LongRightArrow":"⟶","Longrightarrow":"⟹","looparrowleft":"↫","looparrowright":"↬","lopar":"⦅","Lopf":"𝕃","lopf":"𝕝","loplus":"⨭","lotimes":"⨴","lowast":"∗","lowbar":"_","LowerLeftArrow":"↙","LowerRightArrow":"↘","loz":"◊","lozenge":"◊","lozf":"⧫","lpar":"(","lparlt":"⦓","lrarr":"⇆","lrcorner":"⌟","lrhar":"⇋","lrhard":"⥭","lrm":"‎","lrtri":"⊿","lsaquo":"‹","lscr":"𝓁","Lscr":"ℒ","lsh":"↰","Lsh":"↰","lsim":"≲","lsime":"⪍","lsimg":"⪏","lsqb":"[","lsquo":"‘","lsquor":"‚","Lstrok":"Ł","lstrok":"ł","ltcc":"⪦","ltcir":"⩹","lt":"<","LT":"<","Lt":"≪","ltdot":"⋖","lthree":"⋋","ltimes":"⋉","ltlarr":"⥶","ltquest":"⩻","ltri":"◃","ltrie":"⊴","ltrif":"◂","ltrPar":"⦖","lurdshar":"⥊","luruhar":"⥦","lvertneqq":"≨︀","lvnE":"≨︀","macr":"¯","male":"♂","malt":"✠","maltese":"✠","Map":"⤅","map":"↦","mapsto":"↦","mapstodown":"↧","mapstoleft":"↤","mapstoup":"↥","marker":"▮","mcomma":"⨩","Mcy":"М","mcy":"м","mdash":"—","mDDot":"∺","measuredangle":"∡","MediumSpace":" ","Mellintrf":"ℳ","Mfr":"𝔐","mfr":"𝔪","mho":"℧","micro":"µ","midast":"*","midcir":"⫰","mid":"∣","middot":"·","minusb":"⊟","minus":"−","minusd":"∸","minusdu":"⨪","MinusPlus":"∓","mlcp":"⫛","mldr":"…","mnplus":"∓","models":"⊧","Mopf":"𝕄","mopf":"𝕞","mp":"∓","mscr":"𝓂","Mscr":"ℳ","mstpos":"∾","Mu":"Μ","mu":"μ","multimap":"⊸","mumap":"⊸","nabla":"∇","Nacute":"Ń","nacute":"ń","nang":"∠⃒","nap":"≉","napE":"⩰̸","napid":"≋̸","napos":"ŉ","napprox":"≉","natural":"♮","naturals":"ℕ","natur":"♮","nbsp":" ","nbump":"≎̸","nbumpe":"≏̸","ncap":"⩃","Ncaron":"Ň","ncaron":"ň","Ncedil":"Ņ","ncedil":"ņ","ncong":"≇","ncongdot":"⩭̸","ncup":"⩂","Ncy":"Н","ncy":"н","ndash":"–","nearhk":"⤤","nearr":"↗","neArr":"⇗","nearrow":"↗","ne":"≠","nedot":"≐̸","NegativeMediumSpace":"​","NegativeThickSpace":"​","NegativeThinSpace":"​","NegativeVeryThinSpace":"​","nequiv":"≢","nesear":"⤨","nesim":"≂̸","NestedGreaterGreater":"≫","NestedLessLess":"≪","NewLine":"\\n","nexist":"∄","nexists":"∄","Nfr":"𝔑","nfr":"𝔫","ngE":"≧̸","nge":"≱","ngeq":"≱","ngeqq":"≧̸","ngeqslant":"⩾̸","nges":"⩾̸","nGg":"⋙̸","ngsim":"≵","nGt":"≫⃒","ngt":"≯","ngtr":"≯","nGtv":"≫̸","nharr":"↮","nhArr":"⇎","nhpar":"⫲","ni":"∋","nis":"⋼","nisd":"⋺","niv":"∋","NJcy":"Њ","njcy":"њ","nlarr":"↚","nlArr":"⇍","nldr":"‥","nlE":"≦̸","nle":"≰","nleftarrow":"↚","nLeftarrow":"⇍","nleftrightarrow":"↮","nLeftrightarrow":"⇎","nleq":"≰","nleqq":"≦̸","nleqslant":"⩽̸","nles":"⩽̸","nless":"≮","nLl":"⋘̸","nlsim":"≴","nLt":"≪⃒","nlt":"≮","nltri":"⋪","nltrie":"⋬","nLtv":"≪̸","nmid":"∤","NoBreak":"⁠","NonBreakingSpace":" ","nopf":"𝕟","Nopf":"ℕ","Not":"⫬","not":"¬","NotCongruent":"≢","NotCupCap":"≭","NotDoubleVerticalBar":"∦","NotElement":"∉","NotEqual":"≠","NotEqualTilde":"≂̸","NotExists":"∄","NotGreater":"≯","NotGreaterEqual":"≱","NotGreaterFullEqual":"≧̸","NotGreaterGreater":"≫̸","NotGreaterLess":"≹","NotGreaterSlantEqual":"⩾̸","NotGreaterTilde":"≵","NotHumpDownHump":"≎̸","NotHumpEqual":"≏̸","notin":"∉","notindot":"⋵̸","notinE":"⋹̸","notinva":"∉","notinvb":"⋷","notinvc":"⋶","NotLeftTriangleBar":"⧏̸","NotLeftTriangle":"⋪","NotLeftTriangleEqual":"⋬","NotLess":"≮","NotLessEqual":"≰","NotLessGreater":"≸","NotLessLess":"≪̸","NotLessSlantEqual":"⩽̸","NotLessTilde":"≴","NotNestedGreaterGreater":"⪢̸","NotNestedLessLess":"⪡̸","notni":"∌","notniva":"∌","notnivb":"⋾","notnivc":"⋽","NotPrecedes":"⊀","NotPrecedesEqual":"⪯̸","NotPrecedesSlantEqual":"⋠","NotReverseElement":"∌","NotRightTriangleBar":"⧐̸","NotRightTriangle":"⋫","NotRightTriangleEqual":"⋭","NotSquareSubset":"⊏̸","NotSquareSubsetEqual":"⋢","NotSquareSuperset":"⊐̸","NotSquareSupersetEqual":"⋣","NotSubset":"⊂⃒","NotSubsetEqual":"⊈","NotSucceeds":"⊁","NotSucceedsEqual":"⪰̸","NotSucceedsSlantEqual":"⋡","NotSucceedsTilde":"≿̸","NotSuperset":"⊃⃒","NotSupersetEqual":"⊉","NotTilde":"≁","NotTildeEqual":"≄","NotTildeFullEqual":"≇","NotTildeTilde":"≉","NotVerticalBar":"∤","nparallel":"∦","npar":"∦","nparsl":"⫽⃥","npart":"∂̸","npolint":"⨔","npr":"⊀","nprcue":"⋠","nprec":"⊀","npreceq":"⪯̸","npre":"⪯̸","nrarrc":"⤳̸","nrarr":"↛","nrArr":"⇏","nrarrw":"↝̸","nrightarrow":"↛","nRightarrow":"⇏","nrtri":"⋫","nrtrie":"⋭","nsc":"⊁","nsccue":"⋡","nsce":"⪰̸","Nscr":"𝒩","nscr":"𝓃","nshortmid":"∤","nshortparallel":"∦","nsim":"≁","nsime":"≄","nsimeq":"≄","nsmid":"∤","nspar":"∦","nsqsube":"⋢","nsqsupe":"⋣","nsub":"⊄","nsubE":"⫅̸","nsube":"⊈","nsubset":"⊂⃒","nsubseteq":"⊈","nsubseteqq":"⫅̸","nsucc":"⊁","nsucceq":"⪰̸","nsup":"⊅","nsupE":"⫆̸","nsupe":"⊉","nsupset":"⊃⃒","nsupseteq":"⊉","nsupseteqq":"⫆̸","ntgl":"≹","Ntilde":"Ñ","ntilde":"ñ","ntlg":"≸","ntriangleleft":"⋪","ntrianglelefteq":"⋬","ntriangleright":"⋫","ntrianglerighteq":"⋭","Nu":"Ν","nu":"ν","num":"#","numero":"№","numsp":" ","nvap":"≍⃒","nvdash":"⊬","nvDash":"⊭","nVdash":"⊮","nVDash":"⊯","nvge":"≥⃒","nvgt":">⃒","nvHarr":"⤄","nvinfin":"⧞","nvlArr":"⤂","nvle":"≤⃒","nvlt":"<⃒","nvltrie":"⊴⃒","nvrArr":"⤃","nvrtrie":"⊵⃒","nvsim":"∼⃒","nwarhk":"⤣","nwarr":"↖","nwArr":"⇖","nwarrow":"↖","nwnear":"⤧","Oacute":"Ó","oacute":"ó","oast":"⊛","Ocirc":"Ô","ocirc":"ô","ocir":"⊚","Ocy":"О","ocy":"о","odash":"⊝","Odblac":"Ő","odblac":"ő","odiv":"⨸","odot":"⊙","odsold":"⦼","OElig":"Œ","oelig":"œ","ofcir":"⦿","Ofr":"𝔒","ofr":"𝔬","ogon":"˛","Ograve":"Ò","ograve":"ò","ogt":"⧁","ohbar":"⦵","ohm":"Ω","oint":"∮","olarr":"↺","olcir":"⦾","olcross":"⦻","oline":"‾","olt":"⧀","Omacr":"Ō","omacr":"ō","Omega":"Ω","omega":"ω","Omicron":"Ο","omicron":"ο","omid":"⦶","ominus":"⊖","Oopf":"𝕆","oopf":"𝕠","opar":"⦷","OpenCurlyDoubleQuote":"“","OpenCurlyQuote":"‘","operp":"⦹","oplus":"⊕","orarr":"↻","Or":"⩔","or":"∨","ord":"⩝","order":"ℴ","orderof":"ℴ","ordf":"ª","ordm":"º","origof":"⊶","oror":"⩖","orslope":"⩗","orv":"⩛","oS":"Ⓢ","Oscr":"𝒪","oscr":"ℴ","Oslash":"Ø","oslash":"ø","osol":"⊘","Otilde":"Õ","otilde":"õ","otimesas":"⨶","Otimes":"⨷","otimes":"⊗","Ouml":"Ö","ouml":"ö","ovbar":"⌽","OverBar":"‾","OverBrace":"⏞","OverBracket":"⎴","OverParenthesis":"⏜","para":"¶","parallel":"∥","par":"∥","parsim":"⫳","parsl":"⫽","part":"∂","PartialD":"∂","Pcy":"П","pcy":"п","percnt":"%","period":".","permil":"‰","perp":"⊥","pertenk":"‱","Pfr":"𝔓","pfr":"𝔭","Phi":"Φ","phi":"φ","phiv":"ϕ","phmmat":"ℳ","phone":"☎","Pi":"Π","pi":"π","pitchfork":"⋔","piv":"ϖ","planck":"ℏ","planckh":"ℎ","plankv":"ℏ","plusacir":"⨣","plusb":"⊞","pluscir":"⨢","plus":"+","plusdo":"∔","plusdu":"⨥","pluse":"⩲","PlusMinus":"±","plusmn":"±","plussim":"⨦","plustwo":"⨧","pm":"±","Poincareplane":"ℌ","pointint":"⨕","popf":"𝕡","Popf":"ℙ","pound":"£","prap":"⪷","Pr":"⪻","pr":"≺","prcue":"≼","precapprox":"⪷","prec":"≺","preccurlyeq":"≼","Precedes":"≺","PrecedesEqual":"⪯","PrecedesSlantEqual":"≼","PrecedesTilde":"≾","preceq":"⪯","precnapprox":"⪹","precneqq":"⪵","precnsim":"⋨","pre":"⪯","prE":"⪳","precsim":"≾","prime":"′","Prime":"″","primes":"ℙ","prnap":"⪹","prnE":"⪵","prnsim":"⋨","prod":"∏","Product":"∏","profalar":"⌮","profline":"⌒","profsurf":"⌓","prop":"∝","Proportional":"∝","Proportion":"∷","propto":"∝","prsim":"≾","prurel":"⊰","Pscr":"𝒫","pscr":"𝓅","Psi":"Ψ","psi":"ψ","puncsp":" ","Qfr":"𝔔","qfr":"𝔮","qint":"⨌","qopf":"𝕢","Qopf":"ℚ","qprime":"⁗","Qscr":"𝒬","qscr":"𝓆","quaternions":"ℍ","quatint":"⨖","quest":"?","questeq":"≟","quot":"\\"","QUOT":"\\"","rAarr":"⇛","race":"∽̱","Racute":"Ŕ","racute":"ŕ","radic":"√","raemptyv":"⦳","rang":"⟩","Rang":"⟫","rangd":"⦒","range":"⦥","rangle":"⟩","raquo":"»","rarrap":"⥵","rarrb":"⇥","rarrbfs":"⤠","rarrc":"⤳","rarr":"→","Rarr":"↠","rArr":"⇒","rarrfs":"⤞","rarrhk":"↪","rarrlp":"↬","rarrpl":"⥅","rarrsim":"⥴","Rarrtl":"⤖","rarrtl":"↣","rarrw":"↝","ratail":"⤚","rAtail":"⤜","ratio":"∶","rationals":"ℚ","rbarr":"⤍","rBarr":"⤏","RBarr":"⤐","rbbrk":"❳","rbrace":"}","rbrack":"]","rbrke":"⦌","rbrksld":"⦎","rbrkslu":"⦐","Rcaron":"Ř","rcaron":"ř","Rcedil":"Ŗ","rcedil":"ŗ","rceil":"⌉","rcub":"}","Rcy":"Р","rcy":"р","rdca":"⤷","rdldhar":"⥩","rdquo":"”","rdquor":"”","rdsh":"↳","real":"ℜ","realine":"ℛ","realpart":"ℜ","reals":"ℝ","Re":"ℜ","rect":"▭","reg":"®","REG":"®","ReverseElement":"∋","ReverseEquilibrium":"⇋","ReverseUpEquilibrium":"⥯","rfisht":"⥽","rfloor":"⌋","rfr":"𝔯","Rfr":"ℜ","rHar":"⥤","rhard":"⇁","rharu":"⇀","rharul":"⥬","Rho":"Ρ","rho":"ρ","rhov":"ϱ","RightAngleBracket":"⟩","RightArrowBar":"⇥","rightarrow":"→","RightArrow":"→","Rightarrow":"⇒","RightArrowLeftArrow":"⇄","rightarrowtail":"↣","RightCeiling":"⌉","RightDoubleBracket":"⟧","RightDownTeeVector":"⥝","RightDownVectorBar":"⥕","RightDownVector":"⇂","RightFloor":"⌋","rightharpoondown":"⇁","rightharpoonup":"⇀","rightleftarrows":"⇄","rightleftharpoons":"⇌","rightrightarrows":"⇉","rightsquigarrow":"↝","RightTeeArrow":"↦","RightTee":"⊢","RightTeeVector":"⥛","rightthreetimes":"⋌","RightTriangleBar":"⧐","RightTriangle":"⊳","RightTriangleEqual":"⊵","RightUpDownVector":"⥏","RightUpTeeVector":"⥜","RightUpVectorBar":"⥔","RightUpVector":"↾","RightVectorBar":"⥓","RightVector":"⇀","ring":"˚","risingdotseq":"≓","rlarr":"⇄","rlhar":"⇌","rlm":"‏","rmoustache":"⎱","rmoust":"⎱","rnmid":"⫮","roang":"⟭","roarr":"⇾","robrk":"⟧","ropar":"⦆","ropf":"𝕣","Ropf":"ℝ","roplus":"⨮","rotimes":"⨵","RoundImplies":"⥰","rpar":")","rpargt":"⦔","rppolint":"⨒","rrarr":"⇉","Rrightarrow":"⇛","rsaquo":"›","rscr":"𝓇","Rscr":"ℛ","rsh":"↱","Rsh":"↱","rsqb":"]","rsquo":"’","rsquor":"’","rthree":"⋌","rtimes":"⋊","rtri":"▹","rtrie":"⊵","rtrif":"▸","rtriltri":"⧎","RuleDelayed":"⧴","ruluhar":"⥨","rx":"℞","Sacute":"Ś","sacute":"ś","sbquo":"‚","scap":"⪸","Scaron":"Š","scaron":"š","Sc":"⪼","sc":"≻","sccue":"≽","sce":"⪰","scE":"⪴","Scedil":"Ş","scedil":"ş","Scirc":"Ŝ","scirc":"ŝ","scnap":"⪺","scnE":"⪶","scnsim":"⋩","scpolint":"⨓","scsim":"≿","Scy":"С","scy":"с","sdotb":"⊡","sdot":"⋅","sdote":"⩦","searhk":"⤥","searr":"↘","seArr":"⇘","searrow":"↘","sect":"§","semi":";","seswar":"⤩","setminus":"∖","setmn":"∖","sext":"✶","Sfr":"𝔖","sfr":"𝔰","sfrown":"⌢","sharp":"♯","SHCHcy":"Щ","shchcy":"щ","SHcy":"Ш","shcy":"ш","ShortDownArrow":"↓","ShortLeftArrow":"←","shortmid":"∣","shortparallel":"∥","ShortRightArrow":"→","ShortUpArrow":"↑","shy":"­","Sigma":"Σ","sigma":"σ","sigmaf":"ς","sigmav":"ς","sim":"∼","simdot":"⩪","sime":"≃","simeq":"≃","simg":"⪞","simgE":"⪠","siml":"⪝","simlE":"⪟","simne":"≆","simplus":"⨤","simrarr":"⥲","slarr":"←","SmallCircle":"∘","smallsetminus":"∖","smashp":"⨳","smeparsl":"⧤","smid":"∣","smile":"⌣","smt":"⪪","smte":"⪬","smtes":"⪬︀","SOFTcy":"Ь","softcy":"ь","solbar":"⌿","solb":"⧄","sol":"/","Sopf":"𝕊","sopf":"𝕤","spades":"♠","spadesuit":"♠","spar":"∥","sqcap":"⊓","sqcaps":"⊓︀","sqcup":"⊔","sqcups":"⊔︀","Sqrt":"√","sqsub":"⊏","sqsube":"⊑","sqsubset":"⊏","sqsubseteq":"⊑","sqsup":"⊐","sqsupe":"⊒","sqsupset":"⊐","sqsupseteq":"⊒","square":"□","Square":"□","SquareIntersection":"⊓","SquareSubset":"⊏","SquareSubsetEqual":"⊑","SquareSuperset":"⊐","SquareSupersetEqual":"⊒","SquareUnion":"⊔","squarf":"▪","squ":"□","squf":"▪","srarr":"→","Sscr":"𝒮","sscr":"𝓈","ssetmn":"∖","ssmile":"⌣","sstarf":"⋆","Star":"⋆","star":"☆","starf":"★","straightepsilon":"ϵ","straightphi":"ϕ","strns":"¯","sub":"⊂","Sub":"⋐","subdot":"⪽","subE":"⫅","sube":"⊆","subedot":"⫃","submult":"⫁","subnE":"⫋","subne":"⊊","subplus":"⪿","subrarr":"⥹","subset":"⊂","Subset":"⋐","subseteq":"⊆","subseteqq":"⫅","SubsetEqual":"⊆","subsetneq":"⊊","subsetneqq":"⫋","subsim":"⫇","subsub":"⫕","subsup":"⫓","succapprox":"⪸","succ":"≻","succcurlyeq":"≽","Succeeds":"≻","SucceedsEqual":"⪰","SucceedsSlantEqual":"≽","SucceedsTilde":"≿","succeq":"⪰","succnapprox":"⪺","succneqq":"⪶","succnsim":"⋩","succsim":"≿","SuchThat":"∋","sum":"∑","Sum":"∑","sung":"♪","sup1":"¹","sup2":"²","sup3":"³","sup":"⊃","Sup":"⋑","supdot":"⪾","supdsub":"⫘","supE":"⫆","supe":"⊇","supedot":"⫄","Superset":"⊃","SupersetEqual":"⊇","suphsol":"⟉","suphsub":"⫗","suplarr":"⥻","supmult":"⫂","supnE":"⫌","supne":"⊋","supplus":"⫀","supset":"⊃","Supset":"⋑","supseteq":"⊇","supseteqq":"⫆","supsetneq":"⊋","supsetneqq":"⫌","supsim":"⫈","supsub":"⫔","supsup":"⫖","swarhk":"⤦","swarr":"↙","swArr":"⇙","swarrow":"↙","swnwar":"⤪","szlig":"ß","Tab":"\\t","target":"⌖","Tau":"Τ","tau":"τ","tbrk":"⎴","Tcaron":"Ť","tcaron":"ť","Tcedil":"Ţ","tcedil":"ţ","Tcy":"Т","tcy":"т","tdot":"⃛","telrec":"⌕","Tfr":"𝔗","tfr":"𝔱","there4":"∴","therefore":"∴","Therefore":"∴","Theta":"Θ","theta":"θ","thetasym":"ϑ","thetav":"ϑ","thickapprox":"≈","thicksim":"∼","ThickSpace":"  ","ThinSpace":" ","thinsp":" ","thkap":"≈","thksim":"∼","THORN":"Þ","thorn":"þ","tilde":"˜","Tilde":"∼","TildeEqual":"≃","TildeFullEqual":"≅","TildeTilde":"≈","timesbar":"⨱","timesb":"⊠","times":"×","timesd":"⨰","tint":"∭","toea":"⤨","topbot":"⌶","topcir":"⫱","top":"⊤","Topf":"𝕋","topf":"𝕥","topfork":"⫚","tosa":"⤩","tprime":"‴","trade":"™","TRADE":"™","triangle":"▵","triangledown":"▿","triangleleft":"◃","trianglelefteq":"⊴","triangleq":"≜","triangleright":"▹","trianglerighteq":"⊵","tridot":"◬","trie":"≜","triminus":"⨺","TripleDot":"⃛","triplus":"⨹","trisb":"⧍","tritime":"⨻","trpezium":"⏢","Tscr":"𝒯","tscr":"𝓉","TScy":"Ц","tscy":"ц","TSHcy":"Ћ","tshcy":"ћ","Tstrok":"Ŧ","tstrok":"ŧ","twixt":"≬","twoheadleftarrow":"↞","twoheadrightarrow":"↠","Uacute":"Ú","uacute":"ú","uarr":"↑","Uarr":"↟","uArr":"⇑","Uarrocir":"⥉","Ubrcy":"Ў","ubrcy":"ў","Ubreve":"Ŭ","ubreve":"ŭ","Ucirc":"Û","ucirc":"û","Ucy":"У","ucy":"у","udarr":"⇅","Udblac":"Ű","udblac":"ű","udhar":"⥮","ufisht":"⥾","Ufr":"𝔘","ufr":"𝔲","Ugrave":"Ù","ugrave":"ù","uHar":"⥣","uharl":"↿","uharr":"↾","uhblk":"▀","ulcorn":"⌜","ulcorner":"⌜","ulcrop":"⌏","ultri":"◸","Umacr":"Ū","umacr":"ū","uml":"¨","UnderBar":"_","UnderBrace":"⏟","UnderBracket":"⎵","UnderParenthesis":"⏝","Union":"⋃","UnionPlus":"⊎","Uogon":"Ų","uogon":"ų","Uopf":"𝕌","uopf":"𝕦","UpArrowBar":"⤒","uparrow":"↑","UpArrow":"↑","Uparrow":"⇑","UpArrowDownArrow":"⇅","updownarrow":"↕","UpDownArrow":"↕","Updownarrow":"⇕","UpEquilibrium":"⥮","upharpoonleft":"↿","upharpoonright":"↾","uplus":"⊎","UpperLeftArrow":"↖","UpperRightArrow":"↗","upsi":"υ","Upsi":"ϒ","upsih":"ϒ","Upsilon":"Υ","upsilon":"υ","UpTeeArrow":"↥","UpTee":"⊥","upuparrows":"⇈","urcorn":"⌝","urcorner":"⌝","urcrop":"⌎","Uring":"Ů","uring":"ů","urtri":"◹","Uscr":"𝒰","uscr":"𝓊","utdot":"⋰","Utilde":"Ũ","utilde":"ũ","utri":"▵","utrif":"▴","uuarr":"⇈","Uuml":"Ü","uuml":"ü","uwangle":"⦧","vangrt":"⦜","varepsilon":"ϵ","varkappa":"ϰ","varnothing":"∅","varphi":"ϕ","varpi":"ϖ","varpropto":"∝","varr":"↕","vArr":"⇕","varrho":"ϱ","varsigma":"ς","varsubsetneq":"⊊︀","varsubsetneqq":"⫋︀","varsupsetneq":"⊋︀","varsupsetneqq":"⫌︀","vartheta":"ϑ","vartriangleleft":"⊲","vartriangleright":"⊳","vBar":"⫨","Vbar":"⫫","vBarv":"⫩","Vcy":"В","vcy":"в","vdash":"⊢","vDash":"⊨","Vdash":"⊩","VDash":"⊫","Vdashl":"⫦","veebar":"⊻","vee":"∨","Vee":"⋁","veeeq":"≚","vellip":"⋮","verbar":"|","Verbar":"‖","vert":"|","Vert":"‖","VerticalBar":"∣","VerticalLine":"|","VerticalSeparator":"❘","VerticalTilde":"≀","VeryThinSpace":" ","Vfr":"𝔙","vfr":"𝔳","vltri":"⊲","vnsub":"⊂⃒","vnsup":"⊃⃒","Vopf":"𝕍","vopf":"𝕧","vprop":"∝","vrtri":"⊳","Vscr":"𝒱","vscr":"𝓋","vsubnE":"⫋︀","vsubne":"⊊︀","vsupnE":"⫌︀","vsupne":"⊋︀","Vvdash":"⊪","vzigzag":"⦚","Wcirc":"Ŵ","wcirc":"ŵ","wedbar":"⩟","wedge":"∧","Wedge":"⋀","wedgeq":"≙","weierp":"℘","Wfr":"𝔚","wfr":"𝔴","Wopf":"𝕎","wopf":"𝕨","wp":"℘","wr":"≀","wreath":"≀","Wscr":"𝒲","wscr":"𝓌","xcap":"⋂","xcirc":"◯","xcup":"⋃","xdtri":"▽","Xfr":"𝔛","xfr":"𝔵","xharr":"⟷","xhArr":"⟺","Xi":"Ξ","xi":"ξ","xlarr":"⟵","xlArr":"⟸","xmap":"⟼","xnis":"⋻","xodot":"⨀","Xopf":"𝕏","xopf":"𝕩","xoplus":"⨁","xotime":"⨂","xrarr":"⟶","xrArr":"⟹","Xscr":"𝒳","xscr":"𝓍","xsqcup":"⨆","xuplus":"⨄","xutri":"△","xvee":"⋁","xwedge":"⋀","Yacute":"Ý","yacute":"ý","YAcy":"Я","yacy":"я","Ycirc":"Ŷ","ycirc":"ŷ","Ycy":"Ы","ycy":"ы","yen":"¥","Yfr":"𝔜","yfr":"𝔶","YIcy":"Ї","yicy":"ї","Yopf":"𝕐","yopf":"𝕪","Yscr":"𝒴","yscr":"𝓎","YUcy":"Ю","yucy":"ю","yuml":"ÿ","Yuml":"Ÿ","Zacute":"Ź","zacute":"ź","Zcaron":"Ž","zcaron":"ž","Zcy":"З","zcy":"з","Zdot":"Ż","zdot":"ż","zeetrf":"ℨ","ZeroWidthSpace":"​","Zeta":"Ζ","zeta":"ζ","zfr":"𝔷","Zfr":"ℨ","ZHcy":"Ж","zhcy":"ж","zigrarr":"⇝","zopf":"𝕫","Zopf":"ℤ","Zscr":"𝒵","zscr":"𝓏","zwj":"‍","zwnj":"‌"}')
}, function(e) {
  e.exports = JSON.parse('{"amp":"&","apos":"\'","gt":">","lt":"<","quot":"\\""}')
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.DomHandler = void 0;
  var a = r(134);
  i(r(134), t);
  var s = /\s+/g,
    o = {
      normalizeWhitespace: !1,
      withStartIndices: !1,
      withEndIndices: !1
    },
    u = function() {
      function e(e, t, r) {
        this.dom = [], this._done = !1, this._tagStack = [], this._lastNode = null, this._parser = null, "function" == typeof t && (r = t, t = o), "object" == typeof e && (t = e, e = void 0), this._callback = null != e ? e : null, this._options = null != t ? t : o, this._elementCB = null != r ? r : null
      }
      return e.prototype.onparserinit = function(e) {
        this._parser = e
      }, e.prototype.onreset = function() {
        var e;
        this.dom = [], this._done = !1, this._tagStack = [], this._lastNode = null, this._parser = null !== (e = this._parser) && void 0 !== e ? e : null
      }, e.prototype.onend = function() {
        this._done || (this._done = !0, this._parser = null, this.handleCallback(null))
      }, e.prototype.onerror = function(e) {
        this.handleCallback(e)
      }, e.prototype.onclosetag = function() {
        this._lastNode = null;
        var e = this._tagStack.pop();
        e && this._parser && (this._options.withEndIndices && (e.endIndex = this._parser.endIndex), this._elementCB && this._elementCB(e))
      }, e.prototype.onopentag = function(e, t) {
        var r = new a.Element(e, t);
        this.addNode(r), this._tagStack.push(r)
      }, e.prototype.ontext = function(e) {
        var t = this._options.normalizeWhitespace,
          r = this._lastNode;
        if (r && "text" === r.type) t ? r.data = (r.data + e).replace(s, " ") : r.data += e;
        else {
          t && (e = e.replace(s, " "));
          var n = new a.Text(e);
          this.addNode(n), this._lastNode = n
        }
      }, e.prototype.oncomment = function(e) {
        if (this._lastNode && "comment" === this._lastNode.type) this._lastNode.data += e;
        else {
          var t = new a.Comment(e);
          this.addNode(t), this._lastNode = t
        }
      }, e.prototype.oncommentend = function() {
        this._lastNode = null
      }, e.prototype.oncdatastart = function() {
        var e = new a.Text(""),
          t = new a.NodeWithChildren("cdata", [e]);
        this.addNode(t), e.parent = t, this._lastNode = e
      }, e.prototype.oncdataend = function() {
        this._lastNode = null
      }, e.prototype.onprocessinginstruction = function(e, t) {
        var r = new a.ProcessingInstruction(e, t);
        this.addNode(r)
      }, e.prototype.handleCallback = function(e) {
        if ("function" == typeof this._callback) this._callback(e, this.dom);
        else if (e) throw e
      }, e.prototype.addNode = function(e) {
        var t = this._tagStack[this._tagStack.length - 1],
          r = t ? t.children : this.dom,
          n = r[r.length - 1];
        this._parser && (this._options.withStartIndices && (e.startIndex = this._parser.startIndex), this._options.withEndIndices && (e.endIndex = this._parser.endIndex)), r.push(e), n && (e.prev = n, n.next = e), t && (e.parent = t), this._lastNode = null
      }, e.prototype.addDataNode = function(e) {
        this.addNode(e), this._lastNode = e
      }, e
    }();
  t.DomHandler = u, t.default = u
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Doctype = t.CDATA = t.Tag = t.Style = t.Script = t.Comment = t.Directive = t.Text = t.isTag = void 0, t.isTag = function(e) {
    return "tag" === e.type || "script" === e.type || "style" === e.type
  }, t.Text = "text", t.Directive = "directive", t.Comment = "comment", t.Script = "script", t.Style = "style", t.Tag = "tag", t.CDATA = "cdata", t.Doctype = "doctype"
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(290), t), i(r(294), t), i(r(295), t), i(r(138), t), i(r(296), t), i(r(297), t), i(r(37), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Util = void 0;
  const n = r(5),
    i = r(13);
  class a {
    constructor(e, t) {
      this.dataFactory = e || new n.DataFactory, this.baseIRI = t || ""
    }
    static isValidIri(e) {
      return a.IRI_REGEX.test(e)
    }
    createVocabIris(e, t, r) {
      return e.split(/\s+/u).filter(e => !!e).map(e => {
        if (!a.isValidIri(e)) {
          if (!r) return;
          e = `${t.vocab||this.baseIRI+"#"}${e}`
        }
        return this.dataFactory.namedNode(e)
      }).filter(e => !!e)
    }
    getVocabularyExpansionType(e, t, r) {
      const n = e.split(/\s+/u);
      if (n.includes("subPropertyOf") || n.includes("equivalentProperty")) return [this.dataFactory.namedNode(a.RDF + "type")];
      if (t.vocab && t.vocab in r && r[t.vocab].properties) {
        let e = [];
        for (const [i, a] of Object.entries(r[t.vocab].properties)) n.includes(i) && (e = e.concat(Object.values(a).map(e => this.dataFactory.namedNode(e))));
        return e
      }
      return []
    }
    createSubject(e) {
      if (!a.isValidIri(e)) try {
        e = i.resolve(e, this.baseIRI)
      } catch (e) {
        return
      }
      return this.dataFactory.namedNode(e)
    }
    createLiteral(e, t) {
      return this.dataFactory.literal(e, t.language)
    }
    deriveVocab(e, t) {
      let r;
      for (const n in t)
        if (e.startsWith(n)) {
          r = n, r.endsWith("/") || (r += "#");
          break
        } if (!r) {
        const t = e.indexOf("#");
        r = t > 0 ? e.slice(0, t + 1) : i.resolve(".", e)
      }
      return r
    }
  }
  t.Util = a, a.RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#", a.XSD = "http://www.w3.org/2001/XMLSchema#", a.RDFA = "http://www.w3.org/ns/rdfa#", a.IRI_REGEX = /^([A-Za-z][\d+-.A-Za-z]*|_):[^ "<>[\\\]`{|}]*$/u
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeHandlerAdapter = void 0;
  t.NodeHandlerAdapter = class {
    constructor(e, t, r) {
      this.targetKind = e, this.util = t, this.settings = r
    }
    getNodeQuadContextSelectionSet(e, t, r) {
      const n = {};
      if (e)
        for (const t of e.selections)
          if ("Field" === t.kind) {
            const e = t;
            this.handleNodeQuadContextField(e, r, n, "id", "subject"), this.handleNodeQuadContextField(e, r, n, "graph", "graph")
          } return n
    }
    handleNodeQuadContextField(e, t, r, n, i) {
      if (!r[i] && e.name.value === n) {
        if (!r[i]) {
          const a = this.util.getArgument(e.arguments, "_");
          if (a) {
            const s = this.util.handleNodeValue(a.value, e.name.value, t);
            if (1 !== s.terms.length) throw new Error(`Only single values can be set as ${n}, but got ${s.terms.length} at ${e.name.value}`);
            r[i] = s.terms[0], s.auxiliaryPatterns && (r.auxiliaryPatterns || (r.auxiliaryPatterns = []), r.auxiliaryPatterns.concat(s.auxiliaryPatterns))
          }
        }
        if (!r[i]) {
          const n = this.util.nameToVariable(this.util.getFieldLabel(e), t);
          t.terminalVariables.push(n), r[i] = n
        }
      }
    }
    getDirectiveOutputs(e, t, r) {
      const n = [];
      if (e)
        for (const i of e) {
          const e = this.util.handleDirectiveNode({
            directive: i,
            fieldLabel: t
          }, r);
          if (e) {
            if (e.ignore) return null;
            n.push(e)
          }
        }
      return n
    }
    handleDirectiveOutputs(e, t) {
      for (const r of e) {
        if (r.ignore) return this.util.operationFactory.createBgp([]);
        r.operationOverrider && (t = r.operationOverrider(t))
      }
      return t
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeHandlerSelectionAdapter = void 0;
  const n = r(6),
    i = r(48),
    a = r(62);
  class s extends a.NodeHandlerAdapter {
    constructor(e, t, r) {
      super(e, t, r)
    }
    getNodeQuadContextFieldNode(e, t, r) {
      return this.getNodeQuadContextSelectionSet(e.selectionSet, t, Object.assign(Object.assign({}, r), {
        path: this.util.appendFieldToPath(r.path, t)
      }))
    }
    fieldToOperation(e, t, r, a) {
      const s = r;
      let o, u = 0;
      if (("id" === t.name.value || "graph" === t.name.value) && (r = !1, t.arguments))
        for (const r of t.arguments) "_" === r.name.value && this.util.handleNodeValue(r.value, t.name.value, e);
      const c = this.util.getFieldLabel(t);
      if (e.singularizeState === i.SingularizeState.SINGLE && (e.singularizeVariables[this.util.nameToVariable(c, e).value] = !0), r) {
        const t = this.handleMetaField(e, c, a);
        if (t) return t
      }
      const l = a ? [this.util.operationFactory.createBgp(a)] : [],
        h = this.getNodeQuadContextFieldNode(t, c, e);
      let d = h.subject || this.util.nameToVariable(c, e),
        p = h.graph || e.graph;
      h.auxiliaryPatterns && l.push(this.util.operationFactory.createBgp(h.auxiliaryPatterns));
      let f = !0,
        g = null;
      if (r && t.arguments && t.arguments.length)
        for (const n of t.arguments) {
          if ("_" === n.name.value) {
            const i = this.util.handleNodeValue(n.value, t.name.value, e);
            g = i.terms, l.push(this.util.operationFactory.createBgp(i.terms.map(r => this.util.createQuadPattern(e.subject, t.name, r, e.graph, e.context)))), i.auxiliaryPatterns && l.push(this.util.operationFactory.createBgp(h.auxiliaryPatterns)), r = !1;
            break
          }
          if ("graph" === n.name.value) {
            const r = this.util.handleNodeValue(n.value, t.name.value, e);
            if (1 !== r.terms.length) throw new Error(`Only single values can be set as graph, but got ${r.terms.length} at ${t.name.value}`);
            p = r.terms[0], e = Object.assign(Object.assign({}, e), {
              graph: p
            }), r.auxiliaryPatterns && l.push(this.util.operationFactory.createBgp(h.auxiliaryPatterns));
            break
          }
          if ("alt" === n.name.value) {
            let r = n.value;
            "ListValue" !== r.kind && (r = {
              kind: "ListValue",
              values: [r]
            }), l.push(this.util.createQuadPath(e.subject, t.name, r, d, e.graph, e.context)), f = !1;
            break
          }
        }
      if (r && f && l.push(this.util.operationFactory.createBgp([this.util.createQuadPattern(e.subject, t.name, d, e.graph, e.context)])), t.arguments && t.arguments.length)
        for (const r of t.arguments)
          if ("_" === r.name.value || "graph" === r.name.value || "alt" === r.name.value);
          else if ("first" === r.name.value) {
            if ("IntValue" !== r.value.kind) throw new Error("Invalid value type for 'first' argument: " + r.value.kind);
            o = parseInt(r.value.value, 10)
          } else if ("offset" === r.name.value) {
            if ("IntValue" !== r.value.kind) throw new Error("Invalid value type for 'offset' argument: " + r.value.kind);
            u = parseInt(r.value.value, 10)
          } else {
            const t = this.util.handleNodeValue(r.value, r.name.value, e);
            l.push(this.util.operationFactory.createBgp(t.terms.map(t => this.util.createQuadPattern(d, r.name, t, e.graph, e.context)))), t.auxiliaryPatterns && l.push(this.util.operationFactory.createBgp(h.auxiliaryPatterns))
          }
      const m = this.getDirectiveOutputs(t.directives, c, e);
      if (!m) return this.util.operationFactory.createBgp([]);
      let y = this.util.joinOperations(l);
      if (t.selectionSet && t.selectionSet.selections.length) {
        if (g) {
          if (1 !== g.length) throw new Error(`Only single values can be set as id, but got ${g.length} at ${t.name.value}`);
          d = g[0]
        }
        const r = Object.assign(Object.assign(Object.assign({}, e), s ? {
          path: this.util.appendFieldToPath(e.path, c)
        } : {}), {
          graph: p,
          subject: s ? d : e.subject
        });
        let n = !1;
        const i = t.selectionSet.selections.filter(e => "Field" !== e.kind || "totalCount" !== e.name.value || (n = !0, !1));
        let a = this.util.joinOperations(l.concat(i.map(e => this.util.handleNode(e, r))));
        if (n) {
          const t = this.util.dataFactory.variable("var" + this.settings.expressionVariableCounter++),
            r = this.util.dataFactory.variable(d.value + this.settings.variableDelimiter + "totalCount"),
            n = this.util.operationFactory.createBoundAggregate(t, "count", this.util.operationFactory.createTermExpression(d), !1),
            s = this.util.operationFactory.createProject(this.util.operationFactory.createExtend(this.util.operationFactory.createGroup(y, [], [n]), r, this.util.operationFactory.createTermExpression(t)), [r]);
          e.terminalVariables.push(r), a = i.length ? this.util.operationFactory.createJoin(this.util.operationFactory.createProject(a, []), s) : s
        }
        y = a
      } else r && "Variable" === d.termType && e.terminalVariables.push(d);
      return (u || o) && (y = this.util.operationFactory.createSlice(this.util.operationFactory.createProject(y, n.Util.inScopeVariables(y)), u, o)), this.handleDirectiveOutputs(m, y)
    }
    handleMetaField(e, t, r) {
      if ("__typename" === t) {
        const n = this.util.nameToVariable(t, e);
        return e.terminalVariables.push(n), this.util.operationFactory.createBgp([this.util.operationFactory.createPattern(e.subject, this.util.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), this.util.nameToVariable(t, e), e.graph)].concat(r || []))
      }
      return null
    }
  }
  t.NodeHandlerSelectionAdapter = s
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.EntryHandlerPredicate = void 0;
  const n = r(9),
    i = r(27);
  class a {
    static async handlePredicateObject(e, t, r, n, i, a, s) {
      const o = await t.getPropertiesDepth(r, n),
        u = await t.getDepthOffsetGraph(n, r),
        c = n - u,
        l = e.idStack[o];
      if (l)
        for (const h of l) {
          if (u >= 0) {
            const r = e.idStack[c - 1];
            if (r)
              for (const o of r) s ? (t.validateReverseSubject(a), e.emitQuad(n, t.dataFactory.quad(a, i, h, o))) : e.emitQuad(n, t.dataFactory.quad(h, i, a, o));
            else s ? (t.validateReverseSubject(a), e.getUnidentifiedGraphBufferSafe(c - 1).push({
              subject: a,
              predicate: i,
              object: h
            })) : e.getUnidentifiedGraphBufferSafe(c - 1).push({
              subject: h,
              predicate: i,
              object: a
            })
          } else {
            const u = await t.getGraphContainerValue(r, o);
            s ? (t.validateReverseSubject(a), e.emitQuad(n, t.dataFactory.quad(a, i, h, u))) : e.emitQuad(n, t.dataFactory.quad(h, i, a, u))
          }
        } else s && t.validateReverseSubject(a), e.getUnidentifiedValueBufferSafe(o).push({
        predicate: i,
        object: a,
        reverse: s
      })
    }
    isPropertyHandler() {
      return !0
    }
    isStackProcessor() {
      return !0
    }
    async validate(e, t, r, n, a) {
      const s = r[n];
      if (s) {
        const a = await e.getContext(r);
        if (await t.predicateToTerm(a, r[n])) return "@json" === i.Util.getContextValueType(a, s) && (e.jsonLiteralStack[n + 1] = !0), !0
      }
      return !1
    }
    async test(e, t, r, n, i) {
      return n[i]
    }
    async handle(e, t, r, s, o, u, c) {
      const l = s[u],
        h = await e.getContext(s),
        d = await t.predicateToTerm(h, r);
      if (d) {
        const c = await t.valueToTerm(h, r, o, u, s);
        if (c.length)
          for (let p of c) {
            const c = i.Util.isPropertyReverse(h, l, await t.unaliasKeywordParent(s, u));
            if (o) {
              const a = "@list" in i.Util.getContextValueContainer(h, r);
              if (a || o["@list"]) {
                if ((a && !Array.isArray(o) && !o["@list"] || o["@list"] && !Array.isArray(o["@list"])) && p !== t.rdfNil) {
                  const r = t.dataFactory.blankNode();
                  e.emitQuad(u, t.dataFactory.quad(r, t.rdfRest, t.rdfNil, t.getDefaultGraph())), e.emitQuad(u, t.dataFactory.quad(r, t.rdfFirst, p, t.getDefaultGraph())), p = r
                }
                if (c && !e.allowSubjectList) throw new n.ErrorCoded("Found illegal list value in subject position at " + r, n.ERROR_CODES.INVALID_REVERSE_PROPERTY_VALUE)
              }
            }
            await a.handlePredicateObject(e, t, s, u, d, p, c)
          }
      }
    }
  }
  t.EntryHandlerPredicate = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.parseXSDDateTime = t.parseXSDInteger = t.parseXSDDecimal = t.parseXSDFloat = void 0, t.parseXSDFloat = function(e) {
    const t = Number(e);
    return isNaN(t) ? "NaN" === e ? NaN : "INF" === e ? 1 / 0 : "-INF" === e ? -1 / 0 : void 0 : t
  }, t.parseXSDDecimal = function(e) {
    const t = Number(e);
    return isNaN(t) ? void 0 : t
  }, t.parseXSDInteger = function(e) {
    const t = parseInt(e, 10);
    return isNaN(t) ? void 0 : t
  }, t.parseXSDDateTime = function(e) {
    const t = e.indexOf("T"),
      r = t >= 0 ? e.substr(0, t) : e,
      [n, i, a] = r.split("-");
    let s = "",
      o = "",
      u = "",
      c = "";
    if (t >= 0) {
      const r = e.substr(t + 1),
        [n, i] = r.split(/[\+\-Z]/);
      [s, o, u] = n.split(":");
      const a = new RegExp(/([\+\-Z].*)/).exec(r);
      c = a ? a[0] : ""
    } else s = "00", o = "00", u = "00", c = "";
    return {
      year: n,
      month: i,
      day: a,
      hours: s,
      minutes: o,
      seconds: u,
      timezone: c
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.typeCheckLit = t.log = t.dateTime = t.langString = t.string = t.numberFromString = t.number = t.bool = t.map = t.Impl = t.Builder = t.declare = void 0;
  const n = r(23),
    i = r(40),
    a = r(14),
    s = r(20),
    o = r(14),
    u = r(90);
  t.declare = function() {
    return new c
  };
  class c {
    constructor() {
      this.implementations = []
    }
    collect() {
      return d(this.implementations)
    }
    log() {
      return console.log(this.implementations), this
    }
    add(e) {
      return this.implementations.push(e), this
    }
    set(e, t) {
      const r = n.List(e);
      return this.add(new h({
        types: r,
        func: t
      }))
    }
    copy({
           from: e,
           to: t
         }) {
      const r = this.implementations.length - 1,
        i = n.List(e);
      for (let e = r; e >= 0; e--) {
        const r = this.implementations[e];
        if (r.get("types").equals(i)) return this.set(t, r.get("func"))
      }
      throw new s.UnexpectedError("Tried to copy implementation, but types not found", {
        from: e,
        to: t
      })
    }
    onUnary(e, t) {
      return this.set([e], ([e]) => t(e))
    }
    onUnaryTyped(e, t) {
      return this.set([e], ([e]) => t(e.typedValue))
    }
    onBinary(e, t) {
      return this.set(e, ([e, r]) => t(e, r))
    }
    onBinaryTyped(e, t) {
      return this.set(e, ([e, r]) => t(e.typedValue, r.typedValue))
    }
    onTernaryTyped(e, t) {
      return this.set(e, ([e, r, n]) => t(e.typedValue, r.typedValue, n.typedValue))
    }
    onTernary(e, t) {
      return this.set(e, ([e, r, n]) => t(e, r, n))
    }
    onQuaternaryTyped(e, t) {
      return this.set(e, ([e, r, n, i]) => t(e.typedValue, r.typedValue, n.typedValue, i.typedValue))
    }
    unimplemented(e) {
      for (let t = 0; t <= 5; t++) {
        const r = Array(t).fill("term"),
          n = t => {
            throw new s.UnimplementedError(e)
          };
        this.set(r, n)
      }
      return this
    }
    onTerm1(e) {
      return this.set(["term"], ([t]) => e(t))
    }
    onLiteral1(e) {
      return this.set(["literal"], ([t]) => e(t))
    }
    onBoolean1(e) {
      return this.set(["boolean"], ([t]) => e(t))
    }
    onBoolean1Typed(e) {
      return this.set(["boolean"], ([t]) => e(t.typedValue))
    }
    onString1(e) {
      return this.set(["string"], ([t]) => e(t))
    }
    onString1Typed(e) {
      return this.set(["string"], ([t]) => e(t.typedValue))
    }
    onLangString1(e) {
      return this.set(["langString"], ([t]) => e(t))
    }
    onStringly1(e) {
      return this.set(["string"], ([t]) => e(t)).set(["langString"], ([t]) => e(t))
    }
    onStringly1Typed(e) {
      return this.set(["string"], ([t]) => e(t.typedValue)).set(["langString"], ([t]) => e(t.typedValue))
    }
    onNumeric1(e) {
      return this.set(["integer"], ([t]) => e(t)).set(["decimal"], ([t]) => e(t)).set(["float"], ([t]) => e(t)).set(["double"], ([t]) => e(t)).invalidLexicalForm(["nonlexical"], 1)
    }
    onDateTime1(e) {
      return this.set(["date"], ([t]) => e(t)).invalidLexicalForm(["nonlexical"], 1)
    }
    arithmetic(e) {
      return this.numeric(([t, r]) => {
        const n = u.promote(t.type, r.type),
          i = a.decategorize(n);
        return f(e(t.typedValue, r.typedValue), i)
      })
    }
    numberTest(e) {
      return this.numeric(([t, r]) => p(e(t.typedValue, r.typedValue)))
    }
    stringTest(e) {
      return this.set(["string", "string"], ([t, r]) => p(e(t.typedValue, r.typedValue))).invalidLexicalForm(["nonlexical", "string"], 1).invalidLexicalForm(["string", "nonlexical"], 2)
    }
    booleanTest(e) {
      return this.set(["boolean", "boolean"], ([t, r]) => p(e(t.typedValue, r.typedValue))).invalidLexicalForm(["nonlexical", "boolean"], 1).invalidLexicalForm(["boolean", "nonlexical"], 2)
    }
    dateTimeTest(e) {
      return this.set(["date", "date"], ([t, r]) => p(e(t.typedValue, r.typedValue))).invalidLexicalForm(["nonlexical", "date"], 1).invalidLexicalForm(["date", "nonlexical"], 2)
    }
    numeric(e) {
      return this.set(["integer", "integer"], e).set(["integer", "decimal"], e).set(["integer", "float"], e).set(["integer", "double"], e).invalidLexicalForm(["integer", "nonlexical"], 2).set(["decimal", "integer"], e).set(["decimal", "decimal"], e).set(["decimal", "float"], e).set(["decimal", "double"], e).invalidLexicalForm(["decimal", "nonlexical"], 2).set(["float", "integer"], e).set(["float", "decimal"], e).set(["float", "float"], e).set(["float", "double"], e).invalidLexicalForm(["float", "nonlexical"], 2).set(["double", "integer"], e).set(["double", "decimal"], e).set(["double", "float"], e).set(["double", "double"], e).invalidLexicalForm(["double", "nonlexical"], 2).invalidLexicalForm(["nonlexical", "integer"], 1).invalidLexicalForm(["nonlexical", "decimal"], 1).invalidLexicalForm(["nonlexical", "float"], 1).invalidLexicalForm(["nonlexical", "double"], 1)
    }
    invalidLexicalForm(e, t) {
      return this.set(e, e => {
        throw new s.InvalidLexicalForm(e[t - 1].toRDF())
      })
    }
    chain(e) {
      return this.implementations = this.implementations.concat(e), this
    }
  }
  t.Builder = c;
  const l = {
    types: [],
    func() {
      throw new s.UnexpectedError("Implementation not set yet declared as implemented")
    }
  };
  class h extends(n.Record(l)) {
    constructor(e) {
      super(e)
    }
    get(e) {
      return super.get(e)
    }
    toPair() {
      return [this.get("types"), this.get("func")]
    }
  }

  function d(e) {
    const t = e.map(e => e.toPair());
    return n.Map(t)
  }

  function p(e) {
    return new i.BooleanLiteral(e)
  }

  function f(e, t) {
    return new i.NumericLiteral(e, a.make(t || o.TypeURL.XSD_FLOAT), void 0)
  }
  t.Impl = h, t.map = d, t.bool = p, t.number = f, t.numberFromString = function(e, t) {
    const r = Number(e);
    return new i.NumericLiteral(r, a.make(t || o.TypeURL.XSD_FLOAT), void 0)
  }, t.string = function(e) {
    return new i.StringLiteral(e)
  }, t.langString = function(e, t) {
    return new i.LangStringLiteral(e, t)
  }, t.dateTime = function(e, t) {
    return new i.DateTimeLiteral(e, t)
  }, t.log = function(e, ...t) {
    return console.log(e, t), e
  }, t.typeCheckLit = function(e, t, r, n) {
    if ("literal" !== e.termType) throw new s.InvalidArgumentTypes(r, n);
    const i = e;
    if (!t.includes(i.type)) throw new s.InvalidArgumentTypes(r, n);
    return i
  }
}, function(e, t, r) {
  "use strict";
  (function(e) {
    r.d(t, "a", (function() {
      return d
    }));
    var n = r(7),
      i = r(189),
      a = r.n(i);
    const {
      xsd: s
    } = n.a;
    var o = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\([^])/g,
      u = {
        "\\": "\\",
        "'": "'",
        '"': '"',
        n: "\n",
        r: "\r",
        t: "\t",
        f: "\f",
        b: "\b",
        _: "_",
        "~": "~",
        ".": ".",
        "-": "-",
        "!": "!",
        $: "$",
        "&": "&",
        "(": "(",
        ")": ")",
        "*": "*",
        "+": "+",
        ",": ",",
        ";": ";",
        "=": "=",
        "/": "/",
        "?": "?",
        "#": "#",
        "@": "@",
        "%": "%"
      },
      c = /[\x00-\x20<>\\"\{\}\|\^\`]/,
      l = {
        _iri: !0,
        _unescapedIri: !0,
        _simpleQuotedString: !0,
        _langcode: !0,
        _blank: !0,
        _newline: !0,
        _comment: !0,
        _whitespace: !0,
        _endOfFile: !0
      },
      h = /$0^/;
    class d {
      constructor(e) {
        if (this._iri = /^<((?:[^ <>{}\\]|\\[uU])+)>[ \t]*/, this._unescapedIri = /^<([^\x00-\x20<>\\"\{\}\|\^\`]*)>[ \t]*/, this._simpleQuotedString = /^"([^"\\\r\n]*)"(?=[^"])/, this._simpleApostropheString = /^'([^'\\\r\n]*)'(?=[^'])/, this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i, this._prefix = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s<])/, this._prefixed = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?:[ \t]+|(?=\.?[,;!\^\s#()\[\]\{\}"'<>]))/, this._variable = /^\?(?:(?:[A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=[.,;!\^\s#()\[\]\{\}"'<>])/, this._blank = /^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?:[ \t]+|(?=\.?[,;:\s#()\[\]\{\}"'<>]))/, this._number = /^[\-+]?(?:(\d+\.\d*|\.?\d+)[eE][\-+]?|\d*(\.)?)\d+(?=\.?[,;:\s#()\[\]\{\}"'<>])/, this._boolean = /^(?:true|false)(?=[.,;\s#()\[\]\{\}"'<>])/, this._keyword = /^@[a-z]+(?=[\s#<:])/i, this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\s#<])/i, this._shortPredicates = /^a(?=[\s()\[\]\{\}"'<>])/, this._newline = /^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/, this._comment = /#([^\n\r]*)/, this._whitespace = /^[ \t]+/, this._endOfFile = /^(?:#[^\n\r]*)?$/, e = e || {}, this._lineMode = !!e.lineMode)
          for (var t in this._n3Mode = !1, this) !(t in l) && this[t] instanceof RegExp && (this[t] = h);
        else this._n3Mode = !1 !== e.n3;
        this._comments = !!e.comments, this._literalClosingPos = 0
      }
      _tokenizeToEnd(e, t) {
        for (var r = this._input, n = this._comments;;) {
          for (var i, a; i = this._newline.exec(r);) n && (a = this._comment.exec(i[0])) && e(null, {
            line: this._line,
            type: "comment",
            value: a[1],
            prefix: ""
          }), r = r.substr(i[0].length, r.length), this._line++;
          if (!i && (i = this._whitespace.exec(r)) && (r = r.substr(i[0].length, r.length)), this._endOfFile.test(r)) return t && (n && (a = this._comment.exec(r)) && e(null, {
            line: this._line,
            type: "comment",
            value: a[1],
            prefix: ""
          }), e(r = null, {
            line: this._line,
            type: "eof",
            value: "",
            prefix: ""
          })), this._input = r;
          var o = this._line,
            u = "",
            l = "",
            h = "",
            d = r[0],
            p = null,
            f = 0,
            g = !1;
          switch (d) {
            case "^":
              if (r.length < 3) break;
              if ("^" !== r[1]) {
                this._n3Mode && (f = 1, u = "^");
                break
              }
              if (this._previousMarker = "^^", "<" !== (r = r.substr(2))[0]) {
                g = !0;
                break
              }
            case "<":
              if (p = this._unescapedIri.exec(r)) u = "IRI", l = p[1];
              else if (p = this._iri.exec(r)) {
                if (null === (l = this._unescape(p[1])) || c.test(l)) return y(this);
                u = "IRI"
              } else r.length > 1 && "<" === r[1] ? (u = "<<", f = 2) : this._n3Mode && r.length > 1 && "=" === r[1] && (u = "inverse", f = 2, l = ">");
              break;
            case ">":
              r.length > 1 && ">" === r[1] && (u = ">>", f = 2);
              break;
            case "_":
              ((p = this._blank.exec(r)) || t && (p = this._blank.exec(r + " "))) && (u = "blank", h = "_", l = p[1]);
              break;
            case '"':
              if (p = this._simpleQuotedString.exec(r)) l = p[1];
              else if (({
                value: l,
                matchLength: f
              } = this._parseLiteral(r)), null === l) return y(this);
              null === p && 0 === f || (u = "literal", this._literalClosingPos = 0);
              break;
            case "'":
              if (!this._lineMode) {
                if (p = this._simpleApostropheString.exec(r)) l = p[1];
                else if (({
                  value: l,
                  matchLength: f
                } = this._parseLiteral(r)), null === l) return y(this);
                null === p && 0 === f || (u = "literal", this._literalClosingPos = 0)
              }
              break;
            case "?":
              this._n3Mode && (p = this._variable.exec(r)) && (u = "var", l = p[0]);
              break;
            case "@":
              "literal" === this._previousMarker && (p = this._langcode.exec(r)) ? (u = "langcode", l = p[1]) : (p = this._keyword.exec(r)) && (u = p[0]);
              break;
            case ".":
              if (1 === r.length ? t : r[1] < "0" || r[1] > "9") {
                u = ".", f = 1;
                break
              }
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
            case "+":
            case "-":
              (p = this._number.exec(r) || t && (p = this._number.exec(r + " "))) && (u = "literal", l = p[0], h = "string" == typeof p[1] ? s.double : "string" == typeof p[2] ? s.decimal : s.integer);
              break;
            case "B":
            case "b":
            case "p":
            case "P":
            case "G":
            case "g":
              (p = this._sparqlKeyword.exec(r)) ? u = p[0].toUpperCase(): g = !0;
              break;
            case "f":
            case "t":
              (p = this._boolean.exec(r)) ? (u = "literal", l = p[0], h = s.boolean) : g = !0;
              break;
            case "a":
              (p = this._shortPredicates.exec(r)) ? (u = "abbreviation", l = "a") : g = !0;
              break;
            case "=":
              this._n3Mode && r.length > 1 && (u = "abbreviation", ">" !== r[1] ? (f = 1, l = "=") : (f = 2, l = ">"));
              break;
            case "!":
              if (!this._n3Mode) break;
            case ",":
            case ";":
            case "[":
            case "]":
            case "(":
            case ")":
            case "{":
            case "}":
              this._lineMode || (f = 1, u = d);
              break;
            default:
              g = !0
          }
          if (g && ("@prefix" !== this._previousMarker && "PREFIX" !== this._previousMarker || !(p = this._prefix.exec(r)) ? ((p = this._prefixed.exec(r)) || t && (p = this._prefixed.exec(r + " "))) && (u = "prefixed", h = p[1] || "", l = this._unescape(p[2])) : (u = "prefix", l = p[1] || "")), "^^" === this._previousMarker) switch (u) {
            case "prefixed":
              u = "type";
              break;
            case "IRI":
              u = "typeIRI";
              break;
            default:
              u = ""
          }
          if (!u) return t || !/^'''|^"""/.test(r) && /\n|\r/.test(r) ? y(this) : this._input = r;
          var m = {
            line: o,
            type: u,
            value: l,
            prefix: h
          };
          e(null, m), this.previousToken = m, this._previousMarker = u, r = r.substr(f || p[0].length, r.length)
        }

        function y(t) {
          e(t._syntaxError(/^\S*/.exec(r)[0]))
        }
      }
      _unescape(e) {
        let t = !1;
        const r = e.replace(o, (e, r, n, i) => {
          if ("string" == typeof r) return String.fromCharCode(Number.parseInt(r, 16));
          if ("string" == typeof n) {
            let e = Number.parseInt(n, 16);
            return e <= 65535 ? String.fromCharCode(Number.parseInt(n, 16)) : String.fromCharCode(55296 + ((e -= 65536) >> 10), 56320 + (1023 & e))
          }
          return i in u ? u[i] : (t = !0, "")
        });
        return t ? null : r
      }
      _parseLiteral(e) {
        if (e.length >= 3) {
          const t = e.match(/^(?:"""|"|'''|'|)/)[0],
            r = t.length;
          let n = Math.max(this._literalClosingPos, r);
          for (;
            (n = e.indexOf(t, n)) > 0;) {
            let t = 0;
            for (;
              "\\" === e[n - t - 1];) t++;
            if (t % 2 == 0) {
              const t = e.substring(r, n),
                i = t.split(/\r\n|\r|\n/).length - 1,
                a = n + r;
              if (1 === r && 0 !== i || 3 === r && this._lineMode) break;
              return this._line += i, {
                value: this._unescape(t),
                matchLength: a
              }
            }
            n++
          }
          this._literalClosingPos = e.length - r + 1
        }
        return {
          value: "",
          matchLength: 0
        }
      }
      _syntaxError(e) {
        this._input = null;
        var t = new Error('Unexpected "' + e + '" on line ' + this._line + ".");
        return t.context = {
          token: void 0,
          line: this._line,
          previousToken: this.previousToken
        }, t
      }
      tokenize(t, r) {
        var n = this;
        if (this._line = 1, "string" == typeof t) {
          if (this._input = t, "function" != typeof r) {
            var i, s = [];
            if (this._tokenizeToEnd((function(e, t) {
              e ? i = e : s.push(t)
            }), !0), i) throw i;
            return s
          }
          a()(() => n._tokenizeToEnd(r, !0))
        } else this._input = "", this._pendingBuffer = null, "function" == typeof t.setEncoding && t.setEncoding("utf8"), t.on("data", (function(t) {
          null !== n._input && 0 !== t.length && (n._pendingBuffer && (t = e.concat([n._pendingBuffer, t]), n._pendingBuffer = null), 128 & t[t.length - 1] ? n._pendingBuffer = t : (n._input += t, n._tokenizeToEnd(r, !1)))
        })), t.on("end", (function() {
          null !== n._input && n._tokenizeToEnd(r, !0)
        })), t.on("error", r)
      }
    }
  }).call(this, r(11).Buffer)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NamedNode = void 0;
  t.NamedNode = class {
    constructor(e) {
      this.termType = "NamedNode", this.value = e
    }
    equals(e) {
      return !!e && "NamedNode" === e.termType && e.value === this.value
    }
  }
}, function(e, t, r) {
  "use strict";
  var n = r(31).codes.ERR_STREAM_PREMATURE_CLOSE;

  function i() {}
  e.exports = function e(t, r, a) {
    if ("function" == typeof r) return e(t, null, r);
    r || (r = {}), a = function(e) {
      var t = !1;
      return function() {
        if (!t) {
          t = !0;
          for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++) n[i] = arguments[i];
          e.apply(this, n)
        }
      }
    }(a || i);
    var s = r.readable || !1 !== r.readable && t.readable,
      o = r.writable || !1 !== r.writable && t.writable,
      u = function() {
        t.writable || l()
      },
      c = t._writableState && t._writableState.finished,
      l = function() {
        o = !1, c = !0, s || a.call(t)
      },
      h = t._readableState && t._readableState.endEmitted,
      d = function() {
        s = !1, h = !0, o || a.call(t)
      },
      p = function(e) {
        a.call(t, e)
      },
      f = function() {
        var e;
        return s && !h ? (t._readableState && t._readableState.ended || (e = new n), a.call(t, e)) : o && !c ? (t._writableState && t._writableState.ended || (e = new n), a.call(t, e)) : void 0
      },
      g = function() {
        t.req.on("finish", l)
      };
    return ! function(e) {
      return e.setHeader && "function" == typeof e.abort
    }(t) ? o && !t._writableState && (t.on("end", u), t.on("close", u)) : (t.on("complete", l), t.on("abort", f), t.req ? g() : t.on("request", g)), t.on("end", d), t.on("finish", l), !1 !== r.error && t.on("error", p), t.on("close", f),
      function() {
        t.removeListener("complete", l), t.removeListener("abort", f), t.removeListener("request", g), t.req && t.req.removeListener("finish", l), t.removeListener("end", u), t.removeListener("close", u), t.removeListener("finish", l), t.removeListener("end", d), t.removeListener("error", p), t.removeListener("close", f)
      }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  const n = r(52),
    i = r(53);
  class a {
    static flatten(e) {
      return Array.prototype.concat(...e).filter(e => e)
    }
    static inScopeVariables(e) {
      const t = [];

      function r(e) {
        t.find(t => e.value === t.value) || t.push(e)
      }

      function i(e) {
        "Variable" === e.subject.termType && r(e.subject), "Variable" === e.predicate.termType && r(e.predicate), "Variable" === e.object.termType && r(e.object), "Variable" === e.graph.termType && r(e.graph), "Quad" === e.subject.termType && i(e.subject), "Quad" === e.predicate.termType && i(e.predicate), "Quad" === e.object.termType && i(e.object), "Quad" === e.graph.termType && i(e.graph)
      }
      return a.recurseOperation(e, {
        [n.types.EXPRESSION]: e => {
          let t = e;
          if ("aggregate" === t.expressionType && t.variable) {
            r(t.variable)
          }
          return !0
        },
        [n.types.EXTEND]: e => (r(e.variable), !0),
        [n.types.GRAPH]: e => {
          let t = e;
          return "Variable" === t.name.termType && r(t.name), !0
        },
        [n.types.GROUP]: e => (e.variables.forEach(r), !0),
        [n.types.PATH]: e => {
          let t = e;
          return "Variable" === t.subject.termType && r(t.subject), "Variable" === t.object.termType && r(t.object), "Variable" === t.graph.termType && r(t.graph), "Quad" === t.subject.termType && i(t.subject), "Quad" === t.object.termType && i(t.object), "Quad" === t.graph.termType && i(t.graph), !0
        },
        [n.types.PATTERN]: e => (i(e), !0),
        [n.types.PROJECT]: e => (e.variables.forEach(r), !1),
        [n.types.SERVICE]: e => {
          let t = e;
          return "Variable" === t.name.termType && r(t.name), !0
        },
        [n.types.VALUES]: e => (e.variables.forEach(r), !0)
      }), t
    }
    static recurseOperation(e, t) {
      let r = e,
        i = !0;
      if (t[e.type] && (i = t[e.type](e)), !i) return;
      let s = e => a.recurseOperation(e, t);
      switch (r.type) {
        case n.types.ALT:
          const e = r;
          s(e.left), s(e.right);
          break;
        case n.types.ASK:
          s(r.input);
          break;
        case n.types.BGP:
          r.patterns.forEach(s);
          break;
        case n.types.CONSTRUCT:
          const t = r;
          s(t.input), t.template.map(s);
          break;
        case n.types.DESCRIBE:
          s(r.input);
          break;
        case n.types.DISTINCT:
          s(r.input);
          break;
        case n.types.EXPRESSION:
          const i = r;
          if (i.expressionType === n.expressionTypes.EXISTENCE) {
            s(i.input)
          }
          break;
        case n.types.EXTEND:
          const a = r;
          s(a.input), s(a.expression);
          break;
        case n.types.FILTER:
          const o = r;
          s(o.input), s(o.expression);
          break;
        case n.types.FROM:
          s(r.input);
          break;
        case n.types.GRAPH:
          s(r.input);
          break;
        case n.types.GROUP:
          const u = r;
          s(u.input), u.aggregates.forEach(s);
          break;
        case n.types.INV:
          s(r.path);
          break;
        case n.types.JOIN:
          const c = r;
          s(c.left), s(c.right);
          break;
        case n.types.LEFT_JOIN:
          const l = r;
          s(l.left), s(l.right), l.expression && s(l.expression);
          break;
        case n.types.LINK:
          break;
        case n.types.MINUS:
          const h = r;
          s(h.left), s(h.right);
          break;
        case n.types.NPS:
          break;
        case n.types.ONE_OR_MORE_PATH:
          s(r.path);
          break;
        case n.types.ORDER_BY:
          const d = r;
          s(d.input), d.expressions.forEach(s);
          break;
        case n.types.PATH:
          s(r.predicate);
          break;
        case n.types.PATTERN:
          break;
        case n.types.PROJECT:
          s(r.input);
          break;
        case n.types.REDUCED:
          s(r.input);
          break;
        case n.types.SEQ:
          const p = r;
          s(p.left), s(p.right);
          break;
        case n.types.SERVICE:
          s(r.input);
          break;
        case n.types.SLICE:
          s(r.input);
          break;
        case n.types.UNION:
          const f = r;
          s(f.left), s(f.right);
          break;
        case n.types.VALUES:
          break;
        case n.types.ZERO_OR_MORE_PATH:
          s(r.path);
          break;
        case n.types.ZERO_OR_ONE_PATH:
          s(r.path);
          break;
        case n.types.COMPOSITE_UPDATE:
          r.updates.forEach(e => s(e));
          break;
        case n.types.DELETE_INSERT:
          const g = r;
          g.delete && g.delete.forEach(e => s(e)), g.insert && g.insert.forEach(e => s(e)), g.where && s(g.where);
          break;
        case n.types.LOAD:
        case n.types.CLEAR:
        case n.types.CREATE:
        case n.types.DROP:
        case n.types.ADD:
        case n.types.MOVE:
        case n.types.COPY:
          break;
        default:
          throw new Error("Unknown Operation type " + r.type)
      }
    }
    static mapOperation(e, t, r) {
      let s = e,
        o = !0;
      if (r = r || new i.default, t[e.type] && ({
        result: s,
        recurse: o
      } = t[e.type](e, r)), !o) return s;
      let u = e => a.mapOperation(e, t, r);
      switch (s.type) {
        case n.types.ALT:
          const e = s;
          return r.createAlt(u(e.left), u(e.right));
        case n.types.ASK:
          const i = s;
          return r.createAsk(u(i.input));
        case n.types.BGP:
          const o = s;
          return r.createBgp(o.patterns.map(u));
        case n.types.CONSTRUCT:
          const c = s;
          return r.createConstruct(u(c.input), c.template.map(u));
        case n.types.DESCRIBE:
          const l = s;
          return r.createDescribe(u(l.input), l.terms);
        case n.types.DISTINCT:
          const h = s;
          return r.createDistinct(u(h.input));
        case n.types.EXPRESSION:
          const d = s;
          return a.mapExpression(d, t, r);
        case n.types.EXTEND:
          const p = s;
          return r.createExtend(u(p.input), p.variable, u(p.expression));
        case n.types.FILTER:
          const f = s;
          return r.createFilter(u(f.input), u(f.expression));
        case n.types.FROM:
          const g = s;
          return r.createFrom(u(g.input), [].concat(g.default), [].concat(g.named));
        case n.types.GRAPH:
          const m = s;
          return r.createGraph(u(m.input), m.name);
        case n.types.GROUP:
          const y = s;
          return r.createGroup(u(y.input), [].concat(y.variables), y.aggregates.map(u));
        case n.types.INV:
          const b = s;
          return r.createInv(u(b.path));
        case n.types.JOIN:
          const _ = s;
          return r.createJoin(u(_.left), u(_.right));
        case n.types.LEFT_JOIN:
          const v = s;
          return r.createLeftJoin(u(v.left), u(v.right), v.expression ? u(v.expression) : void 0);
        case n.types.LINK:
          const w = s;
          return r.createLink(w.iri);
        case n.types.MINUS:
          const S = s;
          return r.createMinus(u(S.left), u(S.right));
        case n.types.NPS:
          const T = s;
          return r.createNps([].concat(T.iris));
        case n.types.ONE_OR_MORE_PATH:
          const E = s;
          return r.createOneOrMorePath(u(E.path));
        case n.types.ORDER_BY:
          const x = s;
          return r.createOrderBy(u(x.input), x.expressions.map(u));
        case n.types.PATH:
          const O = s;
          return r.createPath(O.subject, u(O.predicate), O.object, O.graph);
        case n.types.PATTERN:
          const A = s;
          return r.createPattern(A.subject, A.predicate, A.object, A.graph);
        case n.types.PROJECT:
          const R = s;
          return r.createProject(u(R.input), [].concat(R.variables));
        case n.types.REDUCED:
          const I = s;
          return r.createReduced(u(I.input));
        case n.types.SEQ:
          const N = s;
          return r.createSeq(u(N.left), u(N.right));
        case n.types.SERVICE:
          const P = s;
          return r.createService(u(P.input), P.name, P.silent);
        case n.types.SLICE:
          const C = s;
          return r.createSlice(u(C.input), C.start, C.length);
        case n.types.UNION:
          const D = s;
          return r.createUnion(u(D.left), u(D.right));
        case n.types.VALUES:
          const j = s;
          return r.createValues([].concat(j.variables), j.bindings.map(e => Object.assign({}, e)));
        case n.types.ZERO_OR_MORE_PATH:
          const k = s;
          return r.createZeroOrMorePath(u(k.path));
        case n.types.ZERO_OR_ONE_PATH:
          const L = s;
          return r.createZeroOrOnePath(u(L.path));
        case n.types.COMPOSITE_UPDATE:
          const M = s;
          return r.createCompositeUpdate(M.updates.map(u));
        case n.types.DELETE_INSERT:
          const F = s;
          return r.createDeleteInsert(F.delete ? F.delete.map(u) : void 0, F.insert ? F.insert.map(u) : void 0, F.where ? u(F.where) : void 0);
        case n.types.LOAD:
          const B = s;
          return r.createLoad(B.source, B.destination, B.silent);
        case n.types.CLEAR:
          const q = s;
          return r.createClear(q.source, q.silent);
        case n.types.CREATE:
          const U = s;
          return r.createCreate(U.source, U.silent);
        case n.types.DROP:
          const V = s;
          return r.createDrop(V.source, V.silent);
        case n.types.ADD:
          const H = s;
          return r.createAdd(H.source, H.destination);
        case n.types.MOVE:
          const G = s;
          return r.createMove(G.source, G.destination);
        case n.types.COPY:
          const z = s;
          return r.createCopy(z.source, z.destination);
        default:
          throw new Error("Unknown Operation type " + s)
      }
    }
    static mapExpression(e, t, r) {
      let i = e => a.mapOperation(e, t, r);
      switch (e.expressionType) {
        case n.expressionTypes.AGGREGATE:
          if (e.variable) {
            const t = e;
            return r.createBoundAggregate(t.variable, t.aggregator, i(t.expression), t.distinct, t.separator)
          }
          const t = e;
          return r.createAggregateExpression(t.aggregator, i(t.expression), t.distinct, t.separator);
        case n.expressionTypes.EXISTENCE:
          const a = e;
          return r.createExistenceExpression(a.not, i(a.input));
        case n.expressionTypes.NAMED:
          const s = e;
          return r.createNamedExpression(s.name, s.args.map(i));
        case n.expressionTypes.OPERATOR:
          const o = e;
          return r.createOperatorExpression(o.operator, o.args.map(i));
        case n.expressionTypes.TERM:
          const u = e;
          return r.createTermExpression(u.term);
        case n.expressionTypes.WILDCARD:
          return r.createWildcardExpression();
        default:
          throw new Error("Unknown Expression type " + e.expressionType)
      }
    }
    static createUniqueVariable(e, t, r) {
      let n = 0,
        i = e;
      for (; t[i];) i = e + n++;
      return r.variable(i)
    }
    static isTerm(e) {
      return void 0 !== e.termType && "Quad" !== e.termType && "Wildcard" !== e.termType
    }
    static isWildcard(e) {
      return "Wildcard" === e.termType
    }
  }
  t.default = a
}, function(e, t, r) {
  (t = e.exports = r(115)).Stream = t, t.Readable = t, t.Writable = r(73), t.Duplex = r(25), t.Transform = r(118), t.PassThrough = r(223)
}, function(e, t, r) {
  var n = r(11),
    i = n.Buffer;

  function a(e, t) {
    for (var r in e) t[r] = e[r]
  }

  function s(e, t, r) {
    return i(e, t, r)
  }
  i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = n : (a(n, t), t.Buffer = s), a(i, s), s.from = function(e, t, r) {
    if ("number" == typeof e) throw new TypeError("Argument must not be a number");
    return i(e, t, r)
  }, s.alloc = function(e, t, r) {
    if ("number" != typeof e) throw new TypeError("Argument must be a number");
    var n = i(e);
    return void 0 !== t ? "string" == typeof r ? n.fill(t, r) : n.fill(t) : n.fill(0), n
  }, s.allocUnsafe = function(e) {
    if ("number" != typeof e) throw new TypeError("Argument must be a number");
    return i(e)
  }, s.allocUnsafeSlow = function(e) {
    if ("number" != typeof e) throw new TypeError("Argument must be a number");
    return n.SlowBuffer(e)
  }
}, function(e, t, r) {
  "use strict";
  (function(t, n, i) {
    var a = r(54);

    function s(e) {
      var t = this;
      this.next = null, this.entry = null, this.finish = function() {
        ! function(e, t, r) {
          var n = e.entry;
          e.entry = null;
          for (; n;) {
            var i = n.callback;
            t.pendingcb--, i(r), n = n.next
          }
          t.corkedRequestsFree ? t.corkedRequestsFree.next = e : t.corkedRequestsFree = e
        }(t, e)
      }
    }
    e.exports = b;
    var o, u = !t.browser && ["v0.10", "v0.9."].indexOf(t.version.slice(0, 5)) > -1 ? n : a.nextTick;
    b.WritableState = y;
    var c = Object.create(r(43));
    c.inherits = r(12);
    var l = {
        deprecate: r(109)
      },
      h = r(116),
      d = r(72).Buffer,
      p = i.Uint8Array || function() {};
    var f, g = r(117);

    function m() {}

    function y(e, t) {
      o = o || r(25), e = e || {};
      var n = t instanceof o;
      this.objectMode = !!e.objectMode, n && (this.objectMode = this.objectMode || !!e.writableObjectMode);
      var i = e.highWaterMark,
        c = e.writableHighWaterMark,
        l = this.objectMode ? 16 : 16384;
      this.highWaterMark = i || 0 === i ? i : n && (c || 0 === c) ? c : l, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
      var h = !1 === e.decodeStrings;
      this.decodeStrings = !h, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(e) {
        ! function(e, t) {
          var r = e._writableState,
            n = r.sync,
            i = r.writecb;
          if (function(e) {
            e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0
          }(r), t) ! function(e, t, r, n, i) {
            --t.pendingcb, r ? (a.nextTick(i, n), a.nextTick(E, e, t), e._writableState.errorEmitted = !0, e.emit("error", n)) : (i(n), e._writableState.errorEmitted = !0, e.emit("error", n), E(e, t))
          }(e, r, n, t, i);
          else {
            var s = S(r);
            s || r.corked || r.bufferProcessing || !r.bufferedRequest || w(e, r), n ? u(v, e, r, s, i) : v(e, r, s, i)
          }
        }(t, e)
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new s(this)
    }

    function b(e) {
      if (o = o || r(25), !(f.call(b, this) || this instanceof o)) return new b(e);
      this._writableState = new y(e, this), this.writable = !0, e && ("function" == typeof e.write && (this._write = e.write), "function" == typeof e.writev && (this._writev = e.writev), "function" == typeof e.destroy && (this._destroy = e.destroy), "function" == typeof e.final && (this._final = e.final)), h.call(this)
    }

    function _(e, t, r, n, i, a, s) {
      t.writelen = n, t.writecb = s, t.writing = !0, t.sync = !0, r ? e._writev(i, t.onwrite) : e._write(i, a, t.onwrite), t.sync = !1
    }

    function v(e, t, r, n) {
      r || function(e, t) {
        0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain"))
      }(e, t), t.pendingcb--, n(), E(e, t)
    }

    function w(e, t) {
      t.bufferProcessing = !0;
      var r = t.bufferedRequest;
      if (e._writev && r && r.next) {
        var n = t.bufferedRequestCount,
          i = new Array(n),
          a = t.corkedRequestsFree;
        a.entry = r;
        for (var o = 0, u = !0; r;) i[o] = r, r.isBuf || (u = !1), r = r.next, o += 1;
        i.allBuffers = u, _(e, t, !0, t.length, i, "", a.finish), t.pendingcb++, t.lastBufferedRequest = null, a.next ? (t.corkedRequestsFree = a.next, a.next = null) : t.corkedRequestsFree = new s(t), t.bufferedRequestCount = 0
      } else {
        for (; r;) {
          var c = r.chunk,
            l = r.encoding,
            h = r.callback;
          if (_(e, t, !1, t.objectMode ? 1 : c.length, c, l, h), r = r.next, t.bufferedRequestCount--, t.writing) break
        }
        null === r && (t.lastBufferedRequest = null)
      }
      t.bufferedRequest = r, t.bufferProcessing = !1
    }

    function S(e) {
      return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing
    }

    function T(e, t) {
      e._final((function(r) {
        t.pendingcb--, r && e.emit("error", r), t.prefinished = !0, e.emit("prefinish"), E(e, t)
      }))
    }

    function E(e, t) {
      var r = S(t);
      return r && (! function(e, t) {
        t.prefinished || t.finalCalled || ("function" == typeof e._final ? (t.pendingcb++, t.finalCalled = !0, a.nextTick(T, e, t)) : (t.prefinished = !0, e.emit("prefinish")))
      }(e, t), 0 === t.pendingcb && (t.finished = !0, e.emit("finish"))), r
    }
    c.inherits(b, h), y.prototype.getBuffer = function() {
      for (var e = this.bufferedRequest, t = []; e;) t.push(e), e = e.next;
      return t
    },
      function() {
        try {
          Object.defineProperty(y.prototype, "buffer", {
            get: l.deprecate((function() {
              return this.getBuffer()
            }), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          })
        } catch (e) {}
      }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (f = Function.prototype[Symbol.hasInstance], Object.defineProperty(b, Symbol.hasInstance, {
      value: function(e) {
        return !!f.call(this, e) || this === b && (e && e._writableState instanceof y)
      }
    })) : f = function(e) {
      return e instanceof this
    }, b.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"))
    }, b.prototype.write = function(e, t, r) {
      var n, i = this._writableState,
        s = !1,
        o = !i.objectMode && (n = e, d.isBuffer(n) || n instanceof p);
      return o && !d.isBuffer(e) && (e = function(e) {
        return d.from(e)
      }(e)), "function" == typeof t && (r = t, t = null), o ? t = "buffer" : t || (t = i.defaultEncoding), "function" != typeof r && (r = m), i.ended ? function(e, t) {
        var r = new Error("write after end");
        e.emit("error", r), a.nextTick(t, r)
      }(this, r) : (o || function(e, t, r, n) {
        var i = !0,
          s = !1;
        return null === r ? s = new TypeError("May not write null values to stream") : "string" == typeof r || void 0 === r || t.objectMode || (s = new TypeError("Invalid non-string/buffer chunk")), s && (e.emit("error", s), a.nextTick(n, s), i = !1), i
      }(this, i, e, r)) && (i.pendingcb++, s = function(e, t, r, n, i, a) {
        if (!r) {
          var s = function(e, t, r) {
            e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = d.from(t, r));
            return t
          }(t, n, i);
          n !== s && (r = !0, i = "buffer", n = s)
        }
        var o = t.objectMode ? 1 : n.length;
        t.length += o;
        var u = t.length < t.highWaterMark;
        u || (t.needDrain = !0);
        if (t.writing || t.corked) {
          var c = t.lastBufferedRequest;
          t.lastBufferedRequest = {
            chunk: n,
            encoding: i,
            isBuf: r,
            callback: a,
            next: null
          }, c ? c.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1
        } else _(e, t, !1, o, n, i, a);
        return u
      }(this, i, o, e, t, r)), s
    }, b.prototype.cork = function() {
      this._writableState.corked++
    }, b.prototype.uncork = function() {
      var e = this._writableState;
      e.corked && (e.corked--, e.writing || e.corked || e.finished || e.bufferProcessing || !e.bufferedRequest || w(this, e))
    }, b.prototype.setDefaultEncoding = function(e) {
      if ("string" == typeof e && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + e);
      return this._writableState.defaultEncoding = e, this
    }, Object.defineProperty(b.prototype, "writableHighWaterMark", {
      enumerable: !1,
      get: function() {
        return this._writableState.highWaterMark
      }
    }), b.prototype._write = function(e, t, r) {
      r(new Error("_write() is not implemented"))
    }, b.prototype._writev = null, b.prototype.end = function(e, t, r) {
      var n = this._writableState;
      "function" == typeof e ? (r = e, e = null, t = null) : "function" == typeof t && (r = t, t = null), null != e && this.write(e, t), n.corked && (n.corked = 1, this.uncork()), n.ending || n.finished || function(e, t, r) {
        t.ending = !0, E(e, t), r && (t.finished ? a.nextTick(r) : e.once("finish", r));
        t.ended = !0, e.writable = !1
      }(this, n, r)
    }, Object.defineProperty(b.prototype, "destroyed", {
      get: function() {
        return void 0 !== this._writableState && this._writableState.destroyed
      },
      set: function(e) {
        this._writableState && (this._writableState.destroyed = e)
      }
    }), b.prototype.destroy = g.destroy, b.prototype._undestroy = g.undestroy, b.prototype._destroy = function(e, t) {
      this.end(), t(e)
    }
  }).call(this, r(8), r(44).setImmediate, r(10))
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(238), t), i(r(122), t)
}, function(e, t, r) {
  "use strict";
  (function(e) {
    var n = r(123),
      i = r(239),
      a = e.from && e.from !== Uint8Array.from;

    function s(e, t) {
      return "string" == typeof e ? t == e : e && "function" == typeof e.exec ? e.exec(t) : "boolean" == typeof e || "object" == typeof e ? e : "function" == typeof e && e(t)
    }
    t.parse = function(t, r) {
      var o, u, c = new n,
        l = i((function(t) {
          "string" == typeof t && (t = a ? e.from(t) : new e(t)), c.write(t)
        }), (function(e) {
          e && l.write(e), o && l.emit("header", o), u && l.emit("footer", u), l.queue(null)
        }));
      "string" == typeof t && (t = t.split(".").map((function(e) {
        return "$*" === e ? {
          emitKey: !0
        } : "*" === e || ("" === e ? {
          recurse: !0
        } : e)
      })));
      return t && t.length || (t = null), c.onValue = function(e) {
        if (this.root || (l.root = e), t) {
          for (var n = 0, i = 0, a = !1, u = !1; n < t.length;) {
            var c, d = t[n];
            if (i++, d && !d.recurse) {
              if (!(c = i === this.stack.length ? this : this.stack[i])) return;
              if (!s(d, c.key)) return void h(c.key, e);
              a = !!d.emitKey, u = !!d.emitPath, n++
            } else {
              n++;
              var p = t[n];
              if (!p) return;
              for (;;) {
                if (!(c = i === this.stack.length ? this : this.stack[i])) return;
                if (s(p, c.key)) {
                  n++, Object.isFrozen(this.stack[i]) || (this.stack[i].value = null);
                  break
                }
                h(c.key, e), i++
              }
            }
          }
          if (o && (l.emit("header", o), o = !1), i === this.stack.length) {
            0;
            var f = this.stack.slice(1).map((function(e) {
                return e.key
              })).concat([this.key]),
              g = e;
            for (var m in null != g && null != (g = r ? r(g, f) : g) && ((a || u) && (g = {
              value: g
            }, a && (g.key = this.key), u && (g.path = f)), l.queue(g)), this.value && delete this.value[this.key], this.stack) Object.isFrozen(this.stack[m]) || (this.stack[m].value = null)
          }
        }
      }, c._onToken = c.onToken, c.onToken = function(e, r) {
        c._onToken(e, r), 0 === this.stack.length && l.root && (t || l.queue(l.root), 0, l.root = null)
      }, c.onError = function(e) {
        e.message.indexOf("at position") > -1 && (e.message = "Invalid JSON (" + e.message + ")"), l.emit("error", e)
      }, l;

      function h(e, t) {
        !1 !== o && ((o = o || {})[e] = t), !1 !== u && !1 === o && ((u = u || {})[e] = t)
      }
    }, t.stringify = function(e, t, r, n) {
      n = n || 0, !1 === e ? (e = "", t = "\n", r = "") : null == e && (e = "[\n", t = "\n,\n", r = "\n]\n");
      var a, s = !0,
        o = !1;
      return a = i((function(r) {
        o = !0;
        try {
          var i = JSON.stringify(r, null, n)
        } catch (e) {
          return a.emit("error", e)
        }
        s ? (s = !1, a.queue(e + i)) : a.queue(t + i)
      }), (function(t) {
        o || a.queue(e), a.queue(r), a.queue(null)
      }))
    }, t.stringifyObject = function(e, t, r, n) {
      n = n || 0, !1 === e ? (e = "", t = "\n", r = "") : null == e && (e = "{\n", t = "\n,\n", r = "\n}\n");
      var a = !0,
        s = !1;
      return i((function(r) {
        s = !0;
        var i = JSON.stringify(r[0]) + ":" + JSON.stringify(r[1], null, n);
        a ? (a = !1, this.queue(e + i)) : this.queue(t + i)
      }), (function(t) {
        s || this.queue(e), this.queue(r), this.queue(null)
      }))
    }
  }).call(this, r(11).Buffer)
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(243), t)
}, function(e, t, r) {
  "use strict";
  var n = this && this.__importDefault || function(e) {
    return e && e.__esModule ? e : {
      default: e
    }
  };
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  var i = n(r(289));
  t.default = function(e) {
    if (e >= 55296 && e <= 57343 || e > 1114111) return "�";
    e in i.default && (e = i.default[e]);
    var t = "";
    return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | 1023 & e), t += String.fromCharCode(e)
  }
}, function(e) {
  e.exports = JSON.parse('{"Aacute":"Á","aacute":"á","Acirc":"Â","acirc":"â","acute":"´","AElig":"Æ","aelig":"æ","Agrave":"À","agrave":"à","amp":"&","AMP":"&","Aring":"Å","aring":"å","Atilde":"Ã","atilde":"ã","Auml":"Ä","auml":"ä","brvbar":"¦","Ccedil":"Ç","ccedil":"ç","cedil":"¸","cent":"¢","copy":"©","COPY":"©","curren":"¤","deg":"°","divide":"÷","Eacute":"É","eacute":"é","Ecirc":"Ê","ecirc":"ê","Egrave":"È","egrave":"è","ETH":"Ð","eth":"ð","Euml":"Ë","euml":"ë","frac12":"½","frac14":"¼","frac34":"¾","gt":">","GT":">","Iacute":"Í","iacute":"í","Icirc":"Î","icirc":"î","iexcl":"¡","Igrave":"Ì","igrave":"ì","iquest":"¿","Iuml":"Ï","iuml":"ï","laquo":"«","lt":"<","LT":"<","macr":"¯","micro":"µ","middot":"·","nbsp":" ","not":"¬","Ntilde":"Ñ","ntilde":"ñ","Oacute":"Ó","oacute":"ó","Ocirc":"Ô","ocirc":"ô","Ograve":"Ò","ograve":"ò","ordf":"ª","ordm":"º","Oslash":"Ø","oslash":"ø","Otilde":"Õ","otilde":"õ","Ouml":"Ö","ouml":"ö","para":"¶","plusmn":"±","pound":"£","quot":"\\"","QUOT":"\\"","raquo":"»","reg":"®","REG":"®","sect":"§","shy":"­","sup1":"¹","sup2":"²","sup3":"³","szlig":"ß","THORN":"Þ","thorn":"þ","times":"×","Uacute":"Ú","uacute":"ú","Ucirc":"Û","ucirc":"û","Ugrave":"Ù","ugrave":"ù","uml":"¨","Uuml":"Ü","uuml":"ü","Yacute":"Ý","yacute":"ý","yen":"¥","yuml":"ÿ"}')
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.RDFA_CONTENTTYPES = t.RDFA_FEATURES = void 0, t.RDFA_FEATURES = {
    "": {
      baseTag: !0,
      xmlBase: !0,
      langAttribute: !0,
      onlyAllowUriRelRevIfProperty: !0,
      inheritSubjectInHeadBody: !0,
      datetimeAttribute: !0,
      timeTag: !0,
      htmlDatatype: !0,
      copyRdfaPatterns: !0,
      xmlnsPrefixMappings: !0,
      xhtmlInitialContext: !0,
      roleAttribute: !0
    },
    core: {
      baseTag: !1,
      xmlBase: !1,
      langAttribute: !0,
      onlyAllowUriRelRevIfProperty: !0,
      inheritSubjectInHeadBody: !1,
      datetimeAttribute: !1,
      timeTag: !1,
      htmlDatatype: !1,
      copyRdfaPatterns: !0,
      xmlnsPrefixMappings: !0,
      xhtmlInitialContext: !1,
      roleAttribute: !1
    },
    html: {
      baseTag: !0,
      xmlBase: !1,
      langAttribute: !0,
      onlyAllowUriRelRevIfProperty: !0,
      inheritSubjectInHeadBody: !0,
      datetimeAttribute: !0,
      timeTag: !0,
      htmlDatatype: !0,
      copyRdfaPatterns: !0,
      xmlnsPrefixMappings: !0,
      xhtmlInitialContext: !1,
      roleAttribute: !0
    },
    xhtml: {
      baseTag: !0,
      xmlBase: !1,
      langAttribute: !0,
      onlyAllowUriRelRevIfProperty: !0,
      inheritSubjectInHeadBody: !0,
      datetimeAttribute: !0,
      timeTag: !0,
      htmlDatatype: !0,
      copyRdfaPatterns: !0,
      xmlnsPrefixMappings: !0,
      xhtmlInitialContext: !0,
      roleAttribute: !0
    },
    xml: {
      baseTag: !1,
      xmlBase: !0,
      langAttribute: !0,
      onlyAllowUriRelRevIfProperty: !1,
      inheritSubjectInHeadBody: !1,
      datetimeAttribute: !0,
      timeTag: !0,
      htmlDatatype: !1,
      copyRdfaPatterns: !1,
      xmlnsPrefixMappings: !0,
      xhtmlInitialContext: !1,
      roleAttribute: !0
    }
  }, t.RDFA_CONTENTTYPES = {
    "text/html": "html",
    "application/xhtml+xml": "xhtml",
    "application/xml": "xml",
    "text/xml": "xml",
    "image/svg+xml": "xml"
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__importDefault || function(e) {
    return e && e.__esModule ? e : {
      default: e
    }
  };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Parser = void 0;
  var i = n(r(140)),
    a = new Set(["input", "option", "optgroup", "select", "button", "datalist", "textarea"]),
    s = new Set(["p"]),
    o = {
      tr: new Set(["tr", "th", "td"]),
      th: new Set(["th"]),
      td: new Set(["thead", "th", "td"]),
      body: new Set(["head", "link", "script"]),
      li: new Set(["li"]),
      p: s,
      h1: s,
      h2: s,
      h3: s,
      h4: s,
      h5: s,
      h6: s,
      select: a,
      input: a,
      output: a,
      button: a,
      datalist: a,
      textarea: a,
      option: new Set(["option"]),
      optgroup: new Set(["optgroup", "option"]),
      dd: new Set(["dt", "dd"]),
      dt: new Set(["dt", "dd"]),
      address: s,
      article: s,
      aside: s,
      blockquote: s,
      details: s,
      div: s,
      dl: s,
      fieldset: s,
      figcaption: s,
      figure: s,
      footer: s,
      form: s,
      header: s,
      hr: s,
      main: s,
      nav: s,
      ol: s,
      pre: s,
      section: s,
      table: s,
      ul: s,
      rt: new Set(["rt", "rp"]),
      rp: new Set(["rt", "rp"]),
      tbody: new Set(["thead", "tbody"]),
      tfoot: new Set(["thead", "tbody"])
    },
    u = new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]),
    c = new Set(["math", "svg"]),
    l = new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignObject", "desc", "title"]),
    h = /\s|\//,
    d = function() {
      function e(e, t) {
        var r, n, a, s, o;
        void 0 === t && (t = {}), this.startIndex = 0, this.endIndex = null, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.foreignContext = [], this.options = t, this.cbs = null != e ? e : {}, this.lowerCaseTagNames = null !== (r = t.lowerCaseTags) && void 0 !== r ? r : !t.xmlMode, this.lowerCaseAttributeNames = null !== (n = t.lowerCaseAttributeNames) && void 0 !== n ? n : !t.xmlMode, this.tokenizer = new(null !== (a = t.Tokenizer) && void 0 !== a ? a : i.default)(this.options, this), null === (o = (s = this.cbs).onparserinit) || void 0 === o || o.call(s, this)
      }
      return e.prototype.updatePosition = function(e) {
        null === this.endIndex ? this.tokenizer.sectionStart <= e ? this.startIndex = 0 : this.startIndex = this.tokenizer.sectionStart - e : this.startIndex = this.endIndex + 1, this.endIndex = this.tokenizer.getAbsoluteIndex()
      }, e.prototype.ontext = function(e) {
        var t, r;
        this.updatePosition(1), this.endIndex--, null === (r = (t = this.cbs).ontext) || void 0 === r || r.call(t, e)
      }, e.prototype.onopentagname = function(e) {
        var t, r;
        if (this.lowerCaseTagNames && (e = e.toLowerCase()), this.tagname = e, !this.options.xmlMode && Object.prototype.hasOwnProperty.call(o, e))
          for (var n = void 0; this.stack.length > 0 && o[e].has(n = this.stack[this.stack.length - 1]);) this.onclosetag(n);
        !this.options.xmlMode && u.has(e) || (this.stack.push(e), c.has(e) ? this.foreignContext.push(!0) : l.has(e) && this.foreignContext.push(!1)), null === (r = (t = this.cbs).onopentagname) || void 0 === r || r.call(t, e), this.cbs.onopentag && (this.attribs = {})
      }, e.prototype.onopentagend = function() {
        var e, t;
        this.updatePosition(1), this.attribs && (null === (t = (e = this.cbs).onopentag) || void 0 === t || t.call(e, this.tagname, this.attribs), this.attribs = null), !this.options.xmlMode && this.cbs.onclosetag && u.has(this.tagname) && this.cbs.onclosetag(this.tagname), this.tagname = ""
      }, e.prototype.onclosetag = function(e) {
        if (this.updatePosition(1), this.lowerCaseTagNames && (e = e.toLowerCase()), (c.has(e) || l.has(e)) && this.foreignContext.pop(), !this.stack.length || !this.options.xmlMode && u.has(e)) this.options.xmlMode || "br" !== e && "p" !== e || (this.onopentagname(e), this.closeCurrentTag());
        else {
          var t = this.stack.lastIndexOf(e);
          if (-1 !== t)
            if (this.cbs.onclosetag)
              for (t = this.stack.length - t; t--;) this.cbs.onclosetag(this.stack.pop());
            else this.stack.length = t;
          else "p" !== e || this.options.xmlMode || (this.onopentagname(e), this.closeCurrentTag())
        }
      }, e.prototype.onselfclosingtag = function() {
        this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1] ? this.closeCurrentTag() : this.onopentagend()
      }, e.prototype.closeCurrentTag = function() {
        var e, t, r = this.tagname;
        this.onopentagend(), this.stack[this.stack.length - 1] === r && (null === (t = (e = this.cbs).onclosetag) || void 0 === t || t.call(e, r), this.stack.pop())
      }, e.prototype.onattribname = function(e) {
        this.lowerCaseAttributeNames && (e = e.toLowerCase()), this.attribname = e
      }, e.prototype.onattribdata = function(e) {
        this.attribvalue += e
      }, e.prototype.onattribend = function(e) {
        var t, r;
        null === (r = (t = this.cbs).onattribute) || void 0 === r || r.call(t, this.attribname, this.attribvalue, e), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribname = "", this.attribvalue = ""
      }, e.prototype.getInstructionName = function(e) {
        var t = e.search(h),
          r = t < 0 ? e : e.substr(0, t);
        return this.lowerCaseTagNames && (r = r.toLowerCase()), r
      }, e.prototype.ondeclaration = function(e) {
        if (this.cbs.onprocessinginstruction) {
          var t = this.getInstructionName(e);
          this.cbs.onprocessinginstruction("!" + t, "!" + e)
        }
      }, e.prototype.onprocessinginstruction = function(e) {
        if (this.cbs.onprocessinginstruction) {
          var t = this.getInstructionName(e);
          this.cbs.onprocessinginstruction("?" + t, "?" + e)
        }
      }, e.prototype.oncomment = function(e) {
        var t, r, n, i;
        this.updatePosition(4), null === (r = (t = this.cbs).oncomment) || void 0 === r || r.call(t, e), null === (i = (n = this.cbs).oncommentend) || void 0 === i || i.call(n)
      }, e.prototype.oncdata = function(e) {
        var t, r, n, i, a, s;
        this.updatePosition(1), this.options.xmlMode || this.options.recognizeCDATA ? (null === (r = (t = this.cbs).oncdatastart) || void 0 === r || r.call(t), null === (i = (n = this.cbs).ontext) || void 0 === i || i.call(n, e), null === (s = (a = this.cbs).oncdataend) || void 0 === s || s.call(a)) : this.oncomment("[CDATA[" + e + "]]")
      }, e.prototype.onerror = function(e) {
        var t, r;
        null === (r = (t = this.cbs).onerror) || void 0 === r || r.call(t, e)
      }, e.prototype.onend = function() {
        var e, t;
        if (this.cbs.onclosetag)
          for (var r = this.stack.length; r > 0; this.cbs.onclosetag(this.stack[--r]));
        null === (t = (e = this.cbs).onend) || void 0 === t || t.call(e)
      }, e.prototype.reset = function() {
        var e, t, r, n;
        null === (t = (e = this.cbs).onreset) || void 0 === t || t.call(e), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack = [], null === (n = (r = this.cbs).onparserinit) || void 0 === n || n.call(r, this)
      }, e.prototype.parseComplete = function(e) {
        this.reset(), this.end(e)
      }, e.prototype.write = function(e) {
        this.tokenizer.write(e)
      }, e.prototype.end = function(e) {
        this.tokenizer.end(e)
      }, e.prototype.pause = function() {
        this.tokenizer.pause()
      }, e.prototype.resume = function() {
        this.tokenizer.resume()
      }, e.prototype.parseChunk = function(e) {
        this.write(e)
      }, e.prototype.done = function(e) {
        this.end(e)
      }, e
    }();
  t.Parser = d
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(308), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.RDFA_CONTENTTYPES = t.RDFA_FEATURES = void 0, t.RDFA_FEATURES = {
    "": {
      baseTag: !0,
      xmlBase: !0,
      langAttribute: !0,
      onlyAllowUriRelRevIfProperty: !0,
      inheritSubjectInHeadBody: !0,
      datetimeAttribute: !0,
      timeTag: !0,
      htmlDatatype: !0,
      copyRdfaPatterns: !0,
      xmlnsPrefixMappings: !0,
      xhtmlInitialContext: !0,
      roleAttribute: !0
    },
    core: {
      baseTag: !1,
      xmlBase: !1,
      langAttribute: !0,
      onlyAllowUriRelRevIfProperty: !0,
      inheritSubjectInHeadBody: !1,
      datetimeAttribute: !1,
      timeTag: !1,
      htmlDatatype: !1,
      copyRdfaPatterns: !0,
      xmlnsPrefixMappings: !0,
      xhtmlInitialContext: !1,
      roleAttribute: !1
    },
    html: {
      baseTag: !0,
      xmlBase: !1,
      langAttribute: !0,
      onlyAllowUriRelRevIfProperty: !0,
      inheritSubjectInHeadBody: !0,
      datetimeAttribute: !0,
      timeTag: !0,
      htmlDatatype: !0,
      copyRdfaPatterns: !0,
      xmlnsPrefixMappings: !0,
      xhtmlInitialContext: !1,
      roleAttribute: !0
    },
    xhtml: {
      baseTag: !0,
      xmlBase: !1,
      langAttribute: !0,
      onlyAllowUriRelRevIfProperty: !0,
      inheritSubjectInHeadBody: !0,
      datetimeAttribute: !0,
      timeTag: !0,
      htmlDatatype: !0,
      copyRdfaPatterns: !0,
      xmlnsPrefixMappings: !0,
      xhtmlInitialContext: !0,
      roleAttribute: !0
    },
    xml: {
      baseTag: !1,
      xmlBase: !0,
      langAttribute: !0,
      onlyAllowUriRelRevIfProperty: !1,
      inheritSubjectInHeadBody: !1,
      datetimeAttribute: !0,
      timeTag: !0,
      htmlDatatype: !1,
      copyRdfaPatterns: !1,
      xmlnsPrefixMappings: !0,
      xhtmlInitialContext: !1,
      roleAttribute: !0
    }
  }, t.RDFA_CONTENTTYPES = {
    "text/html": "html",
    "application/xhtml+xml": "xhtml",
    "application/xml": "xml",
    "text/xml": "xml",
    "image/svg+xml": "xml"
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Util = void 0;
  class n {
    static isCompactIri(e) {
      return e.indexOf(":") > 0 && !(e && "#" === e[0])
    }
    static getPrefix(e, t) {
      if (e && "#" === e[0]) return null;
      const r = e.indexOf(":");
      if (r >= 0) {
        if (e.length > r + 1 && "/" === e.charAt(r + 1) && "/" === e.charAt(r + 2)) return null;
        const n = e.substr(0, r);
        if ("_" === n) return null;
        if (t[n]) return n
      }
      return null
    }
    static getContextValueId(e) {
      if (null === e || "string" == typeof e) return e;
      const t = e["@id"];
      return t || null
    }
    static isSimpleTermDefinitionPrefix(e, t) {
      return !n.isPotentialKeyword(e) && ("_" === e[0] || t.allowPrefixNonGenDelims || n.isPrefixIriEndingWithGenDelim(e))
    }
    static isPotentialKeyword(e) {
      return "string" == typeof e && n.KEYWORD_REGEX.test(e)
    }
    static isPrefixIriEndingWithGenDelim(e) {
      return n.ENDS_WITH_GEN_DELIM.test(e)
    }
    static isPrefixValue(e) {
      return e && ("string" == typeof e || e && "object" == typeof e)
    }
    static isValidIri(e) {
      return n.IRI_REGEX.test(e)
    }
    static isValidIriWeak(e) {
      return !!e && ":" !== e[0] && n.IRI_REGEX_WEAK.test(e)
    }
    static isValidKeyword(e) {
      return n.VALID_KEYWORDS[e]
    }
    static isTermProtected(e, t) {
      const r = e[t];
      return !("string" == typeof r) && r && r["@protected"]
    }
    static hasProtectedTerms(e) {
      for (const t of Object.keys(e))
        if (n.isTermProtected(e, t)) return !0;
      return !1
    }
    static isReservedInternalKeyword(e) {
      return e.startsWith("@__")
    }
  }
  t.Util = n, n.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ "<>{}|\\\[\]`#]*(#[^#]*)?$/, n.IRI_REGEX_WEAK = /(?::[^:])|\//, n.KEYWORD_REGEX = /^@[a-z]+$/i, n.ENDS_WITH_GEN_DELIM = /[:/?#\[\]@]$/, n.REGEX_LANGUAGE_TAG = /^[a-zA-Z]+(-[a-zA-Z0-9]+)*$/, n.REGEX_DIRECTION_TAG = /^(ltr)|(rtl)$/, n.VALID_KEYWORDS = {
    "@base": !0,
    "@container": !0,
    "@context": !0,
    "@direction": !0,
    "@graph": !0,
    "@id": !0,
    "@import": !0,
    "@included": !0,
    "@index": !0,
    "@json": !0,
    "@language": !0,
    "@list": !0,
    "@nest": !0,
    "@none": !0,
    "@prefix": !0,
    "@propagate": !0,
    "@protected": !0,
    "@reverse": !0,
    "@set": !0,
    "@type": !0,
    "@value": !0,
    "@version": !0,
    "@vocab": !0
  }, n.EXPAND_KEYS_BLACKLIST = ["@base", "@vocab", "@language", "@version", "@direction"], n.ALIAS_DOMAIN_BLACKLIST = ["@container", "@graph", "@id", "@index", "@list", "@nest", "@none", "@prefix", "@reverse", "@set", "@type", "@value", "@version"], n.ALIAS_RANGE_BLACKLIST = ["@context", "@preserve"], n.CONTAINERS = ["@list", "@set", "@index", "@language", "@graph", "@id", "@type"], n.CONTAINERS_1_0 = ["@list", "@set", "@index"]
}, function(e, t, r) {
  "use strict";
  e.exports = function(e) {
    return function e(t) {
      if (null === t || "object" != typeof t || null != t.toJSON) return JSON.stringify(t);
      if (Array.isArray(t) && 0 === t.length) return "[]";
      if (Array.isArray(t) && 1 === t.length) return "[" + e(t[0]) + "]";
      if (Array.isArray(t)) return "[" + t.reduce((t, r, n) => (t = 1 === n ? e(t) : t) + "," + e(r)) + "]";
      const r = Object.keys(t);
      if (0 === r.length) return "{}";
      if (1 === r.length) return "{" + e(r[0]) + ":" + e(t[r[0]]) + "}";
      return "{" + r.sort().reduce((r, n, i) => (r = 1 === i ? e(r) + ":" + e(t[r]) : r) + "," + e(n) + ":" + e(t[n])) + "}"
    }(e)
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(158), t), i(r(345), t), i(r(164), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeHandlerDefinitionAdapter = void 0;
  const n = r(62);
  class i extends n.NodeHandlerAdapter {
    constructor(e, t, r) {
      super(e, t, r)
    }
  }
  t.NodeHandlerDefinitionAdapter = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(380), t)
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(515), t), i(r(516), t)
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.namedFunctions = t.specialFunctions = t.regularFunctions = void 0;
  const a = r(90),
    s = r(533),
    o = r(534),
    u = r(538);
  i(r(90), t), t.regularFunctions = o.definitions.map((e, t) => new a.RegularFunction(t, e)).toMap(), t.specialFunctions = u.specialDefinitions.map((e, t) => new a.SpecialFunction(t, e)).toMap(), t.namedFunctions = s.namedDefinitions.map((e, t) => new a.NamedFunction(t, e)).toMap()
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.promote = t.SpecialFunction = t.NamedFunction = t.RegularFunction = t.BaseFunction = void 0;
  const n = r(23),
    i = r(20);
  class a {
    constructor(e, t) {
      this.operator = e, this.apply = e => (this.monomorph(e) || this.handleInvalidTypes(e))(e), this.arity = t.arity, this.overloads = t.overloads
    }
    monomorph(e) {
      return this.overloads.get(s.asConcreteTypes(e)) || this.overloads.get(s.asTermTypes(e)) || this.overloads.get(s.asGenericTerms(e))
    }
  }
  t.BaseFunction = a;
  class s {
    static asConcreteTypes(e) {
      return n.List(e.map(e => e.type || e.termType))
    }
    static asTermTypes(e) {
      return n.List(e.map(e => e.termType))
    }
    static asGenericTerms(e) {
      return n.List(Array(e.length).fill("term"))
    }
  }
  t.RegularFunction = class extends a {
    constructor(e, t) {
      super(e, t), this.functionClass = "regular"
    }
    handleInvalidTypes(e) {
      throw new i.InvalidArgumentTypes(e, this.operator)
    }
  };
  t.NamedFunction = class extends a {
    constructor(e, t) {
      super(e, t), this.functionClass = "named"
    }
    handleInvalidTypes(e) {
      throw new i.InvalidArgumentTypes(e, this.operator)
    }
  };
  t.SpecialFunction = class {
    constructor(e, t) {
      var r;
      this.operator = e, this.functionClass = "special", this.arity = t.arity, this.applySync = t.applySync, this.applyAsync = t.applyAsync, this.checkArity = t.checkArity || (r = this.arity, e => r === 1 / 0 || (Array.isArray(r) ? r.indexOf(e.length) >= 0 : e.length === r))
    }
  };
  const o = {
    integer: {
      integer: "integer",
      decimal: "decimal",
      float: "float",
      double: "double"
    },
    decimal: {
      integer: "decimal",
      decimal: "decimal",
      float: "float",
      double: "double"
    },
    float: {
      integer: "float",
      decimal: "float",
      float: "float",
      double: "double"
    },
    double: {
      integer: "double",
      decimal: "double",
      float: "double",
      double: "double"
    }
  };
  t.promote = function(e, t) {
    return o[e][t]
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.evaluateQuery = t.newEngine = t.bindingsStreamToGraphQl = void 0, i(r(191), t);
  var a = r(113);

  function s() {
    return r(240)
  }
  Object.defineProperty(t, "bindingsStreamToGraphQl", {
    enumerable: !0,
    get: function() {
      return a.bindingsStreamToGraphQl
    }
  }), t.newEngine = s, t.evaluateQuery = function(e, t) {
    return s().query(e, t)
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Bus = void 0;
  t.Bus = class {
    constructor(e) {
      this.actors = [], this.observers = [], this.dependencyLinks = new Map, Object.assign(this, e)
    }
    subscribe(e) {
      this.actors.push(e), this.reorderForDependencies()
    }
    subscribeObserver(e) {
      this.observers.push(e)
    }
    unsubscribe(e) {
      const t = this.actors.indexOf(e);
      return t >= 0 && (this.actors.splice(t, 1), !0)
    }
    unsubscribeObserver(e) {
      const t = this.observers.indexOf(e);
      return t >= 0 && (this.observers.splice(t, 1), !0)
    }
    publish(e) {
      return this.actors.map(t => ({
        actor: t,
        reply: t.test(e)
      }))
    }
    onRun(e, t, r) {
      for (const n of this.observers) n.onRun(e, t, r)
    }
    addDependencies(e, t) {
      for (const r of t) {
        let t = this.dependencyLinks.get(r);
        t || (t = [], this.dependencyLinks.set(r, t)), t.push(e)
      }
      this.reorderForDependencies()
    }
    reorderForDependencies() {
      if (this.dependencyLinks.size > 0) {
        const e = [];
        for (const t of this.dependencyLinks.keys()) {
          const r = this.actors.indexOf(t);
          r >= 0 && (this.actors.splice(r, 1), e.push(t))
        }
        for (; e.length > 0;) {
          let t = -1;
          for (let r = 0; r < e.length; r++) {
            let n = !0;
            for (const t of this.dependencyLinks.get(e[r]))
              if (!this.actors.includes(t) && e.includes(t)) {
                n = !1;
                break
              } if (n) {
              t = r;
              break
            }
          }
          if (t < 0) throw new Error("Cyclic dependency links detected in bus " + this.name);
          const r = e.splice(t, 1)[0];
          this.actors.push(r)
        }
      }
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.KEY_CONTEXT_LOG = t.Logger = void 0;
  class n {
    static getLevelOrdinal(e) {
      return n.LEVELS[e]
    }
  }
  t.Logger = n, n.LEVELS = {
    trace: 0,
    debug: 1,
    info: 2,
    warn: 3,
    error: 4,
    fatal: 5
  }, t.KEY_CONTEXT_LOG = "@comunica/core:log"
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.getMetadata = t.ActorQueryOperation = t.KEY_CONTEXT_QUERY_TIMESTAMP = t.KEY_CONTEXT_BASEIRI = t.KEY_CONTEXT_PATTERN_PARENTMETADATA = t.KEY_CONTEXT_BGP_PATTERNBINDINGS = t.KEY_CONTEXT_BGP_PARENTMETADATA = t.KEY_CONTEXT_BGP_CURRENTMETADATA = void 0;
  const n = r(0),
    i = r(95);
  t.KEY_CONTEXT_BGP_CURRENTMETADATA = "@comunica/bus-query-operation:bgpCurrentMetadata", t.KEY_CONTEXT_BGP_PARENTMETADATA = "@comunica/bus-query-operation:bgpParentMetadata", t.KEY_CONTEXT_BGP_PATTERNBINDINGS = "@comunica/bus-query-operation:bgpPatternBindings", t.KEY_CONTEXT_PATTERN_PARENTMETADATA = "@comunica/bus-query-operation:patternParentMetadata", t.KEY_CONTEXT_BASEIRI = "@comunica/actor-init-sparql:baseIRI", t.KEY_CONTEXT_QUERY_TIMESTAMP = "@comunica/actor-init-sparql:queryTimestamp";
  class a extends n.Actor {
    constructor(e) {
      super(e)
    }
    static getSafeBindings(e) {
      return a.validateQueryOutput(e, "bindings"), e
    }
    static getSafeQuads(e) {
      return a.validateQueryOutput(e, "quads"), e
    }
    static getSafeBoolean(e) {
      return a.validateQueryOutput(e, "boolean"), e
    }
    static cachifyMetadata(e) {
      let t;
      return e && (() => t || (t = e()))
    }
    static validateQueryOutput(e, t) {
      if (e.type !== t) throw new Error(`Invalid query output type: Expected '${t}' but got '${e.type}'`)
    }
    static getExpressionContext(e, r) {
      if (e) {
        const n = e.get(t.KEY_CONTEXT_QUERY_TIMESTAMP),
          i = e.get(t.KEY_CONTEXT_BASEIRI);
        return Object.assign({
          now: n,
          baseIRI: i
        }, r ? {
          exists: a.createExistenceResolver(e, r)
        } : {})
      }
      return {}
    }
    static createExistenceResolver(e, t) {
      return async (r, n) => {
        const s = i.materializeOperation(r.input, n),
          o = await t.mediate({
            operation: s,
            context: e
          }),
          u = a.getSafeBindings(o);
        return new Promise((e, t) => {
          u.bindingsStream.on("end", () => {
            e(!1)
          }), u.bindingsStream.on("error", t), u.bindingsStream.on("data", () => {
            u.bindingsStream.close(), e(!0)
          })
        }).then(e => r.not ? !e : e)
      }
    }
  }
  t.ActorQueryOperation = a, t.getMetadata = function(e) {
    return e.metadata ? e.metadata() : Promise.resolve({})
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.materializeOperation = t.materializeTerm = t.ensureBindings = t.isBindings = t.Bindings = void 0;
  const n = r(23),
    i = r(4),
    a = r(6);

  function s(e) {
    return n.Map(e)
  }

  function o(e) {
    return n.Map.isMap(e)
  }

  function u(e, t) {
    if ("Variable" === e.termType) {
      const r = t.get(i.termToString(e));
      if (r) return r
    }
    return e
  }
  t.Bindings = s, t.isBindings = o, t.ensureBindings = function(e) {
    return o(e) ? e : s(e)
  }, t.materializeTerm = u, t.materializeOperation = function e(t, r, n = !1) {
    return a.Util.mapOperation(t, {
      path: (e, t) => ({
        recurse: !1,
        result: t.createPath(u(e.subject, r), e.predicate, u(e.object, r), u(e.graph, r))
      }),
      pattern: (e, t) => ({
        recurse: !1,
        result: t.createPattern(u(e.subject, r), u(e.predicate, r), u(e.object, r), u(e.graph, r))
      }),
      extend(t) {
        if (r.has(i.termToString(t.variable))) {
          if (n) throw new Error(`Tried to bind variable ${i.termToString(t.variable)} in a BIND operator.`);
          return {
            recurse: !0,
            result: e(t.input, r, n)
          }
        }
        return {
          recurse: !0,
          result: t
        }
      },
      group(e, t) {
        if (n) {
          for (const t of e.variables)
            if (r.has(i.termToString(t))) throw new Error(`Tried to bind variable ${i.termToString(t)} in a GROUP BY operator.`);
          return {
            recurse: !0,
            result: e
          }
        }
        const a = e.variables.filter(e => !r.has(i.termToString(e)));
        return {
          recurse: !0,
          result: t.createGroup(e.input, a, e.aggregates)
        }
      },
      project(e, t) {
        if (n) {
          for (const t of e.variables)
            if (r.has(i.termToString(t))) throw new Error(`Tried to bind variable ${i.termToString(t)} in a SELECT operator.`);
          return {
            recurse: !0,
            result: e
          }
        }
        const a = e.variables.filter(e => !r.has(i.termToString(e)));
        return {
          recurse: !0,
          result: t.createProject(e.input, a)
        }
      },
      values(e, t) {
        if (!n) {
          const n = e.variables.filter(e => !r.has(i.termToString(e))),
            a = e.bindings.map(e => {
              const t = Object.assign({}, e);
              return r.forEach((e, r) => delete t[r]), t
            });
          return {
            recurse: !0,
            result: t.createValues(n, a)
          }
        }
        for (const t of e.variables)
          if (r.has(i.termToString(t))) throw new Error(`Tried to bind variable ${i.termToString(t)} in a VALUES operator.`);
        return {
          recurse: !1,
          result: e
        }
      },
      expression(e, t) {
        if ("term" === e.expressionType) return {
          recurse: !1,
          result: t.createTermExpression(u(e.term, r))
        };
        if ("aggregate" === e.expressionType && "variable" in e && r.has(i.termToString(e.variable))) {
          if (n) throw new Error(`Tried to bind ${i.termToString(e.variable)} in a ${e.aggregator} aggregate.`);
          return {
            recurse: !0,
            result: e
          }
        }
        return {
          recurse: !0,
          result: e
        }
      }
    })
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.BlankNode = void 0;
  t.BlankNode = class {
    constructor(e) {
      this.termType = "BlankNode", this.value = e
    }
    equals(e) {
      return !!e && "BlankNode" === e.termType && e.value === this.value
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.DefaultGraph = void 0;
  class n {
    constructor() {
      this.termType = "DefaultGraph", this.value = ""
    }
    equals(e) {
      return !!e && "DefaultGraph" === e.termType
    }
  }
  t.DefaultGraph = n, n.INSTANCE = new n
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Literal = void 0;
  const n = r(68);
  class i {
    constructor(e, t) {
      this.termType = "Literal", this.value = e, "string" == typeof t ? (this.language = t, this.datatype = i.RDF_LANGUAGE_STRING) : t ? (this.language = "", this.datatype = t) : (this.language = "", this.datatype = i.XSD_STRING)
    }
    equals(e) {
      return !!e && "Literal" === e.termType && e.value === this.value && e.language === this.language && e.datatype.equals(this.datatype)
    }
  }
  t.Literal = i, i.RDF_LANGUAGE_STRING = new n.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"), i.XSD_STRING = new n.NamedNode("http://www.w3.org/2001/XMLSchema#string")
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Quad = void 0;
  t.Quad = class {
    constructor(e, t, r, n) {
      this.termType = "Quad", this.value = "", this.subject = e, this.predicate = t, this.object = r, this.graph = n
    }
    equals(e) {
      return !!e && ("Quad" === e.termType || !e.termType) && this.subject.equals(e.subject) && this.predicate.equals(e.predicate) && this.object.equals(e.object) && this.graph.equals(e.graph)
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Variable = void 0;
  t.Variable = class {
    constructor(e) {
      this.termType = "Variable", this.value = e
    }
    equals(e) {
      return !!e && "Variable" === e.termType && e.value === this.value
    }
  }
}, function(e, t) {
  e.exports = function(e) {
    return e.webpackPolyfill || (e.deprecate = function() {}, e.paths = [], e.children || (e.children = []), Object.defineProperty(e, "loaded", {
      enumerable: !0,
      get: function() {
        return e.l
      }
    }), Object.defineProperty(e, "id", {
      enumerable: !0,
      get: function() {
        return e.i
      }
    }), e.webpackPolyfill = 1), e
  }
}, function(e, t, r) {
  const {
    Term: n
  } = r(41);
  class i extends n {
    constructor() {
      return super(""), a || this
    }
    equals(e) {
      return e && this.termType === e.termType
    }
  }
  Object.defineProperty(i.prototype, "value", {
    enumerable: !0,
    value: "*"
  }), Object.defineProperty(i.prototype, "termType", {
    enumerable: !0,
    value: "Wildcard"
  });
  var a = new i;
  e.exports.Wildcard = i
}, function(e, t) {
  var r = {}.toString;
  e.exports = Array.isArray || function(e) {
    return "[object Array]" == r.call(e)
  }
}, function(e, t, r) {
  "use strict";
  (function(t, n) {
    var i;
    e.exports = x, x.ReadableState = E;
    r(22).EventEmitter;
    var a = function(e, t) {
        return e.listeners(t).length
      },
      s = r(105),
      o = r(11).Buffer,
      u = t.Uint8Array || function() {};
    var c, l = r(204);
    c = l && l.debuglog ? l.debuglog("stream") : function() {};
    var h, d, p, f = r(205),
      g = r(106),
      m = r(107).getHighWaterMark,
      y = r(31).codes,
      b = y.ERR_INVALID_ARG_TYPE,
      _ = y.ERR_STREAM_PUSH_AFTER_EOF,
      v = y.ERR_METHOD_NOT_IMPLEMENTED,
      w = y.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    r(12)(x, s);
    var S = g.errorOrDestroy,
      T = ["error", "close", "destroy", "pause", "resume"];

    function E(e, t, n) {
      i = i || r(32), e = e || {}, "boolean" != typeof n && (n = t instanceof i), this.objectMode = !!e.objectMode, n && (this.objectMode = this.objectMode || !!e.readableObjectMode), this.highWaterMark = m(this, e, "readableHighWaterMark", n), this.buffer = new f, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== e.emitClose, this.autoDestroy = !!e.autoDestroy, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (h || (h = r(33).StringDecoder), this.decoder = new h(e.encoding), this.encoding = e.encoding)
    }

    function x(e) {
      if (i = i || r(32), !(this instanceof x)) return new x(e);
      var t = this instanceof i;
      this._readableState = new E(e, this, t), this.readable = !0, e && ("function" == typeof e.read && (this._read = e.read), "function" == typeof e.destroy && (this._destroy = e.destroy)), s.call(this)
    }

    function O(e, t, r, n, i) {
      c("readableAddChunk", t);
      var a, s = e._readableState;
      if (null === t) s.reading = !1,
        function(e, t) {
          if (c("onEofChunk"), t.ended) return;
          if (t.decoder) {
            var r = t.decoder.end();
            r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length)
          }
          t.ended = !0, t.sync ? I(e) : (t.needReadable = !1, t.emittedReadable || (t.emittedReadable = !0, N(e)))
        }(e, s);
      else if (i || (a = function(e, t) {
        var r;
        n = t, o.isBuffer(n) || n instanceof u || "string" == typeof t || void 0 === t || e.objectMode || (r = new b("chunk", ["string", "Buffer", "Uint8Array"], t));
        var n;
        return r
      }(s, t)), a) S(e, a);
      else if (s.objectMode || t && t.length > 0)
        if ("string" == typeof t || s.objectMode || Object.getPrototypeOf(t) === o.prototype || (t = function(e) {
          return o.from(e)
        }(t)), n) s.endEmitted ? S(e, new w) : A(e, s, t, !0);
        else if (s.ended) S(e, new _);
        else {
          if (s.destroyed) return !1;
          s.reading = !1, s.decoder && !r ? (t = s.decoder.write(t), s.objectMode || 0 !== t.length ? A(e, s, t, !1) : P(e, s)) : A(e, s, t, !1)
        } else n || (s.reading = !1, P(e, s));
      return !s.ended && (s.length < s.highWaterMark || 0 === s.length)
    }

    function A(e, t, r, n) {
      t.flowing && 0 === t.length && !t.sync ? (t.awaitDrain = 0, e.emit("data", r)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && I(e)), P(e, t)
    }
    Object.defineProperty(x.prototype, "destroyed", {
      enumerable: !1,
      get: function() {
        return void 0 !== this._readableState && this._readableState.destroyed
      },
      set: function(e) {
        this._readableState && (this._readableState.destroyed = e)
      }
    }), x.prototype.destroy = g.destroy, x.prototype._undestroy = g.undestroy, x.prototype._destroy = function(e, t) {
      t(e)
    }, x.prototype.push = function(e, t) {
      var r, n = this._readableState;
      return n.objectMode ? r = !0 : "string" == typeof e && ((t = t || n.defaultEncoding) !== n.encoding && (e = o.from(e, t), t = ""), r = !0), O(this, e, t, !1, r)
    }, x.prototype.unshift = function(e) {
      return O(this, e, null, !0, !1)
    }, x.prototype.isPaused = function() {
      return !1 === this._readableState.flowing
    }, x.prototype.setEncoding = function(e) {
      h || (h = r(33).StringDecoder);
      var t = new h(e);
      this._readableState.decoder = t, this._readableState.encoding = this._readableState.decoder.encoding;
      for (var n = this._readableState.buffer.head, i = ""; null !== n;) i += t.write(n.data), n = n.next;
      return this._readableState.buffer.clear(), "" !== i && this._readableState.buffer.push(i), this._readableState.length = i.length, this
    };

    function R(e, t) {
      return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = function(e) {
        return e >= 1073741824 ? e = 1073741824 : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e
      }(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0))
    }

    function I(e) {
      var t = e._readableState;
      c("emitReadable", t.needReadable, t.emittedReadable), t.needReadable = !1, t.emittedReadable || (c("emitReadable", t.flowing), t.emittedReadable = !0, n.nextTick(N, e))
    }

    function N(e) {
      var t = e._readableState;
      c("emitReadable_", t.destroyed, t.length, t.ended), t.destroyed || !t.length && !t.ended || (e.emit("readable"), t.emittedReadable = !1), t.needReadable = !t.flowing && !t.ended && t.length <= t.highWaterMark, L(e)
    }

    function P(e, t) {
      t.readingMore || (t.readingMore = !0, n.nextTick(C, e, t))
    }

    function C(e, t) {
      for (; !t.reading && !t.ended && (t.length < t.highWaterMark || t.flowing && 0 === t.length);) {
        var r = t.length;
        if (c("maybeReadMore read 0"), e.read(0), r === t.length) break
      }
      t.readingMore = !1
    }

    function D(e) {
      var t = e._readableState;
      t.readableListening = e.listenerCount("readable") > 0, t.resumeScheduled && !t.paused ? t.flowing = !0 : e.listenerCount("data") > 0 && e.resume()
    }

    function j(e) {
      c("readable nexttick read 0"), e.read(0)
    }

    function k(e, t) {
      c("resume", t.reading), t.reading || e.read(0), t.resumeScheduled = !1, e.emit("resume"), L(e), t.flowing && !t.reading && e.read(0)
    }

    function L(e) {
      var t = e._readableState;
      for (c("flow", t.flowing); t.flowing && null !== e.read(););
    }

    function M(e, t) {
      return 0 === t.length ? null : (t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (r = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.first() : t.buffer.concat(t.length), t.buffer.clear()) : r = t.buffer.consume(e, t.decoder), r);
      var r
    }

    function F(e) {
      var t = e._readableState;
      c("endReadable", t.endEmitted), t.endEmitted || (t.ended = !0, n.nextTick(B, t, e))
    }

    function B(e, t) {
      if (c("endReadableNT", e.endEmitted, e.length), !e.endEmitted && 0 === e.length && (e.endEmitted = !0, t.readable = !1, t.emit("end"), e.autoDestroy)) {
        var r = t._writableState;
        (!r || r.autoDestroy && r.finished) && t.destroy()
      }
    }

    function q(e, t) {
      for (var r = 0, n = e.length; r < n; r++)
        if (e[r] === t) return r;
      return -1
    }
    x.prototype.read = function(e) {
      c("read", e), e = parseInt(e, 10);
      var t = this._readableState,
        r = e;
      if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && ((0 !== t.highWaterMark ? t.length >= t.highWaterMark : t.length > 0) || t.ended)) return c("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? F(this) : I(this), null;
      if (0 === (e = R(e, t)) && t.ended) return 0 === t.length && F(this), null;
      var n, i = t.needReadable;
      return c("need readable", i), (0 === t.length || t.length - e < t.highWaterMark) && c("length less than watermark", i = !0), t.ended || t.reading ? c("reading or ended", i = !1) : i && (c("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = R(r, t))), null === (n = e > 0 ? M(e, t) : null) ? (t.needReadable = t.length <= t.highWaterMark, e = 0) : (t.length -= e, t.awaitDrain = 0), 0 === t.length && (t.ended || (t.needReadable = !0), r !== e && t.ended && F(this)), null !== n && this.emit("data", n), n
    }, x.prototype._read = function(e) {
      S(this, new v("_read()"))
    }, x.prototype.pipe = function(e, t) {
      var r = this,
        i = this._readableState;
      switch (i.pipesCount) {
        case 0:
          i.pipes = e;
          break;
        case 1:
          i.pipes = [i.pipes, e];
          break;
        default:
          i.pipes.push(e)
      }
      i.pipesCount += 1, c("pipe count=%d opts=%j", i.pipesCount, t);
      var s = (!t || !1 !== t.end) && e !== n.stdout && e !== n.stderr ? u : m;

      function o(t, n) {
        c("onunpipe"), t === r && n && !1 === n.hasUnpiped && (n.hasUnpiped = !0, c("cleanup"), e.removeListener("close", f), e.removeListener("finish", g), e.removeListener("drain", l), e.removeListener("error", p), e.removeListener("unpipe", o), r.removeListener("end", u), r.removeListener("end", m), r.removeListener("data", d), h = !0, !i.awaitDrain || e._writableState && !e._writableState.needDrain || l())
      }

      function u() {
        c("onend"), e.end()
      }
      i.endEmitted ? n.nextTick(s) : r.once("end", s), e.on("unpipe", o);
      var l = function(e) {
        return function() {
          var t = e._readableState;
          c("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && a(e, "data") && (t.flowing = !0, L(e))
        }
      }(r);
      e.on("drain", l);
      var h = !1;

      function d(t) {
        c("ondata");
        var n = e.write(t);
        c("dest.write", n), !1 === n && ((1 === i.pipesCount && i.pipes === e || i.pipesCount > 1 && -1 !== q(i.pipes, e)) && !h && (c("false write response, pause", i.awaitDrain), i.awaitDrain++), r.pause())
      }

      function p(t) {
        c("onerror", t), m(), e.removeListener("error", p), 0 === a(e, "error") && S(e, t)
      }

      function f() {
        e.removeListener("finish", g), m()
      }

      function g() {
        c("onfinish"), e.removeListener("close", f), m()
      }

      function m() {
        c("unpipe"), r.unpipe(e)
      }
      return r.on("data", d),
        function(e, t, r) {
          if ("function" == typeof e.prependListener) return e.prependListener(t, r);
          e._events && e._events[t] ? Array.isArray(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]] : e.on(t, r)
        }(e, "error", p), e.once("close", f), e.once("finish", g), e.emit("pipe", r), i.flowing || (c("pipe resume"), r.resume()), e
    }, x.prototype.unpipe = function(e) {
      var t = this._readableState,
        r = {
          hasUnpiped: !1
        };
      if (0 === t.pipesCount) return this;
      if (1 === t.pipesCount) return e && e !== t.pipes || (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r)), this;
      if (!e) {
        var n = t.pipes,
          i = t.pipesCount;
        t.pipes = null, t.pipesCount = 0, t.flowing = !1;
        for (var a = 0; a < i; a++) n[a].emit("unpipe", this, {
          hasUnpiped: !1
        });
        return this
      }
      var s = q(t.pipes, e);
      return -1 === s || (t.pipes.splice(s, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r)), this
    }, x.prototype.on = function(e, t) {
      var r = s.prototype.on.call(this, e, t),
        i = this._readableState;
      return "data" === e ? (i.readableListening = this.listenerCount("readable") > 0, !1 !== i.flowing && this.resume()) : "readable" === e && (i.endEmitted || i.readableListening || (i.readableListening = i.needReadable = !0, i.flowing = !1, i.emittedReadable = !1, c("on readable", i.length, i.reading), i.length ? I(this) : i.reading || n.nextTick(j, this))), r
    }, x.prototype.addListener = x.prototype.on, x.prototype.removeListener = function(e, t) {
      var r = s.prototype.removeListener.call(this, e, t);
      return "readable" === e && n.nextTick(D, this), r
    }, x.prototype.removeAllListeners = function(e) {
      var t = s.prototype.removeAllListeners.apply(this, arguments);
      return "readable" !== e && void 0 !== e || n.nextTick(D, this), t
    }, x.prototype.resume = function() {
      var e = this._readableState;
      return e.flowing || (c("resume"), e.flowing = !e.readableListening, function(e, t) {
        t.resumeScheduled || (t.resumeScheduled = !0, n.nextTick(k, e, t))
      }(this, e)), e.paused = !1, this
    }, x.prototype.pause = function() {
      return c("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (c("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this
    }, x.prototype.wrap = function(e) {
      var t = this,
        r = this._readableState,
        n = !1;
      for (var i in e.on("end", (function() {
        if (c("wrapped end"), r.decoder && !r.ended) {
          var e = r.decoder.end();
          e && e.length && t.push(e)
        }
        t.push(null)
      })), e.on("data", (function(i) {
        (c("wrapped data"), r.decoder && (i = r.decoder.write(i)), r.objectMode && null == i) || (r.objectMode || i && i.length) && (t.push(i) || (n = !0, e.pause()))
      })), e) void 0 === this[i] && "function" == typeof e[i] && (this[i] = function(t) {
        return function() {
          return e[t].apply(e, arguments)
        }
      }(i));
      for (var a = 0; a < T.length; a++) e.on(T[a], this.emit.bind(this, T[a]));
      return this._read = function(t) {
        c("wrapped _read", t), n && (n = !1, e.resume())
      }, this
    }, "function" == typeof Symbol && (x.prototype[Symbol.asyncIterator] = function() {
      return void 0 === d && (d = r(208)), d(this)
    }), Object.defineProperty(x.prototype, "readableHighWaterMark", {
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark
      }
    }), Object.defineProperty(x.prototype, "readableBuffer", {
      enumerable: !1,
      get: function() {
        return this._readableState && this._readableState.buffer
      }
    }), Object.defineProperty(x.prototype, "readableFlowing", {
      enumerable: !1,
      get: function() {
        return this._readableState.flowing
      },
      set: function(e) {
        this._readableState && (this._readableState.flowing = e)
      }
    }), x._fromList = M, Object.defineProperty(x.prototype, "readableLength", {
      enumerable: !1,
      get: function() {
        return this._readableState.length
      }
    }), "function" == typeof Symbol && (x.from = function(e, t) {
      return void 0 === p && (p = r(209)), p(x, e, t)
    })
  }).call(this, r(10), r(8))
}, function(e, t, r) {
  e.exports = r(22).EventEmitter
}, function(e, t, r) {
  "use strict";
  (function(t) {
    function r(e, t) {
      i(e, t), n(e)
    }

    function n(e) {
      e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close")
    }

    function i(e, t) {
      e.emit("error", t)
    }
    e.exports = {
      destroy: function(e, a) {
        var s = this,
          o = this._readableState && this._readableState.destroyed,
          u = this._writableState && this._writableState.destroyed;
        return o || u ? (a ? a(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, t.nextTick(i, this, e)) : t.nextTick(i, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, (function(e) {
          !a && e ? s._writableState ? s._writableState.errorEmitted ? t.nextTick(n, s) : (s._writableState.errorEmitted = !0, t.nextTick(r, s, e)) : t.nextTick(r, s, e) : a ? (t.nextTick(n, s), a(e)) : t.nextTick(n, s)
        })), this)
      },
      undestroy: function() {
        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1)
      },
      errorOrDestroy: function(e, t) {
        var r = e._readableState,
          n = e._writableState;
        r && r.autoDestroy || n && n.autoDestroy ? e.destroy(t) : e.emit("error", t)
      }
    }
  }).call(this, r(8))
}, function(e, t, r) {
  "use strict";
  var n = r(31).codes.ERR_INVALID_OPT_VALUE;
  e.exports = {
    getHighWaterMark: function(e, t, r, i) {
      var a = function(e, t, r) {
        return null != e.highWaterMark ? e.highWaterMark : t ? e[r] : null
      }(t, i, r);
      if (null != a) {
        if (!isFinite(a) || Math.floor(a) !== a || a < 0) throw new n(i ? r : "highWaterMark", a);
        return Math.floor(a)
      }
      return e.objectMode ? 16 : 16384
    }
  }
}, function(e, t, r) {
  "use strict";
  (function(t, n) {
    function i(e) {
      var t = this;
      this.next = null, this.entry = null, this.finish = function() {
        ! function(e, t, r) {
          var n = e.entry;
          e.entry = null;
          for (; n;) {
            var i = n.callback;
            t.pendingcb--, i(r), n = n.next
          }
          t.corkedRequestsFree.next = e
        }(t, e)
      }
    }
    var a;
    e.exports = x, x.WritableState = E;
    var s = {
        deprecate: r(109)
      },
      o = r(105),
      u = r(11).Buffer,
      c = t.Uint8Array || function() {};
    var l, h = r(106),
      d = r(107).getHighWaterMark,
      p = r(31).codes,
      f = p.ERR_INVALID_ARG_TYPE,
      g = p.ERR_METHOD_NOT_IMPLEMENTED,
      m = p.ERR_MULTIPLE_CALLBACK,
      y = p.ERR_STREAM_CANNOT_PIPE,
      b = p.ERR_STREAM_DESTROYED,
      _ = p.ERR_STREAM_NULL_VALUES,
      v = p.ERR_STREAM_WRITE_AFTER_END,
      w = p.ERR_UNKNOWN_ENCODING,
      S = h.errorOrDestroy;

    function T() {}

    function E(e, t, s) {
      a = a || r(32), e = e || {}, "boolean" != typeof s && (s = t instanceof a), this.objectMode = !!e.objectMode, s && (this.objectMode = this.objectMode || !!e.writableObjectMode), this.highWaterMark = d(this, e, "writableHighWaterMark", s), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
      var o = !1 === e.decodeStrings;
      this.decodeStrings = !o, this.defaultEncoding = e.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(e) {
        ! function(e, t) {
          var r = e._writableState,
            i = r.sync,
            a = r.writecb;
          if ("function" != typeof a) throw new m;
          if (function(e) {
            e.writing = !1, e.writecb = null, e.length -= e.writelen, e.writelen = 0
          }(r), t) ! function(e, t, r, i, a) {
            --t.pendingcb, r ? (n.nextTick(a, i), n.nextTick(P, e, t), e._writableState.errorEmitted = !0, S(e, i)) : (a(i), e._writableState.errorEmitted = !0, S(e, i), P(e, t))
          }(e, r, i, t, a);
          else {
            var s = I(r) || e.destroyed;
            s || r.corked || r.bufferProcessing || !r.bufferedRequest || R(e, r), i ? n.nextTick(A, e, r, s, a) : A(e, r, s, a)
          }
        }(t, e)
      }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== e.emitClose, this.autoDestroy = !!e.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new i(this)
    }

    function x(e) {
      var t = this instanceof(a = a || r(32));
      if (!t && !l.call(x, this)) return new x(e);
      this._writableState = new E(e, this, t), this.writable = !0, e && ("function" == typeof e.write && (this._write = e.write), "function" == typeof e.writev && (this._writev = e.writev), "function" == typeof e.destroy && (this._destroy = e.destroy), "function" == typeof e.final && (this._final = e.final)), o.call(this)
    }

    function O(e, t, r, n, i, a, s) {
      t.writelen = n, t.writecb = s, t.writing = !0, t.sync = !0, t.destroyed ? t.onwrite(new b("write")) : r ? e._writev(i, t.onwrite) : e._write(i, a, t.onwrite), t.sync = !1
    }

    function A(e, t, r, n) {
      r || function(e, t) {
        0 === t.length && t.needDrain && (t.needDrain = !1, e.emit("drain"))
      }(e, t), t.pendingcb--, n(), P(e, t)
    }

    function R(e, t) {
      t.bufferProcessing = !0;
      var r = t.bufferedRequest;
      if (e._writev && r && r.next) {
        var n = t.bufferedRequestCount,
          a = new Array(n),
          s = t.corkedRequestsFree;
        s.entry = r;
        for (var o = 0, u = !0; r;) a[o] = r, r.isBuf || (u = !1), r = r.next, o += 1;
        a.allBuffers = u, O(e, t, !0, t.length, a, "", s.finish), t.pendingcb++, t.lastBufferedRequest = null, s.next ? (t.corkedRequestsFree = s.next, s.next = null) : t.corkedRequestsFree = new i(t), t.bufferedRequestCount = 0
      } else {
        for (; r;) {
          var c = r.chunk,
            l = r.encoding,
            h = r.callback;
          if (O(e, t, !1, t.objectMode ? 1 : c.length, c, l, h), r = r.next, t.bufferedRequestCount--, t.writing) break
        }
        null === r && (t.lastBufferedRequest = null)
      }
      t.bufferedRequest = r, t.bufferProcessing = !1
    }

    function I(e) {
      return e.ending && 0 === e.length && null === e.bufferedRequest && !e.finished && !e.writing
    }

    function N(e, t) {
      e._final((function(r) {
        t.pendingcb--, r && S(e, r), t.prefinished = !0, e.emit("prefinish"), P(e, t)
      }))
    }

    function P(e, t) {
      var r = I(t);
      if (r && (function(e, t) {
        t.prefinished || t.finalCalled || ("function" != typeof e._final || t.destroyed ? (t.prefinished = !0, e.emit("prefinish")) : (t.pendingcb++, t.finalCalled = !0, n.nextTick(N, e, t)))
      }(e, t), 0 === t.pendingcb && (t.finished = !0, e.emit("finish"), t.autoDestroy))) {
        var i = e._readableState;
        (!i || i.autoDestroy && i.endEmitted) && e.destroy()
      }
      return r
    }
    r(12)(x, o), E.prototype.getBuffer = function() {
      for (var e = this.bufferedRequest, t = []; e;) t.push(e), e = e.next;
      return t
    },
      function() {
        try {
          Object.defineProperty(E.prototype, "buffer", {
            get: s.deprecate((function() {
              return this.getBuffer()
            }), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
          })
        } catch (e) {}
      }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (l = Function.prototype[Symbol.hasInstance], Object.defineProperty(x, Symbol.hasInstance, {
      value: function(e) {
        return !!l.call(this, e) || this === x && (e && e._writableState instanceof E)
      }
    })) : l = function(e) {
      return e instanceof this
    }, x.prototype.pipe = function() {
      S(this, new y)
    }, x.prototype.write = function(e, t, r) {
      var i, a = this._writableState,
        s = !1,
        o = !a.objectMode && (i = e, u.isBuffer(i) || i instanceof c);
      return o && !u.isBuffer(e) && (e = function(e) {
        return u.from(e)
      }(e)), "function" == typeof t && (r = t, t = null), o ? t = "buffer" : t || (t = a.defaultEncoding), "function" != typeof r && (r = T), a.ending ? function(e, t) {
        var r = new v;
        S(e, r), n.nextTick(t, r)
      }(this, r) : (o || function(e, t, r, i) {
        var a;
        return null === r ? a = new _ : "string" == typeof r || t.objectMode || (a = new f("chunk", ["string", "Buffer"], r)), !a || (S(e, a), n.nextTick(i, a), !1)
      }(this, a, e, r)) && (a.pendingcb++, s = function(e, t, r, n, i, a) {
        if (!r) {
          var s = function(e, t, r) {
            e.objectMode || !1 === e.decodeStrings || "string" != typeof t || (t = u.from(t, r));
            return t
          }(t, n, i);
          n !== s && (r = !0, i = "buffer", n = s)
        }
        var o = t.objectMode ? 1 : n.length;
        t.length += o;
        var c = t.length < t.highWaterMark;
        c || (t.needDrain = !0);
        if (t.writing || t.corked) {
          var l = t.lastBufferedRequest;
          t.lastBufferedRequest = {
            chunk: n,
            encoding: i,
            isBuf: r,
            callback: a,
            next: null
          }, l ? l.next = t.lastBufferedRequest : t.bufferedRequest = t.lastBufferedRequest, t.bufferedRequestCount += 1
        } else O(e, t, !1, o, n, i, a);
        return c
      }(this, a, o, e, t, r)), s
    }, x.prototype.cork = function() {
      this._writableState.corked++
    }, x.prototype.uncork = function() {
      var e = this._writableState;
      e.corked && (e.corked--, e.writing || e.corked || e.bufferProcessing || !e.bufferedRequest || R(this, e))
    }, x.prototype.setDefaultEncoding = function(e) {
      if ("string" == typeof e && (e = e.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e + "").toLowerCase()) > -1)) throw new w(e);
      return this._writableState.defaultEncoding = e, this
    }, Object.defineProperty(x.prototype, "writableBuffer", {
      enumerable: !1,
      get: function() {
        return this._writableState && this._writableState.getBuffer()
      }
    }), Object.defineProperty(x.prototype, "writableHighWaterMark", {
      enumerable: !1,
      get: function() {
        return this._writableState.highWaterMark
      }
    }), x.prototype._write = function(e, t, r) {
      r(new g("_write()"))
    }, x.prototype._writev = null, x.prototype.end = function(e, t, r) {
      var i = this._writableState;
      return "function" == typeof e ? (r = e, e = null, t = null) : "function" == typeof t && (r = t, t = null), null != e && this.write(e, t), i.corked && (i.corked = 1, this.uncork()), i.ending || function(e, t, r) {
        t.ending = !0, P(e, t), r && (t.finished ? n.nextTick(r) : e.once("finish", r));
        t.ended = !0, e.writable = !1
      }(this, i, r), this
    }, Object.defineProperty(x.prototype, "writableLength", {
      enumerable: !1,
      get: function() {
        return this._writableState.length
      }
    }), Object.defineProperty(x.prototype, "destroyed", {
      enumerable: !1,
      get: function() {
        return void 0 !== this._writableState && this._writableState.destroyed
      },
      set: function(e) {
        this._writableState && (this._writableState.destroyed = e)
      }
    }), x.prototype.destroy = h.destroy, x.prototype._undestroy = h.undestroy, x.prototype._destroy = function(e, t) {
      t(e)
    }
  }).call(this, r(10), r(8))
}, function(e, t, r) {
  (function(t) {
    function r(e) {
      try {
        if (!t.localStorage) return !1
      } catch (e) {
        return !1
      }
      var r = t.localStorage[e];
      return null != r && "true" === String(r).toLowerCase()
    }
    e.exports = function(e, t) {
      if (r("noDeprecation")) return e;
      var n = !1;
      return function() {
        if (!n) {
          if (r("throwDeprecation")) throw new Error(t);
          r("traceDeprecation") ? console.trace(t) : console.warn(t), n = !0
        }
        return e.apply(this, arguments)
      }
    }
  }).call(this, r(10))
}, function(e, t, r) {
  "use strict";
  e.exports = l;
  var n = r(31).codes,
    i = n.ERR_METHOD_NOT_IMPLEMENTED,
    a = n.ERR_MULTIPLE_CALLBACK,
    s = n.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    o = n.ERR_TRANSFORM_WITH_LENGTH_0,
    u = r(32);

  function c(e, t) {
    var r = this._transformState;
    r.transforming = !1;
    var n = r.writecb;
    if (null === n) return this.emit("error", new a);
    r.writechunk = null, r.writecb = null, null != t && this.push(t), n(e);
    var i = this._readableState;
    i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
  }

  function l(e) {
    if (!(this instanceof l)) return new l(e);
    u.call(this, e), this._transformState = {
      afterTransform: c.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && ("function" == typeof e.transform && (this._transform = e.transform), "function" == typeof e.flush && (this._flush = e.flush)), this.on("prefinish", h)
  }

  function h() {
    var e = this;
    "function" != typeof this._flush || this._readableState.destroyed ? d(this, null, null) : this._flush((function(t, r) {
      d(e, t, r)
    }))
  }

  function d(e, t, r) {
    if (t) return e.emit("error", t);
    if (null != r && e.push(r), e._writableState.length) throw new o;
    if (e._transformState.transforming) throw new s;
    return e.push(null)
  }
  r(12)(l, u), l.prototype.push = function(e, t) {
    return this._transformState.needTransform = !1, u.prototype.push.call(this, e, t)
  }, l.prototype._transform = function(e, t, r) {
    r(new i("_transform()"))
  }, l.prototype._write = function(e, t, r) {
    var n = this._transformState;
    if (n.writecb = r, n.writechunk = e, n.writeencoding = t, !n.transforming) {
      var i = this._readableState;
      (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
    }
  }, l.prototype._read = function(e) {
    var t = this._transformState;
    null === t.writechunk || t.transforming ? t.needTransform = !0 : (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform))
  }, l.prototype._destroy = function(e, t) {
    u.prototype._destroy.call(this, e, (function(e) {
      t(e)
    }))
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationTyped = t.KEY_CONTEXT_QUERYOPERATION = void 0;
  const n = r(94);
  t.KEY_CONTEXT_QUERYOPERATION = "@comunica/bus-query-operation:operation";
  class i extends n.ActorQueryOperation {
    constructor(e, t) {
      if (super(Object.assign(Object.assign({}, e), {
        operationName: t
      })), !this.operationName) throw new Error('A valid "operationName" argument must be provided.')
    }
    async test(e) {
      if (!e.operation) throw new Error("Missing field 'operation' in a query operation action.");
      if (e.operation.type !== this.operationName) throw new Error(`Actor ${this.name} only supports ${this.operationName} operations, but got ${e.operation.type}`);
      const t = e.operation;
      return this.testOperation(t, e.context)
    }
    async run(e) {
      const r = e.operation,
        i = e.context && e.context.set(t.KEY_CONTEXT_QUERYOPERATION, r),
        a = await this.runOperation(r, i);
      return a.metadata && (a.metadata = n.ActorQueryOperation.cachifyMetadata(a.metadata)), a
    }
  }
  t.ActorQueryOperationTyped = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfResolveQuadPattern = t.getDataSourceContext = t.getDataSourceValue = t.getDataSourceType = t.isDataSourceRawType = t.KEY_CONTEXT_SOURCE = t.KEY_CONTEXT_SOURCES = void 0;
  const n = r(0);

  function i(e) {
    return "string" == typeof e || "match" in e
  }

  function a(e) {
    return "string" == typeof e ? "" : "match" in e ? "rdfjsSource" : e.type
  }

  function s(e) {
    return i(e) ? e : e.value
  }
  t.KEY_CONTEXT_SOURCES = "@comunica/bus-rdf-resolve-quad-pattern:sources", t.KEY_CONTEXT_SOURCE = "@comunica/bus-rdf-resolve-quad-pattern:source", t.isDataSourceRawType = i, t.getDataSourceType = a, t.getDataSourceValue = s, t.getDataSourceContext = function(e, t) {
    return "string" == typeof e || "match" in e || !e.context ? t : t.merge(e.context)
  };
  class o extends n.Actor {
    constructor(e) {
      super(e)
    }
    getContextSources(e) {
      return e ? e.get(t.KEY_CONTEXT_SOURCES) : void 0
    }
    getContextSource(e) {
      return e ? e.get(t.KEY_CONTEXT_SOURCE) : void 0
    }
    getContextSourceUrl(e) {
      if (e) {
        let t = s(e);
        if ("string" == typeof t) {
          const e = t.indexOf("#");
          return e >= 0 && (t = t.slice(0, e)), t
        }
      }
    }
    hasContextSingleSource(e) {
      const t = this.getContextSource(e);
      return Boolean(t && (i(t) || t.value))
    }
    hasContextSingleSourceOfType(e, t) {
      const r = this.getContextSource(t);
      return Boolean(r && a(r) === e && s(r))
    }
  }
  t.ActorRdfResolveQuadPattern = o
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.bindingsStreamToGraphQl = void 0, i(r(114), t);
  const a = r(114),
    {
      bindingsStreamToGraphQl: s
    } = a.ActorSparqlSerializeTree;
  t.bindingsStreamToGraphQl = s
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorSparqlSerializeTree = void 0;
  const n = r(2),
    i = r(15),
    a = r(0),
    s = r(120);
  class o extends i.ActorSparqlSerializeFixedMediaTypes {
    constructor(e) {
      super(e)
    }
    static bindingsStreamToGraphQl(e, t, r) {
      const n = a.ensureActionContext(t);
      return new Promise((t, i) => {
        const a = [],
          o = new s.Converter(r),
          u = {
            singularizeVariables: n.get("@comunica/actor-init-sparql:singularizeVariables") || {}
          };
        e.on("error", i), e.on("data", e => {
          const t = e.toJS(),
            r = {};
          for (const e in t) r[e.slice(1)] = t[e];
          a.push(r)
        }), e.on("end", () => {
          t(o.bindingsToTree(a, u))
        })
      })
    }
    async testHandleChecked(e) {
      if ("bindings" !== e.type) throw new Error("This actor can only handle bindings streams.");
      return !0
    }
    async runHandle(e, t) {
      const r = new n.Readable;
      r._read = () => {};
      const i = e.bindingsStream;
      return i.on("error", e => r.emit("error", e)), o.bindingsStreamToGraphQl(i, e.context, {
        materializeRdfJsTerms: !0
      }).then(e => {
        r.push(JSON.stringify(e, null, "  ")), r.push(null)
      }).catch(e => r.emit("error", e)), {
        data: r
      }
    }
  }
  t.ActorSparqlSerializeTree = o
}, function(e, t, r) {
  "use strict";
  (function(t, n) {
    var i = r(54);
    e.exports = _;
    var a, s = r(103);
    _.ReadableState = b;
    r(22).EventEmitter;
    var o = function(e, t) {
        return e.listeners(t).length
      },
      u = r(116),
      c = r(72).Buffer,
      l = t.Uint8Array || function() {};
    var h = Object.create(r(43));
    h.inherits = r(12);
    var d = r(219),
      p = void 0;
    p = d && d.debuglog ? d.debuglog("stream") : function() {};
    var f, g = r(220),
      m = r(117);
    h.inherits(_, u);
    var y = ["error", "close", "destroy", "pause", "resume"];

    function b(e, t) {
      e = e || {};
      var n = t instanceof(a = a || r(25));
      this.objectMode = !!e.objectMode, n && (this.objectMode = this.objectMode || !!e.readableObjectMode);
      var i = e.highWaterMark,
        s = e.readableHighWaterMark,
        o = this.objectMode ? 16 : 16384;
      this.highWaterMark = i || 0 === i ? i : n && (s || 0 === s) ? s : o, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new g, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = e.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, e.encoding && (f || (f = r(33).StringDecoder), this.decoder = new f(e.encoding), this.encoding = e.encoding)
    }

    function _(e) {
      if (a = a || r(25), !(this instanceof _)) return new _(e);
      this._readableState = new b(e, this), this.readable = !0, e && ("function" == typeof e.read && (this._read = e.read), "function" == typeof e.destroy && (this._destroy = e.destroy)), u.call(this)
    }

    function v(e, t, r, n, i) {
      var a, s = e._readableState;
      null === t ? (s.reading = !1, function(e, t) {
        if (t.ended) return;
        if (t.decoder) {
          var r = t.decoder.end();
          r && r.length && (t.buffer.push(r), t.length += t.objectMode ? 1 : r.length)
        }
        t.ended = !0, T(e)
      }(e, s)) : (i || (a = function(e, t) {
        var r;
        n = t, c.isBuffer(n) || n instanceof l || "string" == typeof t || void 0 === t || e.objectMode || (r = new TypeError("Invalid non-string/buffer chunk"));
        var n;
        return r
      }(s, t)), a ? e.emit("error", a) : s.objectMode || t && t.length > 0 ? ("string" == typeof t || s.objectMode || Object.getPrototypeOf(t) === c.prototype || (t = function(e) {
        return c.from(e)
      }(t)), n ? s.endEmitted ? e.emit("error", new Error("stream.unshift() after end event")) : w(e, s, t, !0) : s.ended ? e.emit("error", new Error("stream.push() after EOF")) : (s.reading = !1, s.decoder && !r ? (t = s.decoder.write(t), s.objectMode || 0 !== t.length ? w(e, s, t, !1) : x(e, s)) : w(e, s, t, !1))) : n || (s.reading = !1));
      return function(e) {
        return !e.ended && (e.needReadable || e.length < e.highWaterMark || 0 === e.length)
      }(s)
    }

    function w(e, t, r, n) {
      t.flowing && 0 === t.length && !t.sync ? (e.emit("data", r), e.read(0)) : (t.length += t.objectMode ? 1 : r.length, n ? t.buffer.unshift(r) : t.buffer.push(r), t.needReadable && T(e)), x(e, t)
    }
    Object.defineProperty(_.prototype, "destroyed", {
      get: function() {
        return void 0 !== this._readableState && this._readableState.destroyed
      },
      set: function(e) {
        this._readableState && (this._readableState.destroyed = e)
      }
    }), _.prototype.destroy = m.destroy, _.prototype._undestroy = m.undestroy, _.prototype._destroy = function(e, t) {
      this.push(null), t(e)
    }, _.prototype.push = function(e, t) {
      var r, n = this._readableState;
      return n.objectMode ? r = !0 : "string" == typeof e && ((t = t || n.defaultEncoding) !== n.encoding && (e = c.from(e, t), t = ""), r = !0), v(this, e, t, !1, r)
    }, _.prototype.unshift = function(e) {
      return v(this, e, null, !0, !1)
    }, _.prototype.isPaused = function() {
      return !1 === this._readableState.flowing
    }, _.prototype.setEncoding = function(e) {
      return f || (f = r(33).StringDecoder), this._readableState.decoder = new f(e), this._readableState.encoding = e, this
    };

    function S(e, t) {
      return e <= 0 || 0 === t.length && t.ended ? 0 : t.objectMode ? 1 : e != e ? t.flowing && t.length ? t.buffer.head.data.length : t.length : (e > t.highWaterMark && (t.highWaterMark = function(e) {
        return e >= 8388608 ? e = 8388608 : (e--, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e++), e
      }(e)), e <= t.length ? e : t.ended ? t.length : (t.needReadable = !0, 0))
    }

    function T(e) {
      var t = e._readableState;
      t.needReadable = !1, t.emittedReadable || (p("emitReadable", t.flowing), t.emittedReadable = !0, t.sync ? i.nextTick(E, e) : E(e))
    }

    function E(e) {
      p("emit readable"), e.emit("readable"), I(e)
    }

    function x(e, t) {
      t.readingMore || (t.readingMore = !0, i.nextTick(O, e, t))
    }

    function O(e, t) {
      for (var r = t.length; !t.reading && !t.flowing && !t.ended && t.length < t.highWaterMark && (p("maybeReadMore read 0"), e.read(0), r !== t.length);) r = t.length;
      t.readingMore = !1
    }

    function A(e) {
      p("readable nexttick read 0"), e.read(0)
    }

    function R(e, t) {
      t.reading || (p("resume read 0"), e.read(0)), t.resumeScheduled = !1, t.awaitDrain = 0, e.emit("resume"), I(e), t.flowing && !t.reading && e.read(0)
    }

    function I(e) {
      var t = e._readableState;
      for (p("flow", t.flowing); t.flowing && null !== e.read(););
    }

    function N(e, t) {
      return 0 === t.length ? null : (t.objectMode ? r = t.buffer.shift() : !e || e >= t.length ? (r = t.decoder ? t.buffer.join("") : 1 === t.buffer.length ? t.buffer.head.data : t.buffer.concat(t.length), t.buffer.clear()) : r = function(e, t, r) {
        var n;
        e < t.head.data.length ? (n = t.head.data.slice(0, e), t.head.data = t.head.data.slice(e)) : n = e === t.head.data.length ? t.shift() : r ? function(e, t) {
          var r = t.head,
            n = 1,
            i = r.data;
          e -= i.length;
          for (; r = r.next;) {
            var a = r.data,
              s = e > a.length ? a.length : e;
            if (s === a.length ? i += a : i += a.slice(0, e), 0 === (e -= s)) {
              s === a.length ? (++n, r.next ? t.head = r.next : t.head = t.tail = null) : (t.head = r, r.data = a.slice(s));
              break
            }++n
          }
          return t.length -= n, i
        }(e, t) : function(e, t) {
          var r = c.allocUnsafe(e),
            n = t.head,
            i = 1;
          n.data.copy(r), e -= n.data.length;
          for (; n = n.next;) {
            var a = n.data,
              s = e > a.length ? a.length : e;
            if (a.copy(r, r.length - e, 0, s), 0 === (e -= s)) {
              s === a.length ? (++i, n.next ? t.head = n.next : t.head = t.tail = null) : (t.head = n, n.data = a.slice(s));
              break
            }++i
          }
          return t.length -= i, r
        }(e, t);
        return n
      }(e, t.buffer, t.decoder), r);
      var r
    }

    function P(e) {
      var t = e._readableState;
      if (t.length > 0) throw new Error('"endReadable()" called on non-empty stream');
      t.endEmitted || (t.ended = !0, i.nextTick(C, t, e))
    }

    function C(e, t) {
      e.endEmitted || 0 !== e.length || (e.endEmitted = !0, t.readable = !1, t.emit("end"))
    }

    function D(e, t) {
      for (var r = 0, n = e.length; r < n; r++)
        if (e[r] === t) return r;
      return -1
    }
    _.prototype.read = function(e) {
      p("read", e), e = parseInt(e, 10);
      var t = this._readableState,
        r = e;
      if (0 !== e && (t.emittedReadable = !1), 0 === e && t.needReadable && (t.length >= t.highWaterMark || t.ended)) return p("read: emitReadable", t.length, t.ended), 0 === t.length && t.ended ? P(this) : T(this), null;
      if (0 === (e = S(e, t)) && t.ended) return 0 === t.length && P(this), null;
      var n, i = t.needReadable;
      return p("need readable", i), (0 === t.length || t.length - e < t.highWaterMark) && p("length less than watermark", i = !0), t.ended || t.reading ? p("reading or ended", i = !1) : i && (p("do read"), t.reading = !0, t.sync = !0, 0 === t.length && (t.needReadable = !0), this._read(t.highWaterMark), t.sync = !1, t.reading || (e = S(r, t))), null === (n = e > 0 ? N(e, t) : null) ? (t.needReadable = !0, e = 0) : t.length -= e, 0 === t.length && (t.ended || (t.needReadable = !0), r !== e && t.ended && P(this)), null !== n && this.emit("data", n), n
    }, _.prototype._read = function(e) {
      this.emit("error", new Error("_read() is not implemented"))
    }, _.prototype.pipe = function(e, t) {
      var r = this,
        a = this._readableState;
      switch (a.pipesCount) {
        case 0:
          a.pipes = e;
          break;
        case 1:
          a.pipes = [a.pipes, e];
          break;
        default:
          a.pipes.push(e)
      }
      a.pipesCount += 1, p("pipe count=%d opts=%j", a.pipesCount, t);
      var u = (!t || !1 !== t.end) && e !== n.stdout && e !== n.stderr ? l : _;

      function c(t, n) {
        p("onunpipe"), t === r && n && !1 === n.hasUnpiped && (n.hasUnpiped = !0, p("cleanup"), e.removeListener("close", y), e.removeListener("finish", b), e.removeListener("drain", h), e.removeListener("error", m), e.removeListener("unpipe", c), r.removeListener("end", l), r.removeListener("end", _), r.removeListener("data", g), d = !0, !a.awaitDrain || e._writableState && !e._writableState.needDrain || h())
      }

      function l() {
        p("onend"), e.end()
      }
      a.endEmitted ? i.nextTick(u) : r.once("end", u), e.on("unpipe", c);
      var h = function(e) {
        return function() {
          var t = e._readableState;
          p("pipeOnDrain", t.awaitDrain), t.awaitDrain && t.awaitDrain--, 0 === t.awaitDrain && o(e, "data") && (t.flowing = !0, I(e))
        }
      }(r);
      e.on("drain", h);
      var d = !1;
      var f = !1;

      function g(t) {
        p("ondata"), f = !1, !1 !== e.write(t) || f || ((1 === a.pipesCount && a.pipes === e || a.pipesCount > 1 && -1 !== D(a.pipes, e)) && !d && (p("false write response, pause", r._readableState.awaitDrain), r._readableState.awaitDrain++, f = !0), r.pause())
      }

      function m(t) {
        p("onerror", t), _(), e.removeListener("error", m), 0 === o(e, "error") && e.emit("error", t)
      }

      function y() {
        e.removeListener("finish", b), _()
      }

      function b() {
        p("onfinish"), e.removeListener("close", y), _()
      }

      function _() {
        p("unpipe"), r.unpipe(e)
      }
      return r.on("data", g),
        function(e, t, r) {
          if ("function" == typeof e.prependListener) return e.prependListener(t, r);
          e._events && e._events[t] ? s(e._events[t]) ? e._events[t].unshift(r) : e._events[t] = [r, e._events[t]] : e.on(t, r)
        }(e, "error", m), e.once("close", y), e.once("finish", b), e.emit("pipe", r), a.flowing || (p("pipe resume"), r.resume()), e
    }, _.prototype.unpipe = function(e) {
      var t = this._readableState,
        r = {
          hasUnpiped: !1
        };
      if (0 === t.pipesCount) return this;
      if (1 === t.pipesCount) return e && e !== t.pipes || (e || (e = t.pipes), t.pipes = null, t.pipesCount = 0, t.flowing = !1, e && e.emit("unpipe", this, r)), this;
      if (!e) {
        var n = t.pipes,
          i = t.pipesCount;
        t.pipes = null, t.pipesCount = 0, t.flowing = !1;
        for (var a = 0; a < i; a++) n[a].emit("unpipe", this, r);
        return this
      }
      var s = D(t.pipes, e);
      return -1 === s || (t.pipes.splice(s, 1), t.pipesCount -= 1, 1 === t.pipesCount && (t.pipes = t.pipes[0]), e.emit("unpipe", this, r)), this
    }, _.prototype.on = function(e, t) {
      var r = u.prototype.on.call(this, e, t);
      if ("data" === e) !1 !== this._readableState.flowing && this.resume();
      else if ("readable" === e) {
        var n = this._readableState;
        n.endEmitted || n.readableListening || (n.readableListening = n.needReadable = !0, n.emittedReadable = !1, n.reading ? n.length && T(this) : i.nextTick(A, this))
      }
      return r
    }, _.prototype.addListener = _.prototype.on, _.prototype.resume = function() {
      var e = this._readableState;
      return e.flowing || (p("resume"), e.flowing = !0, function(e, t) {
        t.resumeScheduled || (t.resumeScheduled = !0, i.nextTick(R, e, t))
      }(this, e)), this
    }, _.prototype.pause = function() {
      return p("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (p("pause"), this._readableState.flowing = !1, this.emit("pause")), this
    }, _.prototype.wrap = function(e) {
      var t = this,
        r = this._readableState,
        n = !1;
      for (var i in e.on("end", (function() {
        if (p("wrapped end"), r.decoder && !r.ended) {
          var e = r.decoder.end();
          e && e.length && t.push(e)
        }
        t.push(null)
      })), e.on("data", (function(i) {
        (p("wrapped data"), r.decoder && (i = r.decoder.write(i)), r.objectMode && null == i) || (r.objectMode || i && i.length) && (t.push(i) || (n = !0, e.pause()))
      })), e) void 0 === this[i] && "function" == typeof e[i] && (this[i] = function(t) {
        return function() {
          return e[t].apply(e, arguments)
        }
      }(i));
      for (var a = 0; a < y.length; a++) e.on(y[a], this.emit.bind(this, y[a]));
      return this._read = function(t) {
        p("wrapped _read", t), n && (n = !1, e.resume())
      }, this
    }, Object.defineProperty(_.prototype, "readableHighWaterMark", {
      enumerable: !1,
      get: function() {
        return this._readableState.highWaterMark
      }
    }), _._fromList = N
  }).call(this, r(10), r(8))
}, function(e, t, r) {
  e.exports = r(22).EventEmitter
}, function(e, t, r) {
  "use strict";
  var n = r(54);

  function i(e, t) {
    e.emit("error", t)
  }
  e.exports = {
    destroy: function(e, t) {
      var r = this,
        a = this._readableState && this._readableState.destroyed,
        s = this._writableState && this._writableState.destroyed;
      return a || s ? (t ? t(e) : !e || this._writableState && this._writableState.errorEmitted || n.nextTick(i, this, e), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, (function(e) {
        !t && e ? (n.nextTick(i, r, e), r._writableState && (r._writableState.errorEmitted = !0)) : t && t(e)
      })), this)
    },
    undestroy: function() {
      this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1)
    }
  }
}, function(e, t, r) {
  "use strict";
  e.exports = s;
  var n = r(25),
    i = Object.create(r(43));

  function a(e, t) {
    var r = this._transformState;
    r.transforming = !1;
    var n = r.writecb;
    if (!n) return this.emit("error", new Error("write callback called multiple times"));
    r.writechunk = null, r.writecb = null, null != t && this.push(t), n(e);
    var i = this._readableState;
    i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
  }

  function s(e) {
    if (!(this instanceof s)) return new s(e);
    n.call(this, e), this._transformState = {
      afterTransform: a.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && ("function" == typeof e.transform && (this._transform = e.transform), "function" == typeof e.flush && (this._flush = e.flush)), this.on("prefinish", o)
  }

  function o() {
    var e = this;
    "function" == typeof this._flush ? this._flush((function(t, r) {
      u(e, t, r)
    })) : u(this, null, null)
  }

  function u(e, t, r) {
    if (t) return e.emit("error", t);
    if (null != r && e.push(r), e._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (e._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return e.push(null)
  }
  i.inherits = r(12), i.inherits(s, n), s.prototype.push = function(e, t) {
    return this._transformState.needTransform = !1, n.prototype.push.call(this, e, t)
  }, s.prototype._transform = function(e, t, r) {
    throw new Error("_transform() is not implemented")
  }, s.prototype._write = function(e, t, r) {
    var n = this._transformState;
    if (n.writecb = r, n.writechunk = e, n.writeencoding = t, !n.transforming) {
      var i = this._readableState;
      (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this._read(i.highWaterMark)
    }
  }, s.prototype._read = function(e) {
    var t = this._transformState;
    null !== t.writechunk && t.writecb && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0
  }, s.prototype._destroy = function(e, t) {
    var r = this;
    n.prototype._destroy.call(this, e, (function(e) {
      t(e), r.emit("close")
    }))
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorAbstractMediaTyped = void 0;
  const n = r(0);
  class i extends n.Actor {
    constructor(e) {
      super(e)
    }
    async run(e) {
      if ("handle" in e) {
        const t = e;
        return {
          handle: await this.runHandle(t.handle, t.handleMediaType, e.context)
        }
      }
      if ("mediaTypes" in e) return {
        mediaTypes: await this.getMediaTypes(e.context)
      };
      if ("mediaTypeFormats" in e) return {
        mediaTypeFormats: await this.getMediaTypeFormats(e.context)
      };
      throw new Error("Either a handle, mediaTypes or mediaTypeFormats action needs to be provided")
    }
    async test(e) {
      if ("handle" in e) {
        const t = e;
        return {
          handle: await this.testHandle(t.handle, t.handleMediaType, e.context)
        }
      }
      if ("mediaTypes" in e) return {
        mediaTypes: await this.testMediaType(e.context)
      };
      if ("mediaTypeFormats" in e) return {
        mediaTypeFormats: await this.testMediaTypeFormats(e.context)
      };
      throw new Error("Either a handle, mediaTypes or mediaTypeFormats action needs to be provided")
    }
  }
  t.ActorAbstractMediaTyped = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(231), t)
}, function(e, t, r) {
  "use strict";

  function n(e) {
    for (var r in e) t.hasOwnProperty(r) || (t[r] = e[r])
  }
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), n(r(233)), n(r(234)), n(r(235)), n(r(236)), n(r(237))
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.SparqlJsonBindingsTransformer = void 0;
  const n = r(2);
  class i extends n.Transform {
    constructor(e) {
      super({
        objectMode: !0
      }), this.parser = e
    }
    _transform(e, t, r) {
      r(null, this.parser.parseJsonBindings(e))
    }
  }
  t.SparqlJsonBindingsTransformer = i
}, function(e, t, r) {
  (function(t) {
    var r = {},
      n = r.LEFT_BRACE = 1,
      i = r.RIGHT_BRACE = 2,
      a = r.LEFT_BRACKET = 3,
      s = r.RIGHT_BRACKET = 4,
      o = r.COLON = 5,
      u = r.COMMA = 6,
      c = r.TRUE = 7,
      l = r.FALSE = 8,
      h = r.NULL = 9,
      d = r.STRING = 10,
      p = r.NUMBER = 11,
      f = r.START = 17,
      g = r.STOP = 18,
      m = r.TRUE1 = 33,
      y = r.TRUE2 = 34,
      b = r.TRUE3 = 35,
      _ = r.FALSE1 = 49,
      v = r.FALSE2 = 50,
      w = r.FALSE3 = 51,
      S = r.FALSE4 = 52,
      T = r.NULL1 = 65,
      E = r.NULL2 = 66,
      x = r.NULL3 = 67,
      O = r.NUMBER1 = 81,
      A = r.NUMBER3 = 83,
      R = r.STRING1 = 97,
      I = r.STRING2 = 98,
      N = r.STRING3 = 99,
      P = r.STRING4 = 100,
      C = r.STRING5 = 101,
      D = r.STRING6 = 102,
      j = r.VALUE = 113,
      k = r.KEY = 114,
      L = r.OBJECT = 129,
      M = r.ARRAY = 130,
      F = "\\".charCodeAt(0),
      B = "/".charCodeAt(0),
      q = "\b".charCodeAt(0),
      U = "\f".charCodeAt(0),
      V = "\n".charCodeAt(0),
      H = "\r".charCodeAt(0),
      G = "\t".charCodeAt(0);

    function z() {
      this.tState = f, this.value = void 0, this.string = void 0, this.stringBuffer = t.alloc ? t.alloc(65536) : new t(65536), this.stringBufferOffset = 0, this.unicode = void 0, this.highSurrogate = void 0, this.key = void 0, this.mode = void 0, this.stack = [], this.state = j, this.bytes_remaining = 0, this.bytes_in_sequence = 0, this.temp_buffs = {
        2: new t(2),
        3: new t(3),
        4: new t(4)
      }, this.offset = -1
    }
    z.toknam = function(e) {
      for (var t = Object.keys(r), n = 0, i = t.length; n < i; n++) {
        var a = t[n];
        if (r[a] === e) return a
      }
      return e && "0x" + e.toString(16)
    };
    var Q = z.prototype;
    Q.onError = function(e) {
      throw e
    }, Q.charError = function(e, t) {
      this.tState = g, this.onError(new Error("Unexpected " + JSON.stringify(String.fromCharCode(e[t])) + " at position " + t + " in state " + z.toknam(this.tState)))
    }, Q.appendStringChar = function(e) {
      this.stringBufferOffset >= 65536 && (this.string += this.stringBuffer.toString("utf8"), this.stringBufferOffset = 0), this.stringBuffer[this.stringBufferOffset++] = e
    }, Q.appendStringBuf = function(e, t, r) {
      var n = e.length;
      "number" == typeof t && (n = "number" == typeof r ? r < 0 ? e.length - t + r : r - t : e.length - t), n < 0 && (n = 0), this.stringBufferOffset + n > 65536 && (this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset), this.stringBufferOffset = 0), e.copy(this.stringBuffer, this.stringBufferOffset, t, r), this.stringBufferOffset += n
    }, Q.write = function(e) {
      var r;
      "string" == typeof e && (e = new t(e));
      for (var g = 0, j = e.length; g < j; g++)
        if (this.tState === f) {
          if (r = e[g], this.offset++, 123 === r) this.onToken(n, "{");
          else if (125 === r) this.onToken(i, "}");
          else if (91 === r) this.onToken(a, "[");
          else if (93 === r) this.onToken(s, "]");
          else if (58 === r) this.onToken(o, ":");
          else if (44 === r) this.onToken(u, ",");
          else if (116 === r) this.tState = m;
          else if (102 === r) this.tState = _;
          else if (110 === r) this.tState = T;
          else if (34 === r) this.string = "", this.stringBufferOffset = 0, this.tState = R;
          else if (45 === r) this.string = "-", this.tState = O;
          else if (r >= 48 && r < 64) this.string = String.fromCharCode(r), this.tState = A;
          else if (32 !== r && 9 !== r && 10 !== r && 13 !== r) return this.charError(e, g)
        } else if (this.tState === R)
          if (r = e[g], this.bytes_remaining > 0) {
            for (var k = 0; k < this.bytes_remaining; k++) this.temp_buffs[this.bytes_in_sequence][this.bytes_in_sequence - this.bytes_remaining + k] = e[k];
            this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]), this.bytes_in_sequence = this.bytes_remaining = 0, g = g + k - 1
          } else if (0 === this.bytes_remaining && r >= 128) {
            if (r <= 193 || r > 244) return this.onError(new Error("Invalid UTF-8 character at position " + g + " in state " + z.toknam(this.tState)));
            if (r >= 194 && r <= 223 && (this.bytes_in_sequence = 2), r >= 224 && r <= 239 && (this.bytes_in_sequence = 3), r >= 240 && r <= 244 && (this.bytes_in_sequence = 4), this.bytes_in_sequence + g > e.length) {
              for (var L = 0; L <= e.length - 1 - g; L++) this.temp_buffs[this.bytes_in_sequence][L] = e[g + L];
              this.bytes_remaining = g + this.bytes_in_sequence - e.length, g = e.length - 1
            } else this.appendStringBuf(e, g, g + this.bytes_in_sequence), g = g + this.bytes_in_sequence - 1
          } else if (34 === r) this.tState = f, this.string += this.stringBuffer.toString("utf8", 0, this.stringBufferOffset), this.stringBufferOffset = 0, this.onToken(d, this.string), this.offset += t.byteLength(this.string, "utf8") + 1, this.string = void 0;
          else if (92 === r) this.tState = I;
          else {
            if (!(r >= 32)) return this.charError(e, g);
            this.appendStringChar(r)
          } else if (this.tState === I)
          if (34 === (r = e[g])) this.appendStringChar(r), this.tState = R;
          else if (92 === r) this.appendStringChar(F), this.tState = R;
          else if (47 === r) this.appendStringChar(B), this.tState = R;
          else if (98 === r) this.appendStringChar(q), this.tState = R;
          else if (102 === r) this.appendStringChar(U), this.tState = R;
          else if (110 === r) this.appendStringChar(V), this.tState = R;
          else if (114 === r) this.appendStringChar(H), this.tState = R;
          else if (116 === r) this.appendStringChar(G), this.tState = R;
          else {
            if (117 !== r) return this.charError(e, g);
            this.unicode = "", this.tState = N
          } else if (this.tState === N || this.tState === P || this.tState === C || this.tState === D) {
          if (!((r = e[g]) >= 48 && r < 64 || r > 64 && r <= 70 || r > 96 && r <= 102)) return this.charError(e, g);
          if (this.unicode += String.fromCharCode(r), this.tState++ === D) {
            var M = parseInt(this.unicode, 16);
            this.unicode = void 0, void 0 !== this.highSurrogate && M >= 56320 && M < 57344 ? (this.appendStringBuf(new t(String.fromCharCode(this.highSurrogate, M))), this.highSurrogate = void 0) : void 0 === this.highSurrogate && M >= 55296 && M < 56320 ? this.highSurrogate = M : (void 0 !== this.highSurrogate && (this.appendStringBuf(new t(String.fromCharCode(this.highSurrogate))), this.highSurrogate = void 0), this.appendStringBuf(new t(String.fromCharCode(M)))), this.tState = R
          }
        } else if (this.tState === O || this.tState === A) switch (r = e[g]) {
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
          case 46:
          case 101:
          case 69:
          case 43:
          case 45:
            this.string += String.fromCharCode(r), this.tState = A;
            break;
          default:
            this.tState = f;
            var Q = Number(this.string);
            if (isNaN(Q)) return this.charError(e, g);
            this.string.match(/[0-9]+/) == this.string && Q.toString() != this.string ? this.onToken(d, this.string) : this.onToken(p, Q), this.offset += this.string.length - 1, this.string = void 0, g--
        } else if (this.tState === m) {
          if (114 !== e[g]) return this.charError(e, g);
          this.tState = y
        } else if (this.tState === y) {
          if (117 !== e[g]) return this.charError(e, g);
          this.tState = b
        } else if (this.tState === b) {
          if (101 !== e[g]) return this.charError(e, g);
          this.tState = f, this.onToken(c, !0), this.offset += 3
        } else if (this.tState === _) {
          if (97 !== e[g]) return this.charError(e, g);
          this.tState = v
        } else if (this.tState === v) {
          if (108 !== e[g]) return this.charError(e, g);
          this.tState = w
        } else if (this.tState === w) {
          if (115 !== e[g]) return this.charError(e, g);
          this.tState = S
        } else if (this.tState === S) {
          if (101 !== e[g]) return this.charError(e, g);
          this.tState = f, this.onToken(l, !1), this.offset += 4
        } else if (this.tState === T) {
          if (117 !== e[g]) return this.charError(e, g);
          this.tState = E
        } else if (this.tState === E) {
          if (108 !== e[g]) return this.charError(e, g);
          this.tState = x
        } else if (this.tState === x) {
          if (108 !== e[g]) return this.charError(e, g);
          this.tState = f, this.onToken(h, null), this.offset += 3
        }
    }, Q.onToken = function(e, t) {}, Q.parseError = function(e, t) {
      this.tState = g, this.onError(new Error("Unexpected " + z.toknam(e) + (t ? "(" + JSON.stringify(t) + ")" : "") + " in state " + z.toknam(this.state)))
    }, Q.push = function() {
      this.stack.push({
        value: this.value,
        key: this.key,
        mode: this.mode
      })
    }, Q.pop = function() {
      var e = this.value,
        t = this.stack.pop();
      this.value = t.value, this.key = t.key, this.mode = t.mode, this.emit(e), this.mode || (this.state = j)
    }, Q.emit = function(e) {
      this.mode && (this.state = u), this.onValue(e)
    }, Q.onValue = function(e) {}, Q.onToken = function(e, t) {
      if (this.state === j)
        if (e === d || e === p || e === c || e === l || e === h) this.value && (this.value[this.key] = t), this.emit(t);
        else if (e === n) this.push(), this.value ? this.value = this.value[this.key] = {} : this.value = {}, this.key = void 0, this.state = k, this.mode = L;
        else if (e === a) this.push(), this.value ? this.value = this.value[this.key] = [] : this.value = [], this.key = 0, this.mode = M, this.state = j;
        else if (e === i) {
          if (this.mode !== L) return this.parseError(e, t);
          this.pop()
        } else {
          if (e !== s) return this.parseError(e, t);
          if (this.mode !== M) return this.parseError(e, t);
          this.pop()
        } else if (this.state === k)
        if (e === d) this.key = t, this.state = o;
        else {
          if (e !== i) return this.parseError(e, t);
          this.pop()
        }
      else if (this.state === o) {
        if (e !== o) return this.parseError(e, t);
        this.state = j
      } else {
        if (this.state !== u) return this.parseError(e, t);
        if (e === u) this.mode === M ? (this.key++, this.state = j) : this.mode === L && (this.state = k);
        else {
          if (!(e === s && this.mode === M || e === i && this.mode === L)) return this.parseError(e, t);
          this.pop()
        }
      }
    }, z.C = r, e.exports = z
  }).call(this, r(11).Buffer)
}, function(e, t, r) {
  "use strict";
  const n = e => null !== e && "object" == typeof e && "function" == typeof e.pipe;
  n.writable = e => n(e) && !1 !== e.writable && "function" == typeof e._write && "object" == typeof e._writableState, n.readable = e => n(e) && !1 !== e.readable && "function" == typeof e._read && "object" == typeof e._readableState, n.duplex = e => n.writable(e) && n.readable(e), n.transform = e => n.duplex(e) && "function" == typeof e._transform && "object" == typeof e._transformState, e.exports = n
}, function(e, t, r) {
  "use strict";
  (function(t) {
    r(2);
    const n = r(247),
      i = r(248);
    e.exports = r(126), e.exports.toNodeReadable = function(t) {
      if (t instanceof e.exports.ReadableStream || t && "function" == typeof t.getReader) return i.readable.webToNode(t);
      throw new TypeError("Expected a ReadableStream.")
    }, e.exports.toWebReadableStream = function(e) {
      if (n(e) && e.readable) return i.readable.nodeToWeb(e);
      if (Array.isArray(e)) return i.readable.arrayToWeb(e);
      if (t.isBuffer(e) || "string" == typeof e) return i.readable.arrayToWeb([e]);
      throw new TypeError("Expected a Node streams.Readable, an Array, Buffer or String.")
    }
  }).call(this, r(11).Buffer)
}, function(e, t, r) {
  (function(t) {
    e.exports = function e(t, r, n) {
      function i(s, o) {
        if (!r[s]) {
          if (!t[s]) {
            if (a) return a(s, !0);
            var u = new Error("Cannot find module '" + s + "'");
            throw u.code = "MODULE_NOT_FOUND", u
          }
          var c = r[s] = {
            exports: {}
          };
          t[s][0].call(c.exports, (function(e) {
            var r = t[s][1][e];
            return i(r || e)
          }), c, c.exports, e, t, r, n)
        }
        return r[s].exports
      }
      for (var a = !1, s = 0; s < n.length; s++) i(n[s]);
      return i
    }({
      1: [function(e, t, r) {
        "use strict";
        Object.defineProperty(r, "__esModule", {
          value: !0
        });
        var n = e("./spec/reference-implementation/lib/readable-stream").ReadableStream,
          i = e("./spec/reference-implementation/lib/writable-stream").WritableStream,
          a = e("./spec/reference-implementation/lib/byte-length-queuing-strategy"),
          s = e("./spec/reference-implementation/lib/count-queuing-strategy"),
          o = e("./spec/reference-implementation/lib/transform-stream").TransformStream;
        r.ByteLengthQueuingStrategy = a, r.CountQueuingStrategy = s, r.ReadableStream = n, r.WritableStream = i, r.TransformStream = o;
        var u = {
          ReadableStream: n,
          WritableStream: i,
          ByteLengthQueuingStrategy: a,
          CountQueuingStrategy: s,
          TransformStream: o
        };
        r.default = u
      }, {
        "./spec/reference-implementation/lib/byte-length-queuing-strategy": 8,
        "./spec/reference-implementation/lib/count-queuing-strategy": 9,
        "./spec/reference-implementation/lib/readable-stream": 12,
        "./spec/reference-implementation/lib/transform-stream": 13,
        "./spec/reference-implementation/lib/writable-stream": 15
      }],
      2: [function(e, r, n) {
        (function(t) {
          "use strict";

          function n(e, t) {
            if (e === t) return 0;
            for (var r = e.length, n = t.length, i = 0, a = Math.min(r, n); i < a; ++i)
              if (e[i] !== t[i]) {
                r = e[i], n = t[i];
                break
              } return r < n ? -1 : n < r ? 1 : 0
          }

          function i(e) {
            return t.Buffer && "function" == typeof t.Buffer.isBuffer ? t.Buffer.isBuffer(e) : !(null == e || !e._isBuffer)
          }

          function a(e) {
            return Object.prototype.toString.call(e)
          }

          function s(e) {
            return !i(e) && "function" == typeof t.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(e) : !!e && (e instanceof DataView || !!(e.buffer && e.buffer instanceof ArrayBuffer)))
          }

          function o(e) {
            if (m.isFunction(e)) {
              if (_) return e.name;
              var t = e.toString().match(w);
              return t && t[1]
            }
          }

          function u(e, t) {
            return "string" == typeof e ? e.length < t ? e : e.slice(0, t) : e
          }

          function c(e) {
            if (_ || !m.isFunction(e)) return m.inspect(e);
            var t = o(e);
            return "[Function" + (t ? ": " + t : "") + "]"
          }

          function l(e, t, r, n, i) {
            throw new v.AssertionError({
              message: r,
              actual: e,
              expected: t,
              operator: n,
              stackStartFunction: i
            })
          }

          function h(e, t) {
            e || l(e, !0, t, "==", v.ok)
          }

          function d(e, t, r, o) {
            if (e === t) return !0;
            if (i(e) && i(t)) return 0 === n(e, t);
            if (m.isDate(e) && m.isDate(t)) return e.getTime() === t.getTime();
            if (m.isRegExp(e) && m.isRegExp(t)) return e.source === t.source && e.global === t.global && e.multiline === t.multiline && e.lastIndex === t.lastIndex && e.ignoreCase === t.ignoreCase;
            if (null !== e && "object" == typeof e || null !== t && "object" == typeof t) {
              if (s(e) && s(t) && a(e) === a(t) && !(e instanceof Float32Array || e instanceof Float64Array)) return 0 === n(new Uint8Array(e.buffer), new Uint8Array(t.buffer));
              if (i(e) !== i(t)) return !1;
              var u = (o = o || {
                actual: [],
                expected: []
              }).actual.indexOf(e);
              return -1 !== u && u === o.expected.indexOf(t) || (o.actual.push(e), o.expected.push(t), function(e, t, r, n) {
                if (null == e || null == t) return !1;
                if (m.isPrimitive(e) || m.isPrimitive(t)) return e === t;
                if (r && Object.getPrototypeOf(e) !== Object.getPrototypeOf(t)) return !1;
                var i = p(e),
                  a = p(t);
                if (i && !a || !i && a) return !1;
                if (i) return e = b.call(e), t = b.call(t), d(e, t, r);
                var s, o, u = S(e),
                  c = S(t);
                if (u.length !== c.length) return !1;
                for (u.sort(), c.sort(), o = u.length - 1; o >= 0; o--)
                  if (u[o] !== c[o]) return !1;
                for (o = u.length - 1; o >= 0; o--)
                  if (s = u[o], !d(e[s], t[s], r, n)) return !1;
                return !0
              }(e, t, r, o))
            }
            return r ? e === t : e == t
          }

          function p(e) {
            return "[object Arguments]" == Object.prototype.toString.call(e)
          }

          function f(e, t) {
            if (!e || !t) return !1;
            if ("[object RegExp]" == Object.prototype.toString.call(t)) return t.test(e);
            try {
              if (e instanceof t) return !0
            } catch (e) {}
            return !Error.isPrototypeOf(t) && !0 === t.call({}, e)
          }

          function g(e, t, r, n) {
            var i;
            if ("function" != typeof t) throw new TypeError('"block" argument must be a function');
            "string" == typeof r && (n = r, r = null), i = function(e) {
              var t;
              try {
                e()
              } catch (e) {
                t = e
              }
              return t
            }(t), n = (r && r.name ? " (" + r.name + ")." : ".") + (n ? " " + n : "."), e && !i && l(i, r, "Missing expected exception" + n);
            var a = "string" == typeof n,
              s = !e && i && !r;
            if ((!e && m.isError(i) && a && f(i, r) || s) && l(i, r, "Got unwanted exception" + n), e && i && r && !f(i, r) || !e && i) throw i
          }
          var m = e("util/"),
            y = Object.prototype.hasOwnProperty,
            b = Array.prototype.slice,
            _ = "foo" === function() {}.name,
            v = r.exports = h,
            w = /\s*function\s+([^\(\s]*)\s*/;
          v.AssertionError = function(e) {
            this.name = "AssertionError", this.actual = e.actual, this.expected = e.expected, this.operator = e.operator, e.message ? (this.message = e.message, this.generatedMessage = !1) : (this.message = function(e) {
              return u(c(e.actual), 128) + " " + e.operator + " " + u(c(e.expected), 128)
            }(this), this.generatedMessage = !0);
            var t = e.stackStartFunction || l;
            if (Error.captureStackTrace) Error.captureStackTrace(this, t);
            else {
              var r = new Error;
              if (r.stack) {
                var n = r.stack,
                  i = o(t),
                  a = n.indexOf("\n" + i);
                if (a >= 0) {
                  var s = n.indexOf("\n", a + 1);
                  n = n.substring(s + 1)
                }
                this.stack = n
              }
            }
          }, m.inherits(v.AssertionError, Error), v.fail = l, v.ok = h, v.equal = function(e, t, r) {
            e != t && l(e, t, r, "==", v.equal)
          }, v.notEqual = function(e, t, r) {
            e == t && l(e, t, r, "!=", v.notEqual)
          }, v.deepEqual = function(e, t, r) {
            d(e, t, !1) || l(e, t, r, "deepEqual", v.deepEqual)
          }, v.deepStrictEqual = function(e, t, r) {
            d(e, t, !0) || l(e, t, r, "deepStrictEqual", v.deepStrictEqual)
          }, v.notDeepEqual = function(e, t, r) {
            d(e, t, !1) && l(e, t, r, "notDeepEqual", v.notDeepEqual)
          }, v.notDeepStrictEqual = function e(t, r, n) {
            d(t, r, !0) && l(t, r, n, "notDeepStrictEqual", e)
          }, v.strictEqual = function(e, t, r) {
            e !== t && l(e, t, r, "===", v.strictEqual)
          }, v.notStrictEqual = function(e, t, r) {
            e === t && l(e, t, r, "!==", v.notStrictEqual)
          }, v.throws = function(e, t, r) {
            g(!0, e, t, r)
          }, v.doesNotThrow = function(e, t, r) {
            g(!1, e, t, r)
          }, v.ifError = function(e) {
            if (e) throw e
          };
          var S = Object.keys || function(e) {
            var t = [];
            for (var r in e) y.call(e, r) && t.push(r);
            return t
          }
        }).call(this, void 0 !== t ? t : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
      }, {
        "util/": 7
      }],
      3: [function(e, t, r) {}, {}],
      4: [function(e, t, r) {
        function n() {
          throw new Error("setTimeout has not been defined")
        }

        function i() {
          throw new Error("clearTimeout has not been defined")
        }

        function a(e) {
          if (l === setTimeout) return setTimeout(e, 0);
          if ((l === n || !l) && setTimeout) return l = setTimeout, setTimeout(e, 0);
          try {
            return l(e, 0)
          } catch (t) {
            try {
              return l.call(null, e, 0)
            } catch (t) {
              return l.call(this, e, 0)
            }
          }
        }

        function s() {
          g && p && (g = !1, p.length ? f = p.concat(f) : m = -1, f.length && o())
        }

        function o() {
          if (!g) {
            var e = a(s);
            g = !0;
            for (var t = f.length; t;) {
              for (p = f, f = []; ++m < t;) p && p[m].run();
              m = -1, t = f.length
            }
            p = null, g = !1,
              function(e) {
                if (h === clearTimeout) return clearTimeout(e);
                if ((h === i || !h) && clearTimeout) return h = clearTimeout, clearTimeout(e);
                try {
                  h(e)
                } catch (t) {
                  try {
                    return h.call(null, e)
                  } catch (t) {
                    return h.call(this, e)
                  }
                }
              }(e)
          }
        }

        function u(e, t) {
          this.fun = e, this.array = t
        }

        function c() {}
        var l, h, d = t.exports = {};
        ! function() {
          try {
            l = "function" == typeof setTimeout ? setTimeout : n
          } catch (e) {
            l = n
          }
          try {
            h = "function" == typeof clearTimeout ? clearTimeout : i
          } catch (e) {
            h = i
          }
        }();
        var p, f = [],
          g = !1,
          m = -1;
        d.nextTick = function(e) {
          var t = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
          f.push(new u(e, t)), 1 !== f.length || g || a(o)
        }, u.prototype.run = function() {
          this.fun.apply(null, this.array)
        }, d.title = "browser", d.browser = !0, d.env = {}, d.argv = [], d.version = "", d.versions = {}, d.on = c, d.addListener = c, d.once = c, d.off = c, d.removeListener = c, d.removeAllListeners = c, d.emit = c, d.prependListener = c, d.prependOnceListener = c, d.listeners = function(e) {
          return []
        }, d.binding = function(e) {
          throw new Error("process.binding is not supported")
        }, d.cwd = function() {
          return "/"
        }, d.chdir = function(e) {
          throw new Error("process.chdir is not supported")
        }, d.umask = function() {
          return 0
        }
      }, {}],
      5: [function(e, t, r) {
        "function" == typeof Object.create ? t.exports = function(e, t) {
          e.super_ = t, e.prototype = Object.create(t.prototype, {
            constructor: {
              value: e,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          })
        } : t.exports = function(e, t) {
          e.super_ = t;
          var r = function() {};
          r.prototype = t.prototype, e.prototype = new r, e.prototype.constructor = e
        }
      }, {}],
      6: [function(e, t, r) {
        t.exports = function(e) {
          return e && "object" == typeof e && "function" == typeof e.copy && "function" == typeof e.fill && "function" == typeof e.readUInt8
        }
      }, {}],
      7: [function(e, r, n) {
        (function(t, r) {
          function i(e, t) {
            var r = {
              seen: [],
              stylize: s
            };
            return arguments.length >= 3 && (r.depth = arguments[2]), arguments.length >= 4 && (r.colors = arguments[3]), h(t) ? r.showHidden = t : t && n._extend(r, t), g(r.showHidden) && (r.showHidden = !1), g(r.depth) && (r.depth = 2), g(r.colors) && (r.colors = !1), g(r.customInspect) && (r.customInspect = !0), r.colors && (r.stylize = a), o(r, e, r.depth)
          }

          function a(e, t) {
            var r = i.styles[t];
            return r ? "[" + i.colors[r][0] + "m" + e + "[" + i.colors[r][1] + "m" : e
          }

          function s(e, t) {
            return e
          }

          function o(e, t, r) {
            if (e.customInspect && t && v(t.inspect) && t.inspect !== n.inspect && (!t.constructor || t.constructor.prototype !== t)) {
              var i = t.inspect(r, e);
              return f(i) || (i = o(e, i, r)), i
            }
            var a = function(e, t) {
              if (g(t)) return e.stylize("undefined", "undefined");
              if (f(t)) {
                var r = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return e.stylize(r, "string")
              }
              return p(t) ? e.stylize("" + t, "number") : h(t) ? e.stylize("" + t, "boolean") : d(t) ? e.stylize("null", "null") : void 0
            }(e, t);
            if (a) return a;
            var s = Object.keys(t),
              y = function(e) {
                var t = {};
                return e.forEach((function(e, r) {
                  t[e] = !0
                })), t
              }(s);
            if (e.showHidden && (s = Object.getOwnPropertyNames(t)), _(t) && (s.indexOf("message") >= 0 || s.indexOf("description") >= 0)) return u(t);
            if (0 === s.length) {
              if (v(t)) {
                var w = t.name ? ": " + t.name : "";
                return e.stylize("[Function" + w + "]", "special")
              }
              if (m(t)) return e.stylize(RegExp.prototype.toString.call(t), "regexp");
              if (b(t)) return e.stylize(Date.prototype.toString.call(t), "date");
              if (_(t)) return u(t)
            }
            var S, T = "",
              x = !1,
              O = ["{", "}"];
            return l(t) && (x = !0, O = ["[", "]"]), v(t) && (T = " [Function" + (t.name ? ": " + t.name : "") + "]"), m(t) && (T = " " + RegExp.prototype.toString.call(t)), b(t) && (T = " " + Date.prototype.toUTCString.call(t)), _(t) && (T = " " + u(t)), 0 !== s.length || x && 0 != t.length ? r < 0 ? m(t) ? e.stylize(RegExp.prototype.toString.call(t), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(t), S = x ? function(e, t, r, n, i) {
              for (var a = [], s = 0, o = t.length; s < o; ++s) E(t, String(s)) ? a.push(c(e, t, r, n, String(s), !0)) : a.push("");
              return i.forEach((function(i) {
                i.match(/^\d+$/) || a.push(c(e, t, r, n, i, !0))
              })), a
            }(e, t, r, y, s) : s.map((function(n) {
              return c(e, t, r, y, n, x)
            })), e.seen.pop(), function(e, t, r) {
              return e.reduce((function(e, t) {
                return t.indexOf("\n"), e + t.replace(/\u001b\[\d\d?m/g, "").length + 1
              }), 0) > 60 ? r[0] + ("" === t ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + r[1] : r[0] + t + " " + e.join(", ") + " " + r[1]
            }(S, T, O)) : O[0] + T + O[1]
          }

          function u(e) {
            return "[" + Error.prototype.toString.call(e) + "]"
          }

          function c(e, t, r, n, i, a) {
            var s, u, c;
            if ((c = Object.getOwnPropertyDescriptor(t, i) || {
              value: t[i]
            }).get ? u = c.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : c.set && (u = e.stylize("[Setter]", "special")), E(n, i) || (s = "[" + i + "]"), u || (e.seen.indexOf(c.value) < 0 ? (u = d(r) ? o(e, c.value, null) : o(e, c.value, r - 1)).indexOf("\n") > -1 && (u = a ? u.split("\n").map((function(e) {
              return "  " + e
            })).join("\n").substr(2) : "\n" + u.split("\n").map((function(e) {
              return "   " + e
            })).join("\n")) : u = e.stylize("[Circular]", "special")), g(s)) {
              if (a && i.match(/^\d+$/)) return u;
              (s = JSON.stringify("" + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.substr(1, s.length - 2), s = e.stylize(s, "name")) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = e.stylize(s, "string"))
            }
            return s + ": " + u
          }

          function l(e) {
            return Array.isArray(e)
          }

          function h(e) {
            return "boolean" == typeof e
          }

          function d(e) {
            return null === e
          }

          function p(e) {
            return "number" == typeof e
          }

          function f(e) {
            return "string" == typeof e
          }

          function g(e) {
            return void 0 === e
          }

          function m(e) {
            return y(e) && "[object RegExp]" === w(e)
          }

          function y(e) {
            return "object" == typeof e && null !== e
          }

          function b(e) {
            return y(e) && "[object Date]" === w(e)
          }

          function _(e) {
            return y(e) && ("[object Error]" === w(e) || e instanceof Error)
          }

          function v(e) {
            return "function" == typeof e
          }

          function w(e) {
            return Object.prototype.toString.call(e)
          }

          function S(e) {
            return e < 10 ? "0" + e.toString(10) : e.toString(10)
          }

          function T() {
            var e = new Date,
              t = [S(e.getHours()), S(e.getMinutes()), S(e.getSeconds())].join(":");
            return [e.getDate(), R[e.getMonth()], t].join(" ")
          }

          function E(e, t) {
            return Object.prototype.hasOwnProperty.call(e, t)
          }
          var x = /%[sdj%]/g;
          n.format = function(e) {
            if (!f(e)) {
              for (var t = [], r = 0; r < arguments.length; r++) t.push(i(arguments[r]));
              return t.join(" ")
            }
            r = 1;
            for (var n = arguments, a = n.length, s = String(e).replace(x, (function(e) {
              if ("%%" === e) return "%";
              if (r >= a) return e;
              switch (e) {
                case "%s":
                  return String(n[r++]);
                case "%d":
                  return Number(n[r++]);
                case "%j":
                  try {
                    return JSON.stringify(n[r++])
                  } catch (e) {
                    return "[Circular]"
                  }
                default:
                  return e
              }
            })), o = n[r]; r < a; o = n[++r]) d(o) || !y(o) ? s += " " + o : s += " " + i(o);
            return s
          }, n.deprecate = function(e, i) {
            if (g(r.process)) return function() {
              return n.deprecate(e, i).apply(this, arguments)
            };
            if (!0 === t.noDeprecation) return e;
            var a = !1;
            return function() {
              if (!a) {
                if (t.throwDeprecation) throw new Error(i);
                t.traceDeprecation ? console.trace(i) : console.error(i), a = !0
              }
              return e.apply(this, arguments)
            }
          };
          var O, A = {};
          n.debuglog = function(e) {
            if (g(O) && (O = t.env.NODE_DEBUG || ""), e = e.toUpperCase(), !A[e])
              if (new RegExp("\\b" + e + "\\b", "i").test(O)) {
                var r = t.pid;
                A[e] = function() {
                  var t = n.format.apply(n, arguments);
                  console.error("%s %d: %s", e, r, t)
                }
              } else A[e] = function() {};
            return A[e]
          }, n.inspect = i, i.colors = {
            bold: [1, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            white: [37, 39],
            grey: [90, 39],
            black: [30, 39],
            blue: [34, 39],
            cyan: [36, 39],
            green: [32, 39],
            magenta: [35, 39],
            red: [31, 39],
            yellow: [33, 39]
          }, i.styles = {
            special: "cyan",
            number: "yellow",
            boolean: "yellow",
            undefined: "grey",
            null: "bold",
            string: "green",
            date: "magenta",
            regexp: "red"
          }, n.isArray = l, n.isBoolean = h, n.isNull = d, n.isNullOrUndefined = function(e) {
            return null == e
          }, n.isNumber = p, n.isString = f, n.isSymbol = function(e) {
            return "symbol" == typeof e
          }, n.isUndefined = g, n.isRegExp = m, n.isObject = y, n.isDate = b, n.isError = _, n.isFunction = v, n.isPrimitive = function(e) {
            return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || void 0 === e
          }, n.isBuffer = e("./support/isBuffer");
          var R = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          n.log = function() {
            console.log("%s - %s", T(), n.format.apply(n, arguments))
          }, n.inherits = e("inherits"), n._extend = function(e, t) {
            if (!t || !y(t)) return e;
            for (var r = Object.keys(t), n = r.length; n--;) e[r[n]] = t[r[n]];
            return e
          }
        }).call(this, e("_process"), void 0 !== t ? t : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
      }, {
        "./support/isBuffer": 6,
        _process: 4,
        inherits: 5
      }],
      8: [function(e, t, r) {
        "use strict";
        var n = function() {
            function e(e, t) {
              for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
              }
            }
            return function(t, r, n) {
              return r && e(t.prototype, r), n && e(t, n), t
            }
          }(),
          i = e("./helpers.js").createDataProperty;
        t.exports = function() {
          function e(t) {
            var r = t.highWaterMark;
            (function(e, t) {
              if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            })(this, e), i(this, "highWaterMark", r)
          }
          return n(e, [{
            key: "size",
            value: function(e) {
              return e.byteLength
            }
          }]), e
        }()
      }, {
        "./helpers.js": 10
      }],
      9: [function(e, t, r) {
        "use strict";
        var n = function() {
            function e(e, t) {
              for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
              }
            }
            return function(t, r, n) {
              return r && e(t.prototype, r), n && e(t, n), t
            }
          }(),
          i = e("./helpers.js").createDataProperty;
        t.exports = function() {
          function e(t) {
            var r = t.highWaterMark;
            (function(e, t) {
              if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
            })(this, e), i(this, "highWaterMark", r)
          }
          return n(e, [{
            key: "size",
            value: function() {
              return 1
            }
          }]), e
        }()
      }, {
        "./helpers.js": 10
      }],
      10: [function(e, t, r) {
        "use strict";

        function n(e, t, r) {
          if ("function" != typeof e) throw new TypeError("Argument is not a function");
          return Function.prototype.apply.call(e, t, r)
        }

        function i(e, t, r) {
          try {
            return Promise.resolve(n(e, t, r))
          } catch (e) {
            return Promise.reject(e)
          }
        }
        var a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
            return typeof e
          } : function(e) {
            return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
          },
          s = (e("better-assert"), Symbol('is "detached" for our purposes'));
        r.typeIsObject = function(e) {
          return "object" === (void 0 === e ? "undefined" : a(e)) && null !== e || "function" == typeof e
        }, r.createDataProperty = function(e, t, r) {
          Object.defineProperty(e, t, {
            value: r,
            writable: !0,
            enumerable: !0,
            configurable: !0
          })
        }, r.createArrayFromList = function(e) {
          return e.slice()
        }, r.ArrayBufferCopy = function(e, t, r, n, i) {
          new Uint8Array(e).set(new Uint8Array(r, n, i), t)
        }, r.CreateIterResultObject = function(e, t) {
          var r = {};
          return Object.defineProperty(r, "value", {
            value: e,
            enumerable: !0,
            writable: !0,
            configurable: !0
          }), Object.defineProperty(r, "done", {
            value: t,
            enumerable: !0,
            writable: !0,
            configurable: !0
          }), r
        }, r.IsFiniteNonNegativeNumber = function(e) {
          return !1 !== r.IsNonNegativeNumber(e) && e !== 1 / 0
        }, r.IsNonNegativeNumber = function(e) {
          return !("number" != typeof e || Number.isNaN(e) || e < 0)
        }, r.Call = n, r.CreateAlgorithmFromUnderlyingMethod = function(e, t, r, n) {
          var a = e[t];
          if (void 0 !== a) {
            if ("function" != typeof a) throw new TypeError(a + " is not a method");
            switch (r) {
              case 0:
                return function() {
                  return i(a, e, n)
                };
              case 1:
                return function(t) {
                  var r = [t].concat(n);
                  return i(a, e, r)
                }
            }
          }
          return function() {
            return Promise.resolve()
          }
        }, r.InvokeOrNoop = function(e, t, r) {
          var i = e[t];
          if (void 0 !== i) return n(i, e, r)
        }, r.PromiseCall = i, r.TransferArrayBuffer = function(e) {
          var t = e.slice();
          return Object.defineProperty(e, "byteLength", {
            get: function() {
              return 0
            }
          }), e[s] = !0, t
        }, r.IsDetachedBuffer = function(e) {
          return s in e
        }, r.ValidateAndNormalizeHighWaterMark = function(e) {
          if (e = Number(e), Number.isNaN(e) || e < 0) throw new RangeError("highWaterMark property of a queuing strategy must be non-negative and non-NaN");
          return e
        }, r.MakeSizeAlgorithmFromSizeFunction = function(e) {
          if (void 0 === e) return function() {
            return 1
          };
          if ("function" != typeof e) throw new TypeError("size property of a queuing strategy must be a function");
          return function(t) {
            return e(t)
          }
        }
      }, {
        "better-assert": 16
      }],
      11: [function(e, t, r) {
        "use strict";
        e("better-assert");
        var n = e("./helpers.js").IsFiniteNonNegativeNumber;
        r.DequeueValue = function(e) {
          var t = e._queue.shift();
          return e._queueTotalSize -= t.size, e._queueTotalSize < 0 && (e._queueTotalSize = 0), t.value
        }, r.EnqueueValueWithSize = function(e, t, r) {
          if (r = Number(r), !n(r)) throw new RangeError("Size must be a finite, non-NaN, non-negative number.");
          e._queue.push({
            value: t,
            size: r
          }), e._queueTotalSize += r
        }, r.PeekQueueValue = function(e) {
          return e._queue[0].value
        }, r.ResetQueue = function(e) {
          e._queue = [], e._queueTotalSize = 0
        }
      }, {
        "./helpers.js": 10,
        "better-assert": 16
      }],
      12: [function(e, t, r) {
        "use strict";

        function n(e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function i(e) {
          return new Ue(e)
        }

        function a(e) {
          return new qe(e)
        }

        function s(e, t, r) {
          var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
            i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : function() {
              return 1
            },
            a = Object.create(Be.prototype);
          return o(a), L(a, Object.create(Ve.prototype), e, t, r, n, i), a
        }

        function o(e) {
          e._state = "readable", e._reader = void 0, e._storedError = void 0, e._disturbed = !1
        }

        function u(e) {
          return !!Se(e) && !!Object.prototype.hasOwnProperty.call(e, "_readableStreamController")
        }

        function c(e) {
          return void 0 !== e._reader
        }

        function l(e) {
          return new Promise((function(t, r) {
            var n = {
              _resolve: t,
              _reject: r
            };
            e._reader._readIntoRequests.push(n)
          }))
        }

        function h(e) {
          return new Promise((function(t, r) {
            var n = {
              _resolve: t,
              _reject: r
            };
            e._reader._readRequests.push(n)
          }))
        }

        function d(e, t) {
          return e._disturbed = !0, "closed" === e._state ? Promise.resolve(void 0) : "errored" === e._state ? Promise.reject(e._storedError) : (p(e), e._readableStreamController[Me](t).then((function() {})))
        }

        function p(e) {
          e._state = "closed";
          var t = e._reader;
          if (void 0 !== t) {
            if (!0 === w(t)) {
              var r = !0,
                n = !1,
                i = void 0;
              try {
                for (var a, s = t._readRequests[Symbol.iterator](); !(r = (a = s.next()).done); r = !0)(0, a.value._resolve)(fe(void 0, !0))
              } catch (e) {
                n = !0, i = e
              } finally {
                try {
                  !r && s.return && s.return()
                } finally {
                  if (n) throw i
                }
              }
              t._readRequests = []
            }! function(e) {
              e._closedPromise_resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0
            }(t)
          }
        }

        function f(e, t) {
          e._state = "errored", e._storedError = t;
          var r = e._reader;
          if (void 0 !== r) {
            if (!0 === w(r)) {
              var n = !0,
                i = !1,
                a = void 0;
              try {
                for (var s, o = r._readRequests[Symbol.iterator](); !(n = (s = o.next()).done); n = !0) s.value._reject(t)
              } catch (e) {
                i = !0, a = e
              } finally {
                try {
                  !n && o.return && o.return()
                } finally {
                  if (i) throw a
                }
              }
              r._readRequests = []
            } else {
              var u = !0,
                c = !1,
                l = void 0;
              try {
                for (var h, d = r._readIntoRequests[Symbol.iterator](); !(u = (h = d.next()).done); u = !0) h.value._reject(t)
              } catch (e) {
                c = !0, l = e
              } finally {
                try {
                  !u && d.return && d.return()
                } finally {
                  if (c) throw l
                }
              }
              r._readIntoRequests = []
            }
            ae(r, t), r._closedPromise.catch((function() {}))
          }
        }

        function g(e, t, r) {
          e._reader._readRequests.shift()._resolve(fe(t, r))
        }

        function m(e) {
          return e._reader._readIntoRequests.length
        }

        function y(e) {
          return e._reader._readRequests.length
        }

        function b(e) {
          var t = e._reader;
          return void 0 !== t && !1 !== v(t)
        }

        function _(e) {
          var t = e._reader;
          return void 0 !== t && !1 !== w(t)
        }

        function v(e) {
          return !!Se(e) && !!Object.prototype.hasOwnProperty.call(e, "_readIntoRequests")
        }

        function w(e) {
          return !!Se(e) && !!Object.prototype.hasOwnProperty.call(e, "_readRequests")
        }

        function S(e, t) {
          e._ownerReadableStream = t, t._reader = e, "readable" === t._state ? function(e) {
            e._closedPromise = new Promise((function(t, r) {
              e._closedPromise_resolve = t, e._closedPromise_reject = r
            }))
          }(e) : "closed" === t._state ? function(e) {
            e._closedPromise = Promise.resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0
          }(e) : (function(e, t) {
            e._closedPromise = Promise.reject(t), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0
          }(e, t._storedError), e._closedPromise.catch((function() {})))
        }

        function T(e, t) {
          return d(e._ownerReadableStream, t)
        }

        function E(e) {
          "readable" === e._ownerReadableStream._state ? ae(e, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")) : function(e, t) {
            e._closedPromise = Promise.reject(t)
          }(e, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")), e._closedPromise.catch((function() {})), e._ownerReadableStream._reader = void 0, e._ownerReadableStream = void 0
        }

        function x(e, t) {
          var r = e._ownerReadableStream;
          return r._disturbed = !0, "errored" === r._state ? Promise.reject(r._storedError) : function(e, t) {
            var r = e._controlledReadableByteStream,
              n = 1;
            t.constructor !== DataView && (n = t.constructor.BYTES_PER_ELEMENT);
            var i = t.constructor,
              a = {
                buffer: be(t.buffer),
                byteOffset: t.byteOffset,
                byteLength: t.byteLength,
                bytesFilled: 0,
                elementSize: n,
                ctor: i,
                readerType: "byob"
              };
            if (e._pendingPullIntos.length > 0) return e._pendingPullIntos.push(a), l(r);
            if ("closed" === r._state) {
              var s = new t.constructor(a.buffer, a.byteOffset, 0);
              return Promise.resolve(fe(s, !0))
            }
            if (e._queueTotalSize > 0) {
              if (!0 === z(e, a)) {
                var o = H(a);
                return X(e), Promise.resolve(fe(o, !1))
              }
              if (!0 === e._closeRequested) {
                var u = new TypeError("Insufficient bytes to fill elements in the given buffer");
                return K(e, u), Promise.reject(u)
              }
            }
            e._pendingPullIntos.push(a);
            var c = l(r);
            return q(e), c
          }(r._readableStreamController, t)
        }

        function O(e) {
          var t = e._ownerReadableStream;
          return t._disturbed = !0, "closed" === t._state ? Promise.resolve(fe(void 0, !0)) : "errored" === t._state ? Promise.reject(t._storedError) : t._readableStreamController[Fe]()
        }

        function A(e) {
          return !!Se(e) && !!Object.prototype.hasOwnProperty.call(e, "_controlledReadableStream")
        }

        function R(e) {
          !1 !== I(e) && (!0 !== e._pulling ? (e._pulling = !0, e._pullAlgorithm().then((function() {
            if (e._pulling = !1, !0 === e._pullAgain) return e._pullAgain = !1, R(e)
          }), (function(t) {
            D(e, t)
          })).catch(Te)) : e._pullAgain = !0)
        }

        function I(e) {
          var t = e._controlledReadableStream;
          return !1 !== k(e) && !1 !== e._started && (!0 === c(t) && y(t) > 0 || j(e) > 0)
        }

        function N(e) {
          var t = e._controlledReadableStream;
          e._closeRequested = !0, 0 === e._queue.length && p(t)
        }

        function P(e, t) {
          var r = e._controlledReadableStream;
          if (!0 === c(r) && y(r) > 0) g(r, t, !1);
          else {
            var n = void 0;
            try {
              n = e._strategySizeAlgorithm(t)
            } catch (t) {
              throw D(e, t), t
            }
            try {
              Oe(e, t, n)
            } catch (t) {
              throw D(e, t), t
            }
          }
          R(e)
        }

        function C(e, t) {
          var r = e._controlledReadableStream;
          Ae(e), f(r, t)
        }

        function D(e, t) {
          "readable" === e._controlledReadableStream._state && C(e, t)
        }

        function j(e) {
          var t = e._controlledReadableStream._state;
          return "errored" === t ? null : "closed" === t ? 0 : e._strategyHWM - e._queueTotalSize
        }

        function k(e) {
          var t = e._controlledReadableStream._state;
          return !1 === e._closeRequested && "readable" === t
        }

        function L(e, t, r, n, i, a, s) {
          t._controlledReadableStream = e, t._queue = void 0, t._queueTotalSize = void 0, Ae(t), t._started = !1, t._closeRequested = !1, t._pullAgain = !1, t._pulling = !1, t._strategySizeAlgorithm = s, t._strategyHWM = a, t._pullAlgorithm = n, t._cancelAlgorithm = i, e._readableStreamController = t;
          var o = r();
          Promise.resolve(o).then((function() {
            t._started = !0, R(t)
          }), (function(e) {
            D(t, e)
          })).catch(Te)
        }

        function M(e, t, r, n) {
          var i = Object.create(Ve.prototype),
            a = pe(t, "pull", 0, [i]),
            s = pe(t, "cancel", 1, []);
          L(e, i, (function() {
            return me(t, "start", [i])
          }), a, s, r, n)
        }

        function F(e) {
          return !!Se(e) && !!Object.prototype.hasOwnProperty.call(e, "_controlledReadableByteStream")
        }

        function B(e) {
          return !!Se(e) && !!Object.prototype.hasOwnProperty.call(e, "_associatedReadableByteStreamController")
        }

        function q(e) {
          !1 !== function(e) {
            var t = e._controlledReadableByteStream;
            return "readable" === t._state && !0 !== e._closeRequested && !1 !== e._started && (!0 === _(t) && y(t) > 0 || !0 === b(t) && m(t) > 0 || Z(e) > 0)
          }(e) && (!0 !== e._pulling ? (e._pulling = !0, e._pullAlgorithm().then((function() {
            e._pulling = !1, !0 === e._pullAgain && (e._pullAgain = !1, q(e))
          }), (function(t) {
            "readable" === e._controlledReadableByteStream._state && K(e, t)
          })).catch(Te)) : e._pullAgain = !0)
        }

        function U(e) {
          $(e), e._pendingPullIntos = []
        }

        function V(e, t) {
          var r = !1;
          "closed" === e._state && (r = !0);
          var n = H(t);
          "default" === t.readerType ? g(e, n, r) : function(e, t, r) {
            e._reader._readIntoRequests.shift()._resolve(fe(t, r))
          }(e, n, r)
        }

        function H(e) {
          var t = e.bytesFilled,
            r = e.elementSize;
          return new e.ctor(e.buffer, e.byteOffset, t / r)
        }

        function G(e, t, r, n) {
          e._queue.push({
            buffer: t,
            byteOffset: r,
            byteLength: n
          }), e._queueTotalSize += n
        }

        function z(e, t) {
          var r = t.elementSize,
            n = t.bytesFilled - t.bytesFilled % r,
            i = Math.min(e._queueTotalSize, t.byteLength - t.bytesFilled),
            a = t.bytesFilled + i,
            s = a - a % r,
            o = i,
            u = !1;
          s > n && (o = s - t.bytesFilled, u = !0);
          for (var c = e._queue; o > 0;) {
            var l = c[0],
              h = Math.min(o, l.byteLength),
              d = t.byteOffset + t.bytesFilled;
            de(t.buffer, d, l.buffer, l.byteOffset, h), l.byteLength === h ? c.shift() : (l.byteOffset += h, l.byteLength -= h), e._queueTotalSize -= h, Q(e, h, t), o -= h
          }
          return u
        }

        function Q(e, t, r) {
          $(e), r.bytesFilled += t
        }

        function X(e) {
          0 === e._queueTotalSize && !0 === e._closeRequested ? p(e._controlledReadableByteStream) : q(e)
        }

        function $(e) {
          void 0 !== e._byobRequest && (e._byobRequest._associatedReadableByteStreamController = void 0, e._byobRequest._view = void 0, e._byobRequest = void 0)
        }

        function Y(e) {
          for (; e._pendingPullIntos.length > 0;) {
            if (0 === e._queueTotalSize) return;
            var t = e._pendingPullIntos[0];
            !0 === z(e, t) && (W(e), V(e._controlledReadableByteStream, t))
          }
        }

        function J(e, t) {
          var r = e._pendingPullIntos[0];
          if ("closed" === e._controlledReadableByteStream._state) {
            if (0 !== t) throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream");
            ! function(e, t) {
              t.buffer = be(t.buffer);
              var r = e._controlledReadableByteStream;
              if (!0 === b(r))
                for (; m(r) > 0;) V(r, W(e))
            }(e, r)
          } else ! function(e, t, r) {
            if (r.bytesFilled + t > r.byteLength) throw new RangeError("bytesWritten out of range");
            if (Q(e, t, r), !(r.bytesFilled < r.elementSize)) {
              W(e);
              var n = r.bytesFilled % r.elementSize;
              if (n > 0) {
                var i = r.byteOffset + r.bytesFilled,
                  a = r.buffer.slice(i - n, i);
                G(e, a, 0, a.byteLength)
              }
              r.buffer = be(r.buffer), r.bytesFilled -= n, V(e._controlledReadableByteStream, r), Y(e)
            }
          }(e, t, r)
        }

        function W(e) {
          var t = e._pendingPullIntos.shift();
          return $(e), t
        }

        function K(e, t) {
          var r = e._controlledReadableByteStream;
          U(e), Ae(e), f(r, t)
        }

        function Z(e) {
          var t = e._controlledReadableByteStream._state;
          return "errored" === t ? null : "closed" === t ? 0 : e._strategyHWM - e._queueTotalSize
        }

        function ee(e, t, r, n, i, a, s) {
          t._controlledReadableByteStream = e, t._pullAgain = !1, t._pulling = !1, U(t), t._queue = t._queueTotalSize = void 0, Ae(t), t._closeRequested = !1, t._started = !1, t._strategyHWM = _e(a), t._pullAlgorithm = n, t._cancelAlgorithm = i, t._autoAllocateChunkSize = s, t._pendingPullIntos = [], e._readableStreamController = t;
          var o = r();
          Promise.resolve(o).then((function() {
            t._started = !0, q(t)
          }), (function(r) {
            "readable" === e._state && K(t, r)
          })).catch(Te)
        }

        function te(e, t, r) {
          var n = Object.create(Ge.prototype),
            i = pe(t, "pull", 0, [n]),
            a = pe(t, "cancel", 1, []),
            s = t.autoAllocateChunkSize;
          if (void 0 !== s && (!1 === Number.isInteger(s) || s <= 0)) throw new RangeError("autoAllocateChunkSize must be a positive integer");
          ee(e, n, (function() {
            return me(t, "start", [n])
          }), i, a, r, s)
        }

        function re(e) {
          return new TypeError("ReadableStream.prototype." + e + " can only be used on a ReadableStream")
        }

        function ne(e) {
          return new TypeError("Cannot " + e + " a stream using a released reader")
        }

        function ie(e) {
          return new TypeError("ReadableStreamDefaultReader.prototype." + e + " can only be used on a ReadableStreamDefaultReader")
        }

        function ae(e, t) {
          e._closedPromise_reject(t), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0
        }

        function se(e) {
          return new TypeError("ReadableStreamBYOBReader.prototype." + e + " can only be used on a ReadableStreamBYOBReader")
        }

        function oe(e) {
          return new TypeError("ReadableStreamDefaultController.prototype." + e + " can only be used on a ReadableStreamDefaultController")
        }

        function ue(e) {
          return new TypeError("ReadableStreamBYOBRequest.prototype." + e + " can only be used on a ReadableStreamBYOBRequest")
        }

        function ce(e) {
          return new TypeError("ReadableByteStreamController.prototype." + e + " can only be used on a ReadableByteStreamController")
        }
        var le = function() {
            function e(e, t) {
              for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
              }
            }
            return function(t, r, n) {
              return r && e(t.prototype, r), n && e(t, n), t
            }
          }(),
          he = (e("better-assert"), e("./helpers.js")),
          de = he.ArrayBufferCopy,
          pe = he.CreateAlgorithmFromUnderlyingMethod,
          fe = he.CreateIterResultObject,
          ge = he.IsFiniteNonNegativeNumber,
          me = he.InvokeOrNoop,
          ye = he.IsDetachedBuffer,
          be = he.TransferArrayBuffer,
          _e = he.ValidateAndNormalizeHighWaterMark,
          ve = (he.IsNonNegativeNumber, he.MakeSizeAlgorithmFromSizeFunction),
          we = he.createArrayFromList,
          Se = he.typeIsObject,
          Te = e("./utils.js").rethrowAssertionErrorRejection,
          Ee = e("./queue-with-sizes.js"),
          xe = Ee.DequeueValue,
          Oe = Ee.EnqueueValueWithSize,
          Ae = Ee.ResetQueue,
          Re = e("./writable-stream.js"),
          Ie = Re.AcquireWritableStreamDefaultWriter,
          Ne = Re.IsWritableStream,
          Pe = Re.IsWritableStreamLocked,
          Ce = Re.WritableStreamAbort,
          De = Re.WritableStreamDefaultWriterCloseWithErrorPropagation,
          je = Re.WritableStreamDefaultWriterRelease,
          ke = Re.WritableStreamDefaultWriterWrite,
          Le = Re.WritableStreamCloseQueuedOrInFlight,
          Me = Symbol("[[CancelSteps]]"),
          Fe = Symbol("[[PullSteps]]"),
          Be = function() {
            function e() {
              var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                i = r.size,
                a = r.highWaterMark;
              n(this, e), o(this);
              var s = t.type;
              if ("bytes" === String(s)) {
                if (void 0 === a && (a = 0), a = _e(a), void 0 !== i) throw new RangeError("The strategy for a byte stream cannot have a size function");
                te(this, t, a)
              } else {
                if (void 0 !== s) throw new RangeError("Invalid type is specified");
                void 0 === a && (a = 1), M(this, t, a = _e(a), ve(i))
              }
            }
            return le(e, [{
              key: "cancel",
              value: function(e) {
                return !1 === u(this) ? Promise.reject(re("cancel")) : !0 === c(this) ? Promise.reject(new TypeError("Cannot cancel a stream that already has a reader")) : d(this, e)
              }
            }, {
              key: "getReader",
              value: function() {
                var e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).mode;
                if (!1 === u(this)) throw re("getReader");
                if (void 0 === e) return a(this);
                if ("byob" === (e = String(e))) return i(this);
                throw new RangeError("Invalid mode is specified")
              }
            }, {
              key: "pipeThrough",
              value: function(e, t) {
                var r = e.writable,
                  n = e.readable;
                if (void 0 === r || void 0 === n) throw new TypeError("readable and writable arguments must be defined");
                return function(e) {
                  try {
                    Promise.prototype.then.call(e, void 0, (function() {}))
                  } catch (e) {}
                }(this.pipeTo(r, t)), n
              }
            }, {
              key: "pipeTo",
              value: function(e) {
                var t = this,
                  r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                  n = r.preventClose,
                  i = r.preventAbort,
                  s = r.preventCancel;
                if (!1 === u(this)) return Promise.reject(re("pipeTo"));
                if (!1 === Ne(e)) return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
                if (n = Boolean(n), i = Boolean(i), s = Boolean(s), !0 === c(this)) return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream"));
                if (!0 === Pe(e)) return Promise.reject(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream"));
                var o = a(this),
                  l = Ie(e),
                  h = !1,
                  p = Promise.resolve();
                return new Promise((function(r, a) {
                  function u() {
                    var e = p;
                    return p.then((function() {
                      return e !== p ? u() : void 0
                    }))
                  }

                  function c(e, t, r) {
                    "errored" === e._state ? r(e._storedError) : t.catch(r).catch(Te)
                  }

                  function f(t, r, n) {
                    function i() {
                      t().then((function() {
                        return m(r, n)
                      }), (function(e) {
                        return m(!0, e)
                      })).catch(Te)
                    }!0 !== h && (h = !0, "writable" === e._state && !1 === Le(e) ? u().then(i) : i())
                  }

                  function g(t, r) {
                    !0 !== h && (h = !0, "writable" === e._state && !1 === Le(e) ? u().then((function() {
                      return m(t, r)
                    })).catch(Te) : m(t, r))
                  }

                  function m(e, t) {
                    je(l), E(o), e ? a(t) : r(void 0)
                  }
                  if (c(t, o._closedPromise, (function(t) {
                    !1 === i ? f((function() {
                      return Ce(e, t)
                    }), !0, t) : g(!0, t)
                  })), c(e, l._closedPromise, (function(e) {
                    !1 === s ? f((function() {
                      return d(t, e)
                    }), !0, e) : g(!0, e)
                  })), function(e, t, r) {
                    "closed" === e._state ? r() : t.then(r).catch(Te)
                  }(t, o._closedPromise, (function() {
                    !1 === n ? f((function() {
                      return De(l)
                    })) : g()
                  })), !0 === Le(e) || "closed" === e._state) {
                    var y = new TypeError("the destination writable stream closed before all data could be piped to it");
                    !1 === s ? f((function() {
                      return d(t, y)
                    }), !0, y) : g(!0, y)
                  }(function e() {
                    return !0 === h ? Promise.resolve() : l._readyPromise.then((function() {
                      return O(o).then((function(e) {
                        var t = e.value;
                        !0 !== e.done && (p = ke(l, t).catch((function() {})))
                      }))
                    })).then(e)
                  })().catch((function(e) {
                    p = Promise.resolve(), Te(e)
                  }))
                }))
              }
            }, {
              key: "tee",
              value: function() {
                if (!1 === u(this)) throw re("tee");
                var e = function(e, t) {
                  function r() {
                    return O(i).then((function(e) {
                      var t = e.value;
                      if (!0 === e.done && !1 === o && (!1 === u && N(p._readableStreamController), !1 === c && N(f._readableStreamController), o = !0), !0 !== o) {
                        var r = t,
                          n = t;
                        !1 === u && P(p._readableStreamController, r), !1 === c && P(f._readableStreamController, n)
                      }
                    }))
                  }

                  function n() {}
                  var i = a(e),
                    o = !1,
                    u = !1,
                    c = !1,
                    l = void 0,
                    h = void 0,
                    p = void 0,
                    f = void 0,
                    g = void 0,
                    m = new Promise((function(e) {
                      g = e
                    }));
                  return p = s(n, r, (function(t) {
                    if (u = !0, l = t, !0 === c) {
                      var r = we([l, h]),
                        n = d(e, r);
                      g(n)
                    }
                    return m
                  })), f = s(n, r, (function(t) {
                    if (c = !0, h = t, !0 === u) {
                      var r = we([l, h]),
                        n = d(e, r);
                      g(n)
                    }
                    return m
                  })), i._closedPromise.catch((function(e) {
                    !0 !== o && (D(p._readableStreamController, e), D(f._readableStreamController, e), o = !0)
                  })), [p, f]
                }(this);
                return we(e)
              }
            }, {
              key: "locked",
              get: function() {
                if (!1 === u(this)) throw re("locked");
                return c(this)
              }
            }]), e
          }();
        t.exports = {
          CreateReadableByteStream: function(e, t, r) {
            var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
              i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : void 0,
              a = Object.create(Be.prototype);
            return o(a), ee(a, Object.create(Ge.prototype), e, t, r, n, i), a
          },
          CreateReadableStream: s,
          ReadableStream: Be,
          IsReadableStreamDisturbed: function(e) {
            return e._disturbed
          },
          ReadableStreamDefaultControllerClose: N,
          ReadableStreamDefaultControllerEnqueue: P,
          ReadableStreamDefaultControllerError: C,
          ReadableStreamDefaultControllerGetDesiredSize: j,
          ReadableStreamDefaultControllerHasBackpressure: function(e) {
            return !0 !== I(e)
          },
          ReadableStreamDefaultControllerCanCloseOrEnqueue: k
        };
        var qe = function() {
            function e(t) {
              if (n(this, e), !1 === u(t)) throw new TypeError("ReadableStreamDefaultReader can only be constructed with a ReadableStream instance");
              if (!0 === c(t)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
              S(this, t), this._readRequests = []
            }
            return le(e, [{
              key: "cancel",
              value: function(e) {
                return !1 === w(this) ? Promise.reject(ie("cancel")) : void 0 === this._ownerReadableStream ? Promise.reject(ne("cancel")) : T(this, e)
              }
            }, {
              key: "read",
              value: function() {
                return !1 === w(this) ? Promise.reject(ie("read")) : void 0 === this._ownerReadableStream ? Promise.reject(ne("read from")) : O(this)
              }
            }, {
              key: "releaseLock",
              value: function() {
                if (!1 === w(this)) throw ie("releaseLock");
                if (void 0 !== this._ownerReadableStream) {
                  if (this._readRequests.length > 0) throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
                  E(this)
                }
              }
            }, {
              key: "closed",
              get: function() {
                return !1 === w(this) ? Promise.reject(ie("closed")) : this._closedPromise
              }
            }]), e
          }(),
          Ue = function() {
            function e(t) {
              if (n(this, e), !u(t)) throw new TypeError("ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a byte source");
              if (!1 === F(t._readableStreamController)) throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");
              if (c(t)) throw new TypeError("This stream has already been locked for exclusive reading by another reader");
              S(this, t), this._readIntoRequests = []
            }
            return le(e, [{
              key: "cancel",
              value: function(e) {
                return v(this) ? void 0 === this._ownerReadableStream ? Promise.reject(ne("cancel")) : T(this, e) : Promise.reject(se("cancel"))
              }
            }, {
              key: "read",
              value: function(e) {
                return v(this) ? void 0 === this._ownerReadableStream ? Promise.reject(ne("read from")) : ArrayBuffer.isView(e) ? !0 === ye(e.buffer) ? Promise.reject(new TypeError("Cannot read into a view onto a detached ArrayBuffer")) : 0 === e.byteLength ? Promise.reject(new TypeError("view must have non-zero byteLength")) : x(this, e) : Promise.reject(new TypeError("view must be an array buffer view")) : Promise.reject(se("read"))
              }
            }, {
              key: "releaseLock",
              value: function() {
                if (!v(this)) throw se("releaseLock");
                if (void 0 !== this._ownerReadableStream) {
                  if (this._readIntoRequests.length > 0) throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");
                  E(this)
                }
              }
            }, {
              key: "closed",
              get: function() {
                return v(this) ? this._closedPromise : Promise.reject(se("closed"))
              }
            }]), e
          }(),
          Ve = function() {
            function e() {
              throw n(this, e), new TypeError
            }
            return le(e, [{
              key: "close",
              value: function() {
                if (!1 === A(this)) throw oe("close");
                if (!1 === k(this)) throw new TypeError("The stream is not in a state that permits close");
                N(this)
              }
            }, {
              key: "enqueue",
              value: function(e) {
                if (!1 === A(this)) throw oe("enqueue");
                if (!1 === k(this)) throw new TypeError("The stream is not in a state that permits enqueue");
                return P(this, e)
              }
            }, {
              key: "error",
              value: function(e) {
                if (!1 === A(this)) throw oe("error");
                var t = this._controlledReadableStream;
                if ("readable" !== t._state) throw new TypeError("The stream is " + t._state + " and so cannot be errored");
                C(this, e)
              }
            }, {
              key: Me,
              value: function(e) {
                return Ae(this), this._cancelAlgorithm(e)
              }
            }, {
              key: Fe,
              value: function() {
                var e = this._controlledReadableStream;
                if (this._queue.length > 0) {
                  var t = xe(this);
                  return !0 === this._closeRequested && 0 === this._queue.length ? p(e) : R(this), Promise.resolve(fe(t, !1))
                }
                var r = h(e);
                return R(this), r
              }
            }, {
              key: "desiredSize",
              get: function() {
                if (!1 === A(this)) throw oe("desiredSize");
                return j(this)
              }
            }]), e
          }(),
          He = function() {
            function e() {
              throw n(this, e), new TypeError("ReadableStreamBYOBRequest cannot be used directly")
            }
            return le(e, [{
              key: "respond",
              value: function(e) {
                if (!1 === B(this)) throw ue("respond");
                if (void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
                if (!0 === ye(this._view.buffer)) throw new TypeError("The BYOB request's buffer has been detached and so cannot be used as a response");
                ! function(e, t) {
                  if (t = Number(t), !1 === ge(t)) throw new RangeError("bytesWritten must be a finite");
                  J(e, t)
                }(this._associatedReadableByteStreamController, e)
              }
            }, {
              key: "respondWithNewView",
              value: function(e) {
                if (!1 === B(this)) throw ue("respond");
                if (void 0 === this._associatedReadableByteStreamController) throw new TypeError("This BYOB request has been invalidated");
                if (!ArrayBuffer.isView(e)) throw new TypeError("You can only respond with array buffer views");
                if (!0 === ye(e.buffer)) throw new TypeError("The supplied view's buffer has been detached and so cannot be used as a response");
                ! function(e, t) {
                  var r = e._pendingPullIntos[0];
                  if (r.byteOffset + r.bytesFilled !== t.byteOffset) throw new RangeError("The region specified by view does not match byobRequest");
                  if (r.byteLength !== t.byteLength) throw new RangeError("The buffer of view has different capacity than byobRequest");
                  r.buffer = t.buffer, J(e, t.byteLength)
                }(this._associatedReadableByteStreamController, e)
              }
            }, {
              key: "view",
              get: function() {
                if (!1 === B(this)) throw ue("view");
                return this._view
              }
            }]), e
          }(),
          Ge = function() {
            function e() {
              throw n(this, e), new TypeError("ReadableByteStreamController constructor cannot be used directly")
            }
            return le(e, [{
              key: "close",
              value: function() {
                if (!1 === F(this)) throw ce("close");
                if (!0 === this._closeRequested) throw new TypeError("The stream has already been closed; do not close it again!");
                var e = this._controlledReadableByteStream._state;
                if ("readable" !== e) throw new TypeError("The stream (in " + e + " state) is not in the readable state and cannot be closed");
                ! function(e) {
                  var t = e._controlledReadableByteStream;
                  if (e._queueTotalSize > 0) e._closeRequested = !0;
                  else {
                    if (e._pendingPullIntos.length > 0 && e._pendingPullIntos[0].bytesFilled > 0) {
                      var r = new TypeError("Insufficient bytes to fill elements in the given buffer");
                      throw K(e, r), r
                    }
                    p(t)
                  }
                }(this)
              }
            }, {
              key: "enqueue",
              value: function(e) {
                if (!1 === F(this)) throw ce("enqueue");
                if (!0 === this._closeRequested) throw new TypeError("stream is closed or draining");
                var t = this._controlledReadableByteStream._state;
                if ("readable" !== t) throw new TypeError("The stream (in " + t + " state) is not in the readable state and cannot be enqueued to");
                if (!ArrayBuffer.isView(e)) throw new TypeError("You can only enqueue array buffer views when using a ReadableByteStreamController");
                if (!0 === ye(e.buffer)) throw new TypeError("Cannot enqueue a view onto a detached ArrayBuffer");
                ! function(e, t) {
                  var r = e._controlledReadableByteStream,
                    n = t.buffer,
                    i = t.byteOffset,
                    a = t.byteLength,
                    s = be(n);
                  !0 === _(r) ? 0 === y(r) ? G(e, s, i, a) : g(r, new Uint8Array(s, i, a), !1) : !0 === b(r) ? (G(e, s, i, a), Y(e)) : G(e, s, i, a)
                }(this, e)
              }
            }, {
              key: "error",
              value: function(e) {
                if (!1 === F(this)) throw ce("error");
                var t = this._controlledReadableByteStream;
                if ("readable" !== t._state) throw new TypeError("The stream is " + t._state + " and so cannot be errored");
                K(this, e)
              }
            }, {
              key: Me,
              value: function(e) {
                return this._pendingPullIntos.length > 0 && (this._pendingPullIntos[0].bytesFilled = 0), Ae(this), this._cancelAlgorithm(e)
              }
            }, {
              key: Fe,
              value: function() {
                var e = this._controlledReadableByteStream;
                if (this._queueTotalSize > 0) {
                  var t = this._queue.shift();
                  this._queueTotalSize -= t.byteLength, X(this);
                  var r = void 0;
                  try {
                    r = new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
                  } catch (e) {
                    return Promise.reject(e)
                  }
                  return Promise.resolve(fe(r, !1))
                }
                var n = this._autoAllocateChunkSize;
                if (void 0 !== n) {
                  var i = void 0;
                  try {
                    i = new ArrayBuffer(n)
                  } catch (e) {
                    return Promise.reject(e)
                  }
                  var a = {
                    buffer: i,
                    byteOffset: 0,
                    byteLength: n,
                    bytesFilled: 0,
                    elementSize: 1,
                    ctor: Uint8Array,
                    readerType: "default"
                  };
                  this._pendingPullIntos.push(a)
                }
                var s = h(e);
                return q(this), s
              }
            }, {
              key: "byobRequest",
              get: function() {
                if (!1 === F(this)) throw ce("byobRequest");
                if (void 0 === this._byobRequest && this._pendingPullIntos.length > 0) {
                  var e = this._pendingPullIntos[0],
                    t = new Uint8Array(e.buffer, e.byteOffset + e.bytesFilled, e.byteLength - e.bytesFilled),
                    r = Object.create(He.prototype);
                  (function(e, t, r) {
                    e._associatedReadableByteStreamController = t, e._view = r
                  })(r, this, t), this._byobRequest = r
                }
                return this._byobRequest
              }
            }, {
              key: "desiredSize",
              get: function() {
                if (!1 === F(this)) throw ce("desiredSize");
                return Z(this)
              }
            }]), e
          }()
      }, {
        "./helpers.js": 10,
        "./queue-with-sizes.js": 11,
        "./utils.js": 14,
        "./writable-stream.js": 15,
        "better-assert": 16
      }],
      13: [function(e, t, r) {
        "use strict";

        function n(e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function i(e, t, r, n, i, a) {
          function c() {
            return t
          }
          e._writable = D(c, (function(t) {
            return function(e, t) {
              m("TransformStreamDefaultSinkWriteAlgorithm()");
              var r = e._transformStreamController;
              return !0 === e._backpressure ? e._backpressureChangePromise.then((function() {
                var n = e._writable;
                if ("erroring" === n._state) throw n._storedError;
                return r._transformAlgorithm(t)
              })) : r._transformAlgorithm(t)
            }(e, t)
          }), (function() {
            return function(e) {
              m("TransformStreamDefaultSinkCloseAlgorithm()");
              var t = e._readable;
              return e._transformStreamController._flushAlgorithm().then((function() {
                if ("errored" === t._state) throw t._storedError;
                var e = t._readableStreamController;
                !0 === P(e) && O(e)
              })).catch((function(r) {
                throw s(e, r), t._storedError
              }))
            }(e)
          }), (function() {
            return function(e) {
              return s(e, new TypeError("Writable side aborted")), Promise.resolve()
            }(e)
          }), r, n), e._readable = x(c, (function() {
            return function(e) {
              return m("TransformStreamDefaultSourcePullAlgorithm()"), u(e, !1), e._backpressureChangePromise
            }(e)
          }), (function(t) {
            return o(e, t), Promise.resolve()
          }), i, a), e._backpressure = void 0, e._backpressureChangePromise = void 0, e._backpressureChangePromise_resolve = void 0, u(e, !0), e._transformStreamController = void 0
        }

        function a(e) {
          return !!w(e) && !!Object.prototype.hasOwnProperty.call(e, "_transformStreamController")
        }

        function s(e, t) {
          m("TransformStreamError()"), "readable" === e._readable._state && R(e._readable._readableStreamController, t), o(e, t)
        }

        function o(e, t) {
          j(e._writable._writableStreamController, t), !0 === e._backpressure && u(e, !1)
        }

        function u(e, t) {
          m("TransformStreamSetBackpressure() [backpressure = " + t + "]"), void 0 !== e._backpressureChangePromise && e._backpressureChangePromise_resolve(), e._backpressureChangePromise = new Promise((function(t) {
            e._backpressureChangePromise_resolve = t
          })), e._backpressure = t
        }

        function c(e) {
          return !!w(e) && !!Object.prototype.hasOwnProperty.call(e, "_controlledTransformStream")
        }

        function l(e, t, r, n) {
          t._controlledTransformStream = e, e._transformStreamController = t, t._transformAlgorithm = r, t._flushAlgorithm = n
        }

        function h(e, t) {
          var r = Object.create(L.prototype),
            n = function(e) {
              try {
                return d(r, e), Promise.resolve()
              } catch (e) {
                return Promise.reject(e)
              }
            },
            i = t.transform;
          if (void 0 !== i) {
            if ("function" != typeof i) throw new TypeError("transform is not a method");
            n = function(n) {
              return v(i, t, [n, r]).catch((function(t) {
                throw s(e, t), t
              }))
            }
          }
          var a = _(t, "flush", 0, [r]);
          l(e, r, n, a)
        }

        function d(e, t) {
          m("TransformStreamDefaultControllerEnqueue()");
          var r = e._controlledTransformStream,
            n = r._readable._readableStreamController;
          if (!1 === P(n)) throw new TypeError("Readable side is not in a state that permits enqueue");
          try {
            A(n, t)
          } catch (e) {
            throw o(r, e), r._readable._storedError
          }
          N(n) !== r._backpressure && u(r, !0)
        }

        function p(e) {
          return new TypeError("TransformStreamDefaultController.prototype." + e + " can only be used on a TransformStreamDefaultController")
        }

        function f(e) {
          return new TypeError("TransformStream.prototype." + e + " can only be used on a TransformStream")
        }
        var g = function() {
            function e(e, t) {
              for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
              }
            }
            return function(t, r, n) {
              return r && e(t.prototype, r), n && e(t, n), t
            }
          }(),
          m = (e("better-assert"), e("debug")("streams:transform-stream:verbose")),
          y = e("./helpers.js"),
          b = y.InvokeOrNoop,
          _ = y.CreateAlgorithmFromUnderlyingMethod,
          v = y.PromiseCall,
          w = y.typeIsObject,
          S = y.ValidateAndNormalizeHighWaterMark,
          T = (y.IsNonNegativeNumber, y.MakeSizeAlgorithmFromSizeFunction),
          E = e("./readable-stream.js"),
          x = E.CreateReadableStream,
          O = E.ReadableStreamDefaultControllerClose,
          A = E.ReadableStreamDefaultControllerEnqueue,
          R = E.ReadableStreamDefaultControllerError,
          I = E.ReadableStreamDefaultControllerGetDesiredSize,
          N = E.ReadableStreamDefaultControllerHasBackpressure,
          P = E.ReadableStreamDefaultControllerCanCloseOrEnqueue,
          C = e("./writable-stream.js"),
          D = C.CreateWritableStream,
          j = C.WritableStreamDefaultControllerErrorIfNeeded,
          k = function() {
            function e() {
              var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                a = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
              if (n(this, e), void 0 !== t.readableType) throw new RangeError("Invalid readable type specified");
              if (void 0 !== t.writableType) throw new RangeError("Invalid writable type specified");
              var s = r.size,
                o = T(s),
                u = r.highWaterMark;
              void 0 === u && (u = 1), u = S(u);
              var c = a.size,
                l = T(c),
                d = a.highWaterMark;
              void 0 === d && (d = 0), d = S(d);
              var p = void 0;
              i(this, new Promise((function(e) {
                p = e
              })), u, o, d, l), h(this, t);
              var f = b(t, "start", [this._transformStreamController]);
              p(f)
            }
            return g(e, [{
              key: "readable",
              get: function() {
                if (!1 === a(this)) throw f("readable");
                return this._readable
              }
            }, {
              key: "writable",
              get: function() {
                if (!1 === a(this)) throw f("writable");
                return this._writable
              }
            }]), e
          }(),
          L = function() {
            function e() {
              throw n(this, e), new TypeError("TransformStreamDefaultController instances cannot be created directly")
            }
            return g(e, [{
              key: "enqueue",
              value: function(e) {
                if (!1 === c(this)) throw p("enqueue");
                d(this, e)
              }
            }, {
              key: "error",
              value: function(e) {
                if (!1 === c(this)) throw p("error");
                ! function(e, t) {
                  s(e._controlledTransformStream, t)
                }(this, e)
              }
            }, {
              key: "terminate",
              value: function() {
                if (!1 === c(this)) throw p("terminate");
                ! function(e) {
                  m("TransformStreamDefaultControllerTerminate()");
                  var t = e._controlledTransformStream,
                    r = t._readable._readableStreamController;
                  !0 === P(r) && O(r), o(t, new TypeError("TransformStream terminated"))
                }(this)
              }
            }, {
              key: "desiredSize",
              get: function() {
                if (!1 === c(this)) throw p("desiredSize");
                var e = this._controlledTransformStream._readable._readableStreamController;
                return I(e)
              }
            }]), e
          }();
        t.exports = {
          CreateTransformStream: function(e, t, r) {
            var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 1,
              a = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : function() {
                return 1
              },
              s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
              o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : function() {
                return 1
              },
              u = Object.create(k.prototype),
              c = void 0;
            i(u, new Promise((function(e) {
              c = e
            })), n, a, s, o), l(u, Object.create(L.prototype), t, r);
            var h = e();
            return c(h), u
          },
          TransformStream: k
        }
      }, {
        "./helpers.js": 10,
        "./readable-stream.js": 12,
        "./writable-stream.js": 15,
        "better-assert": 16,
        debug: 18
      }],
      14: [function(e, t, r) {
        "use strict";
        var n = e("better-assert");
        r.rethrowAssertionErrorRejection = function(e) {
          e && e.constructor === n.AssertionError && setTimeout((function() {
            throw e
          }), 0)
        }
      }, {
        "better-assert": 16
      }],
      15: [function(e, t, r) {
        "use strict";

        function n(e, t) {
          if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
        }

        function i(e) {
          return new Z(e)
        }

        function a(e) {
          e._state = "writable", e._storedError = void 0, e._writer = void 0, e._writableStreamController = void 0, e._writeRequests = [], e._inFlightWriteRequest = void 0, e._closeRequest = void 0, e._inFlightCloseRequest = void 0, e._pendingAbortRequest = void 0, e._backpressure = !1
        }

        function s(e) {
          return !!H(e) && !!Object.prototype.hasOwnProperty.call(e, "_writableStreamController")
        }

        function o(e) {
          return void 0 !== e._writer
        }

        function u(e, t) {
          var r = e._state;
          if ("closed" === r) return Promise.resolve(void 0);
          if ("errored" === r) return Promise.reject(e._storedError);
          var n = new TypeError("Requested to abort");
          if (void 0 !== e._pendingAbortRequest) return Promise.reject(n);
          var i = !1;
          "erroring" === r && (i = !0, t = void 0);
          var a = new Promise((function(r, n) {
            e._pendingAbortRequest = {
              _resolve: r,
              _reject: n,
              _reason: t,
              _wasAlreadyErroring: i
            }
          }));
          return !1 === i && l(e, n), a
        }

        function c(e, t) {
          M("WritableStreamDealWithRejection(stream, %o)", t), "writable" !== e._state ? h(e) : l(e, t)
        }

        function l(e, t) {
          M("WritableStreamStartErroring(stream, %o)", t);
          var r = e._writableStreamController;
          e._state = "erroring", e._storedError = t;
          var n = e._writer;
          void 0 !== n && b(n, t), !1 === function(e) {
            return void 0 === e._inFlightWriteRequest && void 0 === e._inFlightCloseRequest ? (M("WritableStreamHasOperationMarkedInFlight() is false"), !1) : (M("WritableStreamHasOperationMarkedInFlight() is true"), !0)
          }(e) && !0 === r._started && h(e)
        }

        function h(e) {
          M("WritableStreamFinishErroring()"), e._state = "errored", e._writableStreamController[W]();
          var t = e._storedError,
            r = !0,
            n = !1,
            i = void 0;
          try {
            for (var a, s = e._writeRequests[Symbol.iterator](); !(r = (a = s.next()).done); r = !0) a.value._reject(t)
          } catch (e) {
            n = !0, i = e
          } finally {
            try {
              !r && s.return && s.return()
            } finally {
              if (n) throw i
            }
          }
          if (e._writeRequests = [], void 0 !== e._pendingAbortRequest) {
            var o = e._pendingAbortRequest;
            if (e._pendingAbortRequest = void 0, !0 === o._wasAlreadyErroring) return o._reject(t), void p(e);
            e._writableStreamController[J](o._reason).then((function() {
              o._resolve(), p(e)
            }), (function(t) {
              o._reject(t), p(e)
            }))
          } else p(e)
        }

        function d(e) {
          return void 0 !== e._closeRequest || void 0 !== e._inFlightCloseRequest
        }

        function p(e) {
          M("WritableStreamRejectCloseAndClosedPromiseIfNeeded()"), void 0 !== e._closeRequest && (e._closeRequest._reject(e._storedError), e._closeRequest = void 0);
          var t = e._writer;
          void 0 !== t && (C(t, e._storedError), t._closedPromise.catch((function() {})))
        }

        function f(e, t) {
          var r = e._writer;
          void 0 !== r && t !== e._backpressure && (!0 === t ? function(e) {
            M("defaultWriterReadyPromiseReset()"), e._readyPromise = new Promise((function(t, r) {
              e._readyPromise_resolve = t, e._readyPromise_reject = r
            })), e._readyPromiseState = "pending"
          }(r) : k(r)), e._backpressure = t
        }

        function g(e) {
          return !!H(e) && !!Object.prototype.hasOwnProperty.call(e, "_ownerWritableStream")
        }

        function m(e) {
          var t = e._ownerWritableStream,
            r = t._state;
          if ("closed" === r || "errored" === r) return Promise.reject(new TypeError("The stream (in " + r + " state) is not in the writable state and cannot be closed"));
          var n = new Promise((function(e, r) {
            var n = {
              _resolve: e,
              _reject: r
            };
            t._closeRequest = n
          }));
          return !0 === t._backpressure && "writable" === r && k(e),
            function(e) {
              X(e, "close", 0), E(e)
            }(t._writableStreamController), n
        }

        function y(e, t) {
          "pending" === e._closedPromiseState ? C(e, t) : function(e, t) {
            e._closedPromise = Promise.reject(t), e._closedPromiseState = "rejected"
          }(e, t), e._closedPromise.catch((function() {}))
        }

        function b(e, t) {
          M("WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, %o)", t), "pending" === e._readyPromiseState ? function(e, t) {
            M("defaultWriterReadyPromiseReject(writer, %o)", t), e._readyPromise_reject(t), e._readyPromise_resolve = void 0, e._readyPromise_reject = void 0, e._readyPromiseState = "rejected"
          }(e, t) : function(e, t) {
            M("defaultWriterReadyPromiseResetToRejected(writer, %o)", t), e._readyPromise = Promise.reject(t), e._readyPromiseState = "rejected"
          }(e, t), e._readyPromise.catch((function() {}))
        }

        function _(e) {
          var t = e._ownerWritableStream,
            r = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
          b(e, r), y(e, r), t._writer = void 0, e._ownerWritableStream = void 0
        }

        function v(e, t) {
          var r = e._ownerWritableStream,
            n = r._writableStreamController,
            i = function(e, t) {
              try {
                return e._strategySizeAlgorithm(t)
              } catch (t) {
                return x(e, t), 1
              }
            }(n, t);
          if (r !== e._ownerWritableStream) return Promise.reject(N("write to"));
          var a = r._state;
          if ("errored" === a) return Promise.reject(r._storedError);
          if (!0 === d(r) || "closed" === a) return Promise.reject(new TypeError("The stream is closing or closed and cannot be written to"));
          if ("erroring" === a) return Promise.reject(r._storedError);
          var s = function(e) {
            return new Promise((function(t, r) {
              var n = {
                _resolve: t,
                _reject: r
              };
              e._writeRequests.push(n)
            }))
          }(r);
          return function(e, t, r) {
            var n = {
              chunk: t
            };
            try {
              X(e, n, r)
            } catch (t) {
              return void x(e, t)
            }
            var i = e._controlledWritableStream;
            !1 === d(i) && "writable" === i._state && f(i, O(e)), E(e)
          }(n, t, i), s
        }

        function w(e, t, r, n, i, a, s, o) {
          t._controlledWritableStream = e, e._writableStreamController = t, t._queue = void 0, t._queueTotalSize = void 0, Y(t), t._started = !1, t._strategySizeAlgorithm = o, t._strategyHWM = s, t._writeAlgorithm = n, t._closeAlgorithm = i, t._abortAlgorithm = a;
          var u = O(t);
          f(e, u);
          var l = r();
          Promise.resolve(l).then((function() {
            t._started = !0, E(t)
          }), (function(r) {
            t._started = !0, c(e, r)
          })).catch(G)
        }

        function S(e, t, r, n) {
          var i = Object.create(ee.prototype),
            a = B(t, "write", 1, [i]),
            s = B(t, "close", 0, []),
            o = B(t, "abort", 1, []);
          w(e, i, (function() {
            return q(t, "start", [i])
          }), a, s, o, r, n)
        }

        function T(e) {
          return e._strategyHWM - e._queueTotalSize
        }

        function E(e) {
          M("WritableStreamDefaultControllerAdvanceQueueIfNeeded()");
          var t = e._controlledWritableStream;
          if (!1 !== e._started && void 0 === t._inFlightWriteRequest) {
            var r = t._state;
            if ("closed" !== r && "errored" !== r)
              if ("erroring" !== r) {
                if (0 !== e._queue.length) {
                  var n = $(e);
                  "close" === n ? function(e) {
                    var t = e._controlledWritableStream;
                    (function(e) {
                      e._inFlightCloseRequest = e._closeRequest, e._closeRequest = void 0
                    })(t), Q(e), e._closeAlgorithm().then((function() {
                      ! function(e) {
                        e._inFlightCloseRequest._resolve(void 0), e._inFlightCloseRequest = void 0, "erroring" === e._state && (e._storedError = void 0, void 0 !== e._pendingAbortRequest && (e._pendingAbortRequest._resolve(), e._pendingAbortRequest = void 0)), e._state = "closed";
                        var t = e._writer;
                        void 0 !== t && function(e) {
                          e._closedPromise_resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0, e._closedPromiseState = "resolved"
                        }(t)
                      }(t)
                    }), (function(e) {
                      ! function(e, t) {
                        e._inFlightCloseRequest._reject(t), e._inFlightCloseRequest = void 0, void 0 !== e._pendingAbortRequest && (e._pendingAbortRequest._reject(t), e._pendingAbortRequest = void 0), c(e, t)
                      }(t, e)
                    })).catch(G)
                  }(e) : function(e, t) {
                    var r = e._controlledWritableStream;
                    (function(e) {
                      e._inFlightWriteRequest = e._writeRequests.shift()
                    })(r), e._writeAlgorithm(t).then((function() {
                      ! function(e) {
                        e._inFlightWriteRequest._resolve(void 0), e._inFlightWriteRequest = void 0
                      }(r);
                      var t = r._state;
                      if (Q(e), !1 === d(r) && "writable" === t) {
                        var n = O(e);
                        f(r, n)
                      }
                      E(e)
                    }), (function(e) {
                      ! function(e, t) {
                        e._inFlightWriteRequest._reject(t), e._inFlightWriteRequest = void 0, c(e, t)
                      }(r, e)
                    })).catch(G)
                  }(e, n.chunk)
                }
              } else h(t)
          }
        }

        function x(e, t) {
          "writable" === e._controlledWritableStream._state && A(e, t)
        }

        function O(e) {
          return T(e) <= 0
        }

        function A(e, t) {
          l(e._controlledWritableStream, t)
        }

        function R(e) {
          return new TypeError("WritableStream.prototype." + e + " can only be used on a WritableStream")
        }

        function I(e) {
          return new TypeError("WritableStreamDefaultWriter.prototype." + e + " can only be used on a WritableStreamDefaultWriter")
        }

        function N(e) {
          return new TypeError("Cannot " + e + " a stream using a released writer")
        }

        function P(e) {
          e._closedPromise = new Promise((function(t, r) {
            e._closedPromise_resolve = t, e._closedPromise_reject = r, e._closedPromiseState = "pending"
          }))
        }

        function C(e, t) {
          e._closedPromise_reject(t), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0, e._closedPromiseState = "rejected"
        }

        function D(e, t) {
          M("defaultWriterReadyPromiseInitializeAsRejected(writer, %o)", t), e._readyPromise = Promise.reject(t), e._readyPromise_resolve = void 0, e._readyPromise_reject = void 0, e._readyPromiseState = "rejected"
        }

        function j(e) {
          M("defaultWriterReadyPromiseInitializeAsResolved()"), e._readyPromise = Promise.resolve(void 0), e._readyPromise_resolve = void 0, e._readyPromise_reject = void 0, e._readyPromiseState = "fulfilled"
        }

        function k(e) {
          M("defaultWriterReadyPromiseResolve()"), e._readyPromise_resolve(void 0), e._readyPromise_resolve = void 0, e._readyPromise_reject = void 0, e._readyPromiseState = "fulfilled"
        }
        var L = function() {
            function e(e, t) {
              for (var r = 0; r < t.length; r++) {
                var n = t[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
              }
            }
            return function(t, r, n) {
              return r && e(t.prototype, r), n && e(t, n), t
            }
          }(),
          M = (e("better-assert"), e("debug")("streams:writable-stream:verbose")),
          F = e("./helpers.js"),
          B = F.CreateAlgorithmFromUnderlyingMethod,
          q = F.InvokeOrNoop,
          U = F.ValidateAndNormalizeHighWaterMark,
          V = (F.IsNonNegativeNumber, F.MakeSizeAlgorithmFromSizeFunction),
          H = F.typeIsObject,
          G = e("./utils.js").rethrowAssertionErrorRejection,
          z = e("./queue-with-sizes.js"),
          Q = z.DequeueValue,
          X = z.EnqueueValueWithSize,
          $ = z.PeekQueueValue,
          Y = z.ResetQueue,
          J = Symbol("[[AbortSteps]]"),
          W = Symbol("[[ErrorSteps]]"),
          K = function() {
            function e() {
              var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
                i = r.size,
                s = r.highWaterMark,
                o = void 0 === s ? 1 : s;
              if (n(this, e), a(this), void 0 !== t.type) throw new RangeError("Invalid type is specified");
              var u = V(i);
              S(this, t, o = U(o), u)
            }
            return L(e, [{
              key: "abort",
              value: function(e) {
                return !1 === s(this) ? Promise.reject(R("abort")) : !0 === o(this) ? Promise.reject(new TypeError("Cannot abort a stream that already has a writer")) : u(this, e)
              }
            }, {
              key: "getWriter",
              value: function() {
                if (!1 === s(this)) throw R("getWriter");
                return i(this)
              }
            }, {
              key: "locked",
              get: function() {
                if (!1 === s(this)) throw R("locked");
                return o(this)
              }
            }]), e
          }();
        t.exports = {
          AcquireWritableStreamDefaultWriter: i,
          CreateWritableStream: function(e, t, r, n) {
            var i = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 1,
              s = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : function() {
                return 1
              },
              o = Object.create(K.prototype);
            return a(o), w(o, Object.create(ee.prototype), e, t, r, n, i, s), o
          },
          IsWritableStream: s,
          IsWritableStreamLocked: o,
          WritableStream: K,
          WritableStreamAbort: u,
          WritableStreamDefaultControllerErrorIfNeeded: x,
          WritableStreamDefaultWriterCloseWithErrorPropagation: function(e) {
            var t = e._ownerWritableStream,
              r = t._state;
            return !0 === d(t) || "closed" === r ? Promise.resolve() : "errored" === r ? Promise.reject(t._storedError) : m(e)
          },
          WritableStreamDefaultWriterRelease: _,
          WritableStreamDefaultWriterWrite: v,
          WritableStreamCloseQueuedOrInFlight: d
        };
        var Z = function() {
            function e(t) {
              if (n(this, e), !1 === s(t)) throw new TypeError("WritableStreamDefaultWriter can only be constructed with a WritableStream instance");
              if (!0 === o(t)) throw new TypeError("This stream has already been locked for exclusive writing by another writer");
              this._ownerWritableStream = t, t._writer = this;
              var r = t._state;
              if ("writable" === r) !1 === d(t) && !0 === t._backpressure ? function(e) {
                M("defaultWriterReadyPromiseInitialize()"), e._readyPromise = new Promise((function(t, r) {
                  e._readyPromise_resolve = t, e._readyPromise_reject = r
                })), e._readyPromiseState = "pending"
              }(this) : j(this), P(this);
              else if ("erroring" === r) D(this, t._storedError), this._readyPromise.catch((function() {})), P(this);
              else if ("closed" === r) j(this),
                function(e) {
                  e._closedPromise = Promise.resolve(void 0), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0, e._closedPromiseState = "resolved"
                }(this);
              else {
                var i = t._storedError;
                D(this, i), this._readyPromise.catch((function() {})),
                  function(e, t) {
                    e._closedPromise = Promise.reject(t), e._closedPromise_resolve = void 0, e._closedPromise_reject = void 0, e._closedPromiseState = "rejected"
                  }(this, i), this._closedPromise.catch((function() {}))
              }
            }
            return L(e, [{
              key: "abort",
              value: function(e) {
                return !1 === g(this) ? Promise.reject(I("abort")) : void 0 === this._ownerWritableStream ? Promise.reject(N("abort")) : function(e, t) {
                  return u(e._ownerWritableStream, t)
                }(this, e)
              }
            }, {
              key: "close",
              value: function() {
                if (!1 === g(this)) return Promise.reject(I("close"));
                var e = this._ownerWritableStream;
                return void 0 === e ? Promise.reject(N("close")) : !0 === d(e) ? Promise.reject(new TypeError("cannot close an already-closing stream")) : m(this)
              }
            }, {
              key: "releaseLock",
              value: function() {
                if (!1 === g(this)) throw I("releaseLock");
                void 0 !== this._ownerWritableStream && _(this)
              }
            }, {
              key: "write",
              value: function(e) {
                return !1 === g(this) ? Promise.reject(I("write")) : void 0 === this._ownerWritableStream ? Promise.reject(N("write to")) : v(this, e)
              }
            }, {
              key: "closed",
              get: function() {
                return !1 === g(this) ? Promise.reject(I("closed")) : this._closedPromise
              }
            }, {
              key: "desiredSize",
              get: function() {
                if (!1 === g(this)) throw I("desiredSize");
                if (void 0 === this._ownerWritableStream) throw N("desiredSize");
                return e = this._ownerWritableStream, "errored" === (t = e._state) || "erroring" === t ? null : "closed" === t ? 0 : T(e._writableStreamController);
                var e, t
              }
            }, {
              key: "ready",
              get: function() {
                return !1 === g(this) ? Promise.reject(I("ready")) : this._readyPromise
              }
            }]), e
          }(),
          ee = function() {
            function e() {
              throw n(this, e), new TypeError("WritableStreamDefaultController cannot be constructed explicitly")
            }
            return L(e, [{
              key: "error",
              value: function(e) {
                if (!1 === function(e) {
                  return !!H(e) && !!Object.prototype.hasOwnProperty.call(e, "_controlledWritableStream")
                }(this)) throw new TypeError("WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController");
                "writable" === this._controlledWritableStream._state && A(this, e)
              }
            }, {
              key: J,
              value: function(e) {
                return this._abortAlgorithm(e)
              }
            }, {
              key: W,
              value: function() {
                Y(this)
              }
            }]), e
          }()
      }, {
        "./helpers.js": 10,
        "./queue-with-sizes.js": 11,
        "./utils.js": 14,
        "better-assert": 16,
        debug: 18
      }],
      16: [function(e, t, r) {
        (function(r) {
          var n = e("assert").AssertionError,
            i = e("callsite"),
            a = e("fs");
          t.exports = r.env.NO_ASSERT ? function() {} : function(e) {
            if (!e) {
              var t = i(),
                r = t[1],
                s = r.getFileName(),
                o = r.getLineNumber(),
                u = (u = a.readFileSync(s, "utf8")).split("\n")[o - 1].match(/assert\((.*)\)/)[1];
              throw new n({
                message: u,
                stackStartFunction: t[0].getFunction()
              })
            }
          }
        }).call(this, e("_process"))
      }, {
        _process: 4,
        assert: 2,
        callsite: 17,
        fs: 3
      }],
      17: [function(e, t, r) {
        t.exports = function() {
          var e = Error.prepareStackTrace;
          Error.prepareStackTrace = function(e, t) {
            return t
          };
          var t = new Error;
          Error.captureStackTrace(t, arguments.callee);
          var r = t.stack;
          return Error.prepareStackTrace = e, r
        }
      }, {}],
      18: [function(e, t, r) {
        (function(n) {
          function i() {
            var e;
            try {
              e = r.storage.debug
            } catch (e) {}
            return !e && void 0 !== n && "env" in n && (e = n.env.DEBUG), e
          }(r = t.exports = e("./debug")).log = function() {
            return "object" == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments)
          }, r.formatArgs = function(e) {
            var t = this.useColors;
            if (e[0] = (t ? "%c" : "") + this.namespace + (t ? " %c" : " ") + e[0] + (t ? "%c " : " ") + "+" + r.humanize(this.diff), t) {
              var n = "color: " + this.color;
              e.splice(1, 0, n, "color: inherit");
              var i = 0,
                a = 0;
              e[0].replace(/%[a-zA-Z%]/g, (function(e) {
                "%%" !== e && (i++, "%c" === e && (a = i))
              })), e.splice(a, 0, n)
            }
          }, r.save = function(e) {
            try {
              null == e ? r.storage.removeItem("debug") : r.storage.debug = e
            } catch (e) {}
          }, r.load = i, r.useColors = function() {
            return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type) || ("undefined" == typeof navigator || !navigator.userAgent || !navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
          }, r.storage = "undefined" != typeof chrome && void 0 !== chrome.storage ? chrome.storage.local : function() {
            try {
              return window.localStorage
            } catch (e) {}
          }(), r.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], r.formatters.j = function(e) {
            try {
              return JSON.stringify(e)
            } catch (e) {
              return "[UnexpectedJSONParseError]: " + e.message
            }
          }, r.enable(i())
        }).call(this, e("_process"))
      }, {
        "./debug": 19,
        _process: 4
      }],
      19: [function(e, t, r) {
        function n(e) {
          function t() {
            if (t.enabled) {
              var e = t,
                i = +new Date,
                a = i - (n || i);
              e.diff = a, e.prev = n, e.curr = i, n = i;
              for (var s = new Array(arguments.length), o = 0; o < s.length; o++) s[o] = arguments[o];
              s[0] = r.coerce(s[0]), "string" != typeof s[0] && s.unshift("%O");
              var u = 0;
              s[0] = s[0].replace(/%([a-zA-Z%])/g, (function(t, n) {
                if ("%%" === t) return t;
                u++;
                var i = r.formatters[n];
                if ("function" == typeof i) {
                  var a = s[u];
                  t = i.call(e, a), s.splice(u, 1), u--
                }
                return t
              })), r.formatArgs.call(e, s), (t.log || r.log || console.log.bind(console)).apply(e, s)
            }
          }
          var n;
          return t.namespace = e, t.enabled = r.enabled(e), t.useColors = r.useColors(), t.color = function(e) {
            var t, n = 0;
            for (t in e) n = (n << 5) - n + e.charCodeAt(t), n |= 0;
            return r.colors[Math.abs(n) % r.colors.length]
          }(e), t.destroy = i, "function" == typeof r.init && r.init(t), r.instances.push(t), t
        }

        function i() {
          var e = r.instances.indexOf(this);
          return -1 !== e && (r.instances.splice(e, 1), !0)
        }(r = t.exports = n.debug = n.default = n).coerce = function(e) {
          return e instanceof Error ? e.stack || e.message : e
        }, r.disable = function() {
          r.enable("")
        }, r.enable = function(e) {
          r.save(e), r.names = [], r.skips = [];
          var t, n = ("string" == typeof e ? e : "").split(/[\s,]+/),
            i = n.length;
          for (t = 0; t < i; t++) n[t] && ("-" === (e = n[t].replace(/\*/g, ".*?"))[0] ? r.skips.push(new RegExp("^" + e.substr(1) + "$")) : r.names.push(new RegExp("^" + e + "$")));
          for (t = 0; t < r.instances.length; t++) {
            var a = r.instances[t];
            a.enabled = r.enabled(a.namespace)
          }
        }, r.enabled = function(e) {
          if ("*" === e[e.length - 1]) return !0;
          var t, n;
          for (t = 0, n = r.skips.length; t < n; t++)
            if (r.skips[t].test(e)) return !1;
          for (t = 0, n = r.names.length; t < n; t++)
            if (r.names[t].test(e)) return !0;
          return !1
        }, r.humanize = e("ms"), r.instances = [], r.names = [], r.skips = [], r.formatters = {}
      }, {
        ms: 20
      }],
      20: [function(e, t, r) {
        function n(e) {
          if (!((e = String(e)).length > 100)) {
            var t = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(e);
            if (t) {
              var r = parseFloat(t[1]);
              switch ((t[2] || "ms").toLowerCase()) {
                case "years":
                case "year":
                case "yrs":
                case "yr":
                case "y":
                  return r * h;
                case "days":
                case "day":
                case "d":
                  return r * l;
                case "hours":
                case "hour":
                case "hrs":
                case "hr":
                case "h":
                  return r * c;
                case "minutes":
                case "minute":
                case "mins":
                case "min":
                case "m":
                  return r * u;
                case "seconds":
                case "second":
                case "secs":
                case "sec":
                case "s":
                  return r * o;
                case "milliseconds":
                case "millisecond":
                case "msecs":
                case "msec":
                case "ms":
                  return r;
                default:
                  return
              }
            }
          }
        }

        function i(e) {
          return e >= l ? Math.round(e / l) + "d" : e >= c ? Math.round(e / c) + "h" : e >= u ? Math.round(e / u) + "m" : e >= o ? Math.round(e / o) + "s" : e + "ms"
        }

        function a(e) {
          return s(e, l, "day") || s(e, c, "hour") || s(e, u, "minute") || s(e, o, "second") || e + " ms"
        }

        function s(e, t, r) {
          if (!(e < t)) return e < 1.5 * t ? Math.floor(e / t) + " " + r : Math.ceil(e / t) + " " + r + "s"
        }
        var o = 1e3,
          u = 60 * o,
          c = 60 * u,
          l = 24 * c,
          h = 365.25 * l;
        t.exports = function(e, t) {
          t = t || {};
          var r = typeof e;
          if ("string" === r && e.length > 0) return n(e);
          if ("number" === r && !1 === isNaN(e)) return t.long ? a(e) : i(e);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e))
        }
      }, {}]
    }, {}, [1])(1)
  }).call(this, r(10))
}, function(e, t, r) {
  "use strict";
  var n = r(128),
    i = r(253),
    a = r(256);

  function s(e) {
    return e && e.rel
  }

  function o(e, t) {
    return t.rel.split(/\s+/).forEach((function(r) {
      e[r] = a(t, {
        rel: r
      })
    })), e
  }

  function u(e, t) {
    var r = t.match(/\s*(.+)\s*=\s*"?([^"]+)"?/);
    return r && (e[r[1]] = r[2]), e
  }

  function c(e) {
    try {
      var t = e.match(/<?([^>]*)>(.*)/),
        r = t[1],
        s = t[2].split(";"),
        o = i.parse(r),
        c = n.parse(o.query);
      s.shift();
      var l = s.reduce(u, {});
      return (l = a(c, l)).url = r, l
    } catch (e) {
      return null
    }
  }
  e.exports = function(e) {
    return e ? e.split(/,\s*</).map(c).filter(s).reduce(o, {}) : null
  }
}, function(e, t, r) {
  "use strict";
  t.decode = t.parse = r(251), t.encode = t.stringify = r(252)
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(257), t), i(r(258), t)
}, function(e, t, r) {
  const n = r(263),
    i = r(264),
    a = r(265),
    s = r(266),
    o = r(267);
  e.exports = {
    DynamicNestedLoopJoin: n,
    HashJoin: i,
    NestedLoopJoin: a,
    SymmetricHashJoin: s,
    MergeStream: o
  }
}, function(e, t, r) {
  (function(e) {
    ! function(t) {
      t.parser = function(e, t) {
        return new a(e, t)
      }, t.SAXParser = a, t.SAXStream = o, t.createStream = function(e, t) {
        return new o(e, t)
      }, t.MAX_BUFFER_LENGTH = 65536;
      var n, i = ["comment", "sgmlDecl", "textNode", "tagName", "doctype", "procInstName", "procInstBody", "entity", "attribName", "attribValue", "cdata", "script"];

      function a(e, r) {
        if (!(this instanceof a)) return new a(e, r);
        ! function(e) {
          for (var t = 0, r = i.length; t < r; t++) e[i[t]] = ""
        }(this), this.q = this.c = "", this.bufferCheckPosition = t.MAX_BUFFER_LENGTH, this.opt = r || {}, this.opt.lowercase = this.opt.lowercase || this.opt.lowercasetags, this.looseCase = this.opt.lowercase ? "toLowerCase" : "toUpperCase", this.tags = [], this.closed = this.closedRoot = this.sawRoot = !1, this.tag = this.error = null, this.strict = !!e, this.noscript = !(!e && !this.opt.noscript), this.state = S.BEGIN, this.strictEntities = this.opt.strictEntities, this.ENTITIES = this.strictEntities ? Object.create(t.XML_ENTITIES) : Object.create(t.ENTITIES), this.attribList = [], this.opt.xmlns && (this.ns = Object.create(c)), this.trackPosition = !1 !== this.opt.position, this.trackPosition && (this.position = this.line = this.column = 0), E(this, "onready")
      }
      t.EVENTS = ["text", "processinginstruction", "sgmldeclaration", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "opencdata", "cdata", "closecdata", "error", "end", "ready", "script", "opennamespace", "closenamespace"], Object.create || (Object.create = function(e) {
        function t() {}
        return t.prototype = e, new t
      }), Object.keys || (Object.keys = function(e) {
        var t = [];
        for (var r in e) e.hasOwnProperty(r) && t.push(r);
        return t
      }), a.prototype = {
        end: function() {
          I(this)
        },
        write: function(e) {
          if (this.error) throw this.error;
          if (this.closed) return R(this, "Cannot write after close. Assign an onready handler.");
          if (null === e) return I(this);
          "object" == typeof e && (e = e.toString());
          var r = 0,
            n = "";
          for (; n = F(e, r++), this.c = n, n;) switch (this.trackPosition && (this.position++, "\n" === n ? (this.line++, this.column = 0) : this.column++), this.state) {
            case S.BEGIN:
              if (this.state = S.BEGIN_WHITESPACE, "\ufeff" === n) continue;
              M(this, n);
              continue;
            case S.BEGIN_WHITESPACE:
              M(this, n);
              continue;
            case S.TEXT:
              if (this.sawRoot && !this.closedRoot) {
                for (var a = r - 1; n && "<" !== n && "&" !== n;)(n = F(e, r++)) && this.trackPosition && (this.position++, "\n" === n ? (this.line++, this.column = 0) : this.column++);
                this.textNode += e.substring(a, r - 1)
              }
              "<" !== n || this.sawRoot && this.closedRoot && !this.strict ? (f(n) || this.sawRoot && !this.closedRoot || N(this, "Text data outside of root node."), "&" === n ? this.state = S.TEXT_ENTITY : this.textNode += n) : (this.state = S.OPEN_WAKA, this.startTagPosition = this.position);
              continue;
            case S.SCRIPT:
              "<" === n ? this.state = S.SCRIPT_ENDING : this.script += n;
              continue;
            case S.SCRIPT_ENDING:
              "/" === n ? this.state = S.CLOSE_TAG : (this.script += "<" + n, this.state = S.SCRIPT);
              continue;
            case S.OPEN_WAKA:
              if ("!" === n) this.state = S.SGML_DECL, this.sgmlDecl = "";
              else if (f(n));
              else if (y(l, n)) this.state = S.OPEN_TAG, this.tagName = n;
              else if ("/" === n) this.state = S.CLOSE_TAG, this.tagName = "";
              else if ("?" === n) this.state = S.PROC_INST, this.procInstName = this.procInstBody = "";
              else {
                if (N(this, "Unencoded <"), this.startTagPosition + 1 < this.position) {
                  var s = this.position - this.startTagPosition;
                  n = new Array(s).join(" ") + n
                }
                this.textNode += "<" + n, this.state = S.TEXT
              }
              continue;
            case S.SGML_DECL:
              "[CDATA[" === (this.sgmlDecl + n).toUpperCase() ? (x(this, "onopencdata"), this.state = S.CDATA, this.sgmlDecl = "", this.cdata = "") : this.sgmlDecl + n === "--" ? (this.state = S.COMMENT, this.comment = "", this.sgmlDecl = "") : "DOCTYPE" === (this.sgmlDecl + n).toUpperCase() ? (this.state = S.DOCTYPE, (this.doctype || this.sawRoot) && N(this, "Inappropriately located doctype declaration"), this.doctype = "", this.sgmlDecl = "") : ">" === n ? (x(this, "onsgmldeclaration", this.sgmlDecl), this.sgmlDecl = "", this.state = S.TEXT) : g(n) ? (this.state = S.SGML_DECL_QUOTED, this.sgmlDecl += n) : this.sgmlDecl += n;
              continue;
            case S.SGML_DECL_QUOTED:
              n === this.q && (this.state = S.SGML_DECL, this.q = ""), this.sgmlDecl += n;
              continue;
            case S.DOCTYPE:
              ">" === n ? (this.state = S.TEXT, x(this, "ondoctype", this.doctype), this.doctype = !0) : (this.doctype += n, "[" === n ? this.state = S.DOCTYPE_DTD : g(n) && (this.state = S.DOCTYPE_QUOTED, this.q = n));
              continue;
            case S.DOCTYPE_QUOTED:
              this.doctype += n, n === this.q && (this.q = "", this.state = S.DOCTYPE);
              continue;
            case S.DOCTYPE_DTD:
              this.doctype += n, "]" === n ? this.state = S.DOCTYPE : g(n) && (this.state = S.DOCTYPE_DTD_QUOTED, this.q = n);
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              this.doctype += n, n === this.q && (this.state = S.DOCTYPE_DTD, this.q = "");
              continue;
            case S.COMMENT:
              "-" === n ? this.state = S.COMMENT_ENDING : this.comment += n;
              continue;
            case S.COMMENT_ENDING:
              "-" === n ? (this.state = S.COMMENT_ENDED, this.comment = A(this.opt, this.comment), this.comment && x(this, "oncomment", this.comment), this.comment = "") : (this.comment += "-" + n, this.state = S.COMMENT);
              continue;
            case S.COMMENT_ENDED:
              ">" !== n ? (N(this, "Malformed comment"), this.comment += "--" + n, this.state = S.COMMENT) : this.state = S.TEXT;
              continue;
            case S.CDATA:
              "]" === n ? this.state = S.CDATA_ENDING : this.cdata += n;
              continue;
            case S.CDATA_ENDING:
              "]" === n ? this.state = S.CDATA_ENDING_2 : (this.cdata += "]" + n, this.state = S.CDATA);
              continue;
            case S.CDATA_ENDING_2:
              ">" === n ? (this.cdata && x(this, "oncdata", this.cdata), x(this, "onclosecdata"), this.cdata = "", this.state = S.TEXT) : "]" === n ? this.cdata += "]" : (this.cdata += "]]" + n, this.state = S.CDATA);
              continue;
            case S.PROC_INST:
              "?" === n ? this.state = S.PROC_INST_ENDING : f(n) ? this.state = S.PROC_INST_BODY : this.procInstName += n;
              continue;
            case S.PROC_INST_BODY:
              if (!this.procInstBody && f(n)) continue;
              "?" === n ? this.state = S.PROC_INST_ENDING : this.procInstBody += n;
              continue;
            case S.PROC_INST_ENDING:
              ">" === n ? (x(this, "onprocessinginstruction", {
                name: this.procInstName,
                body: this.procInstBody
              }), this.procInstName = this.procInstBody = "", this.state = S.TEXT) : (this.procInstBody += "?" + n, this.state = S.PROC_INST_BODY);
              continue;
            case S.OPEN_TAG:
              y(h, n) ? this.tagName += n : (P(this), ">" === n ? j(this) : "/" === n ? this.state = S.OPEN_TAG_SLASH : (f(n) || N(this, "Invalid character in tag name"), this.state = S.ATTRIB));
              continue;
            case S.OPEN_TAG_SLASH:
              ">" === n ? (j(this, !0), k(this)) : (N(this, "Forward-slash in opening tag not followed by >"), this.state = S.ATTRIB);
              continue;
            case S.ATTRIB:
              if (f(n)) continue;
              ">" === n ? j(this) : "/" === n ? this.state = S.OPEN_TAG_SLASH : y(l, n) ? (this.attribName = n, this.attribValue = "", this.state = S.ATTRIB_NAME) : N(this, "Invalid attribute name");
              continue;
            case S.ATTRIB_NAME:
              "=" === n ? this.state = S.ATTRIB_VALUE : ">" === n ? (N(this, "Attribute without value"), this.attribValue = this.attribName, D(this), j(this)) : f(n) ? this.state = S.ATTRIB_NAME_SAW_WHITE : y(h, n) ? this.attribName += n : N(this, "Invalid attribute name");
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if ("=" === n) this.state = S.ATTRIB_VALUE;
              else {
                if (f(n)) continue;
                N(this, "Attribute without value"), this.tag.attributes[this.attribName] = "", this.attribValue = "", x(this, "onattribute", {
                  name: this.attribName,
                  value: ""
                }), this.attribName = "", ">" === n ? j(this) : y(l, n) ? (this.attribName = n, this.state = S.ATTRIB_NAME) : (N(this, "Invalid attribute name"), this.state = S.ATTRIB)
              }
              continue;
            case S.ATTRIB_VALUE:
              if (f(n)) continue;
              g(n) ? (this.q = n, this.state = S.ATTRIB_VALUE_QUOTED) : (N(this, "Unquoted attribute value"), this.state = S.ATTRIB_VALUE_UNQUOTED, this.attribValue = n);
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (n !== this.q) {
                "&" === n ? this.state = S.ATTRIB_VALUE_ENTITY_Q : this.attribValue += n;
                continue
              }
              D(this), this.q = "", this.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              f(n) ? this.state = S.ATTRIB : ">" === n ? j(this) : "/" === n ? this.state = S.OPEN_TAG_SLASH : y(l, n) ? (N(this, "No whitespace between attributes"), this.attribName = n, this.attribValue = "", this.state = S.ATTRIB_NAME) : N(this, "Invalid attribute name");
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!m(n)) {
                "&" === n ? this.state = S.ATTRIB_VALUE_ENTITY_U : this.attribValue += n;
                continue
              }
              D(this), ">" === n ? j(this) : this.state = S.ATTRIB;
              continue;
            case S.CLOSE_TAG:
              if (this.tagName) ">" === n ? k(this) : y(h, n) ? this.tagName += n : this.script ? (this.script += "</" + this.tagName, this.tagName = "", this.state = S.SCRIPT) : (f(n) || N(this, "Invalid tagname in closing tag"), this.state = S.CLOSE_TAG_SAW_WHITE);
              else {
                if (f(n)) continue;
                b(l, n) ? this.script ? (this.script += "</" + n, this.state = S.SCRIPT) : N(this, "Invalid tagname in closing tag.") : this.tagName = n
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (f(n)) continue;
              ">" === n ? k(this) : N(this, "Invalid characters in closing tag");
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var o, u;
              switch (this.state) {
                case S.TEXT_ENTITY:
                  o = S.TEXT, u = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  o = S.ATTRIB_VALUE_QUOTED, u = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  o = S.ATTRIB_VALUE_UNQUOTED, u = "attribValue"
              }
              ";" === n ? (this[u] += L(this), this.entity = "", this.state = o) : y(this.entity.length ? p : d, n) ? this.entity += n : (N(this, "Invalid character in entity name"), this[u] += "&" + this.entity + n, this.entity = "", this.state = o);
              continue;
            default:
              throw new Error(this, "Unknown state: " + this.state)
          }
          this.position >= this.bufferCheckPosition && function(e) {
            for (var r = Math.max(t.MAX_BUFFER_LENGTH, 10), n = 0, a = 0, s = i.length; a < s; a++) {
              var o = e[i[a]].length;
              if (o > r) switch (i[a]) {
                case "textNode":
                  O(e);
                  break;
                case "cdata":
                  x(e, "oncdata", e.cdata), e.cdata = "";
                  break;
                case "script":
                  x(e, "onscript", e.script), e.script = "";
                  break;
                default:
                  R(e, "Max buffer length exceeded: " + i[a])
              }
              n = Math.max(n, o)
            }
            var u = t.MAX_BUFFER_LENGTH - n;
            e.bufferCheckPosition = u + e.position
          }(this);
          return this
        }
        /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
        ,
        resume: function() {
          return this.error = null, this
        },
        close: function() {
          return this.write(null)
        },
        flush: function() {
          var e;
          O(e = this), "" !== e.cdata && (x(e, "oncdata", e.cdata), e.cdata = ""), "" !== e.script && (x(e, "onscript", e.script), e.script = "")
        }
      };
      try {
        n = r(2).Stream
      } catch (e) {
        n = function() {}
      }
      var s = t.EVENTS.filter((function(e) {
        return "error" !== e && "end" !== e
      }));

      function o(e, t) {
        if (!(this instanceof o)) return new o(e, t);
        n.apply(this), this._parser = new a(e, t), this.writable = !0, this.readable = !0;
        var r = this;
        this._parser.onend = function() {
          r.emit("end")
        }, this._parser.onerror = function(e) {
          r.emit("error", e), r._parser.error = null
        }, this._decoder = null, s.forEach((function(e) {
          Object.defineProperty(r, "on" + e, {
            get: function() {
              return r._parser["on" + e]
            },
            set: function(t) {
              if (!t) return r.removeAllListeners(e), r._parser["on" + e] = t, t;
              r.on(e, t)
            },
            enumerable: !0,
            configurable: !1
          })
        }))
      }
      o.prototype = Object.create(n.prototype, {
        constructor: {
          value: o
        }
      }), o.prototype.write = function(t) {
        if ("function" == typeof e && "function" == typeof e.isBuffer && e.isBuffer(t)) {
          if (!this._decoder) {
            var n = r(33).StringDecoder;
            this._decoder = new n("utf8")
          }
          t = this._decoder.write(t)
        }
        return this._parser.write(t.toString()), this.emit("data", t), !0
      }, o.prototype.end = function(e) {
        return e && e.length && this.write(e), this._parser.end(), !0
      }, o.prototype.on = function(e, t) {
        var r = this;
        return r._parser["on" + e] || -1 === s.indexOf(e) || (r._parser["on" + e] = function() {
          var t = 1 === arguments.length ? [arguments[0]] : Array.apply(null, arguments);
          t.splice(0, 0, e), r.emit.apply(r, t)
        }), n.prototype.on.call(r, e, t)
      };
      var u = "http://www.w3.org/XML/1998/namespace",
        c = {
          xml: u,
          xmlns: "http://www.w3.org/2000/xmlns/"
        },
        l = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,
        h = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/,
        d = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/,
        p = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;

      function f(e) {
        return " " === e || "\n" === e || "\r" === e || "\t" === e
      }

      function g(e) {
        return '"' === e || "'" === e
      }

      function m(e) {
        return ">" === e || f(e)
      }

      function y(e, t) {
        return e.test(t)
      }

      function b(e, t) {
        return !y(e, t)
      }
      var _, v, w, S = 0;
      for (var T in t.STATE = {
        BEGIN: S++,
        BEGIN_WHITESPACE: S++,
        TEXT: S++,
        TEXT_ENTITY: S++,
        OPEN_WAKA: S++,
        SGML_DECL: S++,
        SGML_DECL_QUOTED: S++,
        DOCTYPE: S++,
        DOCTYPE_QUOTED: S++,
        DOCTYPE_DTD: S++,
        DOCTYPE_DTD_QUOTED: S++,
        COMMENT_STARTING: S++,
        COMMENT: S++,
        COMMENT_ENDING: S++,
        COMMENT_ENDED: S++,
        CDATA: S++,
        CDATA_ENDING: S++,
        CDATA_ENDING_2: S++,
        PROC_INST: S++,
        PROC_INST_BODY: S++,
        PROC_INST_ENDING: S++,
        OPEN_TAG: S++,
        OPEN_TAG_SLASH: S++,
        ATTRIB: S++,
        ATTRIB_NAME: S++,
        ATTRIB_NAME_SAW_WHITE: S++,
        ATTRIB_VALUE: S++,
        ATTRIB_VALUE_QUOTED: S++,
        ATTRIB_VALUE_CLOSED: S++,
        ATTRIB_VALUE_UNQUOTED: S++,
        ATTRIB_VALUE_ENTITY_Q: S++,
        ATTRIB_VALUE_ENTITY_U: S++,
        CLOSE_TAG: S++,
        CLOSE_TAG_SAW_WHITE: S++,
        SCRIPT: S++,
        SCRIPT_ENDING: S++
      }, t.XML_ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
      }, t.ENTITIES = {
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'",
        AElig: 198,
        Aacute: 193,
        Acirc: 194,
        Agrave: 192,
        Aring: 197,
        Atilde: 195,
        Auml: 196,
        Ccedil: 199,
        ETH: 208,
        Eacute: 201,
        Ecirc: 202,
        Egrave: 200,
        Euml: 203,
        Iacute: 205,
        Icirc: 206,
        Igrave: 204,
        Iuml: 207,
        Ntilde: 209,
        Oacute: 211,
        Ocirc: 212,
        Ograve: 210,
        Oslash: 216,
        Otilde: 213,
        Ouml: 214,
        THORN: 222,
        Uacute: 218,
        Ucirc: 219,
        Ugrave: 217,
        Uuml: 220,
        Yacute: 221,
        aacute: 225,
        acirc: 226,
        aelig: 230,
        agrave: 224,
        aring: 229,
        atilde: 227,
        auml: 228,
        ccedil: 231,
        eacute: 233,
        ecirc: 234,
        egrave: 232,
        eth: 240,
        euml: 235,
        iacute: 237,
        icirc: 238,
        igrave: 236,
        iuml: 239,
        ntilde: 241,
        oacute: 243,
        ocirc: 244,
        ograve: 242,
        oslash: 248,
        otilde: 245,
        ouml: 246,
        szlig: 223,
        thorn: 254,
        uacute: 250,
        ucirc: 251,
        ugrave: 249,
        uuml: 252,
        yacute: 253,
        yuml: 255,
        copy: 169,
        reg: 174,
        nbsp: 160,
        iexcl: 161,
        cent: 162,
        pound: 163,
        curren: 164,
        yen: 165,
        brvbar: 166,
        sect: 167,
        uml: 168,
        ordf: 170,
        laquo: 171,
        not: 172,
        shy: 173,
        macr: 175,
        deg: 176,
        plusmn: 177,
        sup1: 185,
        sup2: 178,
        sup3: 179,
        acute: 180,
        micro: 181,
        para: 182,
        middot: 183,
        cedil: 184,
        ordm: 186,
        raquo: 187,
        frac14: 188,
        frac12: 189,
        frac34: 190,
        iquest: 191,
        times: 215,
        divide: 247,
        OElig: 338,
        oelig: 339,
        Scaron: 352,
        scaron: 353,
        Yuml: 376,
        fnof: 402,
        circ: 710,
        tilde: 732,
        Alpha: 913,
        Beta: 914,
        Gamma: 915,
        Delta: 916,
        Epsilon: 917,
        Zeta: 918,
        Eta: 919,
        Theta: 920,
        Iota: 921,
        Kappa: 922,
        Lambda: 923,
        Mu: 924,
        Nu: 925,
        Xi: 926,
        Omicron: 927,
        Pi: 928,
        Rho: 929,
        Sigma: 931,
        Tau: 932,
        Upsilon: 933,
        Phi: 934,
        Chi: 935,
        Psi: 936,
        Omega: 937,
        alpha: 945,
        beta: 946,
        gamma: 947,
        delta: 948,
        epsilon: 949,
        zeta: 950,
        eta: 951,
        theta: 952,
        iota: 953,
        kappa: 954,
        lambda: 955,
        mu: 956,
        nu: 957,
        xi: 958,
        omicron: 959,
        pi: 960,
        rho: 961,
        sigmaf: 962,
        sigma: 963,
        tau: 964,
        upsilon: 965,
        phi: 966,
        chi: 967,
        psi: 968,
        omega: 969,
        thetasym: 977,
        upsih: 978,
        piv: 982,
        ensp: 8194,
        emsp: 8195,
        thinsp: 8201,
        zwnj: 8204,
        zwj: 8205,
        lrm: 8206,
        rlm: 8207,
        ndash: 8211,
        mdash: 8212,
        lsquo: 8216,
        rsquo: 8217,
        sbquo: 8218,
        ldquo: 8220,
        rdquo: 8221,
        bdquo: 8222,
        dagger: 8224,
        Dagger: 8225,
        bull: 8226,
        hellip: 8230,
        permil: 8240,
        prime: 8242,
        Prime: 8243,
        lsaquo: 8249,
        rsaquo: 8250,
        oline: 8254,
        frasl: 8260,
        euro: 8364,
        image: 8465,
        weierp: 8472,
        real: 8476,
        trade: 8482,
        alefsym: 8501,
        larr: 8592,
        uarr: 8593,
        rarr: 8594,
        darr: 8595,
        harr: 8596,
        crarr: 8629,
        lArr: 8656,
        uArr: 8657,
        rArr: 8658,
        dArr: 8659,
        hArr: 8660,
        forall: 8704,
        part: 8706,
        exist: 8707,
        empty: 8709,
        nabla: 8711,
        isin: 8712,
        notin: 8713,
        ni: 8715,
        prod: 8719,
        sum: 8721,
        minus: 8722,
        lowast: 8727,
        radic: 8730,
        prop: 8733,
        infin: 8734,
        ang: 8736,
        and: 8743,
        or: 8744,
        cap: 8745,
        cup: 8746,
        int: 8747,
        there4: 8756,
        sim: 8764,
        cong: 8773,
        asymp: 8776,
        ne: 8800,
        equiv: 8801,
        le: 8804,
        ge: 8805,
        sub: 8834,
        sup: 8835,
        nsub: 8836,
        sube: 8838,
        supe: 8839,
        oplus: 8853,
        otimes: 8855,
        perp: 8869,
        sdot: 8901,
        lceil: 8968,
        rceil: 8969,
        lfloor: 8970,
        rfloor: 8971,
        lang: 9001,
        rang: 9002,
        loz: 9674,
        spades: 9824,
        clubs: 9827,
        hearts: 9829,
        diams: 9830
      }, Object.keys(t.ENTITIES).forEach((function(e) {
        var r = t.ENTITIES[e],
          n = "number" == typeof r ? String.fromCharCode(r) : r;
        t.ENTITIES[e] = n
      })), t.STATE) t.STATE[t.STATE[T]] = T;

      function E(e, t, r) {
        e[t] && e[t](r)
      }

      function x(e, t, r) {
        e.textNode && O(e), E(e, t, r)
      }

      function O(e) {
        e.textNode = A(e.opt, e.textNode), e.textNode && E(e, "ontext", e.textNode), e.textNode = ""
      }

      function A(e, t) {
        return e.trim && (t = t.trim()), e.normalize && (t = t.replace(/\s+/g, " ")), t
      }

      function R(e, t) {
        return O(e), e.trackPosition && (t += "\nLine: " + e.line + "\nColumn: " + e.column + "\nChar: " + e.c), t = new Error(t), e.error = t, E(e, "onerror", t), e
      }

      function I(e) {
        return e.sawRoot && !e.closedRoot && N(e, "Unclosed root tag"), e.state !== S.BEGIN && e.state !== S.BEGIN_WHITESPACE && e.state !== S.TEXT && R(e, "Unexpected end"), O(e), e.c = "", e.closed = !0, E(e, "onend"), a.call(e, e.strict, e.opt), e
      }

      function N(e, t) {
        if ("object" != typeof e || !(e instanceof a)) throw new Error("bad call to strictFail");
        e.strict && R(e, t)
      }

      function P(e) {
        e.strict || (e.tagName = e.tagName[e.looseCase]());
        var t = e.tags[e.tags.length - 1] || e,
          r = e.tag = {
            name: e.tagName,
            attributes: {}
          };
        e.opt.xmlns && (r.ns = t.ns), e.attribList.length = 0, x(e, "onopentagstart", r)
      }

      function C(e, t) {
        var r = e.indexOf(":") < 0 ? ["", e] : e.split(":"),
          n = r[0],
          i = r[1];
        return t && "xmlns" === e && (n = "xmlns", i = ""), {
          prefix: n,
          local: i
        }
      }

      function D(e) {
        if (e.strict || (e.attribName = e.attribName[e.looseCase]()), -1 !== e.attribList.indexOf(e.attribName) || e.tag.attributes.hasOwnProperty(e.attribName)) e.attribName = e.attribValue = "";
        else {
          if (e.opt.xmlns) {
            var t = C(e.attribName, !0),
              r = t.prefix,
              n = t.local;
            if ("xmlns" === r)
              if ("xml" === n && e.attribValue !== u) N(e, "xml: prefix must be bound to " + u + "\nActual: " + e.attribValue);
              else if ("xmlns" === n && "http://www.w3.org/2000/xmlns/" !== e.attribValue) N(e, "xmlns: prefix must be bound to http://www.w3.org/2000/xmlns/\nActual: " + e.attribValue);
              else {
                var i = e.tag,
                  a = e.tags[e.tags.length - 1] || e;
                i.ns === a.ns && (i.ns = Object.create(a.ns)), i.ns[n] = e.attribValue
              }
            e.attribList.push([e.attribName, e.attribValue])
          } else e.tag.attributes[e.attribName] = e.attribValue, x(e, "onattribute", {
            name: e.attribName,
            value: e.attribValue
          });
          e.attribName = e.attribValue = ""
        }
      }

      function j(e, t) {
        if (e.opt.xmlns) {
          var r = e.tag,
            n = C(e.tagName);
          r.prefix = n.prefix, r.local = n.local, r.uri = r.ns[n.prefix] || "", r.prefix && !r.uri && (N(e, "Unbound namespace prefix: " + JSON.stringify(e.tagName)), r.uri = n.prefix);
          var i = e.tags[e.tags.length - 1] || e;
          r.ns && i.ns !== r.ns && Object.keys(r.ns).forEach((function(t) {
            x(e, "onopennamespace", {
              prefix: t,
              uri: r.ns[t]
            })
          }));
          for (var a = 0, s = e.attribList.length; a < s; a++) {
            var o = e.attribList[a],
              u = o[0],
              c = o[1],
              l = C(u, !0),
              h = l.prefix,
              d = l.local,
              p = "" === h ? "" : r.ns[h] || "",
              f = {
                name: u,
                value: c,
                prefix: h,
                local: d,
                uri: p
              };
            h && "xmlns" !== h && !p && (N(e, "Unbound namespace prefix: " + JSON.stringify(h)), f.uri = h), e.tag.attributes[u] = f, x(e, "onattribute", f)
          }
          e.attribList.length = 0
        }
        e.tag.isSelfClosing = !!t, e.sawRoot = !0, e.tags.push(e.tag), x(e, "onopentag", e.tag), t || (e.noscript || "script" !== e.tagName.toLowerCase() ? e.state = S.TEXT : e.state = S.SCRIPT, e.tag = null, e.tagName = ""), e.attribName = e.attribValue = "", e.attribList.length = 0
      }

      function k(e) {
        if (!e.tagName) return N(e, "Weird empty close tag."), e.textNode += "</>", void(e.state = S.TEXT);
        if (e.script) {
          if ("script" !== e.tagName) return e.script += "</" + e.tagName + ">", e.tagName = "", void(e.state = S.SCRIPT);
          x(e, "onscript", e.script), e.script = ""
        }
        var t = e.tags.length,
          r = e.tagName;
        e.strict || (r = r[e.looseCase]());
        for (var n = r; t--;) {
          if (e.tags[t].name === n) break;
          N(e, "Unexpected close tag")
        }
        if (t < 0) return N(e, "Unmatched closing tag: " + e.tagName), e.textNode += "</" + e.tagName + ">", void(e.state = S.TEXT);
        e.tagName = r;
        for (var i = e.tags.length; i-- > t;) {
          var a = e.tag = e.tags.pop();
          e.tagName = e.tag.name, x(e, "onclosetag", e.tagName);
          var s = {};
          for (var o in a.ns) s[o] = a.ns[o];
          var u = e.tags[e.tags.length - 1] || e;
          e.opt.xmlns && a.ns !== u.ns && Object.keys(a.ns).forEach((function(t) {
            var r = a.ns[t];
            x(e, "onclosenamespace", {
              prefix: t,
              uri: r
            })
          }))
        }
        0 === t && (e.closedRoot = !0), e.tagName = e.attribValue = e.attribName = "", e.attribList.length = 0, e.state = S.TEXT
      }

      function L(e) {
        var t, r = e.entity,
          n = r.toLowerCase(),
          i = "";
        return e.ENTITIES[r] ? e.ENTITIES[r] : e.ENTITIES[n] ? e.ENTITIES[n] : ("#" === (r = n).charAt(0) && ("x" === r.charAt(1) ? (r = r.slice(2), i = (t = parseInt(r, 16)).toString(16)) : (r = r.slice(1), i = (t = parseInt(r, 10)).toString(10))), r = r.replace(/^0+/, ""), isNaN(t) || i.toLowerCase() !== r ? (N(e, "Invalid character entity"), "&" + e.entity + ";") : String.fromCodePoint(t))
      }

      function M(e, t) {
        "<" === t ? (e.state = S.OPEN_WAKA, e.startTagPosition = e.position) : f(t) || (N(e, "Non-whitespace before first tag."), e.textNode = t, e.state = S.TEXT)
      }

      function F(e, t) {
        var r = "";
        return t < e.length && (r = e.charAt(t)), r
      }
      S = t.STATE, String.fromCodePoint || (_ = String.fromCharCode, v = Math.floor, w = function() {
        var e, t, r = 16384,
          n = [],
          i = -1,
          a = arguments.length;
        if (!a) return "";
        for (var s = ""; ++i < a;) {
          var o = Number(arguments[i]);
          if (!isFinite(o) || o < 0 || o > 1114111 || v(o) !== o) throw RangeError("Invalid code point: " + o);
          o <= 65535 ? n.push(o) : (e = 55296 + ((o -= 65536) >> 10), t = o % 1024 + 56320, n.push(e, t)), (i + 1 === a || n.length > r) && (s += _.apply(null, n), n.length = 0)
        }
        return s
      }, Object.defineProperty ? Object.defineProperty(String, "fromCodePoint", {
        value: w,
        configurable: !0,
        writable: !0
      }) : String.fromCodePoint = w)
    }(t)
  }).call(this, r(11).Buffer)
}, function(e, t, r) {
  "use strict";
  var n, i = this && this.__extends || (n = function(e, t) {
      return (n = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && function(e, t) {
          e.__proto__ = t
        } || function(e, t) {
          for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
        })(e, t)
    }, function(e, t) {
      function r() {
        this.constructor = e
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
    }),
    a = this && this.__importDefault || function(e) {
      return e && e.__esModule ? e : {
        default: e
      }
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  var s = a(r(133)),
    o = r(22),
    u = new Set(["input", "option", "optgroup", "select", "button", "datalist", "textarea"]),
    c = new Set(["p"]),
    l = {
      tr: new Set(["tr", "th", "td"]),
      th: new Set(["th"]),
      td: new Set(["thead", "th", "td"]),
      body: new Set(["head", "link", "script"]),
      li: new Set(["li"]),
      p: c,
      h1: c,
      h2: c,
      h3: c,
      h4: c,
      h5: c,
      h6: c,
      select: u,
      input: u,
      output: u,
      button: u,
      datalist: u,
      textarea: u,
      option: new Set(["option"]),
      optgroup: new Set(["optgroup", "option"]),
      dd: new Set(["dt", "dd"]),
      dt: new Set(["dt", "dd"]),
      address: c,
      article: c,
      aside: c,
      blockquote: c,
      details: c,
      div: c,
      dl: c,
      fieldset: c,
      figcaption: c,
      figure: c,
      footer: c,
      form: c,
      header: c,
      hr: c,
      main: c,
      nav: c,
      ol: c,
      pre: c,
      section: c,
      table: c,
      ul: c,
      rt: new Set(["rt", "rp"]),
      rp: new Set(["rt", "rp"]),
      tbody: new Set(["thead", "tbody"]),
      tfoot: new Set(["thead", "tbody"])
    },
    h = new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]),
    d = new Set(["math", "svg"]),
    p = new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignObject", "desc", "title"]),
    f = /\s|\//,
    g = function(e) {
      function t(r, n) {
        var i = e.call(this) || this;
        return i._tagname = "", i._attribname = "", i._attribvalue = "", i._attribs = null, i._stack = [], i._foreignContext = [], i.startIndex = 0, i.endIndex = null, i.parseChunk = t.prototype.write, i.done = t.prototype.end, i._options = n || {}, i._cbs = r || {}, i._tagname = "", i._attribname = "", i._attribvalue = "", i._attribs = null, i._stack = [], i._foreignContext = [], i.startIndex = 0, i.endIndex = null, i._lowerCaseTagNames = "lowerCaseTags" in i._options ? !!i._options.lowerCaseTags : !i._options.xmlMode, i._lowerCaseAttributeNames = "lowerCaseAttributeNames" in i._options ? !!i._options.lowerCaseAttributeNames : !i._options.xmlMode, i._tokenizer = new(i._options.Tokenizer || s.default)(i._options, i), i._cbs.onparserinit && i._cbs.onparserinit(i), i
      }
      return i(t, e), t.prototype._updatePosition = function(e) {
        null === this.endIndex ? this._tokenizer._sectionStart <= e ? this.startIndex = 0 : this.startIndex = this._tokenizer._sectionStart - e : this.startIndex = this.endIndex + 1, this.endIndex = this._tokenizer.getAbsoluteIndex()
      }, t.prototype.ontext = function(e) {
        this._updatePosition(1), this.endIndex--, this._cbs.ontext && this._cbs.ontext(e)
      }, t.prototype.onopentagname = function(e) {
        if (this._lowerCaseTagNames && (e = e.toLowerCase()), this._tagname = e, !this._options.xmlMode && Object.prototype.hasOwnProperty.call(l, e))
          for (var t = void 0; l[e].has(t = this._stack[this._stack.length - 1]); this.onclosetag(t));
        !this._options.xmlMode && h.has(e) || (this._stack.push(e), d.has(e) ? this._foreignContext.push(!0) : p.has(e) && this._foreignContext.push(!1)), this._cbs.onopentagname && this._cbs.onopentagname(e), this._cbs.onopentag && (this._attribs = {})
      }, t.prototype.onopentagend = function() {
        this._updatePosition(1), this._attribs && (this._cbs.onopentag && this._cbs.onopentag(this._tagname, this._attribs), this._attribs = null), !this._options.xmlMode && this._cbs.onclosetag && h.has(this._tagname) && this._cbs.onclosetag(this._tagname), this._tagname = ""
      }, t.prototype.onclosetag = function(e) {
        if (this._updatePosition(1), this._lowerCaseTagNames && (e = e.toLowerCase()), (d.has(e) || p.has(e)) && this._foreignContext.pop(), !this._stack.length || !this._options.xmlMode && h.has(e)) this._options.xmlMode || "br" !== e && "p" !== e || (this.onopentagname(e), this._closeCurrentTag());
        else {
          var t = this._stack.lastIndexOf(e);
          if (-1 !== t)
            if (this._cbs.onclosetag)
              for (t = this._stack.length - t; t--;) this._cbs.onclosetag(this._stack.pop());
            else this._stack.length = t;
          else "p" !== e || this._options.xmlMode || (this.onopentagname(e), this._closeCurrentTag())
        }
      }, t.prototype.onselfclosingtag = function() {
        this._options.xmlMode || this._options.recognizeSelfClosing || this._foreignContext[this._foreignContext.length - 1] ? this._closeCurrentTag() : this.onopentagend()
      }, t.prototype._closeCurrentTag = function() {
        var e = this._tagname;
        this.onopentagend(), this._stack[this._stack.length - 1] === e && (this._cbs.onclosetag && this._cbs.onclosetag(e), this._stack.pop())
      }, t.prototype.onattribname = function(e) {
        this._lowerCaseAttributeNames && (e = e.toLowerCase()), this._attribname = e
      }, t.prototype.onattribdata = function(e) {
        this._attribvalue += e
      }, t.prototype.onattribend = function() {
        this._cbs.onattribute && this._cbs.onattribute(this._attribname, this._attribvalue), this._attribs && !Object.prototype.hasOwnProperty.call(this._attribs, this._attribname) && (this._attribs[this._attribname] = this._attribvalue), this._attribname = "", this._attribvalue = ""
      }, t.prototype._getInstructionName = function(e) {
        var t = e.search(f),
          r = t < 0 ? e : e.substr(0, t);
        return this._lowerCaseTagNames && (r = r.toLowerCase()), r
      }, t.prototype.ondeclaration = function(e) {
        if (this._cbs.onprocessinginstruction) {
          var t = this._getInstructionName(e);
          this._cbs.onprocessinginstruction("!" + t, "!" + e)
        }
      }, t.prototype.onprocessinginstruction = function(e) {
        if (this._cbs.onprocessinginstruction) {
          var t = this._getInstructionName(e);
          this._cbs.onprocessinginstruction("?" + t, "?" + e)
        }
      }, t.prototype.oncomment = function(e) {
        this._updatePosition(4), this._cbs.oncomment && this._cbs.oncomment(e), this._cbs.oncommentend && this._cbs.oncommentend()
      }, t.prototype.oncdata = function(e) {
        this._updatePosition(1), this._options.xmlMode || this._options.recognizeCDATA ? (this._cbs.oncdatastart && this._cbs.oncdatastart(), this._cbs.ontext && this._cbs.ontext(e), this._cbs.oncdataend && this._cbs.oncdataend()) : this.oncomment("[CDATA[" + e + "]]")
      }, t.prototype.onerror = function(e) {
        this._cbs.onerror && this._cbs.onerror(e)
      }, t.prototype.onend = function() {
        if (this._cbs.onclosetag)
          for (var e = this._stack.length; e > 0; this._cbs.onclosetag(this._stack[--e]));
        this._cbs.onend && this._cbs.onend()
      }, t.prototype.reset = function() {
        this._cbs.onreset && this._cbs.onreset(), this._tokenizer.reset(), this._tagname = "", this._attribname = "", this._attribs = null, this._stack = [], this._cbs.onparserinit && this._cbs.onparserinit(this)
      }, t.prototype.parseComplete = function(e) {
        this.reset(), this.end(e)
      }, t.prototype.write = function(e) {
        this._tokenizer.write(e)
      }, t.prototype.end = function(e) {
        this._tokenizer.end(e)
      }, t.prototype.pause = function() {
        this._tokenizer.pause()
      }, t.prototype.resume = function() {
        this._tokenizer.resume()
      }, t
    }(o.EventEmitter);
  t.Parser = g
}, function(e, t, r) {
  "use strict";
  var n = this && this.__importDefault || function(e) {
    return e && e.__esModule ? e : {
      default: e
    }
  };
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  var i = n(r(77)),
    a = n(r(56)),
    s = n(r(78)),
    o = n(r(57));

  function u(e) {
    return " " === e || "\n" === e || "\t" === e || "\f" === e || "\r" === e
  }

  function c(e, t, r) {
    var n = e.toLowerCase();
    return e === n ? function(e, i) {
      i === n ? e._state = t : (e._state = r, e._index--)
    } : function(i, a) {
      a === n || a === e ? i._state = t : (i._state = r, i._index--)
    }
  }

  function l(e, t) {
    var r = e.toLowerCase();
    return function(n, i) {
      i === r || i === e ? n._state = t : (n._state = 3, n._index--)
    }
  }
  var h = c("C", 23, 16),
    d = c("D", 24, 16),
    p = c("A", 25, 16),
    f = c("T", 26, 16),
    g = c("A", 27, 16),
    m = l("R", 34),
    y = l("I", 35),
    b = l("P", 36),
    _ = l("T", 37),
    v = c("R", 39, 1),
    w = c("I", 40, 1),
    S = c("P", 41, 1),
    T = c("T", 42, 1),
    E = l("Y", 44),
    x = l("L", 45),
    O = l("E", 46),
    A = c("Y", 48, 1),
    R = c("L", 49, 1),
    I = c("E", 50, 1),
    N = c("#", 52, 53),
    P = c("X", 55, 54),
    C = function() {
      function e(e, t) {
        this._state = 1, this._buffer = "", this._sectionStart = 0, this._index = 0, this._bufferOffset = 0, this._baseState = 1, this._special = 1, this._running = !0, this._ended = !1, this._cbs = t, this._xmlMode = !(!e || !e.xmlMode), this._decodeEntities = !(!e || !e.decodeEntities)
      }
      return e.prototype.reset = function() {
        this._state = 1, this._buffer = "", this._sectionStart = 0, this._index = 0, this._bufferOffset = 0, this._baseState = 1, this._special = 1, this._running = !0, this._ended = !1
      }, e.prototype._stateText = function(e) {
        "<" === e ? (this._index > this._sectionStart && this._cbs.ontext(this._getSection()), this._state = 2, this._sectionStart = this._index) : this._decodeEntities && 1 === this._special && "&" === e && (this._index > this._sectionStart && this._cbs.ontext(this._getSection()), this._baseState = 1, this._state = 51, this._sectionStart = this._index)
      }, e.prototype._stateBeforeTagName = function(e) {
        "/" === e ? this._state = 5 : "<" === e ? (this._cbs.ontext(this._getSection()), this._sectionStart = this._index) : ">" === e || 1 !== this._special || u(e) ? this._state = 1 : "!" === e ? (this._state = 15, this._sectionStart = this._index + 1) : "?" === e ? (this._state = 17, this._sectionStart = this._index + 1) : (this._state = this._xmlMode || "s" !== e && "S" !== e ? 3 : 31, this._sectionStart = this._index)
      }, e.prototype._stateInTagName = function(e) {
        ("/" === e || ">" === e || u(e)) && (this._emitToken("onopentagname"), this._state = 8, this._index--)
      }, e.prototype._stateBeforeClosingTagName = function(e) {
        u(e) || (">" === e ? this._state = 1 : 1 !== this._special ? "s" === e || "S" === e ? this._state = 32 : (this._state = 1, this._index--) : (this._state = 6, this._sectionStart = this._index))
      }, e.prototype._stateInClosingTagName = function(e) {
        (">" === e || u(e)) && (this._emitToken("onclosetag"), this._state = 7, this._index--)
      }, e.prototype._stateAfterClosingTagName = function(e) {
        ">" === e && (this._state = 1, this._sectionStart = this._index + 1)
      }, e.prototype._stateBeforeAttributeName = function(e) {
        ">" === e ? (this._cbs.onopentagend(), this._state = 1, this._sectionStart = this._index + 1) : "/" === e ? this._state = 4 : u(e) || (this._state = 9, this._sectionStart = this._index)
      }, e.prototype._stateInSelfClosingTag = function(e) {
        ">" === e ? (this._cbs.onselfclosingtag(), this._state = 1, this._sectionStart = this._index + 1) : u(e) || (this._state = 8, this._index--)
      }, e.prototype._stateInAttributeName = function(e) {
        ("=" === e || "/" === e || ">" === e || u(e)) && (this._cbs.onattribname(this._getSection()), this._sectionStart = -1, this._state = 10, this._index--)
      }, e.prototype._stateAfterAttributeName = function(e) {
        "=" === e ? this._state = 11 : "/" === e || ">" === e ? (this._cbs.onattribend(), this._state = 8, this._index--) : u(e) || (this._cbs.onattribend(), this._state = 9, this._sectionStart = this._index)
      }, e.prototype._stateBeforeAttributeValue = function(e) {
        '"' === e ? (this._state = 12, this._sectionStart = this._index + 1) : "'" === e ? (this._state = 13, this._sectionStart = this._index + 1) : u(e) || (this._state = 14, this._sectionStart = this._index, this._index--)
      }, e.prototype._stateInAttributeValueDoubleQuotes = function(e) {
        '"' === e ? (this._emitToken("onattribdata"), this._cbs.onattribend(), this._state = 8) : this._decodeEntities && "&" === e && (this._emitToken("onattribdata"), this._baseState = this._state, this._state = 51, this._sectionStart = this._index)
      }, e.prototype._stateInAttributeValueSingleQuotes = function(e) {
        "'" === e ? (this._emitToken("onattribdata"), this._cbs.onattribend(), this._state = 8) : this._decodeEntities && "&" === e && (this._emitToken("onattribdata"), this._baseState = this._state, this._state = 51, this._sectionStart = this._index)
      }, e.prototype._stateInAttributeValueNoQuotes = function(e) {
        u(e) || ">" === e ? (this._emitToken("onattribdata"), this._cbs.onattribend(), this._state = 8, this._index--) : this._decodeEntities && "&" === e && (this._emitToken("onattribdata"), this._baseState = this._state, this._state = 51, this._sectionStart = this._index)
      }, e.prototype._stateBeforeDeclaration = function(e) {
        this._state = "[" === e ? 22 : "-" === e ? 18 : 16
      }, e.prototype._stateInDeclaration = function(e) {
        ">" === e && (this._cbs.ondeclaration(this._getSection()), this._state = 1, this._sectionStart = this._index + 1)
      }, e.prototype._stateInProcessingInstruction = function(e) {
        ">" === e && (this._cbs.onprocessinginstruction(this._getSection()), this._state = 1, this._sectionStart = this._index + 1)
      }, e.prototype._stateBeforeComment = function(e) {
        "-" === e ? (this._state = 19, this._sectionStart = this._index + 1) : this._state = 16
      }, e.prototype._stateInComment = function(e) {
        "-" === e && (this._state = 20)
      }, e.prototype._stateAfterComment1 = function(e) {
        this._state = "-" === e ? 21 : 19
      }, e.prototype._stateAfterComment2 = function(e) {
        ">" === e ? (this._cbs.oncomment(this._buffer.substring(this._sectionStart, this._index - 2)), this._state = 1, this._sectionStart = this._index + 1) : "-" !== e && (this._state = 19)
      }, e.prototype._stateBeforeCdata6 = function(e) {
        "[" === e ? (this._state = 28, this._sectionStart = this._index + 1) : (this._state = 16, this._index--)
      }, e.prototype._stateInCdata = function(e) {
        "]" === e && (this._state = 29)
      }, e.prototype._stateAfterCdata1 = function(e) {
        this._state = "]" === e ? 30 : 28
      }, e.prototype._stateAfterCdata2 = function(e) {
        ">" === e ? (this._cbs.oncdata(this._buffer.substring(this._sectionStart, this._index - 2)), this._state = 1, this._sectionStart = this._index + 1) : "]" !== e && (this._state = 28)
      }, e.prototype._stateBeforeSpecial = function(e) {
        "c" === e || "C" === e ? this._state = 33 : "t" === e || "T" === e ? this._state = 43 : (this._state = 3, this._index--)
      }, e.prototype._stateBeforeSpecialEnd = function(e) {
        2 !== this._special || "c" !== e && "C" !== e ? 3 !== this._special || "t" !== e && "T" !== e ? this._state = 1 : this._state = 47 : this._state = 38
      }, e.prototype._stateBeforeScript5 = function(e) {
        ("/" === e || ">" === e || u(e)) && (this._special = 2), this._state = 3, this._index--
      }, e.prototype._stateAfterScript5 = function(e) {
        ">" === e || u(e) ? (this._special = 1, this._state = 6, this._sectionStart = this._index - 6, this._index--) : this._state = 1
      }, e.prototype._stateBeforeStyle4 = function(e) {
        ("/" === e || ">" === e || u(e)) && (this._special = 3), this._state = 3, this._index--
      }, e.prototype._stateAfterStyle4 = function(e) {
        ">" === e || u(e) ? (this._special = 1, this._state = 6, this._sectionStart = this._index - 5, this._index--) : this._state = 1
      }, e.prototype._parseNamedEntityStrict = function() {
        if (this._sectionStart + 1 < this._index) {
          var e = this._buffer.substring(this._sectionStart + 1, this._index),
            t = this._xmlMode ? o.default : a.default;
          Object.prototype.hasOwnProperty.call(t, e) && (this._emitPartial(t[e]), this._sectionStart = this._index + 1)
        }
      }, e.prototype._parseLegacyEntity = function() {
        var e = this._sectionStart + 1,
          t = this._index - e;
        for (t > 6 && (t = 6); t >= 2;) {
          var r = this._buffer.substr(e, t);
          if (Object.prototype.hasOwnProperty.call(s.default, r)) return this._emitPartial(s.default[r]), void(this._sectionStart += t + 1);
          t--
        }
      }, e.prototype._stateInNamedEntity = function(e) {
        ";" === e ? (this._parseNamedEntityStrict(), this._sectionStart + 1 < this._index && !this._xmlMode && this._parseLegacyEntity(), this._state = this._baseState) : (e < "a" || e > "z") && (e < "A" || e > "Z") && (e < "0" || e > "9") && (this._xmlMode || this._sectionStart + 1 === this._index || (1 !== this._baseState ? "=" !== e && this._parseNamedEntityStrict() : this._parseLegacyEntity()), this._state = this._baseState, this._index--)
      }, e.prototype._decodeNumericEntity = function(e, t) {
        var r = this._sectionStart + e;
        if (r !== this._index) {
          var n = this._buffer.substring(r, this._index),
            a = parseInt(n, t);
          this._emitPartial(i.default(a)), this._sectionStart = this._index
        } else this._sectionStart--;
        this._state = this._baseState
      }, e.prototype._stateInNumericEntity = function(e) {
        ";" === e ? (this._decodeNumericEntity(2, 10), this._sectionStart++) : (e < "0" || e > "9") && (this._xmlMode ? this._state = this._baseState : this._decodeNumericEntity(2, 10), this._index--)
      }, e.prototype._stateInHexEntity = function(e) {
        ";" === e ? (this._decodeNumericEntity(3, 16), this._sectionStart++) : (e < "a" || e > "f") && (e < "A" || e > "F") && (e < "0" || e > "9") && (this._xmlMode ? this._state = this._baseState : this._decodeNumericEntity(3, 16), this._index--)
      }, e.prototype._cleanup = function() {
        this._sectionStart < 0 ? (this._buffer = "", this._bufferOffset += this._index, this._index = 0) : this._running && (1 === this._state ? (this._sectionStart !== this._index && this._cbs.ontext(this._buffer.substr(this._sectionStart)), this._buffer = "", this._bufferOffset += this._index, this._index = 0) : this._sectionStart === this._index ? (this._buffer = "", this._bufferOffset += this._index, this._index = 0) : (this._buffer = this._buffer.substr(this._sectionStart), this._index -= this._sectionStart, this._bufferOffset += this._sectionStart), this._sectionStart = 0)
      }, e.prototype.write = function(e) {
        this._ended && this._cbs.onerror(Error(".write() after done!")), this._buffer += e, this._parse()
      }, e.prototype._parse = function() {
        for (; this._index < this._buffer.length && this._running;) {
          var e = this._buffer.charAt(this._index);
          1 === this._state ? this._stateText(e) : 12 === this._state ? this._stateInAttributeValueDoubleQuotes(e) : 9 === this._state ? this._stateInAttributeName(e) : 19 === this._state ? this._stateInComment(e) : 8 === this._state ? this._stateBeforeAttributeName(e) : 3 === this._state ? this._stateInTagName(e) : 6 === this._state ? this._stateInClosingTagName(e) : 2 === this._state ? this._stateBeforeTagName(e) : 10 === this._state ? this._stateAfterAttributeName(e) : 13 === this._state ? this._stateInAttributeValueSingleQuotes(e) : 11 === this._state ? this._stateBeforeAttributeValue(e) : 5 === this._state ? this._stateBeforeClosingTagName(e) : 7 === this._state ? this._stateAfterClosingTagName(e) : 31 === this._state ? this._stateBeforeSpecial(e) : 20 === this._state ? this._stateAfterComment1(e) : 14 === this._state ? this._stateInAttributeValueNoQuotes(e) : 4 === this._state ? this._stateInSelfClosingTag(e) : 16 === this._state ? this._stateInDeclaration(e) : 15 === this._state ? this._stateBeforeDeclaration(e) : 21 === this._state ? this._stateAfterComment2(e) : 18 === this._state ? this._stateBeforeComment(e) : 32 === this._state ? this._stateBeforeSpecialEnd(e) : 38 === this._state ? v(this, e) : 39 === this._state ? w(this, e) : 40 === this._state ? S(this, e) : 33 === this._state ? m(this, e) : 34 === this._state ? y(this, e) : 35 === this._state ? b(this, e) : 36 === this._state ? _(this, e) : 37 === this._state ? this._stateBeforeScript5(e) : 41 === this._state ? T(this, e) : 42 === this._state ? this._stateAfterScript5(e) : 43 === this._state ? E(this, e) : 28 === this._state ? this._stateInCdata(e) : 44 === this._state ? x(this, e) : 45 === this._state ? O(this, e) : 46 === this._state ? this._stateBeforeStyle4(e) : 47 === this._state ? A(this, e) : 48 === this._state ? R(this, e) : 49 === this._state ? I(this, e) : 50 === this._state ? this._stateAfterStyle4(e) : 17 === this._state ? this._stateInProcessingInstruction(e) : 53 === this._state ? this._stateInNamedEntity(e) : 22 === this._state ? h(this, e) : 51 === this._state ? N(this, e) : 23 === this._state ? d(this, e) : 24 === this._state ? p(this, e) : 29 === this._state ? this._stateAfterCdata1(e) : 30 === this._state ? this._stateAfterCdata2(e) : 25 === this._state ? f(this, e) : 26 === this._state ? g(this, e) : 27 === this._state ? this._stateBeforeCdata6(e) : 55 === this._state ? this._stateInHexEntity(e) : 54 === this._state ? this._stateInNumericEntity(e) : 52 === this._state ? P(this, e) : this._cbs.onerror(Error("unknown _state"), this._state), this._index++
        }
        this._cleanup()
      }, e.prototype.pause = function() {
        this._running = !1
      }, e.prototype.resume = function() {
        this._running = !0, this._index < this._buffer.length && this._parse(), this._ended && this._finish()
      }, e.prototype.end = function(e) {
        this._ended && this._cbs.onerror(Error(".end() after done!")), e && this.write(e), this._ended = !0, this._running && this._finish()
      }, e.prototype._finish = function() {
        this._sectionStart < this._index && this._handleTrailingData(), this._cbs.onend()
      }, e.prototype._handleTrailingData = function() {
        var e = this._buffer.substr(this._sectionStart);
        28 === this._state || 29 === this._state || 30 === this._state ? this._cbs.oncdata(e) : 19 === this._state || 20 === this._state || 21 === this._state ? this._cbs.oncomment(e) : 53 !== this._state || this._xmlMode ? 54 !== this._state || this._xmlMode ? 55 !== this._state || this._xmlMode ? 3 !== this._state && 8 !== this._state && 11 !== this._state && 10 !== this._state && 9 !== this._state && 13 !== this._state && 12 !== this._state && 14 !== this._state && 6 !== this._state && this._cbs.ontext(e) : (this._decodeNumericEntity(3, 16), this._sectionStart < this._index && (this._state = this._baseState, this._handleTrailingData())) : (this._decodeNumericEntity(2, 10), this._sectionStart < this._index && (this._state = this._baseState, this._handleTrailingData())) : (this._parseLegacyEntity(), this._sectionStart < this._index && (this._state = this._baseState, this._handleTrailingData()))
      }, e.prototype.getAbsoluteIndex = function() {
        return this._bufferOffset + this._index
      }, e.prototype._getSection = function() {
        return this._buffer.substring(this._sectionStart, this._index)
      }, e.prototype._emitToken = function(e) {
        this._cbs[e](this._getSection()), this._sectionStart = -1
      }, e.prototype._emitPartial = function(e) {
        1 !== this._baseState ? this._cbs.onattribdata(e) : this._cbs.ontext(e)
      }, e
    }();
  t.default = C
}, function(e, t, r) {
  "use strict";
  var n, i = this && this.__extends || (n = function(e, t) {
      return (n = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && function(e, t) {
          e.__proto__ = t
        } || function(e, t) {
          for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r])
        })(e, t)
    }, function(e, t) {
      function r() {
        this.constructor = e
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
    }),
    a = this && this.__assign || function() {
      return (a = Object.assign || function(e) {
        for (var t, r = 1, n = arguments.length; r < n; r++)
          for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
        return e
      }).apply(this, arguments)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.cloneNode = t.Element = t.NodeWithChildren = t.ProcessingInstruction = t.Comment = t.Text = t.DataNode = t.Node = void 0;
  var s = new Map([
      ["tag", 1],
      ["script", 1],
      ["style", 1],
      ["directive", 1],
      ["text", 3],
      ["cdata", 4],
      ["comment", 8]
    ]),
    o = function() {
      function e(e) {
        this.type = e, this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null
      }
      return Object.defineProperty(e.prototype, "nodeType", {
        get: function() {
          var e;
          return null !== (e = s.get(this.type)) && void 0 !== e ? e : 1
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "parentNode", {
        get: function() {
          return this.parent
        },
        set: function(e) {
          this.parent = e
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "previousSibling", {
        get: function() {
          return this.prev
        },
        set: function(e) {
          this.prev = e
        },
        enumerable: !1,
        configurable: !0
      }), Object.defineProperty(e.prototype, "nextSibling", {
        get: function() {
          return this.next
        },
        set: function(e) {
          this.next = e
        },
        enumerable: !1,
        configurable: !0
      }), e.prototype.cloneNode = function(e) {
        return void 0 === e && (e = !1), f(this, e)
      }, e
    }();
  t.Node = o;
  var u = function(e) {
    function t(t, r) {
      var n = e.call(this, t) || this;
      return n.data = r, n
    }
    return i(t, e), Object.defineProperty(t.prototype, "nodeValue", {
      get: function() {
        return this.data
      },
      set: function(e) {
        this.data = e
      },
      enumerable: !1,
      configurable: !0
    }), t
  }(o);
  t.DataNode = u;
  var c = function(e) {
    function t(t) {
      return e.call(this, "text", t) || this
    }
    return i(t, e), t
  }(u);
  t.Text = c;
  var l = function(e) {
    function t(t) {
      return e.call(this, "comment", t) || this
    }
    return i(t, e), t
  }(u);
  t.Comment = l;
  var h = function(e) {
    function t(t, r) {
      var n = e.call(this, "directive", r) || this;
      return n.name = t, n
    }
    return i(t, e), t
  }(u);
  t.ProcessingInstruction = h;
  var d = function(e) {
    function t(t, r) {
      var n = e.call(this, t) || this;
      return n.children = r, n
    }
    return i(t, e), Object.defineProperty(t.prototype, "firstChild", {
      get: function() {
        var e;
        return null !== (e = this.children[0]) && void 0 !== e ? e : null
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      get: function() {
        return this.children
      },
      set: function(e) {
        this.children = e
      },
      enumerable: !1,
      configurable: !0
    }), t
  }(o);
  t.NodeWithChildren = d;
  var p = function(e) {
    function t(t, r, n) {
      void 0 === n && (n = []);
      var i = e.call(this, "script" === t ? "script" : "style" === t ? "style" : "tag", n) || this;
      return i.name = t, i.attribs = r, i.attribs = r, i
    }
    return i(t, e), Object.defineProperty(t.prototype, "tagName", {
      get: function() {
        return this.name
      },
      set: function(e) {
        this.name = e
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var e = this;
        return Object.keys(this.attribs).map((function(t) {
          return {
            name: t,
            value: e.attribs[t]
          }
        }))
      },
      enumerable: !1,
      configurable: !0
    }), t
  }(d);

  function f(e, t) {
    switch (void 0 === t && (t = !1), e.type) {
      case "text":
        return new c(e.data);
      case "directive":
        var r = e;
        return new h(r.name, r.data);
      case "comment":
        return new l(e.data);
      case "tag":
      case "script":
      case "style":
        var n = e,
          i = t ? g(n.children) : [],
          s = new p(n.name, a({}, n.attribs), i);
        return i.forEach((function(e) {
          return e.parent = s
        })), s;
      case "cdata":
        i = t ? g(e.children) : [];
        var o = new d("cdata", i);
        return i.forEach((function(e) {
          return e.parent = o
        })), o;
      case "doctype":
        throw new Error("Not implemented yet: ElementType.Doctype case")
    }
  }

  function g(e) {
    for (var t = e.map((function(e) {
      return f(e, !0)
    })), r = 1; r < t.length; r++) t[r].prev = t[r - 1], t[r - 1].next = t[r];
    return t
  }
  t.Element = p, t.cloneNode = f
}, function(e, t, r) {
  "use strict";
  var n, i = this && this.__extends || (n = function(e, t) {
      return (n = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && function(e, t) {
          e.__proto__ = t
        } || function(e, t) {
          for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
        })(e, t)
    }, function(e, t) {
      function r() {
        this.constructor = e
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
    }),
    a = this && this.__importDefault || function(e) {
      return e && e.__esModule ? e : {
        default: e
      }
    },
    s = this && this.__importStar || function(e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (null != e)
        for (var r in e) Object.hasOwnProperty.call(e, r) && (t[r] = e[r]);
      return t.default = e, t
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  var o = a(r(58)),
    u = s(r(60)),
    c = r(132),
    l = function(e) {
      function t(t, r) {
        return "object" == typeof t && null !== t && (r = t = void 0), e.call(this, t, r) || this
      }
      return i(t, e), t.prototype.onend = function() {
        var e = {},
          t = d(m, this.dom);
        if (t)
          if ("feed" === t.name) {
            var r = t.children;
            e.type = "atom", g(e, "id", "id", r), g(e, "title", "title", r);
            var n = f("href", d("link", r));
            n && (e.link = n), g(e, "description", "subtitle", r), (i = p("updated", r)) && (e.updated = new Date(i)), g(e, "author", "email", r, !0), e.items = h("entry", r).map((function(e) {
              var t = {},
                r = e.children;
              g(t, "id", "id", r), g(t, "title", "title", r);
              var n = f("href", d("link", r));
              n && (t.link = n);
              var i = p("summary", r) || p("content", r);
              i && (t.description = i);
              var a = p("updated", r);
              return a && (t.pubDate = new Date(a)), t
            }))
          } else {
            var i;
            r = d("channel", t.children).children;
            e.type = t.name.substr(0, 3), e.id = "", g(e, "title", "title", r), g(e, "link", "link", r), g(e, "description", "description", r), (i = p("lastBuildDate", r)) && (e.updated = new Date(i)), g(e, "author", "managingEditor", r, !0), e.items = h("item", t.children).map((function(e) {
              var t = {},
                r = e.children;
              g(t, "id", "guid", r), g(t, "title", "title", r), g(t, "link", "link", r), g(t, "description", "description", r);
              var n = p("pubDate", r);
              return n && (t.pubDate = new Date(n)), t
            }))
          } this.feed = e, this.handleCallback(t ? null : Error("couldn't find root of feed"))
      }, t
    }(o.default);

  function h(e, t) {
    return u.getElementsByTagName(e, t, !0)
  }

  function d(e, t) {
    return u.getElementsByTagName(e, t, !0, 1)[0]
  }

  function p(e, t, r) {
    return void 0 === r && (r = !1), u.getText(u.getElementsByTagName(e, t, r, 1)).trim()
  }

  function f(e, t) {
    return t ? t.attribs[e] : null
  }

  function g(e, t, r, n, i) {
    void 0 === i && (i = !1);
    var a = p(r, n, i);
    a && (e[t] = a)
  }

  function m(e) {
    return "rss" === e || "feed" === e || "rdf:RDF" === e
  }
  t.FeedHandler = l;
  var y = {
    xmlMode: !0
  };
  t.parseFeed = function(e, t) {
    void 0 === t && (t = y);
    var r = new l(t);
    return new c.Parser(r, t).end(e), r.feed
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__importDefault || function(e) {
    return e && e.__esModule ? e : {
      default: e
    }
  };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.decodeHTML = t.decodeHTMLStrict = t.decodeXML = void 0;
  var i = n(r(56)),
    a = n(r(78)),
    s = n(r(57)),
    o = n(r(77));

  function u(e) {
    var t = Object.keys(e).join("|"),
      r = l(e),
      n = new RegExp("&(?:" + (t += "|#[xX][\\da-fA-F]+|#\\d+") + ");", "g");
    return function(e) {
      return String(e).replace(n, r)
    }
  }
  t.decodeXML = u(s.default), t.decodeHTMLStrict = u(i.default);
  var c = function(e, t) {
    return e < t ? 1 : -1
  };

  function l(e) {
    return function(t) {
      if ("#" === t.charAt(1)) {
        var r = t.charAt(2);
        return "X" === r || "x" === r ? o.default(parseInt(t.substr(3), 16)) : o.default(parseInt(t.substr(2), 10))
      }
      return e[t.slice(1, -1)]
    }
  }
  t.decodeHTML = function() {
    for (var e = Object.keys(a.default).sort(c), t = Object.keys(i.default).sort(c), r = 0, n = 0; r < t.length; r++) e[n] === t[r] ? (t[r] += ";?", n++) : t[r] += ";";
    var s = new RegExp("&(?:" + t.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g"),
      o = l(i.default);

    function u(e) {
      return ";" !== e.substr(-1) && (e += ";"), o(e)
    }
    return function(e) {
      return String(e).replace(s, u)
    }
  }()
}, function(e, t, r) {
  "use strict";
  var n = this && this.__importDefault || function(e) {
    return e && e.__esModule ? e : {
      default: e
    }
  };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.escape = t.encodeHTML = t.encodeXML = void 0;
  var i = u(n(r(57)).default),
    a = c(i);
  t.encodeXML = d(i, a);
  var s = u(n(r(56)).default),
    o = c(s);

  function u(e) {
    return Object.keys(e).sort().reduce((function(t, r) {
      return t[e[r]] = "&" + r + ";", t
    }), {})
  }

  function c(e) {
    for (var t = [], r = [], n = 0, i = Object.keys(e); n < i.length; n++) {
      var a = i[n];
      1 === a.length ? t.push("\\" + a) : r.push(a)
    }
    t.sort();
    for (var s = 0; s < t.length - 1; s++) {
      for (var o = s; o < t.length - 1 && t[o].charCodeAt(1) + 1 === t[o + 1].charCodeAt(1);) o += 1;
      var u = 1 + o - s;
      u < 3 || t.splice(s, u, t[s] + "-" + t[o])
    }
    return r.unshift("[" + t.join("") + "]"), new RegExp(r.join("|"), "g")
  }
  t.encodeHTML = d(s, o);
  var l = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;

  function h(e) {
    return "&#x" + e.codePointAt(0).toString(16).toUpperCase() + ";"
  }

  function d(e, t) {
    return function(r) {
      return r.replace(t, (function(t) {
        return e[t]
      })).replace(l, h)
    }
  }
  var p = c(i);
  t.escape = function(e) {
    return e.replace(p, h).replace(l, h)
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.findAll = t.existsOne = t.findOne = t.findOneChild = t.find = t.filter = void 0;
  var n = r(37);

  function i(e, t, r, a) {
    for (var s = [], o = 0, u = t; o < u.length; o++) {
      var c = u[o];
      if (e(c) && (s.push(c), --a <= 0)) break;
      if (r && n.hasChildren(c) && c.children.length > 0) {
        var l = i(e, c.children, r, a);
        if (s.push.apply(s, l), (a -= l.length) <= 0) break
      }
    }
    return s
  }
  t.filter = function(e, t, r, n) {
    return void 0 === r && (r = !0), void 0 === n && (n = 1 / 0), Array.isArray(t) || (t = [t]), i(e, t, r, n)
  }, t.find = i, t.findOneChild = function(e, t) {
    return t.find(e)
  }, t.findOne = function e(t, r, i) {
    void 0 === i && (i = !0);
    for (var a = null, s = 0; s < r.length && !a; s++) {
      var o = r[s];
      n.isTag(o) && (t(o) ? a = o : i && o.children.length > 0 && (a = e(t, o.children)))
    }
    return a
  }, t.existsOne = function e(t, r) {
    return r.some((function(r) {
      return n.isTag(r) && (t(r) || r.children.length > 0 && e(t, r.children))
    }))
  }, t.findAll = function(e, t) {
    for (var r, i, a = [], s = t.filter(n.isTag); i = s.shift();) {
      var o = null === (r = i.children) || void 0 === r ? void 0 : r.filter(n.isTag);
      o && o.length > 0 && s.unshift.apply(s, o), e(i) && a.push(i)
    }
    return a
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Util = void 0;
  const n = r(13),
    i = r(79),
    a = r(5);
  class s {
    constructor(e, t) {
      this.dataFactory = e || new a.DataFactory, this.baseIRI = this.dataFactory.namedNode(t || ""), this.baseIRIDocument = this.baseIRI
    }
    static parsePrefixes(e, t, r) {
      const n = {};
      if (r)
        for (const t in e) t.startsWith("xmlns") && (n[t.substr(6)] = e[t]);
      if (e.prefix || Object.keys(n).length > 0) {
        const r = Object.assign(Object.assign({}, t), n);
        if (e.prefix) {
          let t;
          for (; t = s.PREFIX_REGEX.exec(e.prefix);) r[t[1]] = t[2]
        }
        return r
      }
      return t
    }
    static expandPrefixedTerm(e, t) {
      const r = e.indexOf(":");
      let n, i;
      if (r >= 0 && (n = e.substr(0, r), i = e.substr(r + 1)), "" === n) return "http://www.w3.org/1999/xhtml/vocab#" + i;
      if (n) {
        const e = t.prefixesAll[n];
        if (e) return e + i
      }
      if (e) {
        const r = t.prefixesAll[e.toLocaleLowerCase()];
        if (r) return r
      }
      return e
    }
    static isValidIri(e) {
      return s.IRI_REGEX.test(e)
    }
    static contentTypeToProfile(e) {
      return i.RDFA_CONTENTTYPES[e] || ""
    }
    getBaseIRI(e) {
      let t = e;
      const r = t.indexOf("#");
      return r >= 0 && (t = t.substr(0, r)), this.dataFactory.namedNode(n.resolve(t, this.baseIRI.value))
    }
    getResourceOrBaseIri(e, t) {
      return !0 === e ? this.getBaseIriTerm(t) : e
    }
    getBaseIriTerm(e) {
      return e.localBaseIRI || this.baseIRI
    }
    createVocabIris(e, t, r, n) {
      return e.split(/\s+/).filter(e => e && (r || e.indexOf(":") >= 0)).map(e => this.createIri(e, t, !0, !0, n)).filter(e => null != e)
    }
    createLiteral(e, t) {
      if (t.interpretObjectAsTime && !t.datatype)
        for (const r of s.TIME_REGEXES)
          if (e.match(r.regex)) {
            t.datatype = this.dataFactory.namedNode(s.XSD + r.type);
            break
          } return this.dataFactory.literal(e, t.datatype || t.language)
    }
    createBlankNode() {
      return this.blankNodeFactory ? this.blankNodeFactory() : this.dataFactory.blankNode()
    }
    createIri(e, t, r, i, a) {
      if (e = e || "", !i) return r || (e = n.resolve(e, this.getBaseIriTerm(t).value)), s.isValidIri(e) ? this.dataFactory.namedNode(e) : null;
      if (e.length > 0 && "[" === e[0] && "]" === e[e.length - 1] && (e = e.substr(1, e.length - 2)).indexOf(":") < 0) return null;
      if (e.startsWith("_:")) return a ? this.dataFactory.blankNode(e.substr(2) || "b_identity") : null;
      if (r && t.vocab && e.indexOf(":") < 0) return this.dataFactory.namedNode(t.vocab + e);
      let o = s.expandPrefixedTerm(e, t);
      return r ? e !== o && (o = n.resolve(o, this.baseIRIDocument.value)) : o = n.resolve(o, this.getBaseIriTerm(t).value), s.isValidIri(o) ? this.dataFactory.namedNode(o) : null
    }
  }
  t.Util = s, s.RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#", s.XSD = "http://www.w3.org/2001/XMLSchema#", s.RDFA = "http://www.w3.org/ns/rdfa#", s.PREFIX_REGEX = /\s*([^:\s]*)*:\s*([^\s]*)*\s*/g, s.TIME_REGEXES = [{
    regex: /^-?P([0-9]+Y)?([0-9]+M)?([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+(\.[0-9])?S)?)?$/,
    type: "duration"
  }, {
    regex: /^[0-9]+-[0-9][0-9]-[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\+-][0-9][0-9]:[0-9][0-9]))$/,
    type: "dateTime"
  }, {
    regex: /^[0-9]+-[0-9][0-9]-[0-9][0-9]Z?$/,
    type: "date"
  }, {
    regex: /^[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\+-][0-9][0-9]:[0-9][0-9]))$/,
    type: "time"
  }, {
    regex: /^[0-9]+-[0-9][0-9]$/,
    type: "gYearMonth"
  }, {
    regex: /^[0-9]+$/,
    type: "gYear"
  }], s.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ "<>{}|\\\[\]`]*$/
}, function(e, t, r) {
  "use strict";
  var n = this && this.__importDefault || function(e) {
    return e && e.__esModule ? e : {
      default: e
    }
  };
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  var i = n(r(77)),
    a = n(r(56)),
    s = n(r(78)),
    o = n(r(57));

  function u(e) {
    return " " === e || "\n" === e || "\t" === e || "\f" === e || "\r" === e
  }

  function c(e) {
    return e >= "a" && e <= "z" || e >= "A" && e <= "Z"
  }

  function l(e, t, r) {
    var n = e.toLowerCase();
    return e === n ? function(e, i) {
      i === n ? e._state = t : (e._state = r, e._index--)
    } : function(i, a) {
      a === n || a === e ? i._state = t : (i._state = r, i._index--)
    }
  }

  function h(e, t) {
    var r = e.toLowerCase();
    return function(n, i) {
      i === r || i === e ? n._state = t : (n._state = 3, n._index--)
    }
  }
  var d = l("C", 24, 16),
    p = l("D", 25, 16),
    f = l("A", 26, 16),
    g = l("T", 27, 16),
    m = l("A", 28, 16),
    y = h("R", 35),
    b = h("I", 36),
    _ = h("P", 37),
    v = h("T", 38),
    w = l("R", 40, 1),
    S = l("I", 41, 1),
    T = l("P", 42, 1),
    E = l("T", 43, 1),
    x = h("Y", 45),
    O = h("L", 46),
    A = h("E", 47),
    R = l("Y", 49, 1),
    I = l("L", 50, 1),
    N = l("E", 51, 1),
    P = h("I", 54),
    C = h("T", 55),
    D = h("L", 56),
    j = h("E", 57),
    k = l("I", 58, 1),
    L = l("T", 59, 1),
    M = l("L", 60, 1),
    F = l("E", 61, 1),
    B = l("#", 63, 64),
    q = l("X", 66, 65),
    U = function() {
      function e(e, t) {
        var r;
        this._state = 1, this.buffer = "", this.sectionStart = 0, this._index = 0, this.bufferOffset = 0, this.baseState = 1, this.special = 1, this.running = !0, this.ended = !1, this.cbs = t, this.xmlMode = !!(null == e ? void 0 : e.xmlMode), this.decodeEntities = null === (r = null == e ? void 0 : e.decodeEntities) || void 0 === r || r
      }
      return e.prototype.reset = function() {
        this._state = 1, this.buffer = "", this.sectionStart = 0, this._index = 0, this.bufferOffset = 0, this.baseState = 1, this.special = 1, this.running = !0, this.ended = !1
      }, e.prototype.write = function(e) {
        this.ended && this.cbs.onerror(Error(".write() after done!")), this.buffer += e, this.parse()
      }, e.prototype.end = function(e) {
        this.ended && this.cbs.onerror(Error(".end() after done!")), e && this.write(e), this.ended = !0, this.running && this.finish()
      }, e.prototype.pause = function() {
        this.running = !1
      }, e.prototype.resume = function() {
        this.running = !0, this._index < this.buffer.length && this.parse(), this.ended && this.finish()
      }, e.prototype.getAbsoluteIndex = function() {
        return this.bufferOffset + this._index
      }, e.prototype.stateText = function(e) {
        "<" === e ? (this._index > this.sectionStart && this.cbs.ontext(this.getSection()), this._state = 2, this.sectionStart = this._index) : this.decodeEntities && 1 === this.special && "&" === e && (this._index > this.sectionStart && this.cbs.ontext(this.getSection()), this.baseState = 1, this._state = 62, this.sectionStart = this._index)
      }, e.prototype.stateBeforeTagName = function(e) {
        "/" === e ? this._state = 5 : "<" === e ? (this.cbs.ontext(this.getSection()), this.sectionStart = this._index) : ">" === e || 1 !== this.special || u(e) ? this._state = 1 : "!" === e ? (this._state = 15, this.sectionStart = this._index + 1) : "?" === e ? (this._state = 17, this.sectionStart = this._index + 1) : c(e) ? (this._state = this.xmlMode || "s" !== e && "S" !== e ? this.xmlMode || "t" !== e && "T" !== e ? 3 : 52 : 32, this.sectionStart = this._index) : this._state = 1
      }, e.prototype.stateInTagName = function(e) {
        ("/" === e || ">" === e || u(e)) && (this.emitToken("onopentagname"), this._state = 8, this._index--)
      }, e.prototype.stateBeforeClosingTagName = function(e) {
        u(e) || (">" === e ? this._state = 1 : 1 !== this.special ? "s" === e || "S" === e ? this._state = 33 : "t" === e || "T" === e ? this._state = 53 : (this._state = 1, this._index--) : c(e) ? (this._state = 6, this.sectionStart = this._index) : (this._state = 20, this.sectionStart = this._index))
      }, e.prototype.stateInClosingTagName = function(e) {
        (">" === e || u(e)) && (this.emitToken("onclosetag"), this._state = 7, this._index--)
      }, e.prototype.stateAfterClosingTagName = function(e) {
        ">" === e && (this._state = 1, this.sectionStart = this._index + 1)
      }, e.prototype.stateBeforeAttributeName = function(e) {
        ">" === e ? (this.cbs.onopentagend(), this._state = 1, this.sectionStart = this._index + 1) : "/" === e ? this._state = 4 : u(e) || (this._state = 9, this.sectionStart = this._index)
      }, e.prototype.stateInSelfClosingTag = function(e) {
        ">" === e ? (this.cbs.onselfclosingtag(), this._state = 1, this.sectionStart = this._index + 1, this.special = 1) : u(e) || (this._state = 8, this._index--)
      }, e.prototype.stateInAttributeName = function(e) {
        ("=" === e || "/" === e || ">" === e || u(e)) && (this.cbs.onattribname(this.getSection()), this.sectionStart = -1, this._state = 10, this._index--)
      }, e.prototype.stateAfterAttributeName = function(e) {
        "=" === e ? this._state = 11 : "/" === e || ">" === e ? (this.cbs.onattribend(void 0), this._state = 8, this._index--) : u(e) || (this.cbs.onattribend(void 0), this._state = 9, this.sectionStart = this._index)
      }, e.prototype.stateBeforeAttributeValue = function(e) {
        '"' === e ? (this._state = 12, this.sectionStart = this._index + 1) : "'" === e ? (this._state = 13, this.sectionStart = this._index + 1) : u(e) || (this._state = 14, this.sectionStart = this._index, this._index--)
      }, e.prototype.handleInAttributeValue = function(e, t) {
        e === t ? (this.emitToken("onattribdata"), this.cbs.onattribend(t), this._state = 8) : this.decodeEntities && "&" === e && (this.emitToken("onattribdata"), this.baseState = this._state, this._state = 62, this.sectionStart = this._index)
      }, e.prototype.stateInAttributeValueDoubleQuotes = function(e) {
        this.handleInAttributeValue(e, '"')
      }, e.prototype.stateInAttributeValueSingleQuotes = function(e) {
        this.handleInAttributeValue(e, "'")
      }, e.prototype.stateInAttributeValueNoQuotes = function(e) {
        u(e) || ">" === e ? (this.emitToken("onattribdata"), this.cbs.onattribend(null), this._state = 8, this._index--) : this.decodeEntities && "&" === e && (this.emitToken("onattribdata"), this.baseState = this._state, this._state = 62, this.sectionStart = this._index)
      }, e.prototype.stateBeforeDeclaration = function(e) {
        this._state = "[" === e ? 23 : "-" === e ? 18 : 16
      }, e.prototype.stateInDeclaration = function(e) {
        ">" === e && (this.cbs.ondeclaration(this.getSection()), this._state = 1, this.sectionStart = this._index + 1)
      }, e.prototype.stateInProcessingInstruction = function(e) {
        ">" === e && (this.cbs.onprocessinginstruction(this.getSection()), this._state = 1, this.sectionStart = this._index + 1)
      }, e.prototype.stateBeforeComment = function(e) {
        "-" === e ? (this._state = 19, this.sectionStart = this._index + 1) : this._state = 16
      }, e.prototype.stateInComment = function(e) {
        "-" === e && (this._state = 21)
      }, e.prototype.stateInSpecialComment = function(e) {
        ">" === e && (this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index)), this._state = 1, this.sectionStart = this._index + 1)
      }, e.prototype.stateAfterComment1 = function(e) {
        this._state = "-" === e ? 22 : 19
      }, e.prototype.stateAfterComment2 = function(e) {
        ">" === e ? (this.cbs.oncomment(this.buffer.substring(this.sectionStart, this._index - 2)), this._state = 1, this.sectionStart = this._index + 1) : "-" !== e && (this._state = 19)
      }, e.prototype.stateBeforeCdata6 = function(e) {
        "[" === e ? (this._state = 29, this.sectionStart = this._index + 1) : (this._state = 16, this._index--)
      }, e.prototype.stateInCdata = function(e) {
        "]" === e && (this._state = 30)
      }, e.prototype.stateAfterCdata1 = function(e) {
        this._state = "]" === e ? 31 : 29
      }, e.prototype.stateAfterCdata2 = function(e) {
        ">" === e ? (this.cbs.oncdata(this.buffer.substring(this.sectionStart, this._index - 2)), this._state = 1, this.sectionStart = this._index + 1) : "]" !== e && (this._state = 29)
      }, e.prototype.stateBeforeSpecialS = function(e) {
        "c" === e || "C" === e ? this._state = 34 : "t" === e || "T" === e ? this._state = 44 : (this._state = 3, this._index--)
      }, e.prototype.stateBeforeSpecialSEnd = function(e) {
        2 !== this.special || "c" !== e && "C" !== e ? 3 !== this.special || "t" !== e && "T" !== e ? this._state = 1 : this._state = 48 : this._state = 39
      }, e.prototype.stateBeforeSpecialLast = function(e, t) {
        ("/" === e || ">" === e || u(e)) && (this.special = t), this._state = 3, this._index--
      }, e.prototype.stateAfterSpecialLast = function(e, t) {
        ">" === e || u(e) ? (this.special = 1, this._state = 6, this.sectionStart = this._index - t, this._index--) : this._state = 1
      }, e.prototype.parseFixedEntity = function(e) {
        if (void 0 === e && (e = this.xmlMode ? o.default : a.default), this.sectionStart + 1 < this._index) {
          var t = this.buffer.substring(this.sectionStart + 1, this._index);
          Object.prototype.hasOwnProperty.call(e, t) && (this.emitPartial(e[t]), this.sectionStart = this._index + 1)
        }
      }, e.prototype.parseLegacyEntity = function() {
        for (var e = this.sectionStart + 1, t = Math.min(this._index - e, 6); t >= 2;) {
          var r = this.buffer.substr(e, t);
          if (Object.prototype.hasOwnProperty.call(s.default, r)) return this.emitPartial(s.default[r]), void(this.sectionStart += t + 1);
          t--
        }
      }, e.prototype.stateInNamedEntity = function(e) {
        ";" === e ? (this.parseFixedEntity(), 1 === this.baseState && this.sectionStart + 1 < this._index && !this.xmlMode && this.parseLegacyEntity(), this._state = this.baseState) : (e < "0" || e > "9") && !c(e) && (this.xmlMode || this.sectionStart + 1 === this._index || (1 !== this.baseState ? "=" !== e && this.parseFixedEntity(s.default) : this.parseLegacyEntity()), this._state = this.baseState, this._index--)
      }, e.prototype.decodeNumericEntity = function(e, t, r) {
        var n = this.sectionStart + e;
        if (n !== this._index) {
          var a = this.buffer.substring(n, this._index),
            s = parseInt(a, t);
          this.emitPartial(i.default(s)), this.sectionStart = r ? this._index + 1 : this._index
        }
        this._state = this.baseState
      }, e.prototype.stateInNumericEntity = function(e) {
        ";" === e ? this.decodeNumericEntity(2, 10, !0) : (e < "0" || e > "9") && (this.xmlMode ? this._state = this.baseState : this.decodeNumericEntity(2, 10, !1), this._index--)
      }, e.prototype.stateInHexEntity = function(e) {
        ";" === e ? this.decodeNumericEntity(3, 16, !0) : (e < "a" || e > "f") && (e < "A" || e > "F") && (e < "0" || e > "9") && (this.xmlMode ? this._state = this.baseState : this.decodeNumericEntity(3, 16, !1), this._index--)
      }, e.prototype.cleanup = function() {
        this.sectionStart < 0 ? (this.buffer = "", this.bufferOffset += this._index, this._index = 0) : this.running && (1 === this._state ? (this.sectionStart !== this._index && this.cbs.ontext(this.buffer.substr(this.sectionStart)), this.buffer = "", this.bufferOffset += this._index, this._index = 0) : this.sectionStart === this._index ? (this.buffer = "", this.bufferOffset += this._index, this._index = 0) : (this.buffer = this.buffer.substr(this.sectionStart), this._index -= this.sectionStart, this.bufferOffset += this.sectionStart), this.sectionStart = 0)
      }, e.prototype.parse = function() {
        for (; this._index < this.buffer.length && this.running;) {
          var e = this.buffer.charAt(this._index);
          1 === this._state ? this.stateText(e) : 12 === this._state ? this.stateInAttributeValueDoubleQuotes(e) : 9 === this._state ? this.stateInAttributeName(e) : 19 === this._state ? this.stateInComment(e) : 20 === this._state ? this.stateInSpecialComment(e) : 8 === this._state ? this.stateBeforeAttributeName(e) : 3 === this._state ? this.stateInTagName(e) : 6 === this._state ? this.stateInClosingTagName(e) : 2 === this._state ? this.stateBeforeTagName(e) : 10 === this._state ? this.stateAfterAttributeName(e) : 13 === this._state ? this.stateInAttributeValueSingleQuotes(e) : 11 === this._state ? this.stateBeforeAttributeValue(e) : 5 === this._state ? this.stateBeforeClosingTagName(e) : 7 === this._state ? this.stateAfterClosingTagName(e) : 32 === this._state ? this.stateBeforeSpecialS(e) : 21 === this._state ? this.stateAfterComment1(e) : 14 === this._state ? this.stateInAttributeValueNoQuotes(e) : 4 === this._state ? this.stateInSelfClosingTag(e) : 16 === this._state ? this.stateInDeclaration(e) : 15 === this._state ? this.stateBeforeDeclaration(e) : 22 === this._state ? this.stateAfterComment2(e) : 18 === this._state ? this.stateBeforeComment(e) : 33 === this._state ? this.stateBeforeSpecialSEnd(e) : 53 === this._state ? k(this, e) : 39 === this._state ? w(this, e) : 40 === this._state ? S(this, e) : 41 === this._state ? T(this, e) : 34 === this._state ? y(this, e) : 35 === this._state ? b(this, e) : 36 === this._state ? _(this, e) : 37 === this._state ? v(this, e) : 38 === this._state ? this.stateBeforeSpecialLast(e, 2) : 42 === this._state ? E(this, e) : 43 === this._state ? this.stateAfterSpecialLast(e, 6) : 44 === this._state ? x(this, e) : 29 === this._state ? this.stateInCdata(e) : 45 === this._state ? O(this, e) : 46 === this._state ? A(this, e) : 47 === this._state ? this.stateBeforeSpecialLast(e, 3) : 48 === this._state ? R(this, e) : 49 === this._state ? I(this, e) : 50 === this._state ? N(this, e) : 51 === this._state ? this.stateAfterSpecialLast(e, 5) : 52 === this._state ? P(this, e) : 54 === this._state ? C(this, e) : 55 === this._state ? D(this, e) : 56 === this._state ? j(this, e) : 57 === this._state ? this.stateBeforeSpecialLast(e, 4) : 58 === this._state ? L(this, e) : 59 === this._state ? M(this, e) : 60 === this._state ? F(this, e) : 61 === this._state ? this.stateAfterSpecialLast(e, 5) : 17 === this._state ? this.stateInProcessingInstruction(e) : 64 === this._state ? this.stateInNamedEntity(e) : 23 === this._state ? d(this, e) : 62 === this._state ? B(this, e) : 24 === this._state ? p(this, e) : 25 === this._state ? f(this, e) : 30 === this._state ? this.stateAfterCdata1(e) : 31 === this._state ? this.stateAfterCdata2(e) : 26 === this._state ? g(this, e) : 27 === this._state ? m(this, e) : 28 === this._state ? this.stateBeforeCdata6(e) : 66 === this._state ? this.stateInHexEntity(e) : 65 === this._state ? this.stateInNumericEntity(e) : 63 === this._state ? q(this, e) : this.cbs.onerror(Error("unknown _state"), this._state), this._index++
        }
        this.cleanup()
      }, e.prototype.finish = function() {
        this.sectionStart < this._index && this.handleTrailingData(), this.cbs.onend()
      }, e.prototype.handleTrailingData = function() {
        var e = this.buffer.substr(this.sectionStart);
        29 === this._state || 30 === this._state || 31 === this._state ? this.cbs.oncdata(e) : 19 === this._state || 21 === this._state || 22 === this._state ? this.cbs.oncomment(e) : 64 !== this._state || this.xmlMode ? 65 !== this._state || this.xmlMode ? 66 !== this._state || this.xmlMode ? 3 !== this._state && 8 !== this._state && 11 !== this._state && 10 !== this._state && 9 !== this._state && 13 !== this._state && 12 !== this._state && 14 !== this._state && 6 !== this._state && this.cbs.ontext(e) : (this.decodeNumericEntity(3, 16, !1), this.sectionStart < this._index && (this._state = this.baseState, this.handleTrailingData())) : (this.decodeNumericEntity(2, 10, !1), this.sectionStart < this._index && (this._state = this.baseState, this.handleTrailingData())) : (this.parseLegacyEntity(), this.sectionStart < this._index && (this._state = this.baseState, this.handleTrailingData()))
      }, e.prototype.getSection = function() {
        return this.buffer.substring(this.sectionStart, this._index)
      }, e.prototype.emitToken = function(e) {
        this.cbs[e](this.getSection()), this.sectionStart = -1
      }, e.prototype.emitPartial = function(e) {
        1 !== this.baseState ? this.cbs.onattribdata(e) : this.cbs.ontext(e)
      }, e
    }();
  t.default = U
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ItemPropertyHandlerContent = void 0;
  t.ItemPropertyHandlerContent = class {
    canHandle(e, t) {
      return "content" in t
    }
    getObject(e, t, r) {
      return t.createLiteral(e.content, r)
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ItemPropertyHandlerNumber = void 0;
  const n = r(61);
  t.ItemPropertyHandlerNumber = class {
    constructor(e, t) {
      this.tagName = e, this.attributeName = t
    }
    canHandle(e, t) {
      return this.tagName === e && this.attributeName in t
    }
    getObject(e, t, r) {
      const i = e[this.attributeName];
      let a;
      return Number.isNaN(Number.parseInt(i, 10)) || i.includes(".") ? Number.isNaN(Number.parseFloat(i)) || (a = n.Util.XSD + "double") : a = n.Util.XSD + "integer", t.dataFactory.literal(i, a && t.dataFactory.namedNode(a))
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ItemPropertyHandlerTime = void 0;
  const n = r(61);
  class i {
    canHandle(e, t) {
      return "time" === e && "datetime" in t
    }
    getObject(e, t, r) {
      const a = e.datetime;
      let s;
      for (const e of i.TIME_REGEXES)
        if (e.regex.exec(a)) {
          s = t.dataFactory.namedNode(n.Util.XSD + e.type);
          break
        } return t.dataFactory.literal(a, s)
    }
  }
  t.ItemPropertyHandlerTime = i, i.TIME_REGEXES = [{
    regex: /^-?P(\d+Y)?(\d+M)?(\d+D)?(T(\d+H)?(\d+M)?(\d+(\.\d)?S)?)?$/u,
    type: "duration"
  }, {
    regex: /^\d+-\d\d-\d\dT\d\d:\d\d:\d\d((Z?)|([+-]\d\d:\d\d))$/u,
    type: "dateTime"
  }, {
    regex: /^\d+-\d\d-\d\dZ?$/u,
    type: "date"
  }, {
    regex: /^\d\d:\d\d:\d\d((Z?)|([+-]\d\d:\d\d))$/u,
    type: "time"
  }, {
    regex: /^\d+-\d\d$/u,
    type: "gYearMonth"
  }, {
    regex: /^\d+$/u,
    type: "gYear"
  }]
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ItemPropertyHandlerUrl = void 0;
  const n = r(13);
  t.ItemPropertyHandlerUrl = class {
    constructor(e, t) {
      this.tagName = e, this.attributeName = t
    }
    canHandle(e, t) {
      return this.tagName === e && this.attributeName in t
    }
    getObject(e, t, r) {
      return t.dataFactory.namedNode(n.resolve(e[this.attributeName], t.baseIRI))
    }
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__setModuleDefault || (Object.create ? function(e, t) {
      Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
      })
    } : function(e, t) {
      e.default = t
    }),
    a = this && this.__importStar || function(e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (null != e)
        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && n(t, e, r);
      return i(t, e), t
    },
    s = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    },
    o = this && this.__importDefault || function(e) {
      return e && e.__esModule ? e : {
        default: e
      }
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.RssHandler = t.DefaultHandler = t.DomUtils = t.ElementType = t.Tokenizer = t.createDomStream = t.parseDOM = t.DomHandler = t.Parser = void 0;
  var u = r(80);
  Object.defineProperty(t, "Parser", {
    enumerable: !0,
    get: function() {
      return u.Parser
    }
  });
  var c = r(58);
  Object.defineProperty(t, "DomHandler", {
    enumerable: !0,
    get: function() {
      return c.DomHandler
    }
  }), Object.defineProperty(t, "DefaultHandler", {
    enumerable: !0,
    get: function() {
      return c.DomHandler
    }
  }), t.parseDOM = function(e, t) {
    var r = new c.DomHandler(void 0, t);
    return new u.Parser(r, t).end(e), r.dom
  }, t.createDomStream = function(e, t, r) {
    var n = new c.DomHandler(e, t, r);
    return new u.Parser(n, t)
  };
  var l = r(140);
  Object.defineProperty(t, "Tokenizer", {
    enumerable: !0,
    get: function() {
      return o(l).default
    }
  });
  var h = a(r(59));
  t.ElementType = h, s(r(146), t), t.DomUtils = a(r(60));
  var d = r(146);
  Object.defineProperty(t, "RssHandler", {
    enumerable: !0,
    get: function() {
      return d.FeedHandler
    }
  })
}, function(e, t, r) {
  "use strict";
  var n, i = this && this.__extends || (n = function(e, t) {
      return (n = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && function(e, t) {
          e.__proto__ = t
        } || function(e, t) {
          for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r])
        })(e, t)
    }, function(e, t) {
      function r() {
        this.constructor = e
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
    }),
    a = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    s = this && this.__setModuleDefault || (Object.create ? function(e, t) {
      Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
      })
    } : function(e, t) {
      e.default = t
    }),
    o = this && this.__importStar || function(e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (null != e)
        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && a(t, e, r);
      return s(t, e), t
    },
    u = this && this.__importDefault || function(e) {
      return e && e.__esModule ? e : {
        default: e
      }
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.parseFeed = t.FeedHandler = void 0;
  var c, l, h = u(r(58)),
    d = o(r(60)),
    p = r(80);
  ! function(e) {
    e[e.image = 0] = "image", e[e.audio = 1] = "audio", e[e.video = 2] = "video", e[e.document = 3] = "document", e[e.executable = 4] = "executable"
  }(c || (c = {})),
    function(e) {
      e[e.sample = 0] = "sample", e[e.full = 1] = "full", e[e.nonstop = 2] = "nonstop"
    }(l || (l = {}));
  var f = function(e) {
    function t(t, r) {
      return "object" == typeof t && (r = t = void 0), e.call(this, t, r) || this
    }
    return i(t, e), t.prototype.onend = function() {
      var e, t, r = {},
        n = y(w, this.dom);
      if (n)
        if ("feed" === n.name) {
          var i = n.children;
          r.type = "atom", v(r, "id", "id", i), v(r, "title", "title", i);
          var a = _("href", y("link", i));
          a && (r.link = a), v(r, "description", "subtitle", i), (s = b("updated", i)) && (r.updated = new Date(s)), v(r, "author", "email", i, !0), r.items = m("entry", i).map((function(e) {
            var t = {},
              r = e.children;
            v(t, "id", "id", r), v(t, "title", "title", r);
            var n = _("href", y("link", r));
            n && (t.link = n);
            var i = b("summary", r) || b("content", r);
            i && (t.description = i);
            var a = b("updated", r);
            return a && (t.pubDate = new Date(a)), t.media = g(r), t
          }))
        } else {
          var s;
          i = null !== (t = null === (e = y("channel", n.children)) || void 0 === e ? void 0 : e.children) && void 0 !== t ? t : [];
          r.type = n.name.substr(0, 3), r.id = "", v(r, "title", "title", i), v(r, "link", "link", i), v(r, "description", "description", i), (s = b("lastBuildDate", i)) && (r.updated = new Date(s)), v(r, "author", "managingEditor", i, !0), r.items = m("item", n.children).map((function(e) {
            var t = {},
              r = e.children;
            v(t, "id", "guid", r), v(t, "title", "title", r), v(t, "link", "link", r), v(t, "description", "description", r);
            var n = b("pubDate", r);
            return n && (t.pubDate = new Date(n)), t.media = g(r), t
          }))
        } this.feed = r, this.handleCallback(n ? null : Error("couldn't find root of feed"))
    }, t
  }(h.default);

  function g(e) {
    return m("media:content", e).map((function(e) {
      var t = {
        medium: e.attribs.medium,
        isDefault: !!e.attribs.isDefault
      };
      return e.attribs.url && (t.url = e.attribs.url), e.attribs.fileSize && (t.fileSize = parseInt(e.attribs.fileSize, 10)), e.attribs.type && (t.type = e.attribs.type), e.attribs.expression && (t.expression = e.attribs.expression), e.attribs.bitrate && (t.bitrate = parseInt(e.attribs.bitrate, 10)), e.attribs.framerate && (t.framerate = parseInt(e.attribs.framerate, 10)), e.attribs.samplingrate && (t.samplingrate = parseInt(e.attribs.samplingrate, 10)), e.attribs.channels && (t.channels = parseInt(e.attribs.channels, 10)), e.attribs.duration && (t.duration = parseInt(e.attribs.duration, 10)), e.attribs.height && (t.height = parseInt(e.attribs.height, 10)), e.attribs.width && (t.width = parseInt(e.attribs.width, 10)), e.attribs.lang && (t.lang = e.attribs.lang), t
    }))
  }

  function m(e, t) {
    return d.getElementsByTagName(e, t, !0)
  }

  function y(e, t) {
    return d.getElementsByTagName(e, t, !0, 1)[0]
  }

  function b(e, t, r) {
    return void 0 === r && (r = !1), d.getText(d.getElementsByTagName(e, t, r, 1)).trim()
  }

  function _(e, t) {
    return t ? t.attribs[e] : null
  }

  function v(e, t, r, n, i) {
    void 0 === i && (i = !1);
    var a = b(r, n, i);
    a && (e[t] = a)
  }

  function w(e) {
    return "rss" === e || "feed" === e || "rdf:RDF" === e
  }
  t.FeedHandler = f;
  var S = {
    xmlMode: !0
  };
  t.parseFeed = function(e, t) {
    void 0 === t && (t = S);
    var r = new f(t);
    return new p.Parser(r, t).end(e), r.feed
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Util = void 0;
  const n = r(13),
    i = r(82),
    a = r(5);
  class s {
    constructor(e, t) {
      this.dataFactory = e || new a.DataFactory, this.baseIRI = this.dataFactory.namedNode(t || ""), this.baseIRIDocument = this.baseIRI
    }
    static parsePrefixes(e, t, r) {
      const n = {};
      if (r)
        for (const t in e) t.startsWith("xmlns") && (n[t.substr(6)] = e[t]);
      if (e.prefix || Object.keys(n).length > 0) {
        const r = Object.assign(Object.assign({}, t), n);
        if (e.prefix) {
          let t;
          for (; t = s.PREFIX_REGEX.exec(e.prefix);) r[t[1]] = t[2]
        }
        return r
      }
      return t
    }
    static expandPrefixedTerm(e, t) {
      const r = e.indexOf(":");
      let n, i;
      if (r >= 0 && (n = e.substr(0, r), i = e.substr(r + 1)), "" === n) return "http://www.w3.org/1999/xhtml/vocab#" + i;
      if (n) {
        const e = t.prefixesAll[n];
        if (e) return e + i
      }
      if (e) {
        const r = t.prefixesAll[e.toLocaleLowerCase()];
        if (r) return r
      }
      return e
    }
    static isValidIri(e) {
      return s.IRI_REGEX.test(e)
    }
    static contentTypeToProfile(e) {
      return i.RDFA_CONTENTTYPES[e] || ""
    }
    getBaseIRI(e) {
      let t = e;
      const r = t.indexOf("#");
      return r >= 0 && (t = t.substr(0, r)), this.dataFactory.namedNode(n.resolve(t, this.baseIRI.value))
    }
    getResourceOrBaseIri(e, t) {
      return !0 === e ? this.getBaseIriTerm(t) : e
    }
    getBaseIriTerm(e) {
      return e.localBaseIRI || this.baseIRI
    }
    createVocabIris(e, t, r, n) {
      return e.split(/\s+/).filter(e => e && (r || e.indexOf(":") >= 0)).map(e => this.createIri(e, t, !0, !0, n)).filter(e => null != e)
    }
    createLiteral(e, t) {
      if (t.interpretObjectAsTime && !t.datatype)
        for (const r of s.TIME_REGEXES)
          if (e.match(r.regex)) {
            t.datatype = this.dataFactory.namedNode(s.XSD + r.type);
            break
          } return this.dataFactory.literal(e, t.datatype || t.language)
    }
    createBlankNode() {
      return this.blankNodeFactory ? this.blankNodeFactory() : this.dataFactory.blankNode()
    }
    createIri(e, t, r, i, a) {
      if (e = e || "", !i) return r || (e = n.resolve(e, this.getBaseIriTerm(t).value)), s.isValidIri(e) ? this.dataFactory.namedNode(e) : null;
      if (e.length > 0 && "[" === e[0] && "]" === e[e.length - 1] && (e = e.substr(1, e.length - 2)).indexOf(":") < 0) return null;
      if (e.startsWith("_:")) return a ? this.dataFactory.blankNode(e.substr(2) || "b_identity") : null;
      if (r && t.vocab && e.indexOf(":") < 0) return this.dataFactory.namedNode(t.vocab + e);
      let o = s.expandPrefixedTerm(e, t);
      return r ? e !== o && (o = n.resolve(o, this.baseIRIDocument.value)) : o = n.resolve(o, this.getBaseIriTerm(t).value), s.isValidIri(o) ? this.dataFactory.namedNode(o) : null
    }
  }
  t.Util = s, s.RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#", s.XSD = "http://www.w3.org/2001/XMLSchema#", s.RDFA = "http://www.w3.org/ns/rdfa#", s.PREFIX_REGEX = /\s*([^:\s]*)*:\s*([^\s]*)*\s*/g, s.TIME_REGEXES = [{
    regex: /^-?P([0-9]+Y)?([0-9]+M)?([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+(\.[0-9])?S)?)?$/,
    type: "duration"
  }, {
    regex: /^[0-9]+-[0-9][0-9]-[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\+-][0-9][0-9]:[0-9][0-9]))$/,
    type: "dateTime"
  }, {
    regex: /^[0-9]+-[0-9][0-9]-[0-9][0-9]Z?$/,
    type: "date"
  }, {
    regex: /^[0-9][0-9]:[0-9][0-9]:[0-9][0-9]((Z?)|([\+-][0-9][0-9]:[0-9][0-9]))$/,
    type: "time"
  }, {
    regex: /^[0-9]+-[0-9][0-9]$/,
    type: "gYearMonth"
  }, {
    regex: /^[0-9]+$/,
    type: "gYear"
  }], s.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^ "<>{}|\\\[\]`]*$/
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(327), t), i(r(328), t)
}, function(e, t, r) {
  "use strict";
  var n = this && this.__awaiter || function(e, t, r, n) {
    return new(r || (r = Promise))((function(i, a) {
      function s(e) {
        try {
          u(n.next(e))
        } catch (e) {
          a(e)
        }
      }

      function o(e) {
        try {
          u(n.throw(e))
        } catch (e) {
          a(e)
        }
      }

      function u(e) {
        var t;
        e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
          e(t)
        }))).then(s, o)
      }
      u((n = n.apply(e, t || [])).next())
    }))
  };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.defaultExpandOptions = t.ContextParser = void 0, r(45);
  const i = r(13),
    a = r(47),
    s = r(150),
    o = r(152),
    u = r(83),
    c = r(84);
  class l {
    constructor(e) {
      e = e || {}, this.documentLoader = e.documentLoader || new s.FetchDocumentLoader, this.documentCache = {}, this.validateContext = !e.skipValidation, this.expandContentTypeToBase = !!e.expandContentTypeToBase, this.remoteContextsDepthLimit = e.remoteContextsDepthLimit || 32, this.redirectSchemaOrgHttps = !("redirectSchemaOrgHttps" in e) || !!e.redirectSchemaOrgHttps
    }
    static validateLanguage(e, t, r) {
      if ("string" != typeof e) throw new a.ErrorCoded(`The value of an '@language' must be a string, got '${JSON.stringify(e)}'`, r);
      if (!u.Util.REGEX_LANGUAGE_TAG.test(e)) {
        if (t) throw new a.ErrorCoded(`The value of an '@language' must be a valid language tag, got '${JSON.stringify(e)}'`, r);
        return !1
      }
      return !0
    }
    static validateDirection(e, t) {
      if ("string" != typeof e) throw new a.ErrorCoded(`The value of an '@direction' must be a string, got '${JSON.stringify(e)}'`, a.ERROR_CODES.INVALID_BASE_DIRECTION);
      if (!u.Util.REGEX_DIRECTION_TAG.test(e)) {
        if (t) throw new a.ErrorCoded(`The value of an '@direction' must be 'ltr' or 'rtl', got '${JSON.stringify(e)}'`, a.ERROR_CODES.INVALID_BASE_DIRECTION);
        return !1
      }
      return !0
    }
    idifyReverseTerms(e) {
      for (const t of Object.keys(e)) {
        const r = e[t];
        if (r && "object" == typeof r && r["@reverse"] && !r["@id"]) {
          if ("string" != typeof r["@reverse"] || u.Util.isValidKeyword(r["@reverse"])) throw new a.ErrorCoded(`Invalid @reverse value, must be absolute IRI or blank node: '${r["@reverse"]}'`, a.ERROR_CODES.INVALID_IRI_MAPPING);
          r["@id"] = r["@reverse"], u.Util.isPotentialKeyword(r["@reverse"]) ? delete r["@reverse"] : r["@reverse"] = !0
        }
      }
      return e
    }
    expandPrefixedTerms(e, t) {
      const r = e.getContextRaw();
      for (const n of Object.keys(r))
        if (u.Util.EXPAND_KEYS_BLACKLIST.indexOf(n) < 0 && !u.Util.isReservedInternalKeyword(n)) {
          const i = r[n];
          if (u.Util.isPotentialKeyword(n) && u.Util.ALIAS_DOMAIN_BLACKLIST.indexOf(n) >= 0 && ("@type" !== n || "object" == typeof r[n] && !r[n]["@protected"] && "@set" !== r[n]["@container"])) throw new a.ErrorCoded(`Keywords can not be aliased to something else.\nTried mapping ${n} to ${JSON.stringify(i)}`, a.ERROR_CODES.KEYWORD_REDEFINITION);
          if (u.Util.ALIAS_RANGE_BLACKLIST.indexOf(u.Util.getContextValueId(i)) >= 0) throw new a.ErrorCoded(`Aliasing to certain keywords is not allowed.\nTried mapping ${n} to ${JSON.stringify(i)}`, a.ERROR_CODES.INVALID_KEYWORD_ALIAS);
          if (i && u.Util.isPotentialKeyword(u.Util.getContextValueId(i)) && !0 === i["@prefix"]) throw new a.ErrorCoded(`Tried to use keyword aliases as prefix: '${n}': '${JSON.stringify(i)}'`, a.ERROR_CODES.INVALID_TERM_DEFINITION);
          for (; u.Util.isPrefixValue(r[n]);) {
            const i = r[n];
            let a = !1;
            if ("string" == typeof i) r[n] = e.expandTerm(i, !0), a = a || i !== r[n];
            else {
              const s = i["@id"],
                o = i["@type"],
                c = !("@prefix" in i) || u.Util.isValidIri(n);
              if ("@id" in i) null != s && "string" == typeof s && (r[n]["@id"] = e.expandTerm(s, !0), a = a || s !== r[n]["@id"]);
              else if (!u.Util.isPotentialKeyword(n) && c) {
                const t = e.expandTerm(n, !0);
                t !== n && (r[n]["@id"] = t, a = !0)
              }!o || "string" != typeof o || "@vocab" === o || i["@container"] && i["@container"]["@type"] || !c || (r[n]["@type"] = e.expandTerm(o, !0), t && o === r[n]["@type"] && (r[n]["@type"] = e.expandTerm(o, !1)), a = a || o !== r[n]["@type"])
            }
            if (!a) break
          }
        }
    }
    normalize(e, {
      processingMode: t,
      normalizeLanguageTags: r
    }) {
      if (r || 1 === t)
        for (const t of Object.keys(e))
          if ("@language" === t && "string" == typeof e[t]) e[t] = e[t].toLowerCase();
          else {
            const r = e[t];
            r && "object" == typeof r && "string" == typeof r["@language"] && (r["@language"] = r["@language"].toLowerCase())
          }
    }
    containersToHash(e) {
      for (const t of Object.keys(e)) {
        const r = e[t];
        if (r && "object" == typeof r)
          if ("string" == typeof r["@container"]) r["@container"] = {
            [r["@container"]]: !0
          };
          else if (Array.isArray(r["@container"])) {
            const e = {};
            for (const t of r["@container"]) e[t] = !0;
            r["@container"] = e
          }
      }
    }
    applyScopedProtected(e, {
      processingMode: t
    }) {
      if (t && t >= 1.1 && e["@protected"]) {
        for (const t of Object.keys(e))
          if (!u.Util.isReservedInternalKeyword(t) && !u.Util.isPotentialKeyword(t) && !u.Util.isTermProtected(e, t)) {
            const r = e[t];
            r && "object" == typeof r ? "@protected" in e[t] || (e[t]["@protected"] = !0) : e[t] = {
              "@id": r,
              "@protected": !0
            }
          } delete e["@protected"]
      }
    }
    validateKeywordRedefinitions(e, t, r) {
      for (const n of Object.keys(t))
        if (u.Util.isTermProtected(e, n)) {
          if ("string" == typeof t[n]) {
            const i = u.Util.isSimpleTermDefinitionPrefix(t[n], r);
            t[n] = {
              "@id": t[n]
            }, i && (t[n]["@prefix"] = !0, e[n]["@prefix"] = !0)
          }
          const i = c(e[n]);
          t[n]["@protected"] = !0;
          if (i !== c(t[n])) throw new a.ErrorCoded(`Attempted to override the protected keyword ${n} from ${JSON.stringify(u.Util.getContextValueId(e[n]))} to ${JSON.stringify(u.Util.getContextValueId(t[n]))}`, a.ERROR_CODES.PROTECTED_TERM_REDEFINITION)
        }
    }
    validate(e, {
      processingMode: t
    }) {
      for (const r of Object.keys(e)) {
        if (u.Util.isReservedInternalKeyword(r)) continue;
        if ("" === r) throw new a.ErrorCoded(`The empty term is not allowed, got: '${r}': '${JSON.stringify(e[r])}'`, a.ERROR_CODES.INVALID_TERM_DEFINITION);
        const n = e[r],
          i = typeof n;
        if (u.Util.isPotentialKeyword(r)) {
          switch (r.substr(1)) {
            case "vocab":
              if (null !== n && "string" !== i) throw new a.ErrorCoded("Found an invalid @vocab IRI: " + n, a.ERROR_CODES.INVALID_VOCAB_MAPPING);
              break;
            case "base":
              if (null !== n && "string" !== i) throw new a.ErrorCoded("Found an invalid @base IRI: " + e[r], a.ERROR_CODES.INVALID_BASE_IRI);
              break;
            case "language":
              null !== n && l.validateLanguage(n, !0, a.ERROR_CODES.INVALID_DEFAULT_LANGUAGE);
              break;
            case "version":
              if (null !== n && "number" !== i) throw new a.ErrorCoded("Found an invalid @version number: " + n, a.ERROR_CODES.INVALID_VERSION_VALUE);
              break;
            case "direction":
              null !== n && l.validateDirection(n, !0);
              break;
            case "propagate":
              if (1 === t) throw new a.ErrorCoded("Found an illegal @propagate keyword: " + n, a.ERROR_CODES.INVALID_CONTEXT_ENTRY);
              if (null !== n && "boolean" !== i) throw new a.ErrorCoded("Found an invalid @propagate value: " + n, a.ERROR_CODES.INVALID_PROPAGATE_VALUE)
          }
          if (u.Util.isValidKeyword(r) && u.Util.isValidKeyword(u.Util.getContextValueId(n))) throw new a.ErrorCoded(`Illegal keyword alias in term value, found: '${r}': '${u.Util.getContextValueId(n)}'`, a.ERROR_CODES.KEYWORD_REDEFINITION)
        } else if (null !== n) switch (i) {
          case "string":
            if (u.Util.getPrefix(n, e) === r) throw new a.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${r}': '${JSON.stringify(n)}'`, a.ERROR_CODES.CYCLIC_IRI_MAPPING);
            if (u.Util.isValidIriWeak(r)) {
              if ("@type" === n) throw new a.ErrorCoded(`IRIs can not be mapped to @type, found: '${r}': '${n}'`, a.ERROR_CODES.INVALID_IRI_MAPPING);
              if (u.Util.isValidIri(n) && n !== new o.JsonLdContextNormalized(e).expandTerm(r)) throw new a.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${r}': '${n}'`, a.ERROR_CODES.INVALID_IRI_MAPPING)
            }
            break;
          case "object":
            if (!(u.Util.isCompactIri(r) || "@id" in n || ("@id" === n["@type"] ? e["@base"] : e["@vocab"]))) throw new a.ErrorCoded(`Missing @id in context entry: '${r}': '${JSON.stringify(n)}'`, a.ERROR_CODES.INVALID_IRI_MAPPING);
            for (const s of Object.keys(n)) {
              const c = n[s];
              if (c) switch (s) {
                case "@id":
                  if (u.Util.isValidKeyword(c) && "@type" !== c && "@id" !== c && "@graph" !== c) throw new a.ErrorCoded(`Illegal keyword alias in term value, found: '${r}': '${JSON.stringify(n)}'`, a.ERROR_CODES.INVALID_IRI_MAPPING);
                  if (u.Util.isValidIriWeak(r)) {
                    if ("@type" === c) throw new a.ErrorCoded(`IRIs can not be mapped to @type, found: '${r}': '${JSON.stringify(n)}'`, a.ERROR_CODES.INVALID_IRI_MAPPING);
                    if (u.Util.isValidIri(c) && c !== new o.JsonLdContextNormalized(e).expandTerm(r)) throw new a.ErrorCoded(`IRIs can not be mapped to other IRIs, found: '${r}': '${JSON.stringify(n)}'`, a.ERROR_CODES.INVALID_IRI_MAPPING)
                  }
                  if ("string" != typeof c) throw new a.ErrorCoded(`Detected non-string @id in context entry: '${r}': '${JSON.stringify(n)}'`, a.ERROR_CODES.INVALID_IRI_MAPPING);
                  if (u.Util.getPrefix(c, e) === r) throw new a.ErrorCoded(`Detected cyclical IRI mapping in context entry: '${r}': '${JSON.stringify(n)}'`, a.ERROR_CODES.CYCLIC_IRI_MAPPING);
                  break;
                case "@type":
                  if ("@type" === n["@container"] && "@id" !== c && "@vocab" !== c) throw new a.ErrorCoded(`@container: @type only allows @type: @id or @vocab, but got: '${r}': '${c}'`, a.ERROR_CODES.INVALID_TYPE_MAPPING);
                  if ("string" != typeof c) throw new a.ErrorCoded(`The value of an '@type' must be a string, got '${JSON.stringify(i)}'`, a.ERROR_CODES.INVALID_TYPE_MAPPING);
                  if (!("@id" === c || "@vocab" === c || 1 !== t && "@json" === c || 1 !== t && "@none" === c || "_" !== c[0] && u.Util.isValidIri(c))) throw new a.ErrorCoded(`A context @type must be an absolute IRI, found: '${r}': '${c}'`, a.ERROR_CODES.INVALID_TYPE_MAPPING);
                  break;
                case "@reverse":
                  if ("string" == typeof c && n["@id"] && n["@id"] !== c) throw new a.ErrorCoded(`Found non-matching @id and @reverse term values in '${r}':'${c}' and '${n["@id"]}'`, a.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                  if ("@nest" in n) throw new a.ErrorCoded(`@nest is not allowed in the reverse property '${r}'`, a.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                  break;
                case "@container":
                  if (1 === t && (Object.keys(c).length > 1 || u.Util.CONTAINERS_1_0.indexOf(Object.keys(c)[0]) < 0)) throw new a.ErrorCoded(`Invalid term @container for '${r}' ('${Object.keys(c)}') in 1.0, must be only one of ${u.Util.CONTAINERS_1_0.join(", ")}`, a.ERROR_CODES.INVALID_CONTAINER_MAPPING);
                  for (const e of Object.keys(c)) {
                    if ("@list" === e && n["@reverse"]) throw new a.ErrorCoded(`Term value can not be @container: @list and @reverse at the same time on '${r}'`, a.ERROR_CODES.INVALID_REVERSE_PROPERTY);
                    if (u.Util.CONTAINERS.indexOf(e) < 0) throw new a.ErrorCoded(`Invalid term @container for '${r}' ('${e}'), must be one of ${u.Util.CONTAINERS.join(", ")}`, a.ERROR_CODES.INVALID_CONTAINER_MAPPING)
                  }
                  break;
                case "@language":
                  l.validateLanguage(c, !0, a.ERROR_CODES.INVALID_LANGUAGE_MAPPING);
                  break;
                case "@direction":
                  l.validateDirection(c, !0);
                  break;
                case "@prefix":
                  if (null !== c && "boolean" != typeof c) throw new a.ErrorCoded(`Found an invalid term @prefix boolean in: '${r}': '${JSON.stringify(n)}'`, a.ERROR_CODES.INVALID_PREFIX_VALUE);
                  if (!("@id" in n) && !u.Util.isValidIri(r)) throw new a.ErrorCoded(`Invalid @prefix definition for '${r}' ('${JSON.stringify(n)}'`, a.ERROR_CODES.INVALID_TERM_DEFINITION);
                  break;
                case "@index":
                  if (1 === t || !n["@container"] || !n["@container"]["@index"]) throw new a.ErrorCoded(`Attempt to add illegal key to value object: '${r}': '${JSON.stringify(n)}'`, a.ERROR_CODES.INVALID_TERM_DEFINITION);
                  break;
                case "@nest":
                  if (u.Util.isPotentialKeyword(c) && "@nest" !== c) throw new a.ErrorCoded(`Found an invalid term @nest value in: '${r}': '${JSON.stringify(n)}'`, a.ERROR_CODES.INVALID_NEST_VALUE)
              }
            }
            break;
          default:
            throw new a.ErrorCoded(`Found an invalid term value: '${r}': '${n}'`, a.ERROR_CODES.INVALID_TERM_DEFINITION)
        }
      }
    }
    applyBaseEntry(e, t, r) {
      return "string" == typeof e || (r && !("@base" in e) && t.parentContext && "@base" in t.parentContext && (e["@base"] = t.parentContext["@base"], t.parentContext["@__baseDocument"] && (e["@__baseDocument"] = !0)), t.baseIRI && !t.external && ("@base" in e ? null === e["@base"] || "string" != typeof e["@base"] || u.Util.isValidIri(e["@base"]) || (e["@base"] = i.resolve(e["@base"], t.parentContext && t.parentContext["@base"] || t.baseIRI)) : (e["@base"] = t.baseIRI, e["@__baseDocument"] = !0))), e
    }
    normalizeContextIri(e, t) {
      if (!u.Util.isValidIri(e) && (e = i.resolve(e, t), !u.Util.isValidIri(e))) throw new Error("Invalid context IRI: " + e);
      return this.redirectSchemaOrgHttps && e.startsWith("http://schema.org") && (e = "https://schema.org/"), e
    }
    parseInnerContexts(e, t) {
      return n(this, void 0, void 0, (function*() {
        for (const r of Object.keys(e)) {
          const n = e[r];
          if (n && "object" == typeof n && "@context" in n && null !== n["@context"]) {
            if (this.validateContext) try {
              const i = Object.assign({}, e);
              i[r] = Object.assign({}, i[r]), delete i[r]["@context"], yield this.parse(n["@context"], Object.assign(Object.assign({}, t), {
                parentContext: i,
                ignoreProtection: !0,
                ignoreRemoteScopedContexts: !0
              }))
            } catch (e) {
              throw new a.ErrorCoded(e.message, a.ERROR_CODES.INVALID_SCOPED_CONTEXT)
            }
            n["@context"] = (yield this.parse(n["@context"], Object.assign(Object.assign({}, t), {
              minimalProcessing: !0,
              ignoreRemoteScopedContexts: !0,
              parentContext: e
            }))).getContextRaw()
          }
        }
        return e
      }))
    }
    parse(e, r = {
      processingMode: l.DEFAULT_PROCESSING_MODE
    }) {
      return n(this, void 0, void 0, (function*() {
        const {
          baseIRI: n,
          parentContext: i,
          external: s,
          processingMode: c,
          normalizeLanguageTags: h,
          ignoreProtection: d,
          minimalProcessing: p
        } = r;
        let f = i;
        const g = r.remoteContexts || {};
        if (Object.keys(g).length >= this.remoteContextsDepthLimit) throw new a.ErrorCoded("Detected an overflow in remote context inclusions: " + Object.keys(g), a.ERROR_CODES.CONTEXT_OVERFLOW);
        if (null == e) {
          if (!d && f && u.Util.hasProtectedTerms(f)) throw new a.ErrorCoded("Illegal context nullification when terms are protected", a.ERROR_CODES.INVALID_CONTEXT_NULLIFICATION);
          return new o.JsonLdContextNormalized(this.applyBaseEntry({}, r, !1))
        }
        if ("string" == typeof e) {
          const t = this.normalizeContextIri(e, n),
            i = this.getOverriddenLoad(t, r);
          if (i) return new o.JsonLdContextNormalized(i);
          const a = yield this.parse(yield this.load(t), Object.assign(Object.assign({}, r), {
            baseIRI: t,
            external: !0,
            remoteContexts: Object.assign(Object.assign({}, g), {
              [t]: !0
            })
          }));
          return this.applyBaseEntry(a.getContextRaw(), r, !0), a
        }
        if (Array.isArray(e)) {
          const t = [],
            i = yield Promise.all(e.map((e, i) => {
              if ("string" == typeof e) {
                const a = this.normalizeContextIri(e, n);
                t[i] = a;
                const s = this.getOverriddenLoad(a, r);
                return s || this.load(a)
              }
              return e
            }));
          if (p) return new o.JsonLdContextNormalized(i);
          const a = yield i.reduce((e, n, i) => e.then(e => this.parse(n, Object.assign(Object.assign({}, r), {
            baseIRI: t[i] || r.baseIRI,
            external: !!t[i] || r.external,
            parentContext: e.getContextRaw(),
            remoteContexts: t[i] ? Object.assign(Object.assign({}, g), {
              [t[i]]: !0
            }) : g
          }))), Promise.resolve(new o.JsonLdContextNormalized(f || {})));
          return this.applyBaseEntry(a.getContextRaw(), r, !0), a
        }
        if ("object" == typeof e) {
          if ("@context" in e) return yield this.parse(e["@context"], r);
          e = JSON.parse(JSON.stringify(e)), f && (f = JSON.parse(JSON.stringify(f)));
          let i = {};
          if (s && delete e["@base"], this.applyBaseEntry(e, r, !0), this.containersToHash(e), p) return new o.JsonLdContextNormalized(e);
          let u = {};
          if ("@import" in e) {
            if (!(c && c >= 1.1)) throw new a.ErrorCoded("Context importing is not supported in JSON-LD 1.0", a.ERROR_CODES.INVALID_CONTEXT_ENTRY);
            if ("string" != typeof e["@import"]) throw new a.ErrorCoded("An @import value must be a string, but got " + typeof e["@import"], a.ERROR_CODES.INVALID_IMPORT_VALUE);
            u = yield this.loadImportContext(this.normalizeContextIri(e["@import"], n)), delete e["@import"]
          }
          i = Object.assign(Object.assign(Object.assign(Object.assign({}, i), f), u), e);
          const g = new o.JsonLdContextNormalized(i);
          return yield this.parseInnerContexts(i, r), !d && f && c && c >= 1.1 && this.validateKeywordRedefinitions(f, i, t.defaultExpandOptions), (i && i["@version"] || c || l.DEFAULT_PROCESSING_MODE) >= 1.1 && (e["@vocab"] && "string" == typeof e["@vocab"] || "" === e["@vocab"]) && e["@vocab"].indexOf(":") < 0 && f && "@vocab" in f && (i["@vocab"] = f["@vocab"] + e["@vocab"]), this.idifyReverseTerms(i), this.expandPrefixedTerms(g, this.expandContentTypeToBase), this.normalize(i, {
            processingMode: c,
            normalizeLanguageTags: h
          }), this.applyScopedProtected(i, {
            processingMode: c
          }), this.validateContext && this.validate(i, {
            processingMode: c
          }), g
        }
        throw new a.ErrorCoded("Tried parsing a context that is not a string, array or object, but got " + e, a.ERROR_CODES.INVALID_LOCAL_CONTEXT)
      }))
    }
    load(e) {
      return n(this, void 0, void 0, (function*() {
        const t = this.documentCache[e];
        if (t) return "string" == typeof t ? t : Array.isArray(t) ? t.slice() : Object.assign({}, t);
        let r;
        try {
          r = yield this.documentLoader.load(e)
        } catch (t) {
          throw new a.ErrorCoded(`Failed to load remote context ${e}: ${t.message}`, a.ERROR_CODES.LOADING_REMOTE_CONTEXT_FAILED)
        }
        if (!("@context" in r)) throw new a.ErrorCoded("Missing @context in remote context at " + e, a.ERROR_CODES.INVALID_REMOTE_CONTEXT);
        return this.documentCache[e] = r["@context"]
      }))
    }
    getOverriddenLoad(e, t) {
      if (e in (t.remoteContexts || {})) {
        if (t.ignoreRemoteScopedContexts) return e;
        throw new a.ErrorCoded("Detected a cyclic context inclusion of " + e, a.ERROR_CODES.RECURSIVE_CONTEXT_INCLUSION)
      }
      return null
    }
    loadImportContext(e) {
      return n(this, void 0, void 0, (function*() {
        const t = yield this.load(e);
        if ("object" != typeof t || Array.isArray(t)) throw new a.ErrorCoded("An imported context must be a single object: " + e, a.ERROR_CODES.INVALID_REMOTE_CONTEXT);
        if ("@import" in t) throw new a.ErrorCoded("An imported context can not import another context: " + e, a.ERROR_CODES.INVALID_CONTEXT_ENTRY);
        return t
      }))
    }
  }
  t.ContextParser = l, l.DEFAULT_PROCESSING_MODE = 1.1, t.defaultExpandOptions = {
    allowPrefixForcing: !0,
    allowPrefixNonGenDelims: !1,
    allowVocabRelativeToBase: !0
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__awaiter || function(e, t, r, n) {
    return new(r || (r = Promise))((function(i, a) {
      function s(e) {
        try {
          u(n.next(e))
        } catch (e) {
          a(e)
        }
      }

      function o(e) {
        try {
          u(n.throw(e))
        } catch (e) {
          a(e)
        }
      }

      function u(e) {
        var t;
        e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
          e(t)
        }))).then(s, o)
      }
      u((n = n.apply(e, t || [])).next())
    }))
  };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.FetchDocumentLoader = void 0, r(45);
  const i = r(47),
    a = r(151),
    s = r(13);
  t.FetchDocumentLoader = class {
    constructor(e) {
      this.fetcher = e
    }
    load(e) {
      return n(this, void 0, void 0, (function*() {
        const t = yield(this.fetcher || fetch)(e, {
          headers: new Headers({
            accept: "application/ld+json"
          })
        });
        if (t.ok && t.headers) {
          let r = t.headers.get("Content-Type");
          if (r) {
            const e = r.indexOf(";");
            e > 0 && (r = r.substr(0, e))
          }
          if ("application/ld+json" === r) return yield t.json();
          if (t.headers.has("Link")) {
            let r;
            if (t.headers.forEach((t, n) => {
              if ("link" === n) {
                const n = a.parse(t);
                for (const t of n.get("type", "application/ld+json"))
                  if ("alternate" === t.rel) {
                    if (r) throw new Error("Multiple JSON-LD alternate links were found on " + e);
                    r = s.resolve(t.uri, e)
                  }
              }
            }), r) return this.load(r)
          }
          throw new i.ErrorCoded("Unsupported JSON-LD media type " + r, i.ERROR_CODES.LOADING_DOCUMENT_FAILED)
        }
        throw new Error(t.statusText || "Status code: " + t.status)
      }))
    }
  }
}, function(e, t, r) {
  "use strict";
  (function(t) {
    var r = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i,
      n = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
      i = /\s|\uFEFF|\xA0/,
      a = /\r?\n[\x20\x09]+/g,
      s = /[;,"]/,
      o = /[;,"]|\s/,
      u = /^[!#$%&'*+\-\.^_`|~\da-zA-Z]+$/,
      c = 1,
      l = 2,
      h = 4;

    function d(e) {
      return e.replace(n, "")
    }

    function p(e) {
      return i.test(e)
    }

    function f(e, t) {
      for (; p(e[t]);) t++;
      return t
    }

    function g(e) {
      return o.test(e) || !u.test(e)
    }
    class m {
      constructor(e) {
        this.refs = [], e && this.parse(e)
      }
      rel(e) {
        for (var t = [], r = e.toLowerCase(), n = 0; n < this.refs.length; n++) this.refs[n].rel.toLowerCase() === r && t.push(this.refs[n]);
        return t
      }
      get(e, t) {
        e = e.toLowerCase();
        for (var r = [], n = 0; n < this.refs.length; n++) this.refs[n][e] === t && r.push(this.refs[n]);
        return r
      }
      set(e) {
        return this.refs.push(e), this
      }
      has(e, t) {
        e = e.toLowerCase();
        for (var r = 0; r < this.refs.length; r++)
          if (this.refs[r][e] === t) return !0;
        return !1
      }
      parse(e, t) {
        e = d(e = (t = t || 0) ? e.slice(t) : e).replace(a, "");
        for (var r = c, n = e.length, i = (t = 0, null); t < n;)
          if (r === c) {
            if (p(e[t])) {
              t++;
              continue
            }
            if ("<" !== e[t]) throw new Error('Unexpected character "' + e[t] + '" at offset ' + t);
            if (null != i && (null != i.rel ? this.refs.push(...m.expandRelations(i)) : this.refs.push(i)), -1 === (g = e.indexOf(">", t))) throw new Error("Expected end of URI delimiter at offset " + t);
            i = {
              uri: e.slice(t + 1, g)
            }, t = g, r = l, t++
          } else if (r === l) {
            if (p(e[t])) {
              t++;
              continue
            }
            if (";" === e[t]) r = h, t++;
            else {
              if ("," !== e[t]) throw new Error('Unexpected character "' + e[t] + '" at offset ' + t);
              r = c, t++
            }
          } else {
            if (r !== h) throw new Error('Unknown parser state "' + r + '"');
            if (";" === e[t] || p(e[t])) {
              t++;
              continue
            }
            if (-1 === (g = e.indexOf("=", t))) throw new Error("Expected attribute delimiter at offset " + t);
            var o = d(e.slice(t, g)).toLowerCase(),
              u = "";
            if ('"' === e[t = f(e, t = g + 1)])
              for (t++; t < n;) {
                if ('"' === e[t]) {
                  t++;
                  break
                }
                "\\" === e[t] && t++, u += e[t], t++
              } else {
              for (var g = t + 1; !s.test(e[g]) && g < n;) g++;
              u = e.slice(t, g), t = g
            }
            switch (i[o] && m.isSingleOccurenceAttr(o) || ("*" === o[o.length - 1] ? i[o] = m.parseExtendedValue(u) : (u = "type" === o ? u.toLowerCase() : u, null != i[o] ? Array.isArray(i[o]) ? i[o].push(u) : i[o] = [i[o], u] : i[o] = u)), e[t]) {
              case ",":
                r = c;
                break;
              case ";":
                r = h
            }
            t++
          }
        return null != i && (null != i.rel ? this.refs.push(...m.expandRelations(i)) : this.refs.push(i)), i = null, this
      }
      toString() {
        for (var e = [], t = "", r = null, n = 0; n < this.refs.length; n++) r = this.refs[n], t = Object.keys(this.refs[n]).reduce((function(e, t) {
          return "uri" === t ? e : e + "; " + m.formatAttribute(t, r[t])
        }), "<" + r.uri + ">"), e.push(t);
        return e.join(", ")
      }
    }
    m.isCompatibleEncoding = function(e) {
      return r.test(e)
    }, m.parse = function(e, t) {
      return (new m).parse(e, t)
    }, m.isSingleOccurenceAttr = function(e) {
      return "rel" === e || "type" === e || "media" === e || "title" === e || "title*" === e
    }, m.isTokenAttr = function(e) {
      return "rel" === e || "type" === e || "anchor" === e
    }, m.escapeQuotes = function(e) {
      return e.replace(/"/g, '\\"')
    }, m.expandRelations = function(e) {
      return e.rel.split(" ").map((function(t) {
        var r = Object.assign({}, e);
        return r.rel = t, r
      }))
    }, m.parseExtendedValue = function(e) {
      var t = /([^']+)?(?:'([^']+)')?(.+)/.exec(e);
      return {
        language: t[2].toLowerCase(),
        encoding: m.isCompatibleEncoding(t[1]) ? null : t[1].toLowerCase(),
        value: m.isCompatibleEncoding(t[1]) ? decodeURIComponent(t[3]) : t[3]
      }
    }, m.formatExtendedAttribute = function(e, r) {
      var n = (r.encoding || "utf-8").toUpperCase();
      return e + "=" + n + "'" + (r.language || "en") + "'" + (t.isBuffer(r.value) && m.isCompatibleEncoding(n) ? r.value.toString(n) : t.isBuffer(r.value) ? r.value.toString("hex").replace(/[0-9a-f]{2}/gi, "%$1") : encodeURIComponent(r.value))
    }, m.formatAttribute = function(e, t) {
      return Array.isArray(t) ? t.map(t => m.formatAttribute(e, t)).join("; ") : "*" === e[e.length - 1] || "string" != typeof t ? m.formatExtendedAttribute(e, t) : (m.isTokenAttr(e) ? t = g(t) ? '"' + m.escapeQuotes(t) + '"' : m.escapeQuotes(t) : g(t) && (t = '"' + (t = (t = encodeURIComponent(t)).replace(/%20/g, " ").replace(/%2C/g, ",").replace(/%3B/g, ";")) + '"'), e + "=" + t)
    }, e.exports = m
  }).call(this, r(11).Buffer)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.JsonLdContextNormalized = void 0;
  const n = r(13),
    i = r(149),
    a = r(47),
    s = r(83);
  t.JsonLdContextNormalized = class {
    constructor(e) {
      this.contextRaw = e
    }
    getContextRaw() {
      return this.contextRaw
    }
    expandTerm(e, t, r = i.defaultExpandOptions) {
      const o = this.contextRaw[e];
      if (null === o || o && null === o["@id"]) return null;
      let u = !0;
      if (o && t) {
        const t = s.Util.getContextValueId(o);
        if (t && t !== e) {
          if ("string" == typeof t && (s.Util.isValidIri(t) || s.Util.isValidKeyword(t))) return t;
          s.Util.isPotentialKeyword(t) || (u = !1)
        }
      }
      const c = s.Util.getPrefix(e, this.contextRaw),
        l = this.contextRaw["@vocab"],
        h = (!!l || "" === l) && l.indexOf(":") < 0,
        d = this.contextRaw["@base"],
        p = s.Util.isPotentialKeyword(e);
      if (c) {
        const t = this.contextRaw[c],
          n = s.Util.getContextValueId(t);
        if (n) {
          if ("string" != typeof t && r.allowPrefixForcing) {
            if ("_" !== n[0] && !p && !t["@prefix"] && !(e in this.contextRaw)) return e
          } else if (!s.Util.isSimpleTermDefinitionPrefix(n, r)) return e;
          return n + e.substr(c.length + 1)
        }
      } else {
        if (t && (l || "" === l || r.allowVocabRelativeToBase && d && h) && !p && !s.Util.isCompactIri(e)) {
          if (h) {
            if (r.allowVocabRelativeToBase) return n.resolve(l, d) + e;
            throw new a.ErrorCoded(`Relative vocab expansion for term '${e}' with vocab '${l}' is not allowed.`, a.ERROR_CODES.INVALID_VOCAB_MAPPING)
          }
          return l + e
        }
        if (!t && d && !p && !s.Util.isCompactIri(e)) return n.resolve(e, d)
      }
      if (u) return e;
      throw new a.ErrorCoded(`Invalid IRI mapping found for context entry '${e}': '${JSON.stringify(o)}'`, a.ERROR_CODES.INVALID_IRI_MAPPING)
    }
    compactIri(e, t) {
      if (t && this.contextRaw["@vocab"] && e.startsWith(this.contextRaw["@vocab"])) return e.substr(this.contextRaw["@vocab"].length);
      if (!t && this.contextRaw["@base"] && e.startsWith(this.contextRaw["@base"])) return e.substr(this.contextRaw["@base"].length);
      const r = {
        prefix: "",
        suffix: e
      };
      for (const n in this.contextRaw) {
        const i = this.contextRaw[n];
        if (i && !s.Util.isPotentialKeyword(n)) {
          const a = s.Util.getContextValueId(i);
          if (e.startsWith(a)) {
            const i = e.substr(a.length);
            if (i) i.length < r.suffix.length && (r.prefix = n, r.suffix = i);
            else if (t) return n
          }
        }
      }
      return r.prefix ? r.prefix + ":" + r.suffix : e
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Util = void 0;
  const n = r(9);
  class i {
    static termToValue(e, t, r = {
      compactIds: !1,
      useNativeTypes: !1
    }) {
      switch (e.termType) {
        case "NamedNode":
          const a = t.compactIri(e.value, r.vocab);
          return r.compactIds ? a : {
            "@id": a
          };
        case "DefaultGraph":
          return r.compactIds ? e.value : {
            "@id": e.value
          };
        case "BlankNode":
          const s = "_:" + e.value;
          return r.compactIds ? s : {
            "@id": s
          };
        case "Literal":
          if (e.datatype.value === i.RDF_JSON) {
            let t;
            try {
              t = JSON.parse(e.value)
            } catch (e) {
              throw new n.ErrorCoded("Invalid JSON literal: " + e.message, n.ERROR_CODES.INVALID_JSON_LITERAL)
            }
            return {
              "@value": t,
              "@type": "@json"
            }
          }
          if ("i18n-datatype" === r.rdfDirection && e.datatype.value.startsWith(i.I18N)) {
            const [t, r] = e.datatype.value.substr(i.I18N.length, e.datatype.value.length).split("_");
            return Object.assign(Object.assign({
              "@value": e.value
            }, t ? {
              "@language": t
            } : {}), r ? {
              "@direction": r
            } : {})
          }
          const o = e.datatype.value === i.XSD_STRING,
            u = {
              "@value": !o && r.useNativeTypes ? i.stringToNativeType(e.value, e.datatype.value) : e.value
            };
          return e.language ? Object.assign(Object.assign({}, u), {
            "@language": e.language
          }) : o || "string" != typeof u["@value"] ? u : Object.assign(Object.assign({}, u), {
            "@type": e.datatype.value
          })
      }
    }
    static stringToNativeType(e, t) {
      if (t.startsWith(i.XSD)) {
        switch (t.substr(i.XSD.length)) {
          case "boolean":
            if ("true" === e) return !0;
            if ("false" === e) return !1;
            throw new Error(`Invalid xsd:boolean value '${e}'`);
          case "integer":
          case "number":
          case "int":
          case "byte":
          case "long":
            const t = parseInt(e, 10);
            if (isNaN(t)) throw new Error(`Invalid xsd:integer value '${e}'`);
            return t;
          case "float":
          case "double":
            const r = parseFloat(e);
            if (isNaN(r)) throw new Error(`Invalid xsd:float value '${e}'`);
            return r
        }
      }
      return e
    }
  }
  t.Util = i, i.XSD = "http://www.w3.org/2001/XMLSchema#", i.XSD_STRING = i.XSD + "string", i.RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#", i.RDF_TYPE = i.RDF + "type", i.RDF_JSON = i.RDF + "JSON", i.I18N = "https://www.w3.org/ns/i18n#"
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(336), t), i(r(337), t), i(r(155), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.RdfJsQuadSource = void 0;
  const n = r(3);
  class i {
    constructor(e) {
      this.source = e
    }
    static nullifyVariables(e) {
      return e && "Variable" !== e.termType ? e : void 0
    }
    match(e, t, r, a) {
      const s = this.source.match(i.nullifyVariables(e), i.nullifyVariables(t), i.nullifyVariables(r), i.nullifyVariables(a)),
        o = n.wrap(s, {
          autoStart: !1
        });
      return this.setMetadata(o, e, t, r, a).catch(e => o.destroy(e)), o
    }
    async setMetadata(e, t, r, n, a) {
      let s;
      if (this.source.countQuads) s = await this.source.countQuads(i.nullifyVariables(t), i.nullifyVariables(r), i.nullifyVariables(n), i.nullifyVariables(a));
      else {
        let e = 0;
        s = await new Promise((s, o) => {
          const u = this.source.match(i.nullifyVariables(t), i.nullifyVariables(r), i.nullifyVariables(n), i.nullifyVariables(a));
          u.on("error", o), u.on("end", () => s(e)), u.on("data", () => e++)
        })
      }
      e.setProperty("metadata", {
        totalItems: s
      })
    }
  }
  t.RdfJsQuadSource = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(157), t), i(r(340), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfMetadata = void 0;
  const n = r(0);
  class i extends n.Actor {
    constructor(e) {
      super(e)
    }
  }
  t.ActorRdfMetadata = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfMetadataExtract = void 0;
  const n = r(0);
  class i extends n.Actor {
    constructor(e) {
      super(e)
    }
  }
  t.ActorRdfMetadataExtract = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(160), t), i(r(369), t), i(r(48), t), i(r(370), t), i(r(162), t)
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(161), t), i(r(353), t), i(r(62), t), i(r(86), t), i(r(363), t), i(r(364), t), i(r(365), t), i(r(63), t), i(r(366), t), i(r(367), t), i(r(368), t)
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(38), t), i(r(348), t), i(r(349), t), i(r(350), t), i(r(351), t), i(r(352), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Util = void 0;
  const n = r(5),
    i = r(9),
    a = r(6);
  t.Util = class {
    constructor(e) {
      this.nodeHandlers = {}, this.nodeValueHandlers = {}, this.directiveNodeHandlers = {}, this.settings = e, this.dataFactory = e.dataFactory || new n.DataFactory, this.operationFactory = new a.Factory(this.dataFactory), this.contextParser = new i.ContextParser
    }
    registerNodeHandler(e) {
      this.nodeHandlers[e.targetKind] = e
    }
    registerNodeValueHandler(e) {
      this.nodeValueHandlers[e.targetKind] = e
    }
    registerDirectiveNodeHandler(e) {
      this.directiveNodeHandlers[e.targetKind] = e
    }
    handleNode(e, t) {
      const r = this.nodeHandlers[e.kind];
      if (!r) throw new Error(`Unsupported GraphQL node '${e.kind}'`);
      return r.handle(e, t)
    }
    handleNodeValue(e, t, r) {
      const n = this.nodeValueHandlers[e.kind];
      if (!n) throw new Error(`Unsupported GraphQL value node '${e.kind}'`);
      return n.handle(e, t, r)
    }
    handleDirectiveNode(e, t) {
      const r = this.directiveNodeHandlers[e.directive.name.value];
      return r ? r.handle(e, t) : null
    }
    joinOperations(e) {
      if (1 === e.length) return e[0];
      const t = [],
        r = [];
      for (const n of e) "bgp" === n.type ? t.push(n) : r.push(n);
      if (t.length === e.length) return this.joinOperationsAsBgp(t);
      if (t.length === e.length - 1 && "leftjoin" === r[0].type && "bgp" === r[0].left.type) {
        const e = r[0];
        return t.push(e.left), this.operationFactory.createLeftJoin(this.joinOperationsAsBgp(t), e.right)
      }
      return r.length === e.length ? this.joinOperationsAsNestedJoin(r) : this.joinOperationsAsNestedJoin([this.joinOperationsAsBgp(t), this.joinOperationsAsNestedJoin(r)])
    }
    joinOperationsAsBgp(e) {
      return this.operationFactory.createBgp([].concat.apply([], e.map(e => e.patterns)))
    }
    joinOperationsAsNestedJoin(e) {
      return e.reverse().reduce((e, t) => e ? this.operationFactory.createJoin(t, e) : t, null)
    }
    appendFieldToPath(e, t) {
      return e.concat([t])
    }
    getFieldLabel(e) {
      return (e.alias ? e.alias : e.name).value
    }
    nameToVariable(e, t) {
      return this.dataFactory.variable((t.path.length ? t.path.join(this.settings.variableDelimiter) + this.settings.variableDelimiter : "") + e)
    }
    valueToNamedNode(e, t) {
      const r = t.expandTerm(e, !0);
      if (this.settings.requireContext && !r) throw new Error("No context entry was found for " + e);
      return this.dataFactory.namedNode(r || e)
    }
    getArgument(e, t) {
      if (e)
        for (const r of e)
          if (r.name.value === t) return r;
      return null
    }
    newTypePattern(e, t, r) {
      return this.operationFactory.createPattern(e, this.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"), this.valueToNamedNode(t.name.value, r.context), r.graph)
    }
    createQuadPattern(e, t, r, n, i) {
      const a = this.valueToNamedNode(t.value, i);
      return i && i.getContextRaw()[t.value] && i.getContextRaw()[t.value]["@reverse"] ? this.operationFactory.createPattern(r, a, e, n) : this.operationFactory.createPattern(e, a, r, n)
    }
    createQuadPath(e, t, r, n, i, a) {
      const s = this.valueToNamedNode(t.value, a);
      let o = this.operationFactory.createLink(s);
      for (const e of r.values) {
        if ("EnumValue" !== e.kind) throw new Error("Invalid value type for 'alt' argument, must be EnumValue, but got " + e.kind);
        o = this.operationFactory.createAlt(o, this.operationFactory.createLink(this.valueToNamedNode(e.value, a)))
      }
      return a && a.getContextRaw()[t.value] && a.getContextRaw()[t.value]["@reverse"] ? this.operationFactory.createPath(n, o, e, i) : this.operationFactory.createPath(e, o, n, i)
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.storeStream = void 0;
  const n = r(41);
  t.storeStream = function(e) {
    const t = new n.Store;
    return new Promise(r => t.import(e).once("end", () => r(t)))
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.GraphQlQueryEngine = void 0;
  const n = r(165);
  t.GraphQlQueryEngine = class {
    constructor(e) {
      this.comunicaEngine = e
    }
    async query(e, t) {
      const {
        data: r
      } = await this.comunicaEngine.resultToString(await this.comunicaEngine.query(e, t), "application/sparql-results+json");
      return JSON.parse(await n(r))
    }
  }
}, function(e, t, r) {
  var n = r(372);
  e.exports = function(e, t, r) {
    "function" == typeof t && (r = t, t = null), r = r || function() {};
    var i = "";
    return new n((function(n, a) {
      e.on("data", (function(e) {
        i += "string" == typeof t ? e.toString(t) : e.toString()
      })), e.on("end", (function() {
        n(i), r(null, i)
      })), e.on("error", (function(e) {
        a(e), r(e)
      }))
    }))
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorHttpInvalidate = void 0;
  const n = r(0);
  class i extends n.Actor {
    constructor(e) {
      super(e)
    }
  }
  t.ActorHttpInvalidate = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(389), t)
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(396), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.JsonLdParser = void 0;
  const n = r(123),
    i = r(9),
    a = r(2),
    s = r(427),
    o = r(170),
    u = r(432),
    c = r(64),
    l = r(433),
    h = r(434),
    d = r(435),
    p = r(436),
    f = r(437),
    g = r(438),
    m = r(439),
    y = r(440),
    b = r(441),
    _ = r(27),
    v = r(151);
  class w extends a.Transform {
    constructor(e) {
      super({
        readableObjectMode: !0
      }), e = e || {}, this.options = e, this.parsingContext = new b.ParsingContext(Object.assign({
        parser: this
      }, e)), this.util = new _.Util({
        dataFactory: e.dataFactory,
        parsingContext: this.parsingContext
      }), this.jsonParser = new n, this.contextJobs = [], this.typeJobs = [], this.contextAwaitingJobs = [], this.lastDepth = 0, this.lastKeys = [], this.lastOnValueJob = Promise.resolve(), this.attachJsonParserListeners()
    }
    static fromHttpResponse(e, t, r, n) {
      let a, s;
      if ("application/ld+json" !== t) {
        if ("application/json" !== t && !t.endsWith("+json")) throw new i.ErrorCoded("Unsupported JSON-LD media type " + t, i.ERROR_CODES.LOADING_DOCUMENT_FAILED);
        if (r && r.has("Link") && r.forEach((t, r) => {
          if ("link" === r) {
            const r = v.parse(t);
            for (const t of r.get("rel", "http://www.w3.org/ns/json-ld#context")) {
              if (a) throw new i.ErrorCoded("Multiple JSON-LD context link headers were found on " + e, i.ERROR_CODES.MULTIPLE_CONTEXT_LINK_HEADERS);
              a = t.uri
            }
          }
        }), !a) throw new i.ErrorCoded(`Missing context link header for media type ${t} on ${e}`, i.ERROR_CODES.LOADING_DOCUMENT_FAILED)
      }
      if (r && r.has("Content-Type")) {
        const e = r.get("Content-Type"),
          t = /; *profile=([^"]*)/.exec(e);
        t && "http://www.w3.org/ns/json-ld#streaming" === t[1] && (s = !0)
      }
      return new w(Object.assign({
        baseIRI: e,
        context: a,
        streamingProfile: s
      }, n || {}))
    }
    import(e) {
      const t = new a.PassThrough({
        readableObjectMode: !0
      });
      e.on("error", e => r.emit("error", e)), e.on("data", e => t.push(e)), e.on("end", () => t.push(null));
      const r = t.pipe(new w(this.options));
      return r
    }
    _transform(e, t, r) {
      this.jsonParser.write(e), this.lastOnValueJob.then(() => r(), e => r(e))
    }
    async newOnValueJob(e, t, r, n) {
      let a = !0;
      if (n && r < this.lastDepth) {
        const e = this.parsingContext.listPointerStack[this.lastDepth];
        e && (e.value && this.emit("data", this.util.dataFactory.quad(e.value, this.util.rdfRest, this.util.rdfNil, this.util.getDefaultGraph())), e.listId.listHead = !0, this.parsingContext.idStack[e.listRootDepth + 1] = [e.listId], this.parsingContext.listPointerStack.splice(this.lastDepth, 1)), await o.EntryHandlerContainer.isBufferableContainerHandler(this.parsingContext, this.lastKeys, this.lastDepth) ? (this.parsingContext.pendingContainerFlushBuffers.push({
          depth: this.lastDepth,
          keys: this.lastKeys.slice(0, this.lastKeys.length)
        }), a = !1) : await this.flushBuffer(this.lastDepth, this.lastKeys)
      }
      const s = await this.util.unaliasKeyword(e[r], e, r),
        u = await this.util.unaliasKeywordParent(e, r);
      this.parsingContext.emittedStack[r] = !0;
      let c = !0;
      i.Util.isValidKeyword(s) && "@reverse" === u && this.emit("error", new i.ErrorCoded(`Found the @id '${t}' inside an @reverse property`, i.ERROR_CODES.INVALID_REVERSE_PROPERTY_MAP));
      let l = !1;
      this.parsingContext.validationStack.length > 1 && (l = this.parsingContext.validationStack[this.parsingContext.validationStack.length - 1].property);
      for (let t = Math.max(1, this.parsingContext.validationStack.length - 1); t < e.length - 1; t++) {
        const n = this.parsingContext.validationStack[t] || (this.parsingContext.validationStack[t] = await this.validateKey(e.slice(0, t + 1), t, l));
        if (!n.valid) {
          this.parsingContext.emittedStack[r] = !1, c = !1;
          break
        }!l && n.property && (l = !0)
      }
      if (this.util.isLiteral(r) && (c = !1), c)
        for (const n of w.ENTRY_HANDLERS) {
          const i = await n.test(this.parsingContext, this.util, s, e, r);
          if (i) {
            await n.handle(this.parsingContext, this.util, s, e, t, r, i), n.isStackProcessor() && (this.parsingContext.processingStack[r] = !0);
            break
          }
        }
      0 === r && Array.isArray(t) && await this.util.validateValueIndexes(t), a && r < this.lastDepth && this.flushStacks(this.lastDepth), this.lastDepth = r, this.lastKeys = e, this.parsingContext.unaliasedKeywordCacheStack.splice(r - 1)
    }
    flushStacks(e) {
      this.parsingContext.processingStack.splice(e, 1), this.parsingContext.processingType.splice(e, 1), this.parsingContext.emittedStack.splice(e, 1), this.parsingContext.idStack.splice(e, 1), this.parsingContext.graphStack.splice(e + 1, 1), this.parsingContext.graphContainerTermStack.splice(e, 1), this.parsingContext.jsonLiteralStack.splice(e, 1), this.parsingContext.validationStack.splice(e - 1, 2), this.parsingContext.literalStack.splice(e, this.parsingContext.literalStack.length - e)
    }
    async flushBuffer(e, t) {
      let r = this.parsingContext.idStack[e];
      r || (r = this.parsingContext.idStack[e] = [this.util.dataFactory.blankNode()]);
      const n = this.parsingContext.unidentifiedValuesBuffer[e];
      if (n) {
        for (const i of r) {
          const r = await this.util.getDepthOffsetGraph(e, t),
            a = this.parsingContext.graphStack[e] || r >= 0 ? this.parsingContext.idStack[e - r - 1] : [await this.util.getGraphContainerValue(t, e)];
          if (a)
            for (const t of a) {
              this.parsingContext.emittedStack[e] = !0;
              for (const r of n) r.reverse ? this.parsingContext.emitQuad(e, this.util.dataFactory.quad(r.object, r.predicate, i, t)) : this.parsingContext.emitQuad(e, this.util.dataFactory.quad(i, r.predicate, r.object, t))
            } else {
            const r = this.parsingContext.getUnidentifiedGraphBufferSafe(e - await this.util.getDepthOffsetGraph(e, t) - 1);
            for (const e of n) e.reverse ? r.push({
              object: i,
              predicate: e.predicate,
              subject: e.object
            }) : r.push({
              object: e.object,
              predicate: e.predicate,
              subject: i
            })
          }
        }
        this.parsingContext.unidentifiedValuesBuffer.splice(e, 1), this.parsingContext.literalStack.splice(e, 1), this.parsingContext.jsonLiteralStack.splice(e, 1)
      }
      const i = this.parsingContext.unidentifiedGraphsBuffer[e];
      if (i) {
        for (const t of r) {
          const r = 1 !== e || "BlankNode" !== t.termType || this.parsingContext.topLevelProperties ? t : this.util.getDefaultGraph();
          this.parsingContext.emittedStack[e] = !0;
          for (const t of i) this.parsingContext.emitQuad(e, this.util.dataFactory.quad(t.subject, t.predicate, t.object, r))
        }
        this.parsingContext.unidentifiedGraphsBuffer.splice(e, 1)
      }
    }
    async validateKey(e, t, r) {
      for (const n of w.ENTRY_HANDLERS)
        if (await n.validate(this.parsingContext, this.util, e, t, r)) return {
          valid: !0,
          property: r || n.isPropertyHandler()
        };
      return {
        valid: !1,
        property: !1
      }
    }
    attachJsonParserListeners() {
      this.jsonParser.onValue = e => {
        const t = this.jsonParser.stack.length,
          r = new Array(t + 1).fill(0).map((e, r) => r === t ? this.jsonParser.key : this.jsonParser.stack[r].key);
        if (!this.isParsingContextInner(t)) {
          const n = () => this.newOnValueJob(r, e, t, !0);
          if (this.parsingContext.streamingProfile || this.parsingContext.contextTree.getContext(r.slice(0, -1))) this.lastOnValueJob = this.lastOnValueJob.then(n);
          else if ("@context" === r[t]) {
            let e = this.contextJobs[t];
            e || (e = this.contextJobs[t] = []), e.push(n)
          } else "@type" === r[t] || "number" == typeof r[t] && "@type" === r[t - 1] ? this.typeJobs.push({
            job: n,
            keys: r.slice(0, r.length - 1)
          }) : this.contextAwaitingJobs.push({
            job: n,
            keys: r
          });
          this.parsingContext.streamingProfile || 0 !== t || (this.lastOnValueJob = this.lastOnValueJob.then(() => this.executeBufferedJobs()))
        }
      }, this.jsonParser.onError = e => {
        this.emit("error", e)
      }
    }
    isParsingContextInner(e) {
      for (let t = e; t > 0; t--)
        if ("@context" === this.jsonParser.stack[t - 1].key) return !0;
      return !1
    }
    async executeBufferedJobs() {
      for (const e of this.contextJobs)
        if (e)
          for (const t of e) await t();
      this.parsingContext.unaliasedKeywordCacheStack.splice(0);
      for (const e of this.contextAwaitingJobs) {
        if (this.typeJobs.length > 0) {
          const t = [],
            r = [];
          for (let n = 0; n < this.typeJobs.length; n++) {
            const i = this.typeJobs[n];
            _.Util.isPrefixArray(i.keys, e.keys) && (t.push(i), r.push(n))
          }
          const n = t.sort((e, t) => e.keys.length - t.keys.length);
          for (const e of n) await e.job();
          const i = r.sort().reverse();
          for (const e of i) this.typeJobs.splice(e, 1)
        }
        await e.job()
      }
    }
  }
  t.JsonLdParser = w, w.DEFAULT_PROCESSING_MODE = "1.1", w.ENTRY_HANDLERS = [new s.EntryHandlerArrayValue, new l.EntryHandlerKeywordContext, new d.EntryHandlerKeywordId, new p.EntryHandlerKeywordIncluded, new h.EntryHandlerKeywordGraph, new f.EntryHandlerKeywordNest, new g.EntryHandlerKeywordType, new y.EntryHandlerKeywordValue, new o.EntryHandlerContainer, new m.EntryHandlerKeywordUnknownFallback, new c.EntryHandlerPredicate, new u.EntryHandlerInvalidFallback]
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.EntryHandlerContainer = void 0;
  const n = r(428),
    i = r(429),
    a = r(430),
    s = r(431),
    o = r(27);
  class u {
    static isSimpleGraphContainer(e) {
      return "@graph" in e && ("@set" in e && 2 === Object.keys(e).length || 1 === Object.keys(e).length)
    }
    static isComplexGraphContainer(e) {
      return "@graph" in e && ("@set" in e && Object.keys(e).length > 2 || !("@set" in e) && Object.keys(e).length > 1)
    }
    static getContainerGraphIndex(e, t, r) {
      let n = u.isSimpleGraphContainer(e),
        i = "";
      for (let e = t; e < r.length; e++) n && "number" != typeof r[e] || (i += ":" + r[e]), n || "number" == typeof r[e] || (n = !0);
      return i
    }
    static async getContainerHandler(e, t, r) {
      const n = {
        containers: {
          "@set": !0
        },
        depth: r,
        fallback: !0
      };
      let i = !1;
      const a = await e.getContext(t, 2);
      for (let e = r - 1; e >= 0; e--)
        if ("number" != typeof t[e]) {
          const r = o.Util.getContextValue(a, "@container", t[e], !1);
          if (r && u.isSimpleGraphContainer(r)) return {
            containers: r,
            depth: e + 1,
            fallback: !1
          };
          const s = o.Util.getContextValue(a, "@container", t[e - 1], !1);
          if (s) {
            const t = "@graph" in s;
            for (const r in u.CONTAINER_HANDLERS)
              if (s[r]) return t ? u.CONTAINER_HANDLERS[r].canCombineWithGraph() ? {
                containers: s,
                depth: e,
                fallback: !1
              } : n : i ? n : {
                containers: s,
                depth: e,
                fallback: !1
              };
            return n
          }
          if (i) return n;
          i = !0
        } return n
    }
    static async isBufferableContainerHandler(e, t, r) {
      const n = await u.getContainerHandler(e, t, r);
      return !n.fallback && !("@graph" in n.containers)
    }
    isPropertyHandler() {
      return !1
    }
    isStackProcessor() {
      return !0
    }
    async validate(e, t, r, n, i) {
      return !!await this.test(e, t, null, r, n)
    }
    async test(e, t, r, n, i) {
      const a = o.Util.getContextValueContainer(await e.getContext(n, 2), n[i - 1]);
      for (const e in u.CONTAINER_HANDLERS)
        if (a[e]) return {
          containers: a,
          handler: u.CONTAINER_HANDLERS[e]
        };
      return null
    }
    async handle(e, t, r, n, i, a, s) {
      return s.handler.handle(s.containers, e, t, n, i, a)
    }
  }
  t.EntryHandlerContainer = u, u.CONTAINER_HANDLERS = {
    "@id": new n.ContainerHandlerIdentifier,
    "@index": new i.ContainerHandlerIndex,
    "@language": new a.ContainerHandlerLanguage,
    "@type": new s.ContainerHandlerType
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.DocumentLoaderMediated = void 0;
  const n = r(36),
    i = r(9),
    a = r(165);
  class s extends i.FetchDocumentLoader {
    constructor(e, t) {
      super(s.createFetcher(e, t)), this.mediatorHttp = e, this.context = t
    }
    static createFetcher(e, t) {
      return async (r, i) => {
        const s = await e.mediate({
          input: r,
          init: i,
          context: t
        });
        return s.json = async () => JSON.parse(await a(n.ActorHttp.toNodeReadable(s.body))), s
      }
    }
  }
  t.DocumentLoaderMediated = s
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.AsyncIteratorJsonBindings = void 0;
  const n = r(36),
    i = r(1),
    a = r(3),
    s = r(74);
  class o extends a.BufferedIterator {
    constructor(e, t, r, n) {
      super({
        autoStart: !1,
        maxBufferSize: 1 / 0
      }), this.initialized = !1, this.endpoint = e, this.query = t, this.context = r, this.mediatorHttp = n
    }
    _read(e, t) {
      this.initialized ? super._read(e, t) : (this.initialized = !0, this.fetchBindingsStream(this.endpoint, this.query, this.context).then(r => {
        const n = new s.SparqlJsonParser({
          prefixVariableQuestionMark: !0
        }).parseJsonResultsStream(r);
        r.on("error", e => n.emit("error", e)), n.on("error", e => this.emit("error", e)), n.on("data", e => this._push(i.Bindings(e))), n.on("end", () => {
          this.close()
        }), super._read(e, t)
      }).catch(e => this.emit("error", e)))
    }
    async fetchBindingsStream(e, t, r) {
      const i = `${e}?query=${encodeURIComponent(t)}`,
        a = new Headers;
      a.append("Accept", "application/sparql-results+json");
      const s = {
          context: r,
          input: i,
          init: {
            headers: a
          }
        },
        o = await this.mediatorHttp.mediate(s),
        u = n.ActorHttp.toNodeReadable(o.body);
      if (!o.ok) throw new Error(`Invalid SPARQL endpoint (${e}) response: ${o.statusText} (${o.status})`);
      return u
    }
  }
  t.AsyncIteratorJsonBindings = o
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.SparqlXmlBindingsTransformer = void 0;
  const n = r(2);
  class i extends n.Transform {
    constructor(e) {
      super({
        objectMode: !0
      }), this.parser = e
    }
    _transform(e, t, r) {
      let n;
      try {
        n = this.parser.parseXmlBindings(e)
      } catch (e) {
        return r(e)
      }
      r(null, n)
    }
  }
  t.SparqlXmlBindingsTransformer = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfDereferenceHttpParseBase = void 0;
  const n = r(36),
    i = r(468),
    a = r(470),
    s = r(13);
  class o extends i.ActorRdfDereferenceMediaMappings {
    constructor(e) {
      super(e)
    }
    async test(e) {
      if (!/^https?:/u.test(e.url)) throw new Error(`Cannot retrieve ${e.url} because it is not an HTTP(S) URL.`);
      return !0
    }
    async run(e) {
      var t;
      const {
        mediaTypes: r
      } = await this.mediatorRdfParseMediatypes.mediate({
        context: e.context,
        mediaTypes: !0
      }), i = this.mediaTypesToAcceptString(r, this.getMaxAcceptHeaderLength()), u = new a.Headers({
        Accept: i
      });
      for (const t in e.headers) u.append(t, e.headers[t]);
      const c = {
        context: e.context,
        init: {
          headers: u,
          method: e.method
        },
        input: e.url
      };
      let l;
      try {
        l = await this.mediatorHttp.mediate(c)
      } catch (t) {
        return this.handleDereferenceError(e, t)
      }
      const h = s.resolve(l.url, e.url),
        d = {};
      if (l.headers.forEach((e, t) => d[t] = e), 200 !== l.status) {
        const t = new Error(`Could not retrieve ${e.url} (${l.status}: ${l.statusText||"unknown error"})`);
        return l.body && await l.body.cancel(), this.handleDereferenceError(e, t)
      }
      const p = n.ActorHttp.toNodeReadable(l.body);
      let f = o.REGEX_MEDIATYPE.exec(null !== (t = l.headers.get("content-type")) && void 0 !== t ? t : "")[0];
      f && "text/plain" !== f || (f = this.getMediaTypeFromExtension(l.url));
      const g = {
        baseIRI: h,
        headers: l.headers,
        input: p
      };
      let m;
      try {
        m = (await this.mediatorRdfParseHandle.mediate({
          context: e.context,
          handle: g,
          handleMediaType: f
        })).handle
      } catch (t) {
        return this.handleDereferenceError(e, t)
      }
      return {
        url: h,
        quads: this.handleDereferenceStreamErrors(e, m.quads),
        triples: m.triples,
        headers: d
      }
    }
    mediaTypesToAcceptString(e, t) {
      const r = [],
        n = Object.keys(e).map(t => ({
          mediaType: t,
          priority: e[t]
        })).sort((e, t) => t.priority - e.priority);
      let i = n.length - 1;
      for (const e of n) {
        const n = e.mediaType + (1 !== e.priority ? ";q=" + e.priority.toFixed(3).replace(/0*$/u, "") : "");
        if (i + n.length > t) {
          for (; i + "*/*;q=0.1".length > t;) {
            i -= (r.pop() || "").length + 1
          }
          r.push("*/*;q=0.1");
          break
        }
        r.push(n), i += n.length
      }
      return 0 === r.length ? "*/*" : r.join(",")
    }
  }
  t.ActorRdfDereferenceHttpParseBase = o, o.REGEX_MEDIATYPE = /^[^ ;]*/u
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfDereference = t.KEY_CONTEXT_LENIENT = void 0;
  const n = r(2),
    i = r(0);
  t.KEY_CONTEXT_LENIENT = "@comunica/actor-init-sparql:lenient";
  class a extends i.Actor {
    constructor(e) {
      super(e)
    }
    isHardError(e) {
      return !e.context || !e.context.get(t.KEY_CONTEXT_LENIENT)
    }
    handleDereferenceStreamErrors(e, t) {
      return this.isHardError(e) || (t.on("error", r => {
        this.logError(e.context, r.message, () => ({
          url: e.url
        })), t.push(null)
      }), t = t.pipe(new n.PassThrough({
        objectMode: !0
      }))), t
    }
    async handleDereferenceError(e, t) {
      if (this.isHardError(e)) throw t; {
        this.logError(e.context, t.message);
        const r = new n.Readable;
        return r.push(null), {
          url: e.url,
          quads: r
        }
      }
    }
  }
  t.ActorRdfDereference = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.FederatedQuadSource = void 0;
  const n = r(21),
    i = r(177),
    a = r(3),
    s = r(5),
    o = r(18),
    u = r(6),
    c = new s.DataFactory;
  class l {
    constructor(e, t, r, i) {
      if (this.mediatorResolveQuadPattern = e, this.sources = t.get(n.KEY_CONTEXT_SOURCES), this.contextDefault = t.delete(n.KEY_CONTEXT_SOURCES), this.emptyPatterns = r, this.sourceIds = new Map, this.skipEmptyPatterns = i, this.algebraFactory = new u.Factory, this.skipEmptyPatterns)
        for (const e of this.sources) this.emptyPatterns.has(e) || this.emptyPatterns.set(e, [])
    }
    static isTermBound(e) {
      return "Variable" !== e.termType
    }
    static isSubPatternOf(e, t) {
      return (!l.isTermBound(t.subject) || t.subject.equals(e.subject)) && (!l.isTermBound(t.predicate) || t.predicate.equals(e.predicate)) && (!l.isTermBound(t.object) || t.object.equals(e.object)) && (!l.isTermBound(t.graph) || t.graph.equals(e.graph))
    }
    static skolemizeTerm(e, t) {
      return "BlankNode" === e.termType ? new i.BlankNodeScoped(`bc_${t}_${e.value}`, c.namedNode(`${l.SKOLEM_PREFIX}${t}:${e.value}`)) : e
    }
    static skolemizeQuad(e, t) {
      return o.mapTerms(e, e => l.skolemizeTerm(e, t))
    }
    static deskolemizeTerm(e, t) {
      if ("BlankNode" === e.termType && "skolemized" in e && (e = e.skolemized), "NamedNode" === e.termType && e.value.startsWith(l.SKOLEM_PREFIX)) {
        const r = e.value.indexOf(":", l.SKOLEM_PREFIX.length);
        if (e.value.slice(l.SKOLEM_PREFIX.length, r) === t) {
          const t = e.value.slice(r + 1, e.value.length);
          return c.blankNode(t)
        }
        return null
      }
      return e
    }
    isSourceEmpty(e, t) {
      if (!this.skipEmptyPatterns) return !1;
      const r = this.emptyPatterns.get(e);
      if (r)
        for (const e of r)
          if (l.isSubPatternOf(t, e)) return !0;
      return !1
    }
    getSourceId(e) {
      let t = this.sourceIds.get(e);
      return void 0 === t && (t = "" + this.sourceIds.size, this.sourceIds.set(e, t)), t
    }
    match(e, t, r, i) {
      const s = {
        totalItems: 0
      };
      let o = this.sources.length;
      const u = (e, t, r, n) => {
          this.skipEmptyPatterns && !e && r && !this.isSourceEmpty(t, r) && this.emptyPatterns.get(t).push(r), o || (n && 1 === this.sources.length ? h.setProperty("metadata", n) : h.setProperty("metadata", s))
        },
        c = Promise.all(this.sources.map(async c => {
          const h = this.getSourceId(c),
            d = l.deskolemizeTerm(e, h),
            p = l.deskolemizeTerm(t, h),
            f = l.deskolemizeTerm(r, h),
            g = l.deskolemizeTerm(i, h);
          let m, y, b = n.getDataSourceContext(c, this.contextDefault);
          b = b.set(n.KEY_CONTEXT_SOURCE, {
            type: n.getDataSourceType(c),
            value: n.getDataSourceValue(c)
          }), d && p && f && g && !this.isSourceEmpty(c, m = this.algebraFactory.createPattern(d, p, f, g)) ? y = await this.mediatorResolveQuadPattern.mediate({
            pattern: m,
            context: b
          }) : (y = {
            data: new a.ArrayIterator([], {
              autoStart: !1
            })
          }, y.data.setProperty("metadata", {
            totalItems: 0
          })), y.data.getProperty("metadata", e => {
            !e.totalItems && 0 !== e.totalItems || !Number.isFinite(e.totalItems) ? (s.totalItems = 1 / 0, o = 0, u(1 / 0, c, m, e)) : (s.totalItems += e.totalItems, o--, u(e.totalItems, c, m, e))
          });
          let _ = y.data.map(e => l.skolemizeQuad(e, h));
          return "Variable" === i.termType && (_ = _.filter(e => "DefaultGraph" !== e.graph.termType)), _
        })),
        h = new a.TransformIterator(async () => new a.UnionIterator(await c), {
          autoStart: !1
        });
      return 0 === this.sources.length && h.setProperty("metadata", s), h
    }
  }
  t.FederatedQuadSource = l, l.SKOLEM_PREFIX = "urn:comunica_skolem:source_"
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(479), t)
}, function(e, t, r) {
  "use strict";
  const n = r(487),
    i = Symbol("max"),
    a = Symbol("length"),
    s = Symbol("lengthCalculator"),
    o = Symbol("allowStale"),
    u = Symbol("maxAge"),
    c = Symbol("dispose"),
    l = Symbol("noDisposeOnSet"),
    h = Symbol("lruList"),
    d = Symbol("cache"),
    p = Symbol("updateAgeOnGet"),
    f = () => 1;
  const g = (e, t, r) => {
      const n = e[d].get(t);
      if (n) {
        const t = n.value;
        if (m(e, t)) {
          if (b(e, n), !e[o]) return
        } else r && (e[p] && (n.value.now = Date.now()), e[h].unshiftNode(n));
        return t.value
      }
    },
    m = (e, t) => {
      if (!t || !t.maxAge && !e[u]) return !1;
      const r = Date.now() - t.now;
      return t.maxAge ? r > t.maxAge : e[u] && r > e[u]
    },
    y = e => {
      if (e[a] > e[i])
        for (let t = e[h].tail; e[a] > e[i] && null !== t;) {
          const r = t.prev;
          b(e, t), t = r
        }
    },
    b = (e, t) => {
      if (t) {
        const r = t.value;
        e[c] && e[c](r.key, r.value), e[a] -= r.length, e[d].delete(r.key), e[h].removeNode(t)
      }
    };
  class _ {
    constructor(e, t, r, n, i) {
      this.key = e, this.value = t, this.length = r, this.now = n, this.maxAge = i || 0
    }
  }
  const v = (e, t, r, n) => {
    let i = r.value;
    m(e, i) && (b(e, r), e[o] || (i = void 0)), i && t.call(n, i.value, i.key, e)
  };
  e.exports = class {
    constructor(e) {
      if ("number" == typeof e && (e = {
        max: e
      }), e || (e = {}), e.max && ("number" != typeof e.max || e.max < 0)) throw new TypeError("max must be a non-negative number");
      this[i] = e.max || 1 / 0;
      const t = e.length || f;
      if (this[s] = "function" != typeof t ? f : t, this[o] = e.stale || !1, e.maxAge && "number" != typeof e.maxAge) throw new TypeError("maxAge must be a number");
      this[u] = e.maxAge || 0, this[c] = e.dispose, this[l] = e.noDisposeOnSet || !1, this[p] = e.updateAgeOnGet || !1, this.reset()
    }
    set max(e) {
      if ("number" != typeof e || e < 0) throw new TypeError("max must be a non-negative number");
      this[i] = e || 1 / 0, y(this)
    }
    get max() {
      return this[i]
    }
    set allowStale(e) {
      this[o] = !!e
    }
    get allowStale() {
      return this[o]
    }
    set maxAge(e) {
      if ("number" != typeof e) throw new TypeError("maxAge must be a non-negative number");
      this[u] = e, y(this)
    }
    get maxAge() {
      return this[u]
    }
    set lengthCalculator(e) {
      "function" != typeof e && (e = f), e !== this[s] && (this[s] = e, this[a] = 0, this[h].forEach(e => {
        e.length = this[s](e.value, e.key), this[a] += e.length
      })), y(this)
    }
    get lengthCalculator() {
      return this[s]
    }
    get length() {
      return this[a]
    }
    get itemCount() {
      return this[h].length
    }
    rforEach(e, t) {
      t = t || this;
      for (let r = this[h].tail; null !== r;) {
        const n = r.prev;
        v(this, e, r, t), r = n
      }
    }
    forEach(e, t) {
      t = t || this;
      for (let r = this[h].head; null !== r;) {
        const n = r.next;
        v(this, e, r, t), r = n
      }
    }
    keys() {
      return this[h].toArray().map(e => e.key)
    }
    values() {
      return this[h].toArray().map(e => e.value)
    }
    reset() {
      this[c] && this[h] && this[h].length && this[h].forEach(e => this[c](e.key, e.value)), this[d] = new Map, this[h] = new n, this[a] = 0
    }
    dump() {
      return this[h].map(e => !m(this, e) && {
        k: e.key,
        v: e.value,
        e: e.now + (e.maxAge || 0)
      }).toArray().filter(e => e)
    }
    dumpLru() {
      return this[h]
    }
    set(e, t, r) {
      if ((r = r || this[u]) && "number" != typeof r) throw new TypeError("maxAge must be a number");
      const n = r ? Date.now() : 0,
        o = this[s](t, e);
      if (this[d].has(e)) {
        if (o > this[i]) return b(this, this[d].get(e)), !1;
        const s = this[d].get(e).value;
        return this[c] && (this[l] || this[c](e, s.value)), s.now = n, s.maxAge = r, s.value = t, this[a] += o - s.length, s.length = o, this.get(e), y(this), !0
      }
      const p = new _(e, t, o, n, r);
      return p.length > this[i] ? (this[c] && this[c](e, t), !1) : (this[a] += p.length, this[h].unshift(p), this[d].set(e, this[h].head), y(this), !0)
    }
    has(e) {
      if (!this[d].has(e)) return !1;
      const t = this[d].get(e).value;
      return !m(this, t)
    }
    get(e) {
      return g(this, e, !0)
    }
    peek(e) {
      return g(this, e, !1)
    }
    pop() {
      const e = this[h].tail;
      return e ? (b(this, e), e.value) : null
    }
    del(e) {
      b(this, this[d].get(e))
    }
    load(e) {
      this.reset();
      const t = Date.now();
      for (let r = e.length - 1; r >= 0; r--) {
        const n = e[r],
          i = n.e || 0;
        if (0 === i) this.set(n.k, n.v);
        else {
          const e = i - t;
          e > 0 && this.set(n.k, n.v, e)
        }
      }
    }
    prune() {
      this[d].forEach((e, t) => g(this, t, !1))
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.MediatedQuadSource = void 0;
  const n = r(489);
  t.MediatedQuadSource = class {
    constructor(e, t, r, n, i) {
      this.cacheSize = e, this.context = t, this.firstUrl = r, this.forceSourceType = n, this.mediators = i
    }
    match(e, t, r, i) {
      const a = new n.MediatedLinkedRdfSourcesAsyncRdfIterator(this.cacheSize, this.context, this.forceSourceType, e, t, r, i, this.firstUrl, this.mediators);
      return this.sourcesState ? a.setSourcesState(this.sourcesState) : (a.setSourcesState(), this.sourcesState = a.sourcesState), a
    }
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(512), t)
}, function(e, t, r) {
  var n = t;
  n.utils = r(19), n.common = r(50), n.sha = r(517), n.ripemd = r(521), n.hmac = r(522), n.sha1 = n.sha.sha1, n.sha256 = n.sha.sha256, n.sha224 = n.sha.sha224, n.sha384 = n.sha.sha384, n.sha512 = n.sha.sha512, n.ripemd160 = n.ripemd.ripemd160
}, function(e, t, r) {
  "use strict";
  var n = r(19).rotr32;

  function i(e, t, r) {
    return e & t ^ ~e & r
  }

  function a(e, t, r) {
    return e & t ^ e & r ^ t & r
  }

  function s(e, t, r) {
    return e ^ t ^ r
  }
  t.ft_1 = function(e, t, r, n) {
    return 0 === e ? i(t, r, n) : 1 === e || 3 === e ? s(t, r, n) : 2 === e ? a(t, r, n) : void 0
  }, t.ch32 = i, t.maj32 = a, t.p32 = s, t.s0_256 = function(e) {
    return n(e, 2) ^ n(e, 13) ^ n(e, 22)
  }, t.s1_256 = function(e) {
    return n(e, 6) ^ n(e, 11) ^ n(e, 25)
  }, t.g0_256 = function(e) {
    return n(e, 7) ^ n(e, 18) ^ e >>> 3
  }, t.g1_256 = function(e) {
    return n(e, 17) ^ n(e, 19) ^ e >>> 10
  }
}, function(e, t, r) {
  "use strict";
  var n = r(19),
    i = r(50),
    a = r(182),
    s = r(49),
    o = n.sum32,
    u = n.sum32_4,
    c = n.sum32_5,
    l = a.ch32,
    h = a.maj32,
    d = a.s0_256,
    p = a.s1_256,
    f = a.g0_256,
    g = a.g1_256,
    m = i.BlockHash,
    y = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

  function b() {
    if (!(this instanceof b)) return new b;
    m.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = y, this.W = new Array(64)
  }
  n.inherits(b, m), e.exports = b, b.blockSize = 512, b.outSize = 256, b.hmacStrength = 192, b.padLength = 64, b.prototype._update = function(e, t) {
    for (var r = this.W, n = 0; n < 16; n++) r[n] = e[t + n];
    for (; n < r.length; n++) r[n] = u(g(r[n - 2]), r[n - 7], f(r[n - 15]), r[n - 16]);
    var i = this.h[0],
      a = this.h[1],
      m = this.h[2],
      y = this.h[3],
      b = this.h[4],
      _ = this.h[5],
      v = this.h[6],
      w = this.h[7];
    for (s(this.k.length === r.length), n = 0; n < r.length; n++) {
      var S = c(w, p(b), l(b, _, v), this.k[n], r[n]),
        T = o(d(i), h(i, a, m));
      w = v, v = _, _ = b, b = o(y, S), y = m, m = a, a = i, i = o(S, T)
    }
    this.h[0] = o(this.h[0], i), this.h[1] = o(this.h[1], a), this.h[2] = o(this.h[2], m), this.h[3] = o(this.h[3], y), this.h[4] = o(this.h[4], b), this.h[5] = o(this.h[5], _), this.h[6] = o(this.h[6], v), this.h[7] = o(this.h[7], w)
  }, b.prototype._digest = function(e) {
    return "hex" === e ? n.toHex32(this.h, "big") : n.split32(this.h, "big")
  }
}, function(e, t, r) {
  "use strict";
  var n = r(19),
    i = r(50),
    a = r(49),
    s = n.rotr64_hi,
    o = n.rotr64_lo,
    u = n.shr64_hi,
    c = n.shr64_lo,
    l = n.sum64,
    h = n.sum64_hi,
    d = n.sum64_lo,
    p = n.sum64_4_hi,
    f = n.sum64_4_lo,
    g = n.sum64_5_hi,
    m = n.sum64_5_lo,
    y = i.BlockHash,
    b = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

  function _() {
    if (!(this instanceof _)) return new _;
    y.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = b, this.W = new Array(160)
  }

  function v(e, t, r, n, i) {
    var a = e & r ^ ~e & i;
    return a < 0 && (a += 4294967296), a
  }

  function w(e, t, r, n, i, a) {
    var s = t & n ^ ~t & a;
    return s < 0 && (s += 4294967296), s
  }

  function S(e, t, r, n, i) {
    var a = e & r ^ e & i ^ r & i;
    return a < 0 && (a += 4294967296), a
  }

  function T(e, t, r, n, i, a) {
    var s = t & n ^ t & a ^ n & a;
    return s < 0 && (s += 4294967296), s
  }

  function E(e, t) {
    var r = s(e, t, 28) ^ s(t, e, 2) ^ s(t, e, 7);
    return r < 0 && (r += 4294967296), r
  }

  function x(e, t) {
    var r = o(e, t, 28) ^ o(t, e, 2) ^ o(t, e, 7);
    return r < 0 && (r += 4294967296), r
  }

  function O(e, t) {
    var r = s(e, t, 14) ^ s(e, t, 18) ^ s(t, e, 9);
    return r < 0 && (r += 4294967296), r
  }

  function A(e, t) {
    var r = o(e, t, 14) ^ o(e, t, 18) ^ o(t, e, 9);
    return r < 0 && (r += 4294967296), r
  }

  function R(e, t) {
    var r = s(e, t, 1) ^ s(e, t, 8) ^ u(e, t, 7);
    return r < 0 && (r += 4294967296), r
  }

  function I(e, t) {
    var r = o(e, t, 1) ^ o(e, t, 8) ^ c(e, t, 7);
    return r < 0 && (r += 4294967296), r
  }

  function N(e, t) {
    var r = s(e, t, 19) ^ s(t, e, 29) ^ u(e, t, 6);
    return r < 0 && (r += 4294967296), r
  }

  function P(e, t) {
    var r = o(e, t, 19) ^ o(t, e, 29) ^ c(e, t, 6);
    return r < 0 && (r += 4294967296), r
  }
  n.inherits(_, y), e.exports = _, _.blockSize = 1024, _.outSize = 512, _.hmacStrength = 192, _.padLength = 128, _.prototype._prepareBlock = function(e, t) {
    for (var r = this.W, n = 0; n < 32; n++) r[n] = e[t + n];
    for (; n < r.length; n += 2) {
      var i = N(r[n - 4], r[n - 3]),
        a = P(r[n - 4], r[n - 3]),
        s = r[n - 14],
        o = r[n - 13],
        u = R(r[n - 30], r[n - 29]),
        c = I(r[n - 30], r[n - 29]),
        l = r[n - 32],
        h = r[n - 31];
      r[n] = p(i, a, s, o, u, c, l, h), r[n + 1] = f(i, a, s, o, u, c, l, h)
    }
  }, _.prototype._update = function(e, t) {
    this._prepareBlock(e, t);
    var r = this.W,
      n = this.h[0],
      i = this.h[1],
      s = this.h[2],
      o = this.h[3],
      u = this.h[4],
      c = this.h[5],
      p = this.h[6],
      f = this.h[7],
      y = this.h[8],
      b = this.h[9],
      _ = this.h[10],
      R = this.h[11],
      I = this.h[12],
      N = this.h[13],
      P = this.h[14],
      C = this.h[15];
    a(this.k.length === r.length);
    for (var D = 0; D < r.length; D += 2) {
      var j = P,
        k = C,
        L = O(y, b),
        M = A(y, b),
        F = v(y, b, _, R, I),
        B = w(y, b, _, R, I, N),
        q = this.k[D],
        U = this.k[D + 1],
        V = r[D],
        H = r[D + 1],
        G = g(j, k, L, M, F, B, q, U, V, H),
        z = m(j, k, L, M, F, B, q, U, V, H);
      j = E(n, i), k = x(n, i), L = S(n, i, s, o, u), M = T(n, i, s, o, u, c);
      var Q = h(j, k, L, M),
        X = d(j, k, L, M);
      P = I, C = N, I = _, N = R, _ = y, R = b, y = h(p, f, G, z), b = d(f, f, G, z), p = u, f = c, u = s, c = o, s = n, o = i, n = h(G, z, Q, X), i = d(G, z, Q, X)
    }
    l(this.h, 0, n, i), l(this.h, 2, s, o), l(this.h, 4, u, c), l(this.h, 6, p, f), l(this.h, 8, y, b), l(this.h, 10, _, R), l(this.h, 12, I, N), l(this.h, 14, P, C)
  }, _.prototype._digest = function(e) {
    return "hex" === e ? n.toHex32(this.h, "big") : n.split32(this.h, "big")
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.UnsupportedOperation = t.SyncRecursiveEvaluator = t.AsyncRecursiveEvaluator = void 0;
  const n = r(40),
    i = r(20),
    a = r(39),
    s = {
      term: (e, t) => e,
      variable(e, t) {
        const r = t.get(e.name);
        if (!r) throw new i.UnboundVariableError(e.name, t);
        return a.transformRDFTermUnsafe(r)
      }
    };
  t.AsyncRecursiveEvaluator = class {
    constructor(e) {
      this.context = e, this.subEvaluators = {
        [n.ExpressionType.Term]: s.term,
        [n.ExpressionType.Variable]: s.variable,
        [n.ExpressionType.Operator]: this.evalOperator,
        [n.ExpressionType.SpecialOperator]: this.evalSpecialOperator,
        [n.ExpressionType.Named]: this.evalNamed,
        [n.ExpressionType.Existence]: this.evalExistence,
        [n.ExpressionType.Aggregate]: this.evalAggregate
      }
    }
    async evaluate(e, t) {
      const r = this.subEvaluators[e.expressionType];
      if (!r) throw new i.InvalidExpressionType(e);
      return r.bind(this)(e, t)
    }
    async evalOperator(e, t) {
      const r = e.args.map(e => this.evaluate(e, t)),
        n = await Promise.all(r);
      return e.apply(n)
    }
    async evalSpecialOperator(e, t) {
      const r = this.evaluate.bind(this),
        n = {
          args: e.args,
          mapping: t,
          evaluate: r,
          context: {
            now: this.context.now,
            baseIRI: this.context.baseIRI,
            bnode: this.context.bnode
          }
        };
      return e.applyAsync(n)
    }
    async evalNamed(e, t) {
      const r = e.args.map(e => this.evaluate(e, t)),
        n = await Promise.all(r);
      return e.apply(n)
    }
    async evalExistence(e, t) {
      if (!this.context.exists) throw new i.NoExistenceHook;
      return new n.BooleanLiteral(await this.context.exists(e.expression, t))
    }
    async evalAggregate(e, t) {
      if (!this.context.aggregate) throw new i.NoExistenceHook;
      return a.transformRDFTermUnsafe(await this.context.aggregate(e.expression))
    }
  };
  t.SyncRecursiveEvaluator = class {
    constructor(e) {
      this.context = e, this.subEvaluators = {
        [n.ExpressionType.Term]: s.term,
        [n.ExpressionType.Variable]: s.variable,
        [n.ExpressionType.Operator]: this.evalOperator,
        [n.ExpressionType.SpecialOperator]: this.evalSpecialOperator,
        [n.ExpressionType.Named]: this.evalNamed,
        [n.ExpressionType.Existence]: this.evalExistence,
        [n.ExpressionType.Aggregate]: this.evalAggregate
      }
    }
    evaluate(e, t) {
      const r = this.subEvaluators[e.expressionType];
      if (!r) throw new i.InvalidExpressionType(e);
      return r.bind(this)(e, t)
    }
    evalOperator(e, t) {
      const r = e.args.map(e => this.evaluate(e, t));
      return e.apply(r)
    }
    evalSpecialOperator(e, t) {
      const r = this.evaluate.bind(this),
        n = {
          args: e.args,
          mapping: t,
          evaluate: r,
          context: {
            now: this.context.now,
            baseIRI: this.context.baseIRI,
            bnode: this.context.bnode
          }
        };
      return e.applySync(n)
    }
    evalNamed(e, t) {
      const r = e.args.map(e => this.evaluate(e, t));
      return e.apply(r)
    }
    evalExistence(e, t) {
      if (!this.context.exists) throw new i.NoExistenceHook;
      return new n.BooleanLiteral(this.context.exists(e.expression, t))
    }
    evalAggregate(e, t) {
      if (!this.context.aggregate) throw new i.NoAggregator;
      return a.transformRDFTermUnsafe(this.context.aggregate(e.expression))
    }
  };
  class o extends Error {
    constructor(e) {
      super(`Operation '${e}' is unsupported in SimpleEvaluator`)
    }
  }
  t.UnsupportedOperation = o
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.SyncEvaluator = void 0;
  const n = r(39),
    i = r(185);
  t.SyncEvaluator = class {
    constructor(e, t = {}) {
      this.algExpr = e, this.config = t, this.expr = n.transformAlgebra(e);
      const r = {
        now: t.now || new Date(Date.now()),
        baseIRI: t.baseIRI || void 0,
        exists: t.exists,
        aggregate: t.aggregate
      };
      this.evaluator = new i.SyncRecursiveEvaluator(r)
    }
    evaluate(e) {
      return this.evaluator.evaluate(this.expr, e).toRDF()
    }
    evaluateAsEBV(e) {
      return this.evaluator.evaluate(this.expr, e).coerceEBV()
    }
    evaluateAsInternal(e) {
      return this.evaluator.evaluate(this.expr, e)
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorAbstractPath = void 0;
  const n = r(1),
    i = r(0),
    a = r(3),
    s = r(5),
    o = r(4),
    u = r(6),
    c = new s.DataFactory;
  class l extends n.ActorQueryOperationTypedMediated {
    constructor(e, t) {
      super(e, "path"), this.predicateType = t
    }
    async testOperation(e, t) {
      if (e.predicate.type !== this.predicateType) throw new Error(`This Actor only supports ${this.predicateType} Path operations.`);
      return !0
    }
    generateVariable(e, t) {
      return t ? !e || e.subject.value !== t && e.object.value !== t ? c.variable(t) : this.generateVariable(e, t + "b") : this.generateVariable(e, "b")
    }
    async isPathArbitraryLengthDistinct(e, t) {
      return e && e.get(l.isPathArbitraryLengthDistinctKey) ? {
        context: e = e.set(l.isPathArbitraryLengthDistinctKey, !1),
        operation: void 0
      } : {
        context: e = e ? e.set(l.isPathArbitraryLengthDistinctKey, !0) : i.ActionContext({
          [l.isPathArbitraryLengthDistinctKey]: !0
        }),
        operation: n.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
          operation: l.FACTORY.createDistinct(t),
          context: e
        }))
      }
    }
    async predicateStarGraphVariable(e, t, r, i, s) {
      const u = this.generateVariable(l.FACTORY.createPath(e, r, t, i)),
        c = l.FACTORY.createUnion(l.FACTORY.createPattern(e, u, t, i), l.FACTORY.createPattern(t, u, e, i)),
        h = n.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
          context: s,
          operation: c
        })),
        d = o.termToString(t),
        p = new Set;
      return new a.MultiTransformIterator(h.bindingsStream, {
        multiTransform: t => {
          const u = t.get(o.termToString(i));
          return p.has(o.termToString(u)) ? new a.EmptyIterator : (p.add(o.termToString(u)), new a.TransformIterator(async () => {
            const t = new a.BufferedIterator;
            return await this.getObjectsPredicateStar(e, r, u, s, {}, t, {
              count: 0
            }), t.transform({
              transform(e, t, r) {
                r(n.Bindings({
                  [d]: e,
                  [o.termToString(i)]: u
                })), t()
              }
            })
          }, {
            maxBufferSize: 128
          }))
        },
        autoStart: !1
      })
    }
    async getObjectsPredicateStarEval(e, t, r, i, s) {
      if ("Variable" === i.termType) return this.predicateStarGraphVariable(e, t, r, i, s);
      const u = new a.BufferedIterator;
      return await this.getObjectsPredicateStar(e, r, i, s, {}, u, {
        count: 0
      }), u.transform({
        transform(e, r, i) {
          i(n.Bindings({
            [o.termToString(t)]: e
          })), r()
        }
      })
    }
    async getObjectsPredicateStar(e, t, r, i, a, s, u) {
      const c = o.termToString(e);
      if (a[c]) return;
      s._push(e), a[c] = e, u.count++;
      const h = this.generateVariable(),
        d = o.termToString(h),
        p = l.FACTORY.createPath(e, t, h, r),
        f = n.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
          operation: p,
          context: i
        }));
      f.bindingsStream.on("data", async e => {
        const n = e.get(d);
        await this.getObjectsPredicateStar(n, t, r, i, a, s, u)
      }), f.bindingsStream.on("end", () => {
        0 == --u.count && s.close()
      })
    }
    async getSubjectAndObjectBindingsPredicateStar(e, t, r, i, a, s, u, c, h, d, p) {
      const f = o.termToString(i) + o.termToString(s);
      if (h[f]) return;
      if (p.count++, h[f] = !0, d._push(n.Bindings({
        [e]: r,
        [t]: i
      })), f in c) {
        const n = await c[f];
        for (const i of n) await this.getSubjectAndObjectBindingsPredicateStar(e, t, r, i, a, s, u, c, h, d, p);
        return void(0 == --p.count && d.close())
      }
      const g = new Promise(async (f, g) => {
        const m = [],
          y = this.generateVariable(),
          b = o.termToString(y),
          _ = l.FACTORY.createPath(i, a, y, s),
          v = n.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
            operation: _,
            context: u
          }));
        v.bindingsStream.on("data", async n => {
          const i = n.get(b);
          m.push(i), await this.getSubjectAndObjectBindingsPredicateStar(e, t, r, i, a, s, u, c, h, d, p)
        }), v.bindingsStream.on("error", g), v.bindingsStream.on("end", () => {
          0 == --p.count && d.close(), f(m)
        })
      });
      c[f] = g
    }
  }
  t.ActorAbstractPath = l, l.FACTORY = new u.Factory, l.isPathArbitraryLengthDistinctKey = "isPathArbitraryLengthDistinct"
}, function(e, t, r) {
  "use strict";
  r.r(t), r.d(t, "v1", (function() {
    return g
  })), r.d(t, "v3", (function() {
    return x
  })), r.d(t, "v4", (function() {
    return O
  })), r.d(t, "v5", (function() {
    return I
  })), r.d(t, "NIL", (function() {
    return N
  })), r.d(t, "version", (function() {
    return P
  })), r.d(t, "validate", (function() {
    return o
  })), r.d(t, "stringify", (function() {
    return d
  })), r.d(t, "parse", (function() {
    return m
  }));
  var n = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto),
    i = new Uint8Array(16);

  function a() {
    if (!n) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return n(i)
  }
  var s = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  for (var o = function(e) {
    return "string" == typeof e && s.test(e)
  }, u = [], c = 0; c < 256; ++c) u.push((c + 256).toString(16).substr(1));
  var l, h, d = function(e) {
      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
        r = (u[e[t + 0]] + u[e[t + 1]] + u[e[t + 2]] + u[e[t + 3]] + "-" + u[e[t + 4]] + u[e[t + 5]] + "-" + u[e[t + 6]] + u[e[t + 7]] + "-" + u[e[t + 8]] + u[e[t + 9]] + "-" + u[e[t + 10]] + u[e[t + 11]] + u[e[t + 12]] + u[e[t + 13]] + u[e[t + 14]] + u[e[t + 15]]).toLowerCase();
      if (!o(r)) throw TypeError("Stringified UUID is invalid");
      return r
    },
    p = 0,
    f = 0;
  var g = function(e, t, r) {
    var n = t && r || 0,
      i = t || new Array(16),
      s = (e = e || {}).node || l,
      o = void 0 !== e.clockseq ? e.clockseq : h;
    if (null == s || null == o) {
      var u = e.random || (e.rng || a)();
      null == s && (s = l = [1 | u[0], u[1], u[2], u[3], u[4], u[5]]), null == o && (o = h = 16383 & (u[6] << 8 | u[7]))
    }
    var c = void 0 !== e.msecs ? e.msecs : Date.now(),
      g = void 0 !== e.nsecs ? e.nsecs : f + 1,
      m = c - p + (g - f) / 1e4;
    if (m < 0 && void 0 === e.clockseq && (o = o + 1 & 16383), (m < 0 || c > p) && void 0 === e.nsecs && (g = 0), g >= 1e4) throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    p = c, f = g, h = o;
    var y = (1e4 * (268435455 & (c += 122192928e5)) + g) % 4294967296;
    i[n++] = y >>> 24 & 255, i[n++] = y >>> 16 & 255, i[n++] = y >>> 8 & 255, i[n++] = 255 & y;
    var b = c / 4294967296 * 1e4 & 268435455;
    i[n++] = b >>> 8 & 255, i[n++] = 255 & b, i[n++] = b >>> 24 & 15 | 16, i[n++] = b >>> 16 & 255, i[n++] = o >>> 8 | 128, i[n++] = 255 & o;
    for (var _ = 0; _ < 6; ++_) i[n + _] = s[_];
    return t || d(i)
  };
  var m = function(e) {
    if (!o(e)) throw TypeError("Invalid UUID");
    var t, r = new Uint8Array(16);
    return r[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24, r[1] = t >>> 16 & 255, r[2] = t >>> 8 & 255, r[3] = 255 & t, r[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8, r[5] = 255 & t, r[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8, r[7] = 255 & t, r[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8, r[9] = 255 & t, r[10] = (t = parseInt(e.slice(24, 36), 16)) / 1099511627776 & 255, r[11] = t / 4294967296 & 255, r[12] = t >>> 24 & 255, r[13] = t >>> 16 & 255, r[14] = t >>> 8 & 255, r[15] = 255 & t, r
  };
  var y = function(e, t, r) {
    function n(e, n, i, a) {
      if ("string" == typeof e && (e = function(e) {
        e = unescape(encodeURIComponent(e));
        for (var t = [], r = 0; r < e.length; ++r) t.push(e.charCodeAt(r));
        return t
      }(e)), "string" == typeof n && (n = m(n)), 16 !== n.length) throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      var s = new Uint8Array(16 + e.length);
      if (s.set(n), s.set(e, n.length), (s = r(s))[6] = 15 & s[6] | t, s[8] = 63 & s[8] | 128, i) {
        a = a || 0;
        for (var o = 0; o < 16; ++o) i[a + o] = s[o];
        return i
      }
      return d(s)
    }
    try {
      n.name = e
    } catch (e) {}
    return n.DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", n.URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8", n
  };

  function b(e) {
    return 14 + (e + 64 >>> 9 << 4) + 1
  }

  function _(e, t) {
    var r = (65535 & e) + (65535 & t);
    return (e >> 16) + (t >> 16) + (r >> 16) << 16 | 65535 & r
  }

  function v(e, t, r, n, i, a) {
    return _((s = _(_(t, e), _(n, a))) << (o = i) | s >>> 32 - o, r);
    var s, o
  }

  function w(e, t, r, n, i, a, s) {
    return v(t & r | ~t & n, e, t, i, a, s)
  }

  function S(e, t, r, n, i, a, s) {
    return v(t & n | r & ~n, e, t, i, a, s)
  }

  function T(e, t, r, n, i, a, s) {
    return v(t ^ r ^ n, e, t, i, a, s)
  }

  function E(e, t, r, n, i, a, s) {
    return v(r ^ (t | ~n), e, t, i, a, s)
  }
  var x = y("v3", 48, (function(e) {
    if ("string" == typeof e) {
      var t = unescape(encodeURIComponent(e));
      e = new Uint8Array(t.length);
      for (var r = 0; r < t.length; ++r) e[r] = t.charCodeAt(r)
    }
    return function(e) {
      for (var t = [], r = 32 * e.length, n = 0; n < r; n += 8) {
        var i = e[n >> 5] >>> n % 32 & 255,
          a = parseInt("0123456789abcdef".charAt(i >>> 4 & 15) + "0123456789abcdef".charAt(15 & i), 16);
        t.push(a)
      }
      return t
    }(function(e, t) {
      e[t >> 5] |= 128 << t % 32, e[b(t) - 1] = t;
      for (var r = 1732584193, n = -271733879, i = -1732584194, a = 271733878, s = 0; s < e.length; s += 16) {
        var o = r,
          u = n,
          c = i,
          l = a;
        r = w(r, n, i, a, e[s], 7, -680876936), a = w(a, r, n, i, e[s + 1], 12, -389564586), i = w(i, a, r, n, e[s + 2], 17, 606105819), n = w(n, i, a, r, e[s + 3], 22, -1044525330), r = w(r, n, i, a, e[s + 4], 7, -176418897), a = w(a, r, n, i, e[s + 5], 12, 1200080426), i = w(i, a, r, n, e[s + 6], 17, -1473231341), n = w(n, i, a, r, e[s + 7], 22, -45705983), r = w(r, n, i, a, e[s + 8], 7, 1770035416), a = w(a, r, n, i, e[s + 9], 12, -1958414417), i = w(i, a, r, n, e[s + 10], 17, -42063), n = w(n, i, a, r, e[s + 11], 22, -1990404162), r = w(r, n, i, a, e[s + 12], 7, 1804603682), a = w(a, r, n, i, e[s + 13], 12, -40341101), i = w(i, a, r, n, e[s + 14], 17, -1502002290), n = w(n, i, a, r, e[s + 15], 22, 1236535329), r = S(r, n, i, a, e[s + 1], 5, -165796510), a = S(a, r, n, i, e[s + 6], 9, -1069501632), i = S(i, a, r, n, e[s + 11], 14, 643717713), n = S(n, i, a, r, e[s], 20, -373897302), r = S(r, n, i, a, e[s + 5], 5, -701558691), a = S(a, r, n, i, e[s + 10], 9, 38016083), i = S(i, a, r, n, e[s + 15], 14, -660478335), n = S(n, i, a, r, e[s + 4], 20, -405537848), r = S(r, n, i, a, e[s + 9], 5, 568446438), a = S(a, r, n, i, e[s + 14], 9, -1019803690), i = S(i, a, r, n, e[s + 3], 14, -187363961), n = S(n, i, a, r, e[s + 8], 20, 1163531501), r = S(r, n, i, a, e[s + 13], 5, -1444681467), a = S(a, r, n, i, e[s + 2], 9, -51403784), i = S(i, a, r, n, e[s + 7], 14, 1735328473), n = S(n, i, a, r, e[s + 12], 20, -1926607734), r = T(r, n, i, a, e[s + 5], 4, -378558), a = T(a, r, n, i, e[s + 8], 11, -2022574463), i = T(i, a, r, n, e[s + 11], 16, 1839030562), n = T(n, i, a, r, e[s + 14], 23, -35309556), r = T(r, n, i, a, e[s + 1], 4, -1530992060), a = T(a, r, n, i, e[s + 4], 11, 1272893353), i = T(i, a, r, n, e[s + 7], 16, -155497632), n = T(n, i, a, r, e[s + 10], 23, -1094730640), r = T(r, n, i, a, e[s + 13], 4, 681279174), a = T(a, r, n, i, e[s], 11, -358537222), i = T(i, a, r, n, e[s + 3], 16, -722521979), n = T(n, i, a, r, e[s + 6], 23, 76029189), r = T(r, n, i, a, e[s + 9], 4, -640364487), a = T(a, r, n, i, e[s + 12], 11, -421815835), i = T(i, a, r, n, e[s + 15], 16, 530742520), n = T(n, i, a, r, e[s + 2], 23, -995338651), r = E(r, n, i, a, e[s], 6, -198630844), a = E(a, r, n, i, e[s + 7], 10, 1126891415), i = E(i, a, r, n, e[s + 14], 15, -1416354905), n = E(n, i, a, r, e[s + 5], 21, -57434055), r = E(r, n, i, a, e[s + 12], 6, 1700485571), a = E(a, r, n, i, e[s + 3], 10, -1894986606), i = E(i, a, r, n, e[s + 10], 15, -1051523), n = E(n, i, a, r, e[s + 1], 21, -2054922799), r = E(r, n, i, a, e[s + 8], 6, 1873313359), a = E(a, r, n, i, e[s + 15], 10, -30611744), i = E(i, a, r, n, e[s + 6], 15, -1560198380), n = E(n, i, a, r, e[s + 13], 21, 1309151649), r = E(r, n, i, a, e[s + 4], 6, -145523070), a = E(a, r, n, i, e[s + 11], 10, -1120210379), i = E(i, a, r, n, e[s + 2], 15, 718787259), n = E(n, i, a, r, e[s + 9], 21, -343485551), r = _(r, o), n = _(n, u), i = _(i, c), a = _(a, l)
      }
      return [r, n, i, a]
    }(function(e) {
      if (0 === e.length) return [];
      for (var t = 8 * e.length, r = new Uint32Array(b(t)), n = 0; n < t; n += 8) r[n >> 5] |= (255 & e[n / 8]) << n % 32;
      return r
    }(e), 8 * e.length))
  }));
  var O = function(e, t, r) {
    var n = (e = e || {}).random || (e.rng || a)();
    if (n[6] = 15 & n[6] | 64, n[8] = 63 & n[8] | 128, t) {
      r = r || 0;
      for (var i = 0; i < 16; ++i) t[r + i] = n[i];
      return t
    }
    return d(n)
  };

  function A(e, t, r, n) {
    switch (e) {
      case 0:
        return t & r ^ ~t & n;
      case 1:
        return t ^ r ^ n;
      case 2:
        return t & r ^ t & n ^ r & n;
      case 3:
        return t ^ r ^ n
    }
  }

  function R(e, t) {
    return e << t | e >>> 32 - t
  }
  var I = y("v5", 80, (function(e) {
      var t = [1518500249, 1859775393, 2400959708, 3395469782],
        r = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      if ("string" == typeof e) {
        var n = unescape(encodeURIComponent(e));
        e = [];
        for (var i = 0; i < n.length; ++i) e.push(n.charCodeAt(i))
      } else Array.isArray(e) || (e = Array.prototype.slice.call(e));
      e.push(128);
      for (var a = e.length / 4 + 2, s = Math.ceil(a / 16), o = new Array(s), u = 0; u < s; ++u) {
        for (var c = new Uint32Array(16), l = 0; l < 16; ++l) c[l] = e[64 * u + 4 * l] << 24 | e[64 * u + 4 * l + 1] << 16 | e[64 * u + 4 * l + 2] << 8 | e[64 * u + 4 * l + 3];
        o[u] = c
      }
      o[s - 1][14] = 8 * (e.length - 1) / Math.pow(2, 32), o[s - 1][14] = Math.floor(o[s - 1][14]), o[s - 1][15] = 8 * (e.length - 1) & 4294967295;
      for (var h = 0; h < s; ++h) {
        for (var d = new Uint32Array(80), p = 0; p < 16; ++p) d[p] = o[h][p];
        for (var f = 16; f < 80; ++f) d[f] = R(d[f - 3] ^ d[f - 8] ^ d[f - 14] ^ d[f - 16], 1);
        for (var g = r[0], m = r[1], y = r[2], b = r[3], _ = r[4], v = 0; v < 80; ++v) {
          var w = Math.floor(v / 20),
            S = R(g, 5) + A(w, m, y, b) + _ + t[w] + d[v] >>> 0;
          _ = b, b = y, y = R(m, 30) >>> 0, m = g, g = S
        }
        r[0] = r[0] + g >>> 0, r[1] = r[1] + m >>> 0, r[2] = r[2] + y >>> 0, r[3] = r[3] + b >>> 0, r[4] = r[4] + _ >>> 0
      }
      return [r[0] >> 24 & 255, r[0] >> 16 & 255, r[0] >> 8 & 255, 255 & r[0], r[1] >> 24 & 255, r[1] >> 16 & 255, r[1] >> 8 & 255, 255 & r[1], r[2] >> 24 & 255, r[2] >> 16 & 255, r[2] >> 8 & 255, 255 & r[2], r[3] >> 24 & 255, r[3] >> 16 & 255, r[3] >> 8 & 255, 255 & r[3], r[4] >> 24 & 255, r[4] >> 16 & 255, r[4] >> 8 & 255, 255 & r[4]]
    })),
    N = "00000000-0000-0000-0000-000000000000";
  var P = function(e) {
    if (!o(e)) throw TypeError("Invalid UUID");
    return parseInt(e.substr(14, 1), 16)
  }
}, function(e, t) {
  /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  let r;
  e.exports = "function" == typeof queueMicrotask ? queueMicrotask : e => (r || (r = Promise.resolve())).then(e).catch(e => setTimeout(() => {
    throw e
  }, 0))
}, function(e, t, r) {
  e.exports = r(91)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.KEY_CONTEXT_LENIENT = t.KEY_CONTEXT_GRAPHQL_SINGULARIZEVARIABLES = t.KEY_CONTEXT_QUERYFORMAT = t.KEY_CONTEXT_INITIALBINDINGS = t.ActorInitSparql = void 0;
  const n = r(192),
    i = r(1),
    a = r(21),
    s = r(0),
    o = r(6);
  class u extends n.ActorInit {
    constructor(e) {
      super(e)
    }
    static enhanceQueryResults(e) {
      return e.bindingsStream ? e.bindings = () => new Promise((t, r) => {
        const n = [];
        e.bindingsStream.on("data", e => {
          n.push(e)
        }), e.bindingsStream.on("end", () => {
          t(n)
        }), e.bindingsStream.on("error", r)
      }) : e.quadStream && (e.quads = () => new Promise((t, r) => {
        const n = [];
        e.quadStream.on("data", e => {
          n.push(e)
        }), e.quadStream.on("end", () => {
          t(n)
        }), e.quadStream.on("error", r)
      })), e
    }
    async test(e) {
      return !0
    }
    async query(e, r) {
      r = r || {};
      for (const e in r)
        if (this.contextKeyShortcuts[e]) {
          const t = r[e];
          r[this.contextKeyShortcuts[e]] = t, delete r[e]
        } r[s.KEY_CONTEXT_LOG] || (r[s.KEY_CONTEXT_LOG] = this.logger), r[i.KEY_CONTEXT_QUERY_TIMESTAMP] || (r[i.KEY_CONTEXT_QUERY_TIMESTAMP] = new Date), Array.isArray(r[a.KEY_CONTEXT_SOURCES]) && r[a.KEY_CONTEXT_SOURCES].forEach(e => {
        a.isDataSourceRawType(e) || "auto" !== e.type && "hypermedia" !== e.type || delete e.type
      });
      let n, o, c = "sparql";
      if ((r = s.ActionContext(r)) && r.has(t.KEY_CONTEXT_QUERYFORMAT) && (c = r.get(t.KEY_CONTEXT_QUERYFORMAT), r = r.delete(t.KEY_CONTEXT_QUERYFORMAT), "graphql" !== c || r.has(t.KEY_CONTEXT_GRAPHQL_SINGULARIZEVARIABLES) || (r = r.set(t.KEY_CONTEXT_GRAPHQL_SINGULARIZEVARIABLES, {}))), r && r.has(i.KEY_CONTEXT_BASEIRI) && (n = r.get(i.KEY_CONTEXT_BASEIRI)), r = (await this.mediatorContextPreprocess.mediate({
        context: r
      })).context, "string" == typeof e) {
        const t = await this.mediatorSparqlParse.mediate({
          context: r,
          query: e,
          queryFormat: c,
          baseIRI: n
        });
        o = t.operation, t.baseIRI && (r = r.set(i.KEY_CONTEXT_BASEIRI, t.baseIRI))
      } else o = e;
      if (r.has(t.KEY_CONTEXT_INITIALBINDINGS)) {
        const e = r.get(t.KEY_CONTEXT_INITIALBINDINGS);
        o = i.materializeOperation(o, i.ensureBindings(e))
      }
      o = (await this.mediatorOptimizeQueryOperation.mediate({
        context: r,
        operation: o
      })).operation;
      const l = {
        context: r,
        operation: o
      };
      let h = await this.mediatorQueryOperation.mediate(l);
      return h = u.enhanceQueryResults(h), h.context = r, h
    }
    async getResultMediaTypes(e) {
      return (await this.mediatorSparqlSerializeMediaTypeCombiner.mediate({
        context: e,
        mediaTypes: !0
      })).mediaTypes
    }
    async getResultMediaTypeFormats(e) {
      return (await this.mediatorSparqlSerializeMediaTypeFormatCombiner.mediate({
        context: e,
        mediaTypeFormats: !0
      })).mediaTypeFormats
    }
    async resultToString(e, t, r) {
      if (r = s.ActionContext(r), !t) switch (e.type) {
        case "bindings":
          t = "application/json";
          break;
        case "quads":
          t = "application/trig";
          break;
        default:
          t = "simple"
      }
      const n = e;
      return n.context = r, (await this.mediatorSparqlSerialize.mediate({
        context: r,
        handle: n,
        handleMediaType: t
      })).handle
    }
    invalidateHttpCache(e) {
      return this.mediatorHttpInvalidate.mediate({
        url: e
      })
    }
    async run(e) {
      throw new Error("ActorInitSparql#run is not supported in the browser.")
    }
  }
  t.ActorInitSparql = u, u.ALGEBRA_TYPES = Object.keys(o.Algebra.types).reduce((e, t) => (e[o.Algebra.types[t]] = !0, e), {}), t.KEY_CONTEXT_INITIALBINDINGS = "@comunica/actor-init-sparql:initialBindings", t.KEY_CONTEXT_QUERYFORMAT = "@comunica/actor-init-sparql:queryFormat", t.KEY_CONTEXT_GRAPHQL_SINGULARIZEVARIABLES = "@comunica/actor-init-sparql:singularizeVariables", t.KEY_CONTEXT_LENIENT = "@comunica/actor-init-sparql:lenient"
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(193), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorInit = void 0;
  const n = r(0);
  class i extends n.Actor {
    constructor(e) {
      super(e)
    }
  }
  t.ActorInit = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.BusIndexed = void 0;
  const n = r(92);
  class i extends n.Bus {
    constructor(e) {
      super(e), this.actorsIndex = {}
    }
    subscribe(e) {
      const t = this.getActorIdentifier(e) || "_undefined_";
      let r = this.actorsIndex[t];
      r || (r = this.actorsIndex[t] = []), r.push(e), super.subscribe(e)
    }
    unsubscribe(e) {
      const t = this.getActorIdentifier(e) || "_undefined_",
        r = this.actorsIndex[t];
      if (r) {
        const n = r.indexOf(e);
        n >= 0 && r.splice(n, 1), 0 === r.length && delete this.actorsIndex[t]
      }
      return super.unsubscribe(e)
    }
    publish(e) {
      const t = this.getActionIdentifier(e);
      if (t) {
        return (this.actorsIndex[t] || []).concat(this.actorsIndex._undefined_ || []).map(t => ({
          actor: t,
          reply: t.test(e)
        }))
      }
      return super.publish(e)
    }
    getActorIdentifier(e) {
      return this.actorIdentifierFields.reduce((e, t) => e[t], e)
    }
    getActionIdentifier(e) {
      return this.actionIdentifierFields.reduce((e, t) => e[t], e)
    }
  }
  t.BusIndexed = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActionObserver = void 0;
  t.ActionObserver = class {
    constructor(e) {
      Object.assign(this, e)
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ensureActionContext = t.ActionContext = t.Actor = void 0;
  const n = r(23),
    i = r(93);
  class a {
    constructor(e) {
      this.beforeActors = [], Object.assign(this, e), this.bus.subscribe(this), this.beforeActors.length > 0 && this.bus.addDependencies(this, this.beforeActors)
    }
    static getContextLogger(e) {
      return e && e.get(i.KEY_CONTEXT_LOG)
    }
    runObservable(e) {
      const t = this.run(e);
      return this.bus.onRun(this, e, t), t
    }
    async initialize() {
      return !0
    }
    async deinitialize() {
      return !0
    }
    getDefaultLogData(e, t) {
      const r = t ? t() : {};
      return r.actor = this.name, r
    }
    logTrace(e, t, r) {
      const n = a.getContextLogger(e);
      n && n.trace(t, this.getDefaultLogData(e, r))
    }
    logDebug(e, t, r) {
      const n = a.getContextLogger(e);
      n && n.debug(t, this.getDefaultLogData(e, r))
    }
    logInfo(e, t, r) {
      const n = a.getContextLogger(e);
      n && n.info(t, this.getDefaultLogData(e, r))
    }
    logWarn(e, t, r) {
      const n = a.getContextLogger(e);
      n && n.warn(t, this.getDefaultLogData(e, r))
    }
    logError(e, t, r) {
      const n = a.getContextLogger(e);
      n && n.error(t, this.getDefaultLogData(e, r))
    }
    logFatal(e, t, r) {
      const n = a.getContextLogger(e);
      n && n.fatal(t, this.getDefaultLogData(e, r))
    }
  }

  function s(e) {
    return n.Map(e)
  }
  t.Actor = a, t.ActionContext = s, t.ensureActionContext = function(e) {
    return n.Map.isMap(e) ? e : s(e)
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Mediator = void 0;
  t.Mediator = class {
    constructor(e) {
      Object.assign(this, e)
    }
    publish(e) {
      const t = this.bus.publish(e);
      if (0 === t.length) throw new Error("No actors are able to reply to a message in the bus " + this.bus.name);
      return t
    }
    async mediateActor(e) {
      return await this.mediateWith(e, this.publish(e))
    }
    async mediate(e) {
      return (await this.mediateActor(e)).runObservable(e)
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.stringQuadToQuad = t.quadToStringQuad = t.stringToTerm = t.getLiteralLanguage = t.getLiteralType = t.getLiteralValue = t.termToString = void 0;
  const n = new(r(5).DataFactory);

  function i(e) {
    if (e) switch (e.termType) {
      case "NamedNode":
        return e.value;
      case "BlankNode":
        return "_:" + e.value;
      case "Literal":
        const t = e;
        return '"' + t.value + '"' + (t.datatype && "http://www.w3.org/2001/XMLSchema#string" !== t.datatype.value && "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" !== t.datatype.value ? "^^" + t.datatype.value : "") + (t.language ? "@" + t.language : "");
      case "Quad":
        return `<<${i(e.subject)} ${i(e.predicate)} ${i(e.object)}${"DefaultGraph"===e.graph.termType?"":" "+i(e.graph)}>>`;
      case "Variable":
        return "?" + e.value;
      case "DefaultGraph":
        return e.value
    }
  }

  function a(e) {
    const t = /^"([^]*)"/.exec(e);
    if (!t) throw new Error(e + " is not a literal");
    return t[1]
  }

  function s(e) {
    const t = /^"[^]*"(?:\^\^([^"]+)|(@)[^@"]+)?$/.exec(e);
    if (!t) throw new Error(e + " is not a literal");
    return t[1] || (t[2] ? "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" : "http://www.w3.org/2001/XMLSchema#string")
  }

  function o(e) {
    const t = /^"[^]*"(?:@([^@"]+)|\^\^[^"]+)?$/.exec(e);
    if (!t) throw new Error(e + " is not a literal");
    return t[1] ? t[1].toLowerCase() : ""
  }

  function u(e, t) {
    if (t = t || n, !e || !e.length) return t.defaultGraph();
    switch (e[0]) {
      case "_":
        return t.blankNode(e.substr(2));
      case "?":
        if (!t.variable) throw new Error("Missing 'variable()' method on the given DataFactory");
        return t.variable(e.substr(1));
      case '"':
        const r = o(e),
          n = t.namedNode(s(e));
        return t.literal(a(e), r || n);
      case "<":
      default:
        if (e.startsWith("<<") && e.endsWith(">>")) {
          const r = e.slice(2, -2),
            n = [];
          let i = 0,
            a = 0;
          for (let t = 0; t < r.length; t++) {
            const s = r[t];
            if ("<" === s && i++, ">" === s) {
              if (0 === i) throw new Error("Found closing tag without opening tag in " + e);
              i--
            }
            " " === s && 0 === i && (n.push(r.slice(a, t)), a = t + 1)
          }
          if (0 !== i) throw new Error("Found opening tag without closing tag in " + e);
          if (n.push(r.slice(a, r.length)), 3 !== n.length && 4 !== n.length) throw new Error("Nested quad syntax error " + e);
          return t.quad(u(n[0]), u(n[1]), u(n[2]), n[3] ? u(n[3]) : void 0)
        }
        return t.namedNode(e)
    }
  }
  t.termToString = i, t.getLiteralValue = a, t.getLiteralType = s, t.getLiteralLanguage = o, t.stringToTerm = u, t.quadToStringQuad = function(e) {
    return {
      subject: i(e.subject),
      predicate: i(e.predicate),
      object: i(e.object),
      graph: i(e.graph)
    }
  }, t.stringQuadToQuad = function(e, t) {
    return (t = t || n).quad(u(e.subject, t), u(e.predicate, t), u(e.object, t), u(e.graph, t))
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.DataFactory = void 0;
  const n = r(96),
    i = r(97),
    a = r(98),
    s = r(68),
    o = r(99),
    u = r(100);
  t.DataFactory = class {
    constructor() {
      this.blankNodeCounter = 0
    }
    namedNode(e) {
      return new s.NamedNode(e)
    }
    blankNode(e) {
      return new n.BlankNode(e || "df_" + this.blankNodeCounter++)
    }
    literal(e, t) {
      return new a.Literal(e, t)
    }
    variable(e) {
      return new u.Variable(e)
    }
    defaultGraph() {
      return i.DefaultGraph.INSTANCE
    }
    quad(e, t, r, n) {
      return new o.Quad(e, t, r, n || this.defaultGraph())
    }
    fromTerm(e) {
      switch (e.termType) {
        case "NamedNode":
          return this.namedNode(e.value);
        case "BlankNode":
          return this.blankNode(e.value);
        case "Literal":
          return e.language ? this.literal(e.value, e.language) : e.datatype.equals(a.Literal.XSD_STRING) ? this.literal(e.value) : this.literal(e.value, this.fromTerm(e.datatype));
        case "Variable":
          return this.variable(e.value);
        case "DefaultGraph":
          return this.defaultGraph();
        case "Quad":
          return this.quad(this.fromTerm(e.subject), this.fromTerm(e.predicate), this.fromTerm(e.object), this.fromTerm(e.graph))
      }
    }
    fromQuad(e) {
      return this.fromTerm(e)
    }
    resetBlankNodeCounter() {
      this.blankNodeCounter = 0
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  const n = r(52),
    i = r(53),
    a = r(70),
    s = r(215),
    o = r(4),
    u = r(30).Parser,
    c = n.types;
  let l, h = new Set,
    d = 0,
    p = !1;

  function f(e, t, r) {
    if (h = new Set, d = 0, p = t, "query" !== e.type && "update" !== e.type) throw new Error("Translate only works on complete query or update objects.");
    let n, i = new Set(Object.keys(function e(t) {
      let r = {};
      if (g(t)) r[o.termToString(t)] = !0, h.add(t);
      else if (n = t, null !== n && "object" == typeof n)
        if ("bind" === t.type) e(t.expression), Object.assign(r, e(t.variable));
        else if ("SELECT" === t.queryType) {
          let n = e(t.where);
          for (let i of t.variables) a.default.isWildcard(i) ? Object.assign(r, n) : i.variable ? Object.assign(r, e(i.variable)) : Object.assign(r, e(i));
          if (t.group)
            for (let n of t.group) Object.assign(r, e(n))
        } else
          for (let n of Object.keys(t)) Object.assign(r, e(t[n]));
      var n;
      return r
    }(e)).map(l.createTerm.bind(l)));
    if ("query" === e.type) {
      n = m({
        type: "group",
        patterns: e.where || []
      }), n = function(e, t, r) {
        let n = [],
          i = {};
        if (e.variables = O(e.variables, i), e.having = O(e.having, i), e.order = O(e.order, i), e.group || Object.keys(i).length > 0) {
          let r = Object.keys(i).map(e => function(e, t) {
              if ("aggregate" !== e.type || !e.aggregation) throw new Error("Unexpected input: " + JSON.stringify(e));
              let r = y(e);
              return r.variable = t, r
            }(i[e], l.createTerm(e))),
            n = [];
          if (e.group)
            for (let r of e.group)
              if (r.expression.type) {
                const e = r.variable ? r.variable : v();
                t = l.createExtend(t, e, y(r.expression)), n.push(e)
              } else n.push(r.expression);
          t = l.createGroup(t, n, r)
        }
        if (e.having)
          for (let r of e.having) t = l.createFilter(t, y(r));
        e.values && (t = l.createJoin(t, x(e)));
        let s = new Set;
        if ("SELECT" === e.queryType || "DESCRIBE" === e.queryType)
          if (e.variables.some(e => e && a.default.isWildcard(e))) s = r;
          else
            for (let t of e.variables) g(t) || !t.variable ? s.add(t) : t.variable && (s.add(t.variable), n.push(t));
        for (let e of n) t = l.createExtend(t, e.variable, y(e.expression));
        e.order && (t = l.createOrderBy(t, e.order.map(e => {
          let t = y(e.expression);
          return e.descending && (t = l.createOperatorExpression(c.DESC, [t])), t
        })));
        "SELECT" === e.queryType && (t = l.createProject(t, Array.from(s)));
        e.distinct && (t = l.createDistinct(t));
        e.reduced && (t = l.createReduced(t));
        "CONSTRUCT" === e.queryType ? t = l.createConstruct(t, e.template.map(w)) : "ASK" === e.queryType ? t = l.createAsk(t) : "DESCRIBE" === e.queryType && (t = l.createDescribe(t, Array.from(s)));
        (e.offset || e.limit) && (t = l.createSlice(t, e.offset, e.limit));
        e.from && (t = l.createFrom(t, e.from.default, e.from.named));
        return t
      }(e, n, i)
    } else "update" === e.type && (n = 1 === (s = e).updates.length ? A(s.updates[0]) : l.createCompositeUpdate(s.updates.map(A)));
    var s;
    return r && (n = function e(t, r) {
      const n = {},
        i = Array.from(r).reduce((e, t) => (e[t.value] = !0, e), {});
      return a.default.mapOperation(t, {
        path: (e, t) => ({
          result: t.createPath(s(e.subject), e.predicate, s(e.object), s(e.graph)),
          recurse: !1
        }),
        pattern: (e, t) => ({
          result: t.createPattern(s(e.subject), s(e.predicate), s(e.object), s(e.graph)),
          recurse: !1
        }),
        construct: t => ({
          result: l.createConstruct(e(t.input, r), t.template),
          recurse: !1
        })
      });

      function s(e) {
        if ("BlankNode" === e.termType) {
          let t = n[e.value];
          return t || (t = a.default.createUniqueVariable(e.value, i, l.dataFactory), i[t.value] = !0, n[e.value] = t), t
        }
        return e
      }
    }(n, i)), n
  }

  function g(e) {
    return e && "Variable" === e.termType
  }

  function m(e) {
    let t, r = [],
      n = [];
    if (e.patterns)
      for (let t of e.patterns)("filter" === t.type ? r : n).push(t);
    if ("bgp" === e.type) return function(e) {
      let t = [],
        r = [];
      for (let n of e.triples)
        if ("path" === n.predicate.type) {
          let e = b(n);
          for (let n of e) n.type === c.PATH ? (t.length > 0 && r.push(l.createBgp(t)), t = [], r.push(n)) : t.push(n)
        } else t.push(w(n));
      t.length > 0 && r.push(l.createBgp(t));
      return 1 === r.length ? r[0] : r.reduce((e, t) => l.createJoin(e, t))
    }(e);
    if ("union" === e.type) t = n.map(e => ("group" !== e.type && (e = {
      type: "group",
      patterns: [e]
    }), m(e))).reduce((e, t) => l.createUnion(e, t));
    else {
      if ("graph" === e.type) return function(e) {
        e.type = "group";
        let t = m(e);
        t = p ? function e(t, r, n) {
          if (t.type === c.BGP) t.patterns = t.patterns.map(e => (n && (e.subject.equals(r) && (e.subject = n), e.predicate.equals(r) && (e.predicate = n), e.object.equals(r) && (e.object = n)), e.graph = r, e));
          else if (t.type === c.PATH) {
            const e = t;
            n && (e.subject.equals(r) && (e.subject = n), e.object.equals(r) && (e.object = n)), t.graph = r
          } else if (t.type !== c.PROJECT || n)
            if (t.type !== c.EXTEND || n)
              for (let i of Object.keys(t)) Array.isArray(t[i]) ? t[i] = t[i].map(t => e(t, r, n)) : S.indexOf(t[i].type) >= 0 ? t[i] = e(t[i], r, n) : n && g(t[i]) && t[i].equals(r) && (t[i] = n);
            else {
              const i = t;
              i.variable.equals(r) && (n = v()), i.input = e(i.input, r, n)
            }
          else {
            const i = t;
            i.variables.some(e => e.equals(r)) || (n = v()), i.input = e(i.input, r, n)
          }
          return t
        }(t, e.name) : l.createGraph(t, e.name);
        return t
      }(e);
      if ("group" === e.type) t = n.reduce(T, l.createBgp([]));
      else if ("values" === e.type) t = x(e);
      else {
        if ("query" !== e.type) throw new Error("Unexpected type: " + e.type);
        t = f(e, p, !1)
      }
    }
    if (r.length > 0) {
      let e = r.map(e => y(e.expression));
      e.length > 0 && (t = l.createFilter(t, e.reduce((e, t) => l.createOperatorExpression("&&", [e, t]))))
    }
    return t
  }

  function y(e) {
    if (a.default.isTerm(e) || "Quad" === e.termType) return l.createTermExpression(e);
    if (a.default.isWildcard(e)) return l.createWildcardExpression();
    if (e.aggregation) return l.createAggregateExpression(e.aggregation, y(e.expression), e.distinct, e.separator);
    if (e.function) return l.createNamedExpression(e.function, e.args.map(y));
    if (e.operator) return "exists" === e.operator || "notexists" === e.operator ? l.createExistenceExpression("notexists" === e.operator, m(e.args[0])) : ("in" !== e.operator && "notin" !== e.operator || (e.args = [e.args[0]].concat(e.args[1])), l.createOperatorExpression(e.operator, e.args.map(y)));
    throw new Error("Unknown expression: " + JSON.stringify(e))
  }

  function b(e) {
    return function e(t, r, n) {
      if (r.type === c.LINK) return [l.createPattern(t, r.iri, n)];
      if (r.type === c.INV) return e(n, r.path, t);
      if (r.type === c.SEQ) {
        let i = v(),
          a = e(t, r.left, i),
          s = e(i, r.right, n);
        return a.concat(s)
      }
      return [l.createPath(t, r, n)]
    }(e.subject, _(e.predicate), e.object)
  }

  function _(e) {
    if (a.default.isTerm(e) && "NamedNode" === e.termType) return l.createLink(e);
    if ("^" === e.pathType) return l.createInv(_(e.items[0]));
    if ("!" === e.pathType) {
      let t, r = [],
        n = [];
      t = "path" === e.items[0].type && "|" === e.items[0].pathType ? e.items[0].items : e.items;
      for (let e of t)
        if (a.default.isTerm(e)) r.push(e);
        else {
          if ("^" !== e.pathType) throw new Error("Unexpected item: " + JSON.stringify(e));
          n.push(e.items[0])
        } let i = l.createNps(r),
        s = l.createInv(l.createNps(n));
      return 0 === n.length ? i : 0 === r.length ? s : l.createAlt(i, s)
    }
    if ("/" === e.pathType) return e.items.map(_).reduce((e, t) => l.createSeq(e, t));
    if ("|" === e.pathType) return e.items.map(_).reduce((e, t) => l.createAlt(e, t));
    if ("*" === e.pathType) return l.createZeroOrMorePath(_(e.items[0]));
    if ("+" === e.pathType) return l.createOneOrMorePath(_(e.items[0]));
    if ("?" === e.pathType) return l.createZeroOrOnePath(_(e.items[0]));
    throw new Error("Unable to translate path expression " + JSON.stringify(e))
  }

  function v() {
    let e = "?var" + d++;
    return h.has(e) ? v() : (h.add(e), l.createTerm(e))
  }

  function w(e) {
    return l.createPattern(e.subject, e.predicate, e.object, e.graph)
  }
  t.default = function(e, t) {
    if (t = t || {}, l = new i.default(t.dataFactory), "string" == typeof e) {
      let r = new u(t);
      r._resetBlanks(), e = r.parse(e)
    }
    return f(e, t.quads, t.blankToVariable)
  };
  let S = Object.keys(c).map(e => c[e]);

  function T(e, t) {
    if ("optional" === t.type) {
      let r = m({
        type: "group",
        patterns: t.patterns
      });
      if (r.type === c.FILTER) {
        let t = r;
        e = l.createLeftJoin(e, t.input, t.expression)
      } else e = l.createLeftJoin(e, r)
    } else if ("minus" === t.type) {
      let r = m({
        type: "group",
        patterns: t.patterns
      });
      e = l.createMinus(e, r)
    } else if ("bind" === t.type) e = l.createExtend(e, t.variable, y(t.expression));
    else if ("service" === t.type) {
      t.type = "group", e = E(e, l.createService(m(t), t.name, t.silent))
    } else {
      e = E(e, m(t))
    }
    return e
  }

  function E(e, t) {
    return e.type === c.BGP && t.type === c.BGP ? e = l.createBgp([].concat(e.patterns, t.patterns)) : e.type === c.BGP && 0 === e.patterns.length ? e = t : t.type === c.BGP && 0 === t.patterns.length || (e = l.createJoin(e, t)), e
  }

  function x(e) {
    let t = (0 === e.values.length ? [] : Object.keys(e.values[0])).map(l.createTerm.bind(l)),
      r = e.values.map(e => {
        let t = Object.keys(e);
        t = t.filter(t => void 0 !== e[t]);
        let r = {};
        for (let n of t) r[n] = e[n];
        return r
      });
    return l.createValues(t, r)
  }

  function O(e, t) {
    if (!e) return e;
    if ("aggregate" === e.type) {
      let r, n = !1;
      for (let i of Object.keys(t))
        if (s(t[i], e)) {
          r = l.createTerm(i), n = !0;
          break
        } return n || (r = v(), t[o.termToString(r)] = e), r
    }
    return e.expression ? e.expression = O(e.expression, t) : e.args ? O(e.args, t) : Array.isArray(e) && e.forEach((r, n) => e[n] = O(r, t)), e
  }

  function A(e) {
    if ("insertdelete" === e.updateType || "deletewhere" === e.updateType || "delete" === e.updateType || "insert" === e.updateType) return function(e) {
      if (!p) throw new Error("INSERT/DELETE operations are only supported with quads option enabled");
      let t, r = [],
        n = [];
      e.delete && (r = a.default.flatten(e.delete.map(t => R(t, e.graph))));
      e.insert && (n = a.default.flatten(e.insert.map(t => R(t, e.graph))));
      e.where && e.where.length > 0 && (t = m({
        type: "group",
        patterns: e.where
      }), e.using ? t = l.createFrom(t, e.using.default, e.using.named) : e.graph && (t = l.createFrom(t, [e.graph], [])));
      return l.createDeleteInsert(r.length > 0 ? r.map(w) : void 0, n.length > 0 ? n.map(w) : void 0, t)
    }(e);
    if ("load" === e.type) return function(e) {
      return l.createLoad(e.source, e.destination, e.silent)
    }(e);
    if ("clear" === e.type || "create" === e.type || "drop" === e.type) return function(e) {
      let t;
      t = e.graph.all ? "ALL" : e.graph.default ? "DEFAULT" : e.graph.named ? "NAMED" : e.graph.name;
      switch (e.type) {
        case "clear":
          return l.createClear(t, e.silent);
        case "create":
          return l.createCreate(t, e.silent);
        case "drop":
          return l.createDrop(t, e.silent)
      }
    }(e);
    if ("add" === e.type || "copy" === e.type || "move" === e.type) return function(e) {
      const t = e.source.default ? "DEFAULT" : e.source.name,
        r = e.destination.default ? "DEFAULT" : e.destination.name;
      switch (e.type) {
        case "copy":
          return l.createCopy(t, r, e.silent);
        case "move":
          return l.createMove(t, r, e.silent);
        case "add":
          return l.createAdd(t, r, e.silent)
      }
    }(e);
    throw new Error("Unknown update type " + e.updateType)
  }

  function R(e, t) {
    let r = t;
    "graph" === e.type && (r = e.name);
    let n = e.triples;
    return r && (n = n.map(e => Object.assign(e, {
      graph: r
    }))), n
  }
}, function(e, t, r) {
  (function(e, n) {
    var i = function() {
      var e = function(e, t, r, n) {
          for (r = r || {}, n = e.length; n--; r[e[n]] = t);
          return r
        },
        t = [6, 12, 15, 28, 41, 50, 55, 107, 117, 120, 122, 123, 132, 133, 138, 320, 321, 322, 323, 324],
        n = [2, 208],
        i = [107, 117, 120, 122, 123, 132, 133, 138, 320, 321, 322, 323, 324],
        a = [1, 20],
        s = [1, 29],
        o = [6, 90],
        u = [45, 46, 58],
        c = [45, 58],
        l = [1, 58],
        h = [1, 60],
        d = [1, 56],
        p = [1, 59],
        f = [1, 65],
        g = [1, 66],
        m = [26, 34, 35],
        y = [13, 16, 310],
        b = [119, 141, 318, 325],
        _ = [13, 16, 119, 141, 310],
        v = [1, 88],
        w = [1, 92],
        S = [1, 94],
        T = [119, 141, 318, 319, 325],
        E = [13, 16, 119, 141, 310, 319],
        x = [1, 100],
        O = [2, 250],
        A = [1, 99],
        R = [13, 16, 34, 35, 87, 93, 224, 229, 243, 244, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310],
        I = [6, 45, 46, 58, 68, 75, 78, 86, 88, 90],
        N = [6, 13, 16, 34, 45, 46, 58, 68, 75, 78, 86, 88, 90, 310],
        P = [6, 13, 16, 26, 34, 35, 37, 38, 45, 46, 48, 58, 68, 75, 78, 86, 87, 88, 90, 93, 100, 116, 119, 132, 133, 135, 140, 167, 168, 170, 173, 174, 191, 195, 217, 222, 224, 225, 229, 233, 243, 244, 248, 252, 256, 271, 276, 293, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 326, 328, 329, 331, 332, 333, 334, 335, 336, 337, 338],
        C = [34, 35, 45, 46, 58],
        D = [13, 16, 34, 35, 87, 273, 274, 275, 277, 279, 280, 282, 283, 286, 288, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 338, 339, 340, 341, 342, 343],
        j = [2, 451],
        k = [1, 123],
        L = [1, 117],
        M = [1, 124],
        F = [1, 125],
        B = [6, 13, 16, 34, 35, 46, 48, 87, 90, 93, 119, 167, 168, 170, 173, 174, 224, 229, 243, 244, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 326],
        q = [2, 309],
        U = [1, 142],
        V = [1, 140],
        H = [6, 191],
        G = [2, 326],
        z = [2, 314],
        Q = [45, 135],
        X = [6, 48, 78, 86, 88, 90],
        $ = [2, 254],
        Y = [1, 156],
        J = [1, 158],
        W = [6, 48, 75, 78, 86, 88, 90],
        K = [2, 252],
        Z = [1, 164],
        ee = [1, 176],
        te = [1, 174],
        re = [1, 184],
        ne = [1, 182],
        ie = [1, 175],
        ae = [1, 180],
        se = [1, 181],
        oe = [1, 185],
        ue = [1, 186],
        ce = [1, 189],
        le = [1, 190],
        he = [1, 191],
        de = [1, 192],
        pe = [1, 193],
        fe = [1, 194],
        ge = [1, 195],
        me = [1, 196],
        ye = [1, 197],
        be = [1, 198],
        _e = [1, 199],
        ve = [6, 68, 75, 78, 86, 88, 90],
        we = [37, 38, 191, 248, 276],
        Se = [37, 38, 191, 248, 252, 276],
        Te = [37, 38, 191, 248, 252, 256, 271, 276, 293, 304, 305, 306, 307, 308, 309, 332, 333, 334, 335, 336, 337, 338],
        Ee = [26, 37, 38, 191, 248, 252, 256, 271, 276, 293, 304, 305, 306, 307, 308, 309, 329, 332, 333, 334, 335, 336, 337, 338],
        xe = [1, 229],
        Oe = [1, 230],
        Ae = [1, 232],
        Re = [1, 233],
        Ie = [1, 234],
        Ne = [1, 235],
        Pe = [1, 237],
        Ce = [1, 238],
        De = [2, 458],
        je = [1, 240],
        ke = [1, 241],
        Le = [1, 242],
        Me = [1, 248],
        Fe = [1, 243],
        Be = [1, 244],
        qe = [1, 245],
        Ue = [1, 246],
        Ve = [1, 247],
        He = [13, 16, 48, 87, 100, 229, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310],
        Ge = [48, 93],
        ze = [34, 38],
        Qe = [6, 116, 191],
        Xe = [48, 119],
        $e = [6, 48, 86, 88, 90],
        Ye = [2, 338],
        Je = [2, 330],
        We = [1, 293],
        Ke = [1, 295],
        Ze = [48, 119, 326],
        et = [13, 16, 34, 195, 310],
        tt = [13, 16, 34, 35, 38, 46, 48, 87, 90, 93, 119, 167, 168, 170, 173, 174, 191, 195, 217, 222, 224, 225, 229, 233, 243, 244, 276, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 326],
        rt = [13, 16, 26, 34, 35, 37, 38, 46, 48, 87, 90, 93, 100, 119, 167, 168, 170, 173, 174, 191, 195, 217, 222, 224, 225, 229, 233, 243, 244, 248, 252, 256, 271, 276, 293, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 326, 329, 332, 333, 334, 335, 336, 337, 338],
        nt = [13, 16, 26, 34, 35, 37, 38, 46, 48, 87, 90, 93, 100, 119, 167, 168, 170, 173, 174, 191, 195, 217, 222, 224, 225, 229, 233, 243, 244, 248, 252, 256, 271, 276, 293, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 326, 329, 332, 333, 334, 335, 336, 337, 338],
        it = [13, 16, 34, 35, 87, 217, 271, 273, 274, 275, 277, 279, 280, 282, 283, 286, 288, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 332, 338, 339, 340, 341, 342, 343],
        at = [1, 329],
        st = [1, 330],
        ot = [1, 332],
        ut = [1, 331],
        ct = [6, 13, 16, 26, 34, 35, 37, 38, 46, 48, 75, 78, 81, 83, 86, 87, 88, 90, 93, 119, 167, 168, 170, 173, 174, 191, 224, 229, 243, 244, 248, 252, 256, 271, 273, 274, 275, 276, 277, 279, 280, 282, 283, 286, 288, 293, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 326, 329, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343],
        lt = [1, 340],
        ht = [1, 339],
        dt = [35, 93],
        pt = [1, 353],
        ft = [1, 354],
        gt = [1, 367],
        mt = [6, 48, 90],
        yt = [6, 13, 16, 35, 48, 78, 86, 88, 90, 273, 274, 275, 277, 279, 280, 282, 283, 286, 288, 310, 338, 339, 340, 341, 342, 343],
        bt = [6, 13, 16, 34, 35, 46, 48, 78, 81, 83, 86, 87, 88, 90, 93, 119, 167, 168, 170, 173, 174, 224, 229, 243, 244, 273, 274, 275, 277, 279, 280, 282, 283, 286, 288, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 326, 338, 339, 340, 341, 342, 343],
        _t = [46, 48, 90, 119, 167, 168, 170, 173, 174],
        vt = [1, 386],
        wt = [1, 387],
        St = [1, 393],
        Tt = [1, 392],
        Et = [48, 119, 191, 225, 326],
        xt = [2, 370],
        Ot = [13, 16, 34, 35, 38, 87, 93, 224, 229, 243, 244, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310],
        At = [13, 16, 34, 35, 38, 46, 48, 87, 90, 93, 119, 167, 168, 170, 173, 174, 191, 224, 225, 229, 243, 244, 276, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 326],
        Rt = [13, 16, 26, 34, 35, 87, 217, 271, 273, 274, 275, 277, 279, 280, 282, 283, 286, 288, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 332, 338, 339, 340, 341, 342, 343],
        It = [13, 16, 38, 48, 87, 100, 229, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310],
        Nt = [35, 48],
        Pt = [2, 329],
        Ct = [1, 451],
        Dt = [1, 448],
        jt = [1, 449],
        kt = [6, 13, 16, 26, 34, 35, 37, 38, 46, 48, 68, 75, 78, 81, 83, 86, 87, 88, 90, 93, 119, 167, 168, 170, 173, 174, 191, 224, 229, 243, 244, 248, 252, 256, 271, 273, 274, 275, 276, 277, 279, 280, 282, 283, 286, 288, 293, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 326, 327, 329, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343],
        Lt = [13, 16, 35, 195, 217, 222, 310],
        Mt = [2, 384],
        Ft = [1, 469],
        Bt = [46, 48, 90, 119, 167, 168, 170, 173, 174, 326],
        qt = [13, 16, 34, 35, 195, 217, 222, 310],
        Ut = [6, 13, 16, 34, 35, 48, 75, 78, 86, 88, 90, 273, 274, 275, 277, 279, 280, 282, 283, 286, 288, 310, 338, 339, 340, 341, 342, 343],
        Vt = [13, 16, 34, 35, 38, 46, 48, 87, 90, 93, 119, 167, 168, 170, 173, 174, 191, 195, 224, 225, 229, 243, 244, 276, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 326],
        Ht = [6, 13, 16, 34, 35, 48, 81, 83, 86, 88, 90, 273, 274, 275, 277, 279, 280, 282, 283, 286, 288, 310, 338, 339, 340, 341, 342, 343],
        Gt = [13, 16, 34, 35, 46, 48, 87, 90, 93, 119, 167, 168, 170, 173, 174, 224, 229, 243, 244, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310],
        zt = [13, 16, 34, 310],
        Qt = [13, 16, 34, 35, 46, 48, 87, 90, 93, 119, 167, 168, 170, 173, 174, 224, 229, 243, 244, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 326],
        Xt = [2, 341],
        $t = [46, 48, 90, 119, 167, 168, 170, 173, 174, 191, 225, 326],
        Yt = [13, 16, 34, 35, 37, 38, 46, 48, 87, 90, 93, 119, 167, 168, 170, 173, 174, 191, 195, 217, 222, 224, 225, 229, 233, 243, 244, 276, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 326],
        Jt = [2, 336],
        Wt = [13, 16, 35, 195, 217, 310],
        Kt = [13, 16, 34, 35, 38, 46, 48, 87, 90, 93, 119, 167, 168, 170, 173, 174, 191, 195, 217, 222, 224, 225, 229, 243, 244, 276, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 326],
        Zt = [13, 16, 38, 87, 100, 229, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310],
        er = [13, 16, 34, 38, 48, 87, 100, 195, 229, 233, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310],
        tr = [13, 16, 34, 35, 48, 87, 93, 119, 224, 229, 243, 244, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310],
        rr = [13, 16, 34, 35, 38, 87, 93, 224, 229, 243, 244, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 328, 329],
        nr = [13, 16, 26, 34, 35, 38, 87, 93, 224, 229, 243, 244, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 328, 329, 331, 332],
        ir = [1, 630],
        ar = [1, 631],
        sr = [2, 324],
        or = [13, 16, 38, 195, 222, 310],
        ur = {
          trace: function() {},
          yy: {},
          symbols_: {
            error: 2,
            QueryOrUpdate: 3,
            Prologue: 4,
            QueryOrUpdate_group0: 5,
            EOF: 6,
            Prologue_repetition0: 7,
            Query: 8,
            Query_group0: 9,
            Query_option0: 10,
            BaseDecl: 11,
            BASE: 12,
            IRIREF: 13,
            PrefixDecl: 14,
            PREFIX: 15,
            PNAME_NS: 16,
            SelectQuery: 17,
            SelectClauseWildcard: 18,
            SelectQuery_repetition0: 19,
            WhereClause: 20,
            SolutionModifierNoGroup: 21,
            SelectClauseVars: 22,
            SelectQuery_repetition1: 23,
            SolutionModifier: 24,
            SelectClauseBase: 25,
            "*": 26,
            SelectClauseVars_repetition_plus0: 27,
            SELECT: 28,
            SelectClauseBase_option0: 29,
            SubSelect: 30,
            SubSelect_option0: 31,
            SubSelect_option1: 32,
            SelectClauseItem: 33,
            VAR: 34,
            "(": 35,
            Expression: 36,
            AS: 37,
            ")": 38,
            VarTriple: 39,
            ConstructQuery: 40,
            CONSTRUCT: 41,
            ConstructTemplate: 42,
            ConstructQuery_repetition0: 43,
            ConstructQuery_repetition1: 44,
            WHERE: 45,
            "{": 46,
            ConstructQuery_option0: 47,
            "}": 48,
            DescribeQuery: 49,
            DESCRIBE: 50,
            DescribeQuery_group0: 51,
            DescribeQuery_repetition0: 52,
            DescribeQuery_option0: 53,
            AskQuery: 54,
            ASK: 55,
            AskQuery_repetition0: 56,
            DatasetClause: 57,
            FROM: 58,
            DatasetClause_option0: 59,
            iri: 60,
            WhereClause_option0: 61,
            GroupGraphPattern: 62,
            SolutionModifier_option0: 63,
            SolutionModifierNoGroup_option0: 64,
            SolutionModifierNoGroup_option1: 65,
            SolutionModifierNoGroup_option2: 66,
            GroupClause: 67,
            GROUP: 68,
            BY: 69,
            GroupClause_repetition_plus0: 70,
            GroupCondition: 71,
            BuiltInCall: 72,
            FunctionCall: 73,
            HavingClause: 74,
            HAVING: 75,
            HavingClause_repetition_plus0: 76,
            OrderClause: 77,
            ORDER: 78,
            OrderClause_repetition_plus0: 79,
            OrderCondition: 80,
            ASC: 81,
            BrackettedExpression: 82,
            DESC: 83,
            Constraint: 84,
            LimitOffsetClauses: 85,
            LIMIT: 86,
            INTEGER: 87,
            OFFSET: 88,
            ValuesClause: 89,
            VALUES: 90,
            InlineData: 91,
            InlineData_repetition0: 92,
            NIL: 93,
            InlineData_repetition1: 94,
            InlineData_repetition_plus2: 95,
            InlineData_repetition3: 96,
            DataBlockValue: 97,
            Literal: 98,
            ConstTriple: 99,
            UNDEF: 100,
            DataBlockValueList: 101,
            DataBlockValueList_repetition_plus0: 102,
            Update: 103,
            Update_repetition0: 104,
            Update1: 105,
            Update_option0: 106,
            LOAD: 107,
            Update1_option0: 108,
            Update1_option1: 109,
            Update1_group0: 110,
            Update1_option2: 111,
            GraphRefAll: 112,
            Update1_group1: 113,
            Update1_option3: 114,
            GraphOrDefault: 115,
            TO: 116,
            CREATE: 117,
            Update1_option4: 118,
            GRAPH: 119,
            INSERTDATA: 120,
            QuadPattern: 121,
            DELETEDATA: 122,
            DELETEWHERE: 123,
            Update1_option5: 124,
            InsertClause: 125,
            Update1_option6: 126,
            Update1_repetition0: 127,
            Update1_option7: 128,
            DeleteClause: 129,
            Update1_option8: 130,
            Update1_repetition1: 131,
            DELETE: 132,
            INSERT: 133,
            UsingClause: 134,
            USING: 135,
            UsingClause_option0: 136,
            WithClause: 137,
            WITH: 138,
            IntoGraphClause: 139,
            INTO: 140,
            DEFAULT: 141,
            GraphOrDefault_option0: 142,
            GraphRefAll_group0: 143,
            QuadPattern_option0: 144,
            QuadPattern_repetition0: 145,
            QuadsNotTriples: 146,
            QuadsNotTriples_group0: 147,
            QuadsNotTriples_option0: 148,
            QuadsNotTriples_option1: 149,
            QuadsNotTriples_option2: 150,
            TriplesTemplate: 151,
            TriplesTemplate_repetition0: 152,
            TriplesSameSubject: 153,
            TriplesTemplate_option0: 154,
            GroupGraphPatternSub: 155,
            GroupGraphPatternSub_option0: 156,
            GroupGraphPatternSub_repetition0: 157,
            GroupGraphPatternSubTail: 158,
            GraphPatternNotTriples: 159,
            GroupGraphPatternSubTail_option0: 160,
            GroupGraphPatternSubTail_option1: 161,
            TriplesBlock: 162,
            TriplesBlock_repetition0: 163,
            TriplesSameSubjectPath: 164,
            TriplesBlock_option0: 165,
            GraphPatternNotTriples_repetition0: 166,
            OPTIONAL: 167,
            MINUS: 168,
            GraphPatternNotTriples_group0: 169,
            SERVICE: 170,
            GraphPatternNotTriples_option0: 171,
            GraphPatternNotTriples_group1: 172,
            FILTER: 173,
            BIND: 174,
            FunctionCall_option0: 175,
            FunctionCall_repetition0: 176,
            ExpressionList: 177,
            ExpressionList_repetition0: 178,
            ConstructTemplate_option0: 179,
            ConstructTriples: 180,
            ConstructTriples_repetition0: 181,
            ConstructTriples_option0: 182,
            TriplesSameSubject_group0: 183,
            PropertyListNotEmpty: 184,
            TriplesNode: 185,
            PropertyList: 186,
            PropertyList_option0: 187,
            VerbObjectList: 188,
            PropertyListNotEmpty_repetition0: 189,
            SemiOptionalVerbObjectList: 190,
            ";": 191,
            SemiOptionalVerbObjectList_option0: 192,
            Verb: 193,
            ObjectList: 194,
            a: 195,
            ObjectList_repetition0: 196,
            GraphNode: 197,
            TriplesSameSubjectPath_group0: 198,
            PropertyListPathNotEmpty: 199,
            TriplesNodePath: 200,
            TriplesSameSubjectPath_option0: 201,
            PropertyListPathNotEmpty_group0: 202,
            PropertyListPathNotEmpty_repetition0: 203,
            GraphNodePath: 204,
            PropertyListPathNotEmpty_repetition1: 205,
            PropertyListPathNotEmptyTail: 206,
            PropertyListPathNotEmptyTail_group0: 207,
            Path: 208,
            Path_repetition0: 209,
            PathSequence: 210,
            PathSequence_repetition0: 211,
            PathEltOrInverse: 212,
            PathElt: 213,
            PathPrimary: 214,
            PathElt_option0: 215,
            PathEltOrInverse_option0: 216,
            "!": 217,
            PathNegatedPropertySet: 218,
            PathOneInPropertySet: 219,
            PathNegatedPropertySet_repetition0: 220,
            PathNegatedPropertySet_option0: 221,
            "^": 222,
            TriplesNode_repetition_plus0: 223,
            "[": 224,
            "]": 225,
            TriplesNodePath_repetition_plus0: 226,
            GraphNode_group0: 227,
            GraphNodePath_group0: 228,
            "<<": 229,
            VarTriple_group0: 230,
            VarTriple_group1: 231,
            VarTriple_group2: 232,
            ">>": 233,
            VarTriple_group3: 234,
            VarTriple_group4: 235,
            ConstTriple_group0: 236,
            ConstTriple_group1: 237,
            ConstTriple_group2: 238,
            ConstTriple_group3: 239,
            ConstTriple_group4: 240,
            VarOrTerm: 241,
            Term: 242,
            BLANK_NODE_LABEL: 243,
            ANON: 244,
            ConditionalAndExpression: 245,
            Expression_repetition0: 246,
            ExpressionTail: 247,
            "||": 248,
            RelationalExpression: 249,
            ConditionalAndExpression_repetition0: 250,
            ConditionalAndExpressionTail: 251,
            "&&": 252,
            AdditiveExpression: 253,
            RelationalExpression_group0: 254,
            RelationalExpression_option0: 255,
            IN: 256,
            MultiplicativeExpression: 257,
            AdditiveExpression_repetition0: 258,
            AdditiveExpressionTail: 259,
            AdditiveExpressionTail_group0: 260,
            NumericLiteralPositive: 261,
            AdditiveExpressionTail_repetition0: 262,
            NumericLiteralNegative: 263,
            AdditiveExpressionTail_repetition1: 264,
            UnaryExpression: 265,
            MultiplicativeExpression_repetition0: 266,
            MultiplicativeExpressionTail: 267,
            MultiplicativeExpressionTail_group0: 268,
            UnaryExpression_option0: 269,
            PrimaryExpression: 270,
            "-": 271,
            Aggregate: 272,
            FUNC_ARITY0: 273,
            FUNC_ARITY1: 274,
            FUNC_ARITY2: 275,
            ",": 276,
            IF: 277,
            BuiltInCall_group0: 278,
            BOUND: 279,
            BNODE: 280,
            BuiltInCall_option0: 281,
            EXISTS: 282,
            COUNT: 283,
            Aggregate_option0: 284,
            Aggregate_group0: 285,
            FUNC_AGGREGATE: 286,
            Aggregate_option1: 287,
            GROUP_CONCAT: 288,
            Aggregate_option2: 289,
            Aggregate_option3: 290,
            GroupConcatSeparator: 291,
            SEPARATOR: 292,
            "=": 293,
            String: 294,
            LANGTAG: 295,
            "^^": 296,
            DECIMAL: 297,
            DOUBLE: 298,
            BOOLEAN: 299,
            STRING_LITERAL1: 300,
            STRING_LITERAL2: 301,
            STRING_LITERAL_LONG1: 302,
            STRING_LITERAL_LONG2: 303,
            INTEGER_POSITIVE: 304,
            DECIMAL_POSITIVE: 305,
            DOUBLE_POSITIVE: 306,
            INTEGER_NEGATIVE: 307,
            DECIMAL_NEGATIVE: 308,
            DOUBLE_NEGATIVE: 309,
            PNAME_LN: 310,
            QueryOrUpdate_group0_option0: 311,
            Prologue_repetition0_group0: 312,
            SelectClauseBase_option0_group0: 313,
            DISTINCT: 314,
            REDUCED: 315,
            DescribeQuery_group0_repetition_plus0_group0: 316,
            DescribeQuery_group0_repetition_plus0: 317,
            NAMED: 318,
            SILENT: 319,
            CLEAR: 320,
            DROP: 321,
            ADD: 322,
            MOVE: 323,
            COPY: 324,
            ALL: 325,
            ".": 326,
            UNION: 327,
            "|": 328,
            "/": 329,
            PathElt_option0_group0: 330,
            "?": 331,
            "+": 332,
            "!=": 333,
            "<": 334,
            ">": 335,
            "<=": 336,
            ">=": 337,
            NOT: 338,
            CONCAT: 339,
            COALESCE: 340,
            SUBSTR: 341,
            REGEX: 342,
            REPLACE: 343,
            $accept: 0,
            $end: 1
          },
          terminals_: {
            2: "error",
            6: "EOF",
            12: "BASE",
            13: "IRIREF",
            15: "PREFIX",
            16: "PNAME_NS",
            26: "*",
            28: "SELECT",
            34: "VAR",
            35: "(",
            37: "AS",
            38: ")",
            41: "CONSTRUCT",
            45: "WHERE",
            46: "{",
            48: "}",
            50: "DESCRIBE",
            55: "ASK",
            58: "FROM",
            68: "GROUP",
            69: "BY",
            75: "HAVING",
            78: "ORDER",
            81: "ASC",
            83: "DESC",
            86: "LIMIT",
            87: "INTEGER",
            88: "OFFSET",
            90: "VALUES",
            93: "NIL",
            100: "UNDEF",
            107: "LOAD",
            116: "TO",
            117: "CREATE",
            119: "GRAPH",
            120: "INSERTDATA",
            122: "DELETEDATA",
            123: "DELETEWHERE",
            132: "DELETE",
            133: "INSERT",
            135: "USING",
            138: "WITH",
            140: "INTO",
            141: "DEFAULT",
            167: "OPTIONAL",
            168: "MINUS",
            170: "SERVICE",
            173: "FILTER",
            174: "BIND",
            191: ";",
            195: "a",
            217: "!",
            222: "^",
            224: "[",
            225: "]",
            229: "<<",
            233: ">>",
            243: "BLANK_NODE_LABEL",
            244: "ANON",
            248: "||",
            252: "&&",
            256: "IN",
            271: "-",
            273: "FUNC_ARITY0",
            274: "FUNC_ARITY1",
            275: "FUNC_ARITY2",
            276: ",",
            277: "IF",
            279: "BOUND",
            280: "BNODE",
            282: "EXISTS",
            283: "COUNT",
            286: "FUNC_AGGREGATE",
            288: "GROUP_CONCAT",
            292: "SEPARATOR",
            293: "=",
            295: "LANGTAG",
            296: "^^",
            297: "DECIMAL",
            298: "DOUBLE",
            299: "BOOLEAN",
            300: "STRING_LITERAL1",
            301: "STRING_LITERAL2",
            302: "STRING_LITERAL_LONG1",
            303: "STRING_LITERAL_LONG2",
            304: "INTEGER_POSITIVE",
            305: "DECIMAL_POSITIVE",
            306: "DOUBLE_POSITIVE",
            307: "INTEGER_NEGATIVE",
            308: "DECIMAL_NEGATIVE",
            309: "DOUBLE_NEGATIVE",
            310: "PNAME_LN",
            314: "DISTINCT",
            315: "REDUCED",
            318: "NAMED",
            319: "SILENT",
            320: "CLEAR",
            321: "DROP",
            322: "ADD",
            323: "MOVE",
            324: "COPY",
            325: "ALL",
            326: ".",
            327: "UNION",
            328: "|",
            329: "/",
            331: "?",
            332: "+",
            333: "!=",
            334: "<",
            335: ">",
            336: "<=",
            337: ">=",
            338: "NOT",
            339: "CONCAT",
            340: "COALESCE",
            341: "SUBSTR",
            342: "REGEX",
            343: "REPLACE"
          },
          productions_: [0, [3, 3],
            [4, 1],
            [8, 2],
            [11, 2],
            [14, 3],
            [17, 4],
            [17, 4],
            [18, 2],
            [22, 2],
            [25, 2],
            [30, 4],
            [30, 4],
            [33, 1],
            [33, 5],
            [33, 5],
            [40, 5],
            [40, 7],
            [49, 5],
            [54, 4],
            [57, 3],
            [20, 2],
            [24, 2],
            [21, 3],
            [67, 3],
            [71, 1],
            [71, 1],
            [71, 3],
            [71, 5],
            [71, 1],
            [74, 2],
            [77, 3],
            [80, 2],
            [80, 2],
            [80, 1],
            [80, 1],
            [85, 2],
            [85, 2],
            [85, 4],
            [85, 4],
            [89, 2],
            [91, 4],
            [91, 4],
            [91, 6],
            [97, 1],
            [97, 1],
            [97, 1],
            [97, 1],
            [101, 3],
            [103, 3],
            [105, 4],
            [105, 3],
            [105, 5],
            [105, 4],
            [105, 2],
            [105, 2],
            [105, 2],
            [105, 6],
            [105, 6],
            [129, 2],
            [125, 2],
            [134, 3],
            [137, 2],
            [139, 3],
            [115, 1],
            [115, 2],
            [112, 2],
            [112, 1],
            [121, 4],
            [146, 7],
            [151, 3],
            [62, 3],
            [62, 3],
            [155, 2],
            [158, 3],
            [162, 3],
            [159, 2],
            [159, 2],
            [159, 2],
            [159, 3],
            [159, 4],
            [159, 2],
            [159, 6],
            [159, 6],
            [159, 1],
            [84, 1],
            [84, 1],
            [84, 1],
            [73, 2],
            [73, 6],
            [177, 1],
            [177, 4],
            [42, 3],
            [180, 3],
            [153, 2],
            [153, 2],
            [186, 1],
            [184, 2],
            [190, 2],
            [188, 2],
            [193, 1],
            [193, 1],
            [193, 1],
            [194, 2],
            [164, 2],
            [164, 2],
            [199, 4],
            [206, 1],
            [206, 3],
            [208, 2],
            [210, 2],
            [213, 2],
            [212, 2],
            [214, 1],
            [214, 1],
            [214, 2],
            [214, 3],
            [218, 1],
            [218, 1],
            [218, 4],
            [219, 1],
            [219, 1],
            [219, 2],
            [219, 2],
            [185, 3],
            [185, 3],
            [200, 3],
            [200, 3],
            [197, 1],
            [197, 1],
            [204, 1],
            [204, 1],
            [39, 9],
            [39, 5],
            [99, 9],
            [99, 5],
            [241, 1],
            [241, 1],
            [242, 1],
            [242, 1],
            [242, 1],
            [242, 1],
            [242, 1],
            [36, 2],
            [247, 2],
            [245, 2],
            [251, 2],
            [249, 1],
            [249, 3],
            [249, 4],
            [253, 2],
            [259, 2],
            [259, 2],
            [259, 2],
            [257, 2],
            [267, 2],
            [265, 2],
            [265, 2],
            [265, 2],
            [270, 1],
            [270, 1],
            [270, 1],
            [270, 1],
            [270, 1],
            [270, 1],
            [82, 3],
            [72, 1],
            [72, 2],
            [72, 4],
            [72, 6],
            [72, 8],
            [72, 2],
            [72, 4],
            [72, 2],
            [72, 4],
            [72, 3],
            [272, 5],
            [272, 5],
            [272, 6],
            [291, 4],
            [98, 1],
            [98, 2],
            [98, 3],
            [98, 1],
            [98, 1],
            [98, 1],
            [98, 1],
            [98, 1],
            [98, 1],
            [294, 1],
            [294, 1],
            [294, 1],
            [294, 1],
            [261, 1],
            [261, 1],
            [261, 1],
            [263, 1],
            [263, 1],
            [263, 1],
            [60, 1],
            [60, 1],
            [60, 1],
            [311, 0],
            [311, 1],
            [5, 1],
            [5, 1],
            [312, 1],
            [312, 1],
            [7, 0],
            [7, 2],
            [9, 1],
            [9, 1],
            [9, 1],
            [9, 1],
            [10, 0],
            [10, 1],
            [19, 0],
            [19, 2],
            [23, 0],
            [23, 2],
            [27, 1],
            [27, 2],
            [313, 1],
            [313, 1],
            [29, 0],
            [29, 1],
            [31, 0],
            [31, 1],
            [32, 0],
            [32, 1],
            [43, 0],
            [43, 2],
            [44, 0],
            [44, 2],
            [47, 0],
            [47, 1],
            [316, 1],
            [316, 1],
            [317, 1],
            [317, 2],
            [51, 1],
            [51, 1],
            [52, 0],
            [52, 2],
            [53, 0],
            [53, 1],
            [56, 0],
            [56, 2],
            [59, 0],
            [59, 1],
            [61, 0],
            [61, 1],
            [63, 0],
            [63, 1],
            [64, 0],
            [64, 1],
            [65, 0],
            [65, 1],
            [66, 0],
            [66, 1],
            [70, 1],
            [70, 2],
            [76, 1],
            [76, 2],
            [79, 1],
            [79, 2],
            [92, 0],
            [92, 2],
            [94, 0],
            [94, 2],
            [95, 1],
            [95, 2],
            [96, 0],
            [96, 2],
            [102, 1],
            [102, 2],
            [104, 0],
            [104, 4],
            [106, 0],
            [106, 2],
            [108, 0],
            [108, 1],
            [109, 0],
            [109, 1],
            [110, 1],
            [110, 1],
            [111, 0],
            [111, 1],
            [113, 1],
            [113, 1],
            [113, 1],
            [114, 0],
            [114, 1],
            [118, 0],
            [118, 1],
            [124, 0],
            [124, 1],
            [126, 0],
            [126, 1],
            [127, 0],
            [127, 2],
            [128, 0],
            [128, 1],
            [130, 0],
            [130, 1],
            [131, 0],
            [131, 2],
            [136, 0],
            [136, 1],
            [142, 0],
            [142, 1],
            [143, 1],
            [143, 1],
            [143, 1],
            [144, 0],
            [144, 1],
            [145, 0],
            [145, 2],
            [147, 1],
            [147, 1],
            [148, 0],
            [148, 1],
            [149, 0],
            [149, 1],
            [150, 0],
            [150, 1],
            [152, 0],
            [152, 3],
            [154, 0],
            [154, 1],
            [156, 0],
            [156, 1],
            [157, 0],
            [157, 2],
            [160, 0],
            [160, 1],
            [161, 0],
            [161, 1],
            [163, 0],
            [163, 3],
            [165, 0],
            [165, 1],
            [166, 0],
            [166, 3],
            [169, 1],
            [169, 1],
            [171, 0],
            [171, 1],
            [172, 1],
            [172, 1],
            [175, 0],
            [175, 1],
            [176, 0],
            [176, 3],
            [178, 0],
            [178, 3],
            [179, 0],
            [179, 1],
            [181, 0],
            [181, 3],
            [182, 0],
            [182, 1],
            [183, 1],
            [183, 1],
            [187, 0],
            [187, 1],
            [189, 0],
            [189, 2],
            [192, 0],
            [192, 1],
            [196, 0],
            [196, 3],
            [198, 1],
            [198, 1],
            [201, 0],
            [201, 1],
            [202, 1],
            [202, 1],
            [203, 0],
            [203, 3],
            [205, 0],
            [205, 2],
            [207, 1],
            [207, 1],
            [209, 0],
            [209, 3],
            [211, 0],
            [211, 3],
            [330, 1],
            [330, 1],
            [330, 1],
            [215, 0],
            [215, 1],
            [216, 0],
            [216, 1],
            [220, 0],
            [220, 3],
            [221, 0],
            [221, 1],
            [223, 1],
            [223, 2],
            [226, 1],
            [226, 2],
            [227, 1],
            [227, 1],
            [228, 1],
            [228, 1],
            [230, 1],
            [230, 1],
            [231, 1],
            [231, 1],
            [232, 1],
            [232, 1],
            [234, 1],
            [234, 1],
            [235, 1],
            [235, 1],
            [236, 1],
            [236, 1],
            [237, 1],
            [237, 1],
            [238, 1],
            [238, 1],
            [239, 1],
            [239, 1],
            [240, 1],
            [240, 1],
            [246, 0],
            [246, 2],
            [250, 0],
            [250, 2],
            [254, 1],
            [254, 1],
            [254, 1],
            [254, 1],
            [254, 1],
            [254, 1],
            [255, 0],
            [255, 1],
            [258, 0],
            [258, 2],
            [260, 1],
            [260, 1],
            [262, 0],
            [262, 2],
            [264, 0],
            [264, 2],
            [266, 0],
            [266, 2],
            [268, 1],
            [268, 1],
            [269, 0],
            [269, 1],
            [278, 1],
            [278, 1],
            [278, 1],
            [278, 1],
            [278, 1],
            [281, 0],
            [281, 1],
            [284, 0],
            [284, 1],
            [285, 1],
            [285, 1],
            [287, 0],
            [287, 1],
            [289, 0],
            [289, 1],
            [290, 0],
            [290, 1]
          ],
          performAction: function(e, t, r, n, i, a, s) {
            var o, u, c, l, h = a.length - 1;
            switch (i) {
              case 1:
                return a[h - 1] = a[h - 1] || {}, Kr.base && (a[h - 1].base = Kr.base), Kr.base = br = _r = vr = "", a[h - 1].prefixes = Kr.prefixes, Kr.prefixes = null, a[h - 1];
              case 3:
                this.$ = Er(a[h - 1], a[h], {
                  type: "query"
                });
                break;
              case 4:
                Kr.base = Or(a[h]), br = _r = vr = "";
                break;
              case 5:
                Kr.prefixes || (Kr.prefixes = {}), a[h - 1] = a[h - 1].substr(0, a[h - 1].length - 1), a[h] = Or(a[h]), Kr.prefixes[a[h - 1]] = a[h];
                break;
              case 6:
                this.$ = Er(a[h - 3], Cr(a[h - 2]), a[h - 1], a[h]);
                break;
              case 7:
                if (Xr(a[h - 3].variables.map(e => zr(e.expression))).some(e => "count" === e.aggregation) || a[h].group)
                  for (const e of a[h - 3].variables)
                    if ("Variable" === e.termType) {
                      if (!a[h].group || !a[h].group.map(e => Gr(e)).includes(Gr(e))) throw Error("Projection of ungrouped variable (?" + Gr(e) + ")")
                    } else if (0 === zr(e.expression).length) {
                      const t = Qr(e.expression);
                      for (const e of t)
                        if (!a[h].group.map(e => Gr(e)).includes(Gr(e))) throw Error("Use of ungrouped variable in projection of operation (?" + Gr(e) + ")")
                    }
                const e = a[h - 1].where.filter(e => "query" === e.type);
                if (e.length > 0) {
                  const t = a[h - 3].variables.filter(e => e.variable && e.variable.value).map(e => e.variable.value),
                    r = Xr(e.map(e => e.variables)).map(e => e.value || e.variable.value);
                  for (const e of t)
                    if (r.indexOf(e) >= 0) throw Error("Target id of 'AS' (?" + e + ") already used in subquery")
                }
                this.$ = Er(a[h - 3], Cr(a[h - 2]), a[h - 1], a[h]);
                break;
              case 8:
                this.$ = Er(a[h - 1], {
                  variables: [new cr]
                });
                break;
              case 9:
                const t = function(e) {
                  const t = e.slice().sort(),
                    r = [];
                  for (let e = 0; e < t.length - 1; e++) t[e + 1] == t[e] && r.push(t[e]);
                  return r
                }(a[h].map(e => e.value || e.variable.value));
                if (t.length > 0) throw Error("Two or more of the resulting columns have the same name (?" + t[0] + ")");
                this.$ = Er(a[h - 1], {
                  variables: a[h]
                });
                break;
              case 10:
                this.$ = Er({
                  queryType: "SELECT"
                }, a[h] && (a[h - 1] = wr(a[h]), a[h] = {}, a[h][a[h - 1]] = !0, a[h]));
                break;
              case 11:
              case 12:
                this.$ = Er(a[h - 3], a[h - 2], a[h - 1], a[h], {
                  type: "query"
                });
                break;
              case 13:
              case 100:
              case 136:
              case 164:
                this.$ = Ar(a[h]);
                break;
              case 14:
              case 28:
                this.$ = Ir(a[h - 3], {
                  variable: Ar(a[h - 1])
                });
                break;
              case 15:
                this.$ = Jr(Ir(a[h - 3], {
                  variable: Ar(a[h - 1])
                }));
                break;
              case 16:
                this.$ = Er({
                  queryType: "CONSTRUCT",
                  template: a[h - 3]
                }, Cr(a[h - 2]), a[h - 1], a[h]);
                break;
              case 17:
                this.$ = Er({
                  queryType: "CONSTRUCT",
                  template: a[h - 2] = a[h - 2] ? a[h - 2].triples : []
                }, Cr(a[h - 5]), {
                  where: [{
                    type: "bgp",
                    triples: Tr([], a[h - 2])
                  }]
                }, a[h]);
                break;
              case 18:
                this.$ = Er({
                  queryType: "DESCRIBE",
                  variables: "*" === a[h - 3] ? [new cr] : a[h - 3].map(Ar)
                }, Cr(a[h - 2]), a[h - 1], a[h]);
                break;
              case 19:
                this.$ = Er({
                  queryType: "ASK"
                }, Cr(a[h - 2]), a[h - 1], a[h]);
                break;
              case 20:
              case 61:
                this.$ = {
                  iri: a[h],
                  named: !!a[h - 1]
                };
                break;
              case 21:
                this.$ = {
                  where: a[h].patterns
                };
                break;
              case 22:
                this.$ = Er(a[h - 1], a[h]);
                break;
              case 23:
                this.$ = Er(a[h - 2], a[h - 1], a[h]);
                break;
              case 24:
                this.$ = {
                  group: a[h]
                };
                break;
              case 25:
              case 26:
              case 32:
              case 34:
                this.$ = Ir(a[h]);
                break;
              case 27:
                this.$ = Ir(a[h - 1]);
                break;
              case 29:
              case 35:
                this.$ = Ir(Ar(a[h]));
                break;
              case 30:
                this.$ = {
                  having: a[h]
                };
                break;
              case 31:
                this.$ = {
                  order: a[h]
                };
                break;
              case 33:
                this.$ = Ir(a[h], {
                  descending: !0
                });
                break;
              case 36:
                this.$ = {
                  limit: Dr(a[h])
                };
                break;
              case 37:
                this.$ = {
                  offset: Dr(a[h])
                };
                break;
              case 38:
                this.$ = {
                  limit: Dr(a[h - 2]),
                  offset: Dr(a[h])
                };
                break;
              case 39:
                this.$ = {
                  limit: Dr(a[h]),
                  offset: Dr(a[h - 2])
                };
                break;
              case 40:
                this.$ = {
                  type: "values",
                  values: a[h]
                };
                break;
              case 41:
                this.$ = a[h - 1].map((function(e) {
                  var t = {};
                  return t[a[h - 3]] = e, t
                }));
                break;
              case 42:
                this.$ = a[h - 1].map((function() {
                  return {}
                }));
                break;
              case 43:
                var d = a[h - 4].length;
                a[h - 4] = a[h - 4].map(Ar), this.$ = a[h - 1].map((function(e) {
                  if (e.length !== d) throw Error("Inconsistent VALUES length");
                  for (var t = {}, r = 0; r < d; r++) t["?" + a[h - 4][r].value] = e[r];
                  return t
                }));
                break;
              case 46:
                this.$ = Jr(a[h]);
                break;
              case 47:
                this.$ = void 0;
                break;
              case 48:
              case 92:
              case 116:
              case 165:
                this.$ = a[h - 1];
                break;
              case 49:
                this.$ = {
                  type: "update",
                  updates: Sr(a[h - 2], a[h - 1])
                };
                break;
              case 50:
                this.$ = Er({
                  type: "load",
                  silent: !!a[h - 2],
                  source: a[h - 1]
                }, a[h] && {
                  destination: a[h]
                });
                break;
              case 51:
                this.$ = {
                  type: wr(a[h - 2]),
                  silent: !!a[h - 1],
                  graph: a[h]
                };
                break;
              case 52:
                this.$ = {
                  type: wr(a[h - 4]),
                  silent: !!a[h - 3],
                  source: a[h - 2],
                  destination: a[h]
                };
                break;
              case 53:
                this.$ = {
                  type: "create",
                  silent: !!a[h - 2],
                  graph: {
                    type: "graph",
                    name: a[h]
                  }
                };
                break;
              case 54:
                this.$ = {
                  updateType: "insert",
                  insert: a[h]
                };
                break;
              case 55:
                this.$ = {
                  updateType: "delete",
                  delete: a[h]
                };
                break;
              case 56:
                this.$ = {
                  updateType: "deletewhere",
                  delete: a[h]
                };
                break;
              case 57:
                this.$ = Er({
                  updateType: "insertdelete"
                }, a[h - 5], {
                  insert: a[h - 4] || []
                }, {
                  delete: a[h - 3] || []
                }, Cr(a[h - 2], "using"), {
                  where: a[h].patterns
                });
                break;
              case 58:
                this.$ = Er({
                  updateType: "insertdelete"
                }, a[h - 5], {
                  delete: a[h - 4] || []
                }, {
                  insert: a[h - 3] || []
                }, Cr(a[h - 2], "using"), {
                  where: a[h].patterns
                });
                break;
              case 59:
              case 60:
              case 63:
              case 156:
              case 179:
                this.$ = a[h];
                break;
              case 62:
                this.$ = {
                  graph: a[h]
                };
                break;
              case 64:
                this.$ = {
                  type: "graph",
                  default: !0
                };
                break;
              case 65:
              case 66:
                this.$ = {
                  type: "graph",
                  name: a[h]
                };
                break;
              case 67:
                this.$ = {}, this.$[wr(a[h])] = !0;
                break;
              case 68:
                this.$ = a[h - 2] ? xr(a[h - 1], [a[h - 2]]) : xr(a[h - 1]);
                break;
              case 69:
                var p = Er(a[h - 3] || {
                  triples: []
                }, {
                  type: "graph",
                  name: Ar(a[h - 5])
                });
                this.$ = a[h] ? [p, a[h]] : [p];
                break;
              case 70:
              case 75:
                this.$ = {
                  type: "bgp",
                  triples: xr(a[h - 2], [a[h - 1]])
                };
                break;
              case 71:
                this.$ = {
                  type: "group",
                  patterns: [a[h - 1]]
                };
                break;
              case 72:
                for (const e of a[h - 1].filter(e => "bind" === e.type)) {
                  const t = a[h - 1].indexOf(e),
                    r = new Set;
                  for (const e of a[h - 1].slice(0, t)) "group" !== e.type && "bgp" !== e.type || Yr(e).forEach(e => r.add(e));
                  if (r.has(e.variable.value)) throw Error("Variable used to bind is already bound (?" + e.variable.value + ")")
                }
                this.$ = {
                  type: "group",
                  patterns: a[h - 1]
                };
                break;
              case 73:
                this.$ = a[h - 1] ? xr([a[h - 1]], a[h]) : xr(a[h]);
                break;
              case 74:
                this.$ = a[h] ? [a[h - 2], a[h]] : a[h - 2];
                break;
              case 76:
                a[h - 1].length ? this.$ = {
                  type: "union",
                  patterns: xr(a[h - 1].map(jr), [jr(a[h])])
                } : this.$ = a[h];
                break;
              case 77:
                this.$ = Er(a[h], {
                  type: "optional"
                });
                break;
              case 78:
                this.$ = Er(a[h], {
                  type: "minus"
                });
                break;
              case 79:
                this.$ = Er(a[h], {
                  type: "graph",
                  name: Ar(a[h - 1])
                });
                break;
              case 80:
                this.$ = Er(a[h], {
                  type: "service",
                  name: Ar(a[h - 1]),
                  silent: !!a[h - 2]
                });
                break;
              case 81:
                this.$ = {
                  type: "filter",
                  expression: a[h]
                };
                break;
              case 82:
                this.$ = {
                  type: "bind",
                  variable: Ar(a[h - 1]),
                  expression: a[h - 3]
                };
                break;
              case 83:
                this.$ = Jr({
                  type: "bind",
                  variable: Ar(a[h - 1]),
                  expression: a[h - 3]
                });
                break;
              case 88:
                this.$ = {
                  type: "functionCall",
                  function: a[h - 1],
                  args: []
                };
                break;
              case 89:
                this.$ = {
                  type: "functionCall",
                  function: a[h - 5],
                  args: Sr(a[h - 2], a[h - 1]),
                  distinct: !!a[h - 3]
                };
                break;
              case 90:
              case 107:
              case 118:
              case 208:
              case 216:
              case 218:
              case 230:
              case 232:
              case 242:
              case 246:
              case 266:
              case 268:
              case 272:
              case 276:
              case 299:
              case 305:
              case 316:
              case 326:
              case 332:
              case 338:
              case 342:
              case 352:
              case 354:
              case 358:
              case 366:
              case 370:
              case 378:
              case 380:
              case 384:
              case 386:
              case 395:
              case 427:
              case 429:
              case 439:
              case 443:
              case 445:
              case 447:
                this.$ = [];
                break;
              case 91:
                this.$ = Sr(a[h - 2], a[h - 1]);
                break;
              case 93:
                this.$ = xr(a[h - 2], [a[h - 1]]);
                break;
              case 94:
              case 104:
                this.$ = a[h].map((function(e) {
                  return Er(Lr(a[h - 1]), e)
                }));
                break;
              case 95:
                this.$ = Tr(a[h].map((function(e) {
                  return Er(Lr(a[h - 1].entity), e)
                })), a[h - 1].triples);
                break;
              case 97:
                this.$ = xr([a[h - 1]], a[h]);
                break;
              case 98:
                this.$ = xr(a[h]);
                break;
              case 99:
                this.$ = Hr(a[h - 1], a[h]);
                break;
              case 102:
              case 114:
              case 121:
                this.$ = Kr.factory.namedNode(hr);
                break;
              case 103:
                this.$ = Sr(a[h - 1], a[h]);
                break;
              case 105:
                this.$ = a[h] ? Tr(a[h].map((function(e) {
                  return Er(Lr(a[h - 1].entity), e)
                })), a[h - 1].triples) : a[h - 1].triples;
                break;
              case 106:
                this.$ = Hr(Ar(a[h - 3]), Sr(a[h - 2], a[h - 1]), a[h]);
                break;
              case 108:
                this.$ = Hr(Ar(a[h - 1]), a[h]);
                break;
              case 109:
                this.$ = a[h - 1].length ? Nr("|", Sr(a[h - 1], a[h])) : a[h];
                break;
              case 110:
                this.$ = a[h - 1].length ? Nr("/", Sr(a[h - 1], a[h])) : a[h];
                break;
              case 111:
                this.$ = a[h] ? Nr(a[h], [a[h - 1]]) : a[h - 1];
                break;
              case 112:
                this.$ = a[h - 1] ? Nr(a[h - 1], [a[h]]) : a[h];
                break;
              case 115:
              case 122:
                this.$ = Nr(a[h - 1], [a[h]]);
                break;
              case 119:
                this.$ = Nr("|", Sr(a[h - 2], a[h - 1]));
                break;
              case 123:
                this.$ = Nr(a[h - 1], [Kr.factory.namedNode(hr)]);
                break;
              case 124:
              case 126:
                this.$ = function(e) {
                  var t = Mr(),
                    r = t,
                    n = [],
                    i = [];
                  e.forEach((function(e) {
                    n.push(e.entity), Tr(i, e.triples)
                  }));
                  for (var a = 0, s = 0, o = n.length, u = Array(2 * o); a < o;) u[s++] = Lr(r, Kr.factory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#first"), n[a]), u[s++] = Lr(r, Kr.factory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#rest"), r = ++a < o ? Mr() : Kr.factory.namedNode(dr));
                  return {
                    entity: t,
                    triples: Tr(u, i)
                  }
                }(a[h - 1]);
                break;
              case 125:
              case 127:
                this.$ = (c = a[h - 1], {
                  entity: l = Mr(),
                  triples: c.map((function(e) {
                    return Er(Lr(l), e)
                  }))
                });
                break;
              case 128:
              case 130:
                this.$ = {
                  entity: a[h],
                  triples: []
                };
                break;
              case 132:
              case 134:
                this.$ = Jr(Kr.factory.quad(a[h - 4], a[h - 3], a[h - 2], Ar(a[h - 6])));
                break;
              case 133:
              case 135:
                this.$ = Jr(Kr.factory.quad(a[h - 3], a[h - 2], a[h - 1]));
                break;
              case 140:
                this.$ = Mr(a[h].replace(/^(_:)/, ""));
                break;
              case 141:
                this.$ = Mr();
                break;
              case 142:
                this.$ = Kr.factory.namedNode(dr);
                break;
              case 143:
              case 145:
              case 150:
              case 154:
                this.$ = Pr(a[h - 1], a[h]);
                break;
              case 144:
                this.$ = ["||", a[h]];
                break;
              case 146:
                this.$ = ["&&", a[h]];
                break;
              case 148:
                this.$ = Rr(a[h - 1], [a[h - 2], a[h]]);
                break;
              case 149:
                this.$ = Rr(a[h - 2] ? "notin" : "in", [a[h - 3], a[h]]);
                break;
              case 151:
              case 155:
                this.$ = [a[h - 1], a[h]];
                break;
              case 152:
                this.$ = ["+", Pr(a[h - 1], a[h])];
                break;
              case 153:
                var f = kr(a[h - 1].value.replace("-", ""), a[h - 1].datatype);
                this.$ = ["-", Pr(f, a[h])];
                break;
              case 157:
                this.$ = Rr(a[h - 1], [a[h]]);
                break;
              case 158:
                this.$ = Rr("UMINUS", [a[h]]);
                break;
              case 167:
                this.$ = Rr(wr(a[h - 1]));
                break;
              case 168:
                this.$ = Rr(wr(a[h - 3]), [a[h - 1]]);
                break;
              case 169:
                this.$ = Rr(wr(a[h - 5]), [a[h - 3], a[h - 1]]);
                break;
              case 170:
                this.$ = Rr(wr(a[h - 7]), [a[h - 5], a[h - 3], a[h - 1]]);
                break;
              case 171:
                this.$ = Rr(wr(a[h - 1]), a[h]);
                break;
              case 172:
                this.$ = Rr("bound", [Ar(a[h - 1])]);
                break;
              case 173:
                this.$ = Rr(a[h - 1], []);
                break;
              case 174:
                this.$ = Rr(a[h - 3], [a[h - 1]]);
                break;
              case 175:
                this.$ = Rr(a[h - 2] ? "notexists" : "exists", [jr(a[h])]);
                break;
              case 176:
              case 177:
                this.$ = Ir(a[h - 1], {
                  type: "aggregate",
                  aggregation: wr(a[h - 4]),
                  distinct: !!a[h - 2]
                });
                break;
              case 178:
                this.$ = Ir(a[h - 2], {
                  type: "aggregate",
                  aggregation: wr(a[h - 5]),
                  distinct: !!a[h - 3],
                  separator: a[h - 1] || " "
                });
                break;
              case 180:
                this.$ = kr(a[h]);
                break;
              case 181:
                this.$ = (o = a[h - 1], u = wr(a[h].substr(1)), Kr.factory.literal(o, u));
                break;
              case 182:
                this.$ = kr(a[h - 2], a[h]);
                break;
              case 183:
              case 196:
                this.$ = kr(a[h], fr);
                break;
              case 184:
              case 197:
                this.$ = kr(a[h], gr);
                break;
              case 185:
              case 198:
                this.$ = kr(wr(a[h]), mr);
                break;
              case 188:
                this.$ = kr(a[h].toLowerCase(), yr);
                break;
              case 189:
              case 190:
                this.$ = Vr(a[h], 1);
                break;
              case 191:
              case 192:
                this.$ = Vr(a[h], 3);
                break;
              case 193:
                this.$ = kr(a[h].substr(1), fr);
                break;
              case 194:
                this.$ = kr(a[h].substr(1), gr);
                break;
              case 195:
                this.$ = kr(a[h].substr(1).toLowerCase(), mr);
                break;
              case 199:
                this.$ = Kr.factory.namedNode(Or(a[h]));
                break;
              case 200:
                var g = a[h].indexOf(":"),
                  m = a[h].substr(0, g),
                  y = Kr.prefixes[m];
                if (!y) throw new Error("Unknown prefix: " + m);
                var b = Or(y + a[h].substr(g + 1));
                this.$ = Kr.factory.namedNode(b);
                break;
              case 201:
                if (a[h] = a[h].substr(0, a[h].length - 1), !(a[h] in Kr.prefixes)) throw new Error("Unknown prefix: " + a[h]);
                b = Or(Kr.prefixes[a[h]]);
                this.$ = Kr.factory.namedNode(b);
                break;
              case 209:
              case 217:
              case 219:
              case 221:
              case 231:
              case 233:
              case 239:
              case 243:
              case 247:
              case 261:
              case 263:
              case 265:
              case 267:
              case 269:
              case 271:
              case 273:
              case 275:
              case 300:
              case 306:
              case 317:
              case 333:
              case 367:
              case 381:
              case 400:
              case 402:
              case 428:
              case 430:
              case 440:
              case 444:
              case 446:
              case 448:
                a[h - 1].push(a[h]);
                break;
              case 220:
              case 238:
              case 260:
              case 262:
              case 264:
              case 270:
              case 274:
              case 399:
              case 401:
                this.$ = [a[h]];
                break;
              case 277:
                a[h - 3].push(a[h - 2]);
                break;
              case 327:
              case 339:
              case 343:
              case 353:
              case 355:
              case 359:
              case 371:
              case 379:
              case 385:
              case 387:
              case 396:
                a[h - 2].push(a[h - 1])
            }
          },
          table: [e(t, n, {
            3: 1,
            4: 2,
            7: 3
          }), {
            1: [3]
          }, e(i, [2, 276], {
            5: 4,
            8: 5,
            311: 6,
            9: 7,
            103: 8,
            17: 9,
            40: 10,
            49: 11,
            54: 12,
            104: 13,
            18: 14,
            22: 15,
            25: 19,
            6: [2, 202],
            28: a,
            41: [1, 16],
            50: [1, 17],
            55: [1, 18]
          }), e([6, 28, 41, 50, 55, 107, 117, 120, 122, 123, 132, 133, 138, 320, 321, 322, 323, 324], [2, 2], {
            312: 21,
            11: 22,
            14: 23,
            12: [1, 24],
            15: [1, 25]
          }), {
            6: [1, 26]
          }, {
            6: [2, 204]
          }, {
            6: [2, 205]
          }, {
            6: [2, 214],
            10: 27,
            89: 28,
            90: s
          }, {
            6: [2, 203]
          }, e(o, [2, 210]), e(o, [2, 211]), e(o, [2, 212]), e(o, [2, 213]), {
            105: 30,
            107: [1, 31],
            110: 32,
            113: 33,
            117: [1, 34],
            120: [1, 35],
            122: [1, 36],
            123: [1, 37],
            124: 38,
            128: 39,
            132: [2, 301],
            133: [2, 295],
            137: 45,
            138: [1, 46],
            320: [1, 40],
            321: [1, 41],
            322: [1, 42],
            323: [1, 43],
            324: [1, 44]
          }, e(u, [2, 216], {
            19: 47
          }), e(u, [2, 218], {
            23: 48
          }), e(c, [2, 232], {
            42: 49,
            44: 50,
            46: [1, 51]
          }), {
            13: l,
            16: h,
            26: [1, 54],
            34: d,
            51: 52,
            60: 57,
            310: p,
            316: 55,
            317: 53
          }, e(u, [2, 246], {
            56: 61
          }), {
            26: [1, 62],
            27: 63,
            33: 64,
            34: f,
            35: g
          }, e(m, [2, 224], {
            29: 67,
            313: 68,
            314: [1, 69],
            315: [1, 70]
          }), e(t, [2, 209]), e(t, [2, 206]), e(t, [2, 207]), {
            13: [1, 71]
          }, {
            16: [1, 72]
          }, {
            1: [2, 1]
          }, {
            6: [2, 3]
          }, {
            6: [2, 215]
          }, {
            34: [1, 74],
            35: [1, 76],
            91: 73,
            93: [1, 75]
          }, {
            6: [2, 278],
            106: 77,
            191: [1, 78]
          }, e(y, [2, 280], {
            108: 79,
            319: [1, 80]
          }), e(b, [2, 286], {
            111: 81,
            319: [1, 82]
          }), e(_, [2, 291], {
            114: 83,
            319: [1, 84]
          }), {
            118: 85,
            119: [2, 293],
            319: [1, 86]
          }, {
            46: v,
            121: 87
          }, {
            46: v,
            121: 89
          }, {
            46: v,
            121: 90
          }, {
            125: 91,
            133: w
          }, {
            129: 93,
            132: S
          }, e(T, [2, 284]), e(T, [2, 285]), e(E, [2, 288]), e(E, [2, 289]), e(E, [2, 290]), {
            132: [2, 302],
            133: [2, 296]
          }, {
            13: l,
            16: h,
            60: 95,
            310: p
          }, {
            20: 96,
            45: x,
            46: O,
            57: 97,
            58: A,
            61: 98
          }, {
            20: 101,
            45: x,
            46: O,
            57: 102,
            58: A,
            61: 98
          }, e(u, [2, 230], {
            43: 103
          }), {
            45: [1, 104],
            57: 105,
            58: A
          }, e(R, [2, 358], {
            179: 106,
            180: 107,
            181: 108,
            48: [2, 356]
          }), e(I, [2, 242], {
            52: 109
          }), e(I, [2, 240], {
            60: 57,
            316: 110,
            13: l,
            16: h,
            34: d,
            310: p
          }), e(I, [2, 241]), e(N, [2, 238]), e(N, [2, 236]), e(N, [2, 237]), e(P, [2, 199]), e(P, [2, 200]), e(P, [2, 201]), {
            20: 111,
            45: x,
            46: O,
            57: 112,
            58: A,
            61: 98
          }, e(u, [2, 8]), e(u, [2, 9], {
            33: 113,
            34: f,
            35: g
          }), e(C, [2, 220]), e(C, [2, 13]), e(D, j, {
            36: 114,
            39: 115,
            245: 116,
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            217: k,
            229: L,
            271: M,
            332: F
          }), e(m, [2, 10]), e(m, [2, 225]), e(m, [2, 222]), e(m, [2, 223]), e(t, [2, 4]), {
            13: [1, 126]
          }, e(B, [2, 40]), {
            46: [1, 127]
          }, {
            46: [1, 128]
          }, {
            34: [1, 130],
            95: 129
          }, {
            6: [2, 49]
          }, e(t, n, {
            7: 3,
            4: 131
          }), {
            13: l,
            16: h,
            60: 132,
            310: p
          }, e(y, [2, 281]), {
            112: 133,
            119: [1, 134],
            141: [1, 136],
            143: 135,
            318: [1, 137],
            325: [1, 138]
          }, e(b, [2, 287]), e(y, q, {
            115: 139,
            142: 141,
            119: U,
            141: V
          }), e(_, [2, 292]), {
            119: [1, 143]
          }, {
            119: [2, 294]
          }, e(H, [2, 54]), e(R, G, {
            144: 144,
            151: 145,
            152: 146,
            48: z,
            119: z
          }), e(H, [2, 55]), e(H, [2, 56]), e(Q, [2, 297], {
            126: 147,
            129: 148,
            132: S
          }), {
            46: v,
            121: 149
          }, e(Q, [2, 303], {
            130: 150,
            125: 151,
            133: w
          }), {
            46: v,
            121: 152
          }, e([132, 133], [2, 62]), e(X, $, {
            21: 153,
            64: 154,
            74: 155,
            75: Y
          }), e(u, [2, 217]), {
            46: J,
            62: 157
          }, e(y, [2, 248], {
            59: 159,
            318: [1, 160]
          }), {
            46: [2, 251]
          }, e(W, K, {
            24: 161,
            63: 162,
            67: 163,
            68: Z
          }), e(u, [2, 219]), {
            20: 165,
            45: x,
            46: O,
            57: 166,
            58: A,
            61: 98
          }, {
            46: [1, 167]
          }, e(c, [2, 233]), {
            48: [1, 168]
          }, {
            48: [2, 357]
          }, {
            13: l,
            16: h,
            34: ee,
            35: te,
            39: 173,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            153: 169,
            183: 170,
            185: 171,
            224: ie,
            229: L,
            241: 172,
            242: 177,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, e(ve, [2, 244], {
            61: 98,
            53: 200,
            57: 201,
            20: 202,
            45: x,
            46: O,
            58: A
          }), e(N, [2, 239]), e(W, K, {
            63: 162,
            67: 163,
            24: 203,
            68: Z
          }), e(u, [2, 247]), e(C, [2, 221]), {
            37: [1, 204]
          }, {
            37: [1, 205]
          }, e(we, [2, 427], {
            246: 206
          }), {
            13: l,
            16: h,
            34: ee,
            39: 209,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            119: [1, 207],
            229: L,
            234: 208,
            241: 210,
            242: 177,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, e(Se, [2, 429], {
            250: 211
          }), e(Se, [2, 147], {
            254: 212,
            255: 213,
            256: [2, 437],
            293: [1, 214],
            333: [1, 215],
            334: [1, 216],
            335: [1, 217],
            336: [1, 218],
            337: [1, 219],
            338: [1, 220]
          }), e(Te, [2, 439], {
            258: 221
          }), e(Ee, [2, 447], {
            266: 222
          }), {
            13: l,
            16: h,
            34: xe,
            35: Oe,
            60: 226,
            72: 225,
            73: 227,
            82: 224,
            87: re,
            98: 228,
            261: 187,
            263: 188,
            270: 223,
            272: 231,
            273: Ae,
            274: Re,
            275: Ie,
            277: Ne,
            278: 236,
            279: Pe,
            280: Ce,
            281: 239,
            282: De,
            283: je,
            286: ke,
            288: Le,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p,
            338: Me,
            339: Fe,
            340: Be,
            341: qe,
            342: Ue,
            343: Ve
          }, {
            13: l,
            16: h,
            34: xe,
            35: Oe,
            60: 226,
            72: 225,
            73: 227,
            82: 224,
            87: re,
            98: 228,
            261: 187,
            263: 188,
            270: 249,
            272: 231,
            273: Ae,
            274: Re,
            275: Ie,
            277: Ne,
            278: 236,
            279: Pe,
            280: Ce,
            281: 239,
            282: De,
            283: je,
            286: ke,
            288: Le,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p,
            338: Me,
            339: Fe,
            340: Be,
            341: qe,
            342: Ue,
            343: Ve
          }, {
            13: l,
            16: h,
            34: xe,
            35: Oe,
            60: 226,
            72: 225,
            73: 227,
            82: 224,
            87: re,
            98: 228,
            261: 187,
            263: 188,
            270: 250,
            272: 231,
            273: Ae,
            274: Re,
            275: Ie,
            277: Ne,
            278: 236,
            279: Pe,
            280: Ce,
            281: 239,
            282: De,
            283: je,
            286: ke,
            288: Le,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p,
            338: Me,
            339: Fe,
            340: Be,
            341: qe,
            342: Ue,
            343: Ve
          }, e(D, [2, 452]), e(t, [2, 5]), e(He, [2, 266], {
            92: 251
          }), e(Ge, [2, 268], {
            94: 252
          }), {
            34: [1, 254],
            38: [1, 253]
          }, e(ze, [2, 270]), e(i, [2, 277], {
            6: [2, 279]
          }), e(H, [2, 282], {
            109: 255,
            139: 256,
            140: [1, 257]
          }), e(H, [2, 51]), {
            13: l,
            16: h,
            60: 258,
            310: p
          }, e(H, [2, 67]), e(H, [2, 311]), e(H, [2, 312]), e(H, [2, 313]), {
            116: [1, 259]
          }, e(Qe, [2, 64]), {
            13: l,
            16: h,
            60: 260,
            310: p
          }, e(y, [2, 310]), {
            13: l,
            16: h,
            60: 261,
            310: p
          }, e(Xe, [2, 316], {
            145: 262
          }), e(Xe, [2, 315]), {
            13: l,
            16: h,
            34: ee,
            35: te,
            39: 173,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            153: 263,
            183: 170,
            185: 171,
            224: ie,
            229: L,
            241: 172,
            242: 177,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, e(Q, [2, 299], {
            127: 264
          }), e(Q, [2, 298]), e([45, 132, 135], [2, 60]), e(Q, [2, 305], {
            131: 265
          }), e(Q, [2, 304]), e([45, 133, 135], [2, 59]), e(o, [2, 6]), e($e, [2, 256], {
            65: 266,
            77: 267,
            78: [1, 268]
          }), e(X, [2, 255]), {
            13: l,
            16: h,
            35: Oe,
            60: 274,
            72: 272,
            73: 273,
            76: 269,
            82: 271,
            84: 270,
            272: 231,
            273: Ae,
            274: Re,
            275: Ie,
            277: Ne,
            278: 236,
            279: Pe,
            280: Ce,
            281: 239,
            282: De,
            283: je,
            286: ke,
            288: Le,
            310: p,
            338: Me,
            339: Fe,
            340: Be,
            341: qe,
            342: Ue,
            343: Ve
          }, e([6, 48, 68, 75, 78, 86, 88, 90], [2, 21]), e(R, Ye, {
            25: 19,
            30: 275,
            155: 276,
            18: 277,
            22: 278,
            156: 279,
            162: 280,
            163: 281,
            28: a,
            46: Je,
            48: Je,
            90: Je,
            119: Je,
            167: Je,
            168: Je,
            170: Je,
            173: Je,
            174: Je
          }), {
            13: l,
            16: h,
            60: 282,
            310: p
          }, e(y, [2, 249]), e(o, [2, 7]), e(X, $, {
            64: 154,
            74: 155,
            21: 283,
            75: Y
          }), e(W, [2, 253]), {
            69: [1, 284]
          }, e(W, K, {
            63: 162,
            67: 163,
            24: 285,
            68: Z
          }), e(u, [2, 231]), e(R, G, {
            152: 146,
            47: 286,
            151: 287,
            48: [2, 234]
          }), e(u, [2, 92]), {
            48: [2, 360],
            182: 288,
            326: [1, 289]
          }, {
            13: l,
            16: h,
            34: We,
            60: 294,
            184: 290,
            188: 291,
            193: 292,
            195: Ke,
            310: p
          }, e(Ze, [2, 364], {
            188: 291,
            193: 292,
            60: 294,
            186: 296,
            187: 297,
            184: 298,
            13: l,
            16: h,
            34: We,
            195: Ke,
            310: p
          }), e(et, [2, 362]), e(et, [2, 363]), {
            13: l,
            16: h,
            34: ee,
            35: te,
            39: 304,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            185: 302,
            197: 300,
            223: 299,
            224: ie,
            227: 301,
            229: L,
            241: 303,
            242: 177,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, {
            13: l,
            16: h,
            34: We,
            60: 294,
            184: 305,
            188: 291,
            193: 292,
            195: Ke,
            310: p
          }, e(tt, [2, 136]), e(tt, [2, 137]), e(tt, [2, 138]), e(tt, [2, 139]), e(tt, [2, 140]), e(tt, [2, 141]), e(tt, [2, 142]), e(rt, [2, 180], {
            295: [1, 306],
            296: [1, 307]
          }), e(rt, [2, 183]), e(rt, [2, 184]), e(rt, [2, 185]), e(rt, [2, 186]), e(rt, [2, 187]), e(rt, [2, 188]), e(nt, [2, 189]), e(nt, [2, 190]), e(nt, [2, 191]), e(nt, [2, 192]), e(rt, [2, 193]), e(rt, [2, 194]), e(rt, [2, 195]), e(rt, [2, 196]), e(rt, [2, 197]), e(rt, [2, 198]), e(W, K, {
            63: 162,
            67: 163,
            24: 308,
            68: Z
          }), e(I, [2, 243]), e(ve, [2, 245]), e(o, [2, 19]), {
            34: [1, 309]
          }, {
            34: [1, 310]
          }, e([37, 38, 191, 276], [2, 143], {
            247: 311,
            248: [1, 312]
          }), {
            13: l,
            16: h,
            34: [1, 314],
            60: 315,
            230: 313,
            310: p
          }, {
            13: l,
            16: h,
            34: We,
            60: 294,
            193: 316,
            195: Ke,
            310: p
          }, e(et, [2, 413]), e(et, [2, 414]), e(we, [2, 145], {
            251: 317,
            252: [1, 318]
          }), e(D, j, {
            257: 120,
            265: 121,
            269: 122,
            253: 319,
            217: k,
            271: M,
            332: F
          }), {
            256: [1, 320]
          }, e(it, [2, 431]), e(it, [2, 432]), e(it, [2, 433]), e(it, [2, 434]), e(it, [2, 435]), e(it, [2, 436]), {
            256: [2, 438]
          }, e([37, 38, 191, 248, 252, 256, 276, 293, 333, 334, 335, 336, 337, 338], [2, 150], {
            259: 321,
            260: 322,
            261: 323,
            263: 324,
            271: [1, 326],
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            332: [1, 325]
          }), e(Te, [2, 154], {
            267: 327,
            268: 328,
            26: at,
            329: st
          }), e(Ee, [2, 156]), e(Ee, [2, 159]), e(Ee, [2, 160]), e(Ee, [2, 161], {
            35: ot,
            93: ut
          }), e(Ee, [2, 162]), e(Ee, [2, 163]), e(Ee, [2, 164]), e(D, j, {
            245: 116,
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            36: 333,
            217: k,
            271: M,
            332: F
          }), e(ct, [2, 166]), {
            93: [1, 334]
          }, {
            35: [1, 335]
          }, {
            35: [1, 336]
          }, {
            35: [1, 337]
          }, {
            35: lt,
            93: ht,
            177: 338
          }, {
            35: [1, 341]
          }, {
            35: [1, 343],
            93: [1, 342]
          }, {
            282: [1, 344]
          }, {
            35: [1, 345]
          }, {
            35: [1, 346]
          }, {
            35: [1, 347]
          }, e(dt, [2, 453]), e(dt, [2, 454]), e(dt, [2, 455]), e(dt, [2, 456]), e(dt, [2, 457]), {
            282: [2, 459]
          }, e(Ee, [2, 157]), e(Ee, [2, 158]), {
            13: l,
            16: h,
            48: [1, 348],
            60: 350,
            87: re,
            97: 349,
            98: 351,
            99: 352,
            100: pt,
            229: ft,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, {
            48: [1, 355],
            93: [1, 356]
          }, {
            46: [1, 357]
          }, e(ze, [2, 271]), e(H, [2, 50]), e(H, [2, 283]), {
            119: [1, 358]
          }, e(H, [2, 66]), e(y, q, {
            142: 141,
            115: 359,
            119: U,
            141: V
          }), e(Qe, [2, 65]), e(H, [2, 53]), {
            48: [1, 360],
            119: [1, 362],
            146: 361
          }, e(Xe, [2, 328], {
            154: 363,
            326: [1, 364]
          }), {
            45: [1, 365],
            134: 366,
            135: gt
          }, {
            45: [1, 368],
            134: 369,
            135: gt
          }, e(mt, [2, 258], {
            66: 370,
            85: 371,
            86: [1, 372],
            88: [1, 373]
          }), e($e, [2, 257]), {
            69: [1, 374]
          }, e(X, [2, 30], {
            272: 231,
            278: 236,
            281: 239,
            82: 271,
            72: 272,
            73: 273,
            60: 274,
            84: 375,
            13: l,
            16: h,
            35: Oe,
            273: Ae,
            274: Re,
            275: Ie,
            277: Ne,
            279: Pe,
            280: Ce,
            282: De,
            283: je,
            286: ke,
            288: Le,
            310: p,
            338: Me,
            339: Fe,
            340: Be,
            341: qe,
            342: Ue,
            343: Ve
          }), e(yt, [2, 262]), e(bt, [2, 85]), e(bt, [2, 86]), e(bt, [2, 87]), {
            35: ot,
            93: ut
          }, {
            48: [1, 376]
          }, {
            48: [1, 377]
          }, {
            20: 378,
            45: x,
            46: O,
            61: 98
          }, {
            20: 379,
            45: x,
            46: O,
            61: 98
          }, e(_t, [2, 332], {
            157: 380
          }), e(_t, [2, 331]), {
            13: l,
            16: h,
            34: ee,
            35: vt,
            39: 385,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            164: 381,
            198: 382,
            200: 383,
            224: wt,
            229: L,
            241: 384,
            242: 177,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, e(I, [2, 20]), e(mt, [2, 22]), {
            13: l,
            16: h,
            34: St,
            35: Tt,
            60: 274,
            70: 388,
            71: 389,
            72: 390,
            73: 391,
            272: 231,
            273: Ae,
            274: Re,
            275: Ie,
            277: Ne,
            278: 236,
            279: Pe,
            280: Ce,
            281: 239,
            282: De,
            283: je,
            286: ke,
            288: Le,
            310: p,
            338: Me,
            339: Fe,
            340: Be,
            341: qe,
            342: Ue,
            343: Ve
          }, e(o, [2, 16]), {
            48: [1, 394]
          }, {
            48: [2, 235]
          }, {
            48: [2, 93]
          }, e(R, [2, 359], {
            48: [2, 361]
          }), e(Ze, [2, 94]), e(Et, [2, 366], {
            189: 395
          }), e(R, xt, {
            194: 396,
            196: 397
          }), e(R, [2, 100]), e(R, [2, 101]), e(R, [2, 102]), e(Ze, [2, 95]), e(Ze, [2, 96]), e(Ze, [2, 365]), {
            13: l,
            16: h,
            34: ee,
            35: te,
            38: [1, 398],
            39: 304,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            185: 302,
            197: 399,
            224: ie,
            227: 301,
            229: L,
            241: 303,
            242: 177,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, e(Ot, [2, 399]), e(At, [2, 128]), e(At, [2, 129]), e(At, [2, 403]), e(At, [2, 404]), {
            225: [1, 400]
          }, e(rt, [2, 181]), {
            13: l,
            16: h,
            60: 401,
            310: p
          }, e(o, [2, 18]), {
            38: [1, 402]
          }, {
            38: [1, 403]
          }, e(we, [2, 428]), e(D, j, {
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            245: 404,
            217: k,
            271: M,
            332: F
          }), {
            46: [1, 405]
          }, {
            46: [2, 407]
          }, {
            46: [2, 408]
          }, {
            13: l,
            16: h,
            34: ee,
            39: 407,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            229: L,
            235: 406,
            241: 408,
            242: 177,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, e(Se, [2, 430]), e(D, j, {
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            249: 409,
            217: k,
            271: M,
            332: F
          }), e(Se, [2, 148]), {
            35: lt,
            93: ht,
            177: 410
          }, e(Te, [2, 440]), e(D, j, {
            265: 121,
            269: 122,
            257: 411,
            217: k,
            271: M,
            332: F
          }), e(Ee, [2, 443], {
            262: 412
          }), e(Ee, [2, 445], {
            264: 413
          }), e(it, [2, 441]), e(it, [2, 442]), e(Ee, [2, 448]), e(D, j, {
            269: 122,
            265: 414,
            217: k,
            271: M,
            332: F
          }), e(it, [2, 449]), e(it, [2, 450]), e(ct, [2, 88]), e(it, [2, 350], {
            175: 415,
            314: [1, 416]
          }), {
            38: [1, 417]
          }, e(ct, [2, 167]), e(D, j, {
            245: 116,
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            36: 418,
            217: k,
            271: M,
            332: F
          }), e(D, j, {
            245: 116,
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            36: 419,
            217: k,
            271: M,
            332: F
          }), e(D, j, {
            245: 116,
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            36: 420,
            217: k,
            271: M,
            332: F
          }), e(ct, [2, 171]), e(ct, [2, 90]), e(it, [2, 354], {
            178: 421
          }), {
            34: [1, 422]
          }, e(ct, [2, 173]), e(D, j, {
            245: 116,
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            36: 423,
            217: k,
            271: M,
            332: F
          }), {
            46: J,
            62: 424
          }, e(Rt, [2, 460], {
            284: 425,
            314: [1, 426]
          }), e(it, [2, 464], {
            287: 427,
            314: [1, 428]
          }), e(it, [2, 466], {
            289: 429,
            314: [1, 430]
          }), e(B, [2, 41]), e(He, [2, 267]), e(It, [2, 44]), e(It, [2, 45]), e(It, [2, 46]), e(It, [2, 47]), {
            13: l,
            16: h,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            99: 433,
            119: [1, 431],
            229: ft,
            239: 432,
            242: 434,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, e(B, [2, 42]), e(Ge, [2, 269]), e(Nt, [2, 272], {
            96: 435
          }), {
            13: l,
            16: h,
            60: 436,
            310: p
          }, e(H, [2, 52]), e([6, 45, 132, 133, 135, 191], [2, 68]), e(Xe, [2, 317]), {
            13: l,
            16: h,
            34: [1, 438],
            60: 439,
            147: 437,
            310: p
          }, e(Xe, [2, 70]), e(R, [2, 327], {
            48: Pt,
            119: Pt
          }), {
            46: J,
            62: 440
          }, e(Q, [2, 300]), e(y, [2, 307], {
            136: 441,
            318: [1, 442]
          }), {
            46: J,
            62: 443
          }, e(Q, [2, 306]), e(mt, [2, 23]), e(mt, [2, 259]), {
            87: [1, 444]
          }, {
            87: [1, 445]
          }, {
            13: l,
            16: h,
            34: Ct,
            35: Oe,
            60: 274,
            72: 272,
            73: 273,
            79: 446,
            80: 447,
            81: Dt,
            82: 271,
            83: jt,
            84: 450,
            272: 231,
            273: Ae,
            274: Re,
            275: Ie,
            277: Ne,
            278: 236,
            279: Pe,
            280: Ce,
            281: 239,
            282: De,
            283: je,
            286: ke,
            288: Le,
            310: p,
            338: Me,
            339: Fe,
            340: Be,
            341: qe,
            342: Ue,
            343: Ve
          }, e(yt, [2, 263]), e(kt, [2, 71]), e(kt, [2, 72]), e(X, $, {
            64: 154,
            74: 155,
            21: 452,
            75: Y
          }), e(W, K, {
            63: 162,
            67: 163,
            24: 453,
            68: Z
          }), {
            46: [2, 342],
            48: [2, 73],
            89: 463,
            90: s,
            119: [1, 459],
            158: 454,
            159: 455,
            166: 456,
            167: [1, 457],
            168: [1, 458],
            170: [1, 460],
            173: [1, 461],
            174: [1, 462]
          }, e(_t, [2, 340], {
            165: 464,
            326: [1, 465]
          }), e(Lt, Mt, {
            199: 466,
            202: 467,
            208: 468,
            209: 470,
            34: Ft
          }), e(Bt, [2, 374], {
            202: 467,
            208: 468,
            209: 470,
            201: 471,
            199: 472,
            13: Mt,
            16: Mt,
            35: Mt,
            195: Mt,
            217: Mt,
            222: Mt,
            310: Mt,
            34: Ft
          }), e(qt, [2, 372]), e(qt, [2, 373]), {
            13: l,
            16: h,
            34: ee,
            35: vt,
            39: 478,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            200: 476,
            204: 474,
            224: wt,
            226: 473,
            228: 475,
            229: L,
            241: 477,
            242: 177,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, e(Lt, Mt, {
            202: 467,
            208: 468,
            209: 470,
            199: 479,
            34: Ft
          }), e(W, [2, 24], {
            272: 231,
            278: 236,
            281: 239,
            60: 274,
            72: 390,
            73: 391,
            71: 480,
            13: l,
            16: h,
            34: St,
            35: Tt,
            273: Ae,
            274: Re,
            275: Ie,
            277: Ne,
            279: Pe,
            280: Ce,
            282: De,
            283: je,
            286: ke,
            288: Le,
            310: p,
            338: Me,
            339: Fe,
            340: Be,
            341: qe,
            342: Ue,
            343: Ve
          }), e(Ut, [2, 260]), e(Ut, [2, 25]), e(Ut, [2, 26]), e(D, j, {
            245: 116,
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            36: 481,
            217: k,
            271: M,
            332: F
          }), e(Ut, [2, 29]), e(W, K, {
            63: 162,
            67: 163,
            24: 482,
            68: Z
          }), e([48, 119, 225, 326], [2, 97], {
            190: 483,
            191: [1, 484]
          }), e(Et, [2, 99]), {
            13: l,
            16: h,
            34: ee,
            35: te,
            39: 304,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            185: 302,
            197: 485,
            224: ie,
            227: 301,
            229: L,
            241: 303,
            242: 177,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, e(Vt, [2, 124]), e(Ot, [2, 400]), e(Vt, [2, 125]), e(rt, [2, 182]), e(C, [2, 14]), e(C, [2, 15]), e(we, [2, 144]), {
            13: l,
            16: h,
            34: ee,
            39: 487,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            229: L,
            231: 486,
            241: 488,
            242: 177,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, {
            233: [1, 489]
          }, {
            233: [2, 415]
          }, {
            233: [2, 416]
          }, e(Se, [2, 146]), e(Se, [2, 149]), e(Te, [2, 151]), e(Te, [2, 152], {
            268: 328,
            267: 490,
            26: at,
            329: st
          }), e(Te, [2, 153], {
            268: 328,
            267: 491,
            26: at,
            329: st
          }), e(Ee, [2, 155]), e(it, [2, 352], {
            176: 492
          }), e(it, [2, 351]), e([6, 13, 16, 26, 34, 35, 37, 38, 46, 48, 78, 81, 83, 86, 87, 88, 90, 93, 119, 167, 168, 170, 173, 174, 191, 224, 229, 243, 244, 248, 252, 256, 271, 273, 274, 275, 276, 277, 279, 280, 282, 283, 286, 288, 293, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 326, 329, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343], [2, 165]), {
            38: [1, 493]
          }, {
            276: [1, 494]
          }, {
            276: [1, 495]
          }, e(D, j, {
            245: 116,
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            36: 496,
            217: k,
            271: M,
            332: F
          }), {
            38: [1, 497]
          }, {
            38: [1, 498]
          }, e(ct, [2, 175]), e(D, j, {
            245: 116,
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            285: 499,
            36: 501,
            26: [1, 500],
            217: k,
            271: M,
            332: F
          }), e(Rt, [2, 461]), e(D, j, {
            245: 116,
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            36: 502,
            217: k,
            271: M,
            332: F
          }), e(it, [2, 465]), e(D, j, {
            245: 116,
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            36: 503,
            217: k,
            271: M,
            332: F
          }), e(it, [2, 467]), {
            13: l,
            16: h,
            34: [1, 505],
            60: 506,
            236: 504,
            310: p
          }, {
            13: l,
            16: h,
            34: We,
            60: 294,
            193: 507,
            195: Ke,
            310: p
          }, e(et, [2, 423]), e(et, [2, 424]), {
            35: [1, 510],
            48: [1, 508],
            101: 509
          }, e(H, [2, 63]), {
            46: [1, 511]
          }, {
            46: [2, 318]
          }, {
            46: [2, 319]
          }, e(H, [2, 57]), {
            13: l,
            16: h,
            60: 512,
            310: p
          }, e(y, [2, 308]), e(H, [2, 58]), e(mt, [2, 36], {
            88: [1, 513]
          }), e(mt, [2, 37], {
            86: [1, 514]
          }), e($e, [2, 31], {
            272: 231,
            278: 236,
            281: 239,
            82: 271,
            72: 272,
            73: 273,
            60: 274,
            84: 450,
            80: 515,
            13: l,
            16: h,
            34: Ct,
            35: Oe,
            81: Dt,
            83: jt,
            273: Ae,
            274: Re,
            275: Ie,
            277: Ne,
            279: Pe,
            280: Ce,
            282: De,
            283: je,
            286: ke,
            288: Le,
            310: p,
            338: Me,
            339: Fe,
            340: Be,
            341: qe,
            342: Ue,
            343: Ve
          }), e(Ht, [2, 264]), {
            35: Oe,
            82: 516
          }, {
            35: Oe,
            82: 517
          }, e(Ht, [2, 34]), e(Ht, [2, 35]), {
            31: 518,
            48: [2, 226],
            89: 519,
            90: s
          }, {
            32: 520,
            48: [2, 228],
            89: 521,
            90: s
          }, e(_t, [2, 333]), e(Gt, [2, 334], {
            160: 522,
            326: [1, 523]
          }), {
            46: J,
            62: 524
          }, {
            46: J,
            62: 525
          }, {
            46: J,
            62: 526
          }, {
            13: l,
            16: h,
            34: [1, 528],
            60: 529,
            169: 527,
            310: p
          }, e(zt, [2, 346], {
            171: 530,
            319: [1, 531]
          }), {
            13: l,
            16: h,
            35: Oe,
            60: 274,
            72: 272,
            73: 273,
            82: 271,
            84: 532,
            272: 231,
            273: Ae,
            274: Re,
            275: Ie,
            277: Ne,
            278: 236,
            279: Pe,
            280: Ce,
            281: 239,
            282: De,
            283: je,
            286: ke,
            288: Le,
            310: p,
            338: Me,
            339: Fe,
            340: Be,
            341: qe,
            342: Ue,
            343: Ve
          }, {
            35: [1, 533]
          }, e(Qt, [2, 84]), e(_t, [2, 75]), e(R, [2, 339], {
            46: Xt,
            48: Xt,
            90: Xt,
            119: Xt,
            167: Xt,
            168: Xt,
            170: Xt,
            173: Xt,
            174: Xt
          }), e(Bt, [2, 104]), e(R, [2, 378], {
            203: 534
          }), e(R, [2, 376]), e(R, [2, 377]), e(Lt, [2, 386], {
            210: 535,
            211: 536
          }), e(Bt, [2, 105]), e(Bt, [2, 375]), {
            13: l,
            16: h,
            34: ee,
            35: vt,
            38: [1, 537],
            39: 478,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            200: 476,
            204: 538,
            224: wt,
            228: 475,
            229: L,
            241: 477,
            242: 177,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, e(Ot, [2, 401]), e(At, [2, 130]), e(At, [2, 131]), e(At, [2, 405]), e(At, [2, 406]), {
            225: [1, 539]
          }, e(Ut, [2, 261]), {
            37: [1, 541],
            38: [1, 540]
          }, e(o, [2, 17]), e(Et, [2, 367]), e(Et, [2, 368], {
            193: 292,
            60: 294,
            192: 542,
            188: 543,
            13: l,
            16: h,
            34: We,
            195: Ke,
            310: p
          }), e($t, [2, 103], {
            276: [1, 544]
          }), {
            13: l,
            16: h,
            34: We,
            60: 294,
            193: 545,
            195: Ke,
            310: p
          }, e(et, [2, 409]), e(et, [2, 410]), e(Yt, [2, 133]), e(Ee, [2, 444]), e(Ee, [2, 446]), e(D, j, {
            245: 116,
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            36: 546,
            217: k,
            271: M,
            332: F
          }), e(ct, [2, 168]), e(D, j, {
            245: 116,
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            36: 547,
            217: k,
            271: M,
            332: F
          }), e(D, j, {
            245: 116,
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            36: 548,
            217: k,
            271: M,
            332: F
          }), {
            38: [1, 549],
            276: [1, 550]
          }, e(ct, [2, 172]), e(ct, [2, 174]), {
            38: [1, 551]
          }, {
            38: [2, 462]
          }, {
            38: [2, 463]
          }, {
            38: [1, 552]
          }, {
            38: [2, 468],
            191: [1, 555],
            290: 553,
            291: 554
          }, {
            46: [1, 556]
          }, {
            46: [2, 417]
          }, {
            46: [2, 418]
          }, {
            13: l,
            16: h,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            99: 558,
            229: ft,
            240: 557,
            242: 559,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, e(B, [2, 43]), e(Nt, [2, 273]), {
            13: l,
            16: h,
            60: 350,
            87: re,
            97: 561,
            98: 351,
            99: 352,
            100: pt,
            102: 560,
            229: ft,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, e(R, G, {
            152: 146,
            148: 562,
            151: 563,
            48: [2, 320]
          }), e(Q, [2, 61]), {
            87: [1, 564]
          }, {
            87: [1, 565]
          }, e(Ht, [2, 265]), e(Ht, [2, 32]), e(Ht, [2, 33]), {
            48: [2, 11]
          }, {
            48: [2, 227]
          }, {
            48: [2, 12]
          }, {
            48: [2, 229]
          }, e(R, Ye, {
            163: 281,
            161: 566,
            162: 567,
            46: Jt,
            48: Jt,
            90: Jt,
            119: Jt,
            167: Jt,
            168: Jt,
            170: Jt,
            173: Jt,
            174: Jt
          }), e(Gt, [2, 335]), e(Qt, [2, 76], {
            327: [1, 568]
          }), e(Qt, [2, 77]), e(Qt, [2, 78]), {
            46: J,
            62: 569
          }, {
            46: [2, 344]
          }, {
            46: [2, 345]
          }, {
            13: l,
            16: h,
            34: [1, 571],
            60: 572,
            172: 570,
            310: p
          }, e(zt, [2, 347]), e(Qt, [2, 81]), e(D, j, {
            245: 116,
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            36: 573,
            39: 574,
            217: k,
            229: L,
            271: M,
            332: F
          }), {
            13: l,
            16: h,
            34: ee,
            35: vt,
            39: 478,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            200: 476,
            204: 575,
            224: wt,
            228: 475,
            229: L,
            241: 477,
            242: 177,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, e(Ot, [2, 109], {
            328: [1, 576]
          }), e(Wt, [2, 393], {
            212: 577,
            216: 578,
            222: [1, 579]
          }), e(Kt, [2, 126]), e(Ot, [2, 402]), e(Kt, [2, 127]), e(Ut, [2, 27]), {
            34: [1, 580]
          }, e(Et, [2, 98]), e(Et, [2, 369]), e(R, [2, 371]), {
            13: l,
            16: h,
            34: ee,
            39: 582,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            229: L,
            232: 581,
            241: 583,
            242: 177,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, {
            38: [1, 584],
            276: [1, 585]
          }, {
            38: [1, 586]
          }, {
            276: [1, 587]
          }, e(ct, [2, 91]), e(it, [2, 355]), e(ct, [2, 176]), e(ct, [2, 177]), {
            38: [1, 588]
          }, {
            38: [2, 469]
          }, {
            292: [1, 589]
          }, {
            13: l,
            16: h,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            99: 591,
            229: ft,
            237: 590,
            242: 592,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, {
            233: [1, 593]
          }, {
            233: [2, 425]
          }, {
            233: [2, 426]
          }, {
            13: l,
            16: h,
            38: [1, 594],
            60: 350,
            87: re,
            97: 595,
            98: 351,
            99: 352,
            100: pt,
            229: ft,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, e(Zt, [2, 274]), {
            48: [1, 596]
          }, {
            48: [2, 321]
          }, e(mt, [2, 38]), e(mt, [2, 39]), e(_t, [2, 74]), e(_t, [2, 337]), {
            46: [2, 343]
          }, e(Qt, [2, 79]), {
            46: J,
            62: 597
          }, {
            46: [2, 348]
          }, {
            46: [2, 349]
          }, {
            37: [1, 598]
          }, {
            37: [1, 599]
          }, e($t, [2, 380], {
            205: 600,
            276: [1, 601]
          }), e(Lt, [2, 385]), e([13, 16, 34, 35, 38, 87, 93, 224, 229, 243, 244, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 328], [2, 110], {
            329: [1, 602]
          }), {
            13: l,
            16: h,
            35: [1, 608],
            60: 605,
            195: [1, 606],
            213: 603,
            214: 604,
            217: [1, 607],
            310: p
          }, e(Wt, [2, 394]), {
            38: [1, 609]
          }, {
            48: [1, 610]
          }, {
            48: [2, 411]
          }, {
            48: [2, 412]
          }, e(ct, [2, 89]), e(it, [2, 353]), e(ct, [2, 169]), e(D, j, {
            245: 116,
            249: 118,
            253: 119,
            257: 120,
            265: 121,
            269: 122,
            36: 611,
            217: k,
            271: M,
            332: F
          }), e(ct, [2, 178]), {
            293: [1, 612]
          }, {
            13: l,
            16: h,
            34: We,
            60: 294,
            193: 613,
            195: Ke,
            310: p
          }, e(et, [2, 419]), e(et, [2, 420]), e(er, [2, 135]), e(Nt, [2, 48]), e(Zt, [2, 275]), e(tr, [2, 322], {
            149: 614,
            326: [1, 615]
          }), e(Qt, [2, 80]), {
            34: [1, 616]
          }, {
            34: [1, 617]
          }, e([46, 48, 90, 119, 167, 168, 170, 173, 174, 225, 326], [2, 106], {
            206: 618,
            191: [1, 619]
          }), e(R, [2, 379]), e(Lt, [2, 387]), e(rr, [2, 112]), e(rr, [2, 391], {
            215: 620,
            330: 621,
            26: [1, 623],
            331: [1, 622],
            332: [1, 624]
          }), e(nr, [2, 113]), e(nr, [2, 114]), {
            13: l,
            16: h,
            35: [1, 628],
            60: 629,
            93: [1, 627],
            195: ir,
            218: 625,
            219: 626,
            222: ar,
            310: p
          }, e(Lt, Mt, {
            209: 470,
            208: 632
          }), e(Ut, [2, 28]), {
            233: [1, 633]
          }, {
            38: [1, 634]
          }, {
            294: 635,
            300: le,
            301: he,
            302: de,
            303: pe
          }, {
            13: l,
            16: h,
            60: 178,
            87: re,
            93: ne,
            98: 179,
            99: 637,
            229: ft,
            238: 636,
            242: 638,
            243: ae,
            244: se,
            261: 187,
            263: 188,
            294: 183,
            297: oe,
            298: ue,
            299: ce,
            300: le,
            301: he,
            302: de,
            303: pe,
            304: fe,
            305: ge,
            306: me,
            307: ye,
            308: be,
            309: _e,
            310: p
          }, e(R, G, {
            152: 146,
            150: 639,
            151: 640,
            48: sr,
            119: sr
          }), e(tr, [2, 323]), {
            38: [1, 641]
          }, {
            38: [1, 642]
          }, e($t, [2, 381]), e($t, [2, 107], {
            209: 470,
            207: 643,
            208: 644,
            13: Mt,
            16: Mt,
            35: Mt,
            195: Mt,
            217: Mt,
            222: Mt,
            310: Mt,
            34: [1, 645]
          }), e(rr, [2, 111]), e(rr, [2, 392]), e(rr, [2, 388]), e(rr, [2, 389]), e(rr, [2, 390]), e(nr, [2, 115]), e(nr, [2, 117]), e(nr, [2, 118]), e(or, [2, 395], {
            220: 646
          }), e(nr, [2, 120]), e(nr, [2, 121]), {
            13: l,
            16: h,
            60: 647,
            195: [1, 648],
            310: p
          }, {
            38: [1, 649]
          }, e(Yt, [2, 132]), e(ct, [2, 170]), {
            38: [2, 179]
          }, {
            48: [1, 650]
          }, {
            48: [2, 421]
          }, {
            48: [2, 422]
          }, e(Xe, [2, 69]), e(Xe, [2, 325]), e(Qt, [2, 82]), e(Qt, [2, 83]), e(R, xt, {
            196: 397,
            194: 651
          }), e(R, [2, 382]), e(R, [2, 383]), {
            13: l,
            16: h,
            38: [2, 397],
            60: 629,
            195: ir,
            219: 653,
            221: 652,
            222: ar,
            310: p
          }, e(nr, [2, 122]), e(nr, [2, 123]), e(nr, [2, 116]), {
            233: [1, 654]
          }, e($t, [2, 108]), {
            38: [1, 655]
          }, {
            38: [2, 398],
            328: [1, 656]
          }, e(er, [2, 134]), e(nr, [2, 119]), e(or, [2, 396])],
          defaultActions: {
            5: [2, 204],
            6: [2, 205],
            8: [2, 203],
            26: [2, 1],
            27: [2, 3],
            28: [2, 215],
            77: [2, 49],
            86: [2, 294],
            100: [2, 251],
            107: [2, 357],
            220: [2, 438],
            248: [2, 459],
            287: [2, 235],
            288: [2, 93],
            314: [2, 407],
            315: [2, 408],
            407: [2, 415],
            408: [2, 416],
            438: [2, 318],
            439: [2, 319],
            500: [2, 462],
            501: [2, 463],
            505: [2, 417],
            506: [2, 418],
            518: [2, 11],
            519: [2, 227],
            520: [2, 12],
            521: [2, 229],
            528: [2, 344],
            529: [2, 345],
            554: [2, 469],
            558: [2, 425],
            559: [2, 426],
            563: [2, 321],
            568: [2, 343],
            571: [2, 348],
            572: [2, 349],
            582: [2, 411],
            583: [2, 412],
            635: [2, 179],
            637: [2, 421],
            638: [2, 422]
          },
          parseError: function(e, t) {
            if (!t.recoverable) {
              var r = new Error(e);
              throw r.hash = t, r
            }
            this.trace(e)
          },
          parse: function(e) {
            var t = this,
              r = [0],
              n = [null],
              i = [],
              a = this.table,
              s = "",
              o = 0,
              u = 0,
              c = 0,
              l = 2,
              h = 1,
              d = i.slice.call(arguments, 1),
              p = Object.create(this.lexer),
              f = {
                yy: {}
              };
            for (var g in this.yy) Object.prototype.hasOwnProperty.call(this.yy, g) && (f.yy[g] = this.yy[g]);
            p.setInput(e, f.yy), f.yy.lexer = p, f.yy.parser = this, void 0 === p.yylloc && (p.yylloc = {});
            var m = p.yylloc;
            i.push(m);
            var y = p.options && p.options.ranges;
            "function" == typeof f.yy.parseError ? this.parseError = f.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;
            for (var b, _, v, w, S, T, E, x, O, A = function() {
              var e;
              return "number" != typeof(e = p.lex() || h) && (e = t.symbols_[e] || e), e
            }, R = {};;) {
              if (v = r[r.length - 1], this.defaultActions[v] ? w = this.defaultActions[v] : (null == b && (b = A()), w = a[v] && a[v][b]), void 0 === w || !w.length || !w[0]) {
                var I = "";
                for (T in O = [], a[v]) this.terminals_[T] && T > l && O.push("'" + this.terminals_[T] + "'");
                I = p.showPosition ? "Parse error on line " + (o + 1) + ":\n" + p.showPosition() + "\nExpecting " + O.join(", ") + ", got '" + (this.terminals_[b] || b) + "'" : "Parse error on line " + (o + 1) + ": Unexpected " + (b == h ? "end of input" : "'" + (this.terminals_[b] || b) + "'"), this.parseError(I, {
                  text: p.match,
                  token: this.terminals_[b] || b,
                  line: p.yylineno,
                  loc: m,
                  expected: O
                })
              }
              if (w[0] instanceof Array && w.length > 1) throw new Error("Parse Error: multiple actions possible at state: " + v + ", token: " + b);
              switch (w[0]) {
                case 1:
                  r.push(b), n.push(p.yytext), i.push(p.yylloc), r.push(w[1]), b = null, _ ? (b = _, _ = null) : (u = p.yyleng, s = p.yytext, o = p.yylineno, m = p.yylloc, c > 0 && c--);
                  break;
                case 2:
                  if (E = this.productions_[w[1]][1], R.$ = n[n.length - E], R._$ = {
                    first_line: i[i.length - (E || 1)].first_line,
                    last_line: i[i.length - 1].last_line,
                    first_column: i[i.length - (E || 1)].first_column,
                    last_column: i[i.length - 1].last_column
                  }, y && (R._$.range = [i[i.length - (E || 1)].range[0], i[i.length - 1].range[1]]), void 0 !== (S = this.performAction.apply(R, [s, u, o, f.yy, w[1], n, i].concat(d)))) return S;
                  E && (r = r.slice(0, -1 * E * 2), n = n.slice(0, -1 * E), i = i.slice(0, -1 * E)), r.push(this.productions_[w[1]][0]), n.push(R.$), i.push(R._$), x = a[r[r.length - 2]][r[r.length - 1]], r.push(x);
                  break;
                case 3:
                  return !0
              }
            }
            return !0
          }
        },
        cr = r(102).Wildcard,
        lr = "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
        hr = lr + "type",
        dr = lr + "nil",
        pr = "http://www.w3.org/2001/XMLSchema#",
        fr = pr + "integer",
        gr = pr + "decimal",
        mr = pr + "double",
        yr = pr + "boolean",
        br = "",
        _r = "",
        vr = "";

      function wr(e) {
        return e.toLowerCase()
      }

      function Sr(e, t) {
        return e.push(t), e
      }

      function Tr(e, t) {
        return e.push.apply(e, t), e
      }

      function Er(e) {
        e || (e = {});
        for (var t, r = 1, n = arguments.length; r < n && (t = arguments[r] || {}); r++)
          for (var i in t) e[i] = t[i];
        return e
      }

      function xr() {
        for (var e = [], t = 0, r = arguments.length; t < r; t++) e = e.concat.apply(e, arguments[t]);
        return e
      }

      function Or(e) {
        if ("<" === e[0] && (e = e.substring(1, e.length - 1)), /^[a-z]+:/.test(e)) return e;
        if (!Kr.base) throw new Error("Cannot resolve relative IRI " + e + " because no base IRI was set.");
        switch (br || (br = Kr.base, _r = br.replace(/[^\/:]*$/, ""), vr = br.match(/^(?:[a-z]+:\/*)?[^\/]*/)[0]), e[0]) {
          case void 0:
            return br;
          case "#":
            return br + e;
          case "?":
            return br.replace(/(?:\?.*)?$/, e);
          case "/":
            return vr + e;
          default:
            return _r + e
        }
      }

      function Ar(e) {
        if (e) {
          var t = e[0];
          if ("?" === t || "$" === t) return Kr.factory.variable(e.substr(1))
        }
        return e
      }

      function Rr(e, t) {
        return {
          type: "operation",
          operator: e,
          args: t || []
        }
      }

      function Ir(e, t) {
        var r = {
          expression: "*" === e ? new cr : e
        };
        if (t)
          for (var n in t) r[n] = t[n];
        return r
      }

      function Nr(e, t) {
        return {
          type: "path",
          pathType: e,
          items: t
        }
      }

      function Pr(e, t) {
        for (var r, n = 0, i = t.length; n < i && (r = t[n]); n++) e = Rr(r[0], [e, r[1]]);
        return e
      }

      function Cr(e, t) {
        var r, n = [],
          i = [],
          a = e.length,
          s = {};
        if (!a) return null;
        for (var o = 0; o < a && (r = e[o]); o++)(r.named ? i : n).push(r.iri);
        return s[t || "from"] = {
          default: n,
          named: i
        }, s
      }

      function Dr(e) {
        return parseInt(e, 10)
      }

      function jr(e) {
        return "group" === e.type && 1 === e.patterns.length ? e.patterns[0] : e
      }

      function kr(e, t) {
        return t && "NamedNode" !== t.termType && (t = Kr.factory.namedNode(t)), Kr.factory.literal(e, t)
      }

      function Lr(e, t, r) {
        var n = {};
        return null != e && (n.subject = e), null != t && (n.predicate = t), null != r && (n.object = r), n
      }

      function Mr(e) {
        return "string" == typeof e ? e.startsWith("e_") ? Kr.factory.blankNode(e) : Kr.factory.blankNode("e_" + e) : Kr.factory.blankNode("g_" + Fr++)
      }
      var Fr = 0;
      Kr._resetBlanks = function() {
        Fr = 0
      };
      var Br = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\(.)/g,
        qr = {
          "\\": "\\",
          "'": "'",
          '"': '"',
          t: "\t",
          b: "\b",
          n: "\n",
          r: "\r",
          f: "\f"
        },
        Ur = String.fromCharCode;

      function Vr(e, t) {
        e = e.substring(t, e.length - t);
        try {
          e = e.replace(Br, (function(e, t, r, n) {
            var i;
            if (t) {
              if (i = parseInt(t, 16), isNaN(i)) throw new Error;
              return Ur(i)
            }
            if (r) {
              if (i = parseInt(r, 16), isNaN(i)) throw new Error;
              return i < 65535 ? Ur(i) : Ur(55296 + ((i -= 65536) >> 10), 56320 + (1023 & i))
            }
            var a = qr[n];
            if (!a) throw new Error;
            return a
          }))
        } catch (e) {
          return ""
        }
        return e
      }

      function Hr(e, t, r) {
        var n = [],
          i = [];
        return t.forEach((function(t) {
          n.push(Lr(null, e, t.entity)), Tr(i, t.triples)
        })), xr(n, r || [], i)
      }

      function Gr(e) {
        return e.variable ? e.variable.value : e.value || e.expression.value
      }

      function zr(e) {
        if (!e) return [];
        if ("aggregate" === e.type) return [e];
        if ("operation" === e.type) {
          const t = [];
          for (const r of e.args) t.push(...zr(r));
          return t
        }
        return []
      }

      function Qr(e) {
        const t = new Set,
          r = function(e) {
            e && ("Variable" === e.termType ? t.add(e) : "operation" === e.type && e.args.forEach(r))
          };
        return r(e), t
      }

      function Xr(e, t = 1, r = []) {
        for (const n of e) t > 0 && n instanceof Array ? Xr(n, t - 1, r) : r.push(n);
        return r
      }

      function $r(e) {
        return "Variable" === e.termType
      }

      function Yr(e) {
        if (e.triples) {
          const t = [];
          for (const r of e.triples) $r(r.subject) && t.push(r.subject.value), $r(r.predicate) && t.push(r.predicate.value), $r(r.object) && t.push(r.object.value);
          return t
        }
        if (e.patterns) {
          const t = [];
          for (const r of e.patterns) t.push(...Yr(r));
          return t
        }
        return []
      }

      function Jr(e) {
        if (!Kr.sparqlStar) throw new Error("SPARQL* support is not enabled");
        return e
      }
      var Wr = {
        EOF: 1,
        parseError: function(e, t) {
          if (!this.yy.parser) throw new Error(e);
          this.yy.parser.parseError(e, t)
        },
        setInput: function(e, t) {
          return this.yy = t || this.yy || {}, this._input = e, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this
        },
        input: function() {
          var e = this._input[0];
          return this.yytext += e, this.yyleng++, this.offset++, this.match += e, this.matched += e, e.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), e
        },
        unput: function(e) {
          var t = e.length,
            r = e.split(/(?:\r\n?|\n)/g);
          this._input = e + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - t), this.offset -= t;
          var n = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), r.length - 1 && (this.yylineno -= r.length - 1);
          var i = this.yylloc.range;
          return this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: r ? (r.length === n.length ? this.yylloc.first_column : 0) + n[n.length - r.length].length - r[0].length : this.yylloc.first_column - t
          }, this.options.ranges && (this.yylloc.range = [i[0], i[0] + this.yyleng - t]), this.yyleng = this.yytext.length, this
        },
        more: function() {
          return this._more = !0, this
        },
        reject: function() {
          return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          })
        },
        less: function(e) {
          this.unput(this.match.slice(e))
        },
        pastInput: function() {
          var e = this.matched.substr(0, this.matched.length - this.match.length);
          return (e.length > 20 ? "..." : "") + e.substr(-20).replace(/\n/g, "")
        },
        upcomingInput: function() {
          var e = this.match;
          return e.length < 20 && (e += this._input.substr(0, 20 - e.length)), (e.substr(0, 20) + (e.length > 20 ? "..." : "")).replace(/\n/g, "")
        },
        showPosition: function() {
          var e = this.pastInput(),
            t = new Array(e.length + 1).join("-");
          return e + this.upcomingInput() + "\n" + t + "^"
        },
        test_match: function(e, t) {
          var r, n, i;
          if (this.options.backtrack_lexer && (i = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          }, this.options.ranges && (i.yylloc.range = this.yylloc.range.slice(0))), (n = e[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += n.length), this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: n ? n[n.length - 1].length - n[n.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + e[0].length
          }, this.yytext += e[0], this.match += e[0], this.matches = e, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(e[0].length), this.matched += e[0], r = this.performAction.call(this, this.yy, this, t, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), r) return r;
          if (this._backtrack) {
            for (var a in i) this[a] = i[a];
            return !1
          }
          return !1
        },
        next: function() {
          if (this.done) return this.EOF;
          var e, t, r, n;
          this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");
          for (var i = this._currentRules(), a = 0; a < i.length; a++)
            if ((r = this._input.match(this.rules[i[a]])) && (!t || r[0].length > t[0].length)) {
              if (t = r, n = a, this.options.backtrack_lexer) {
                if (!1 !== (e = this.test_match(r, i[a]))) return e;
                if (this._backtrack) {
                  t = !1;
                  continue
                }
                return !1
              }
              if (!this.options.flex) break
            } return t ? !1 !== (e = this.test_match(t, i[n])) && e : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          })
        },
        lex: function() {
          var e = this.next();
          return e || this.lex()
        },
        begin: function(e) {
          this.conditionStack.push(e)
        },
        popState: function() {
          return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0]
        },
        _currentRules: function() {
          return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules
        },
        topState: function(e) {
          return (e = this.conditionStack.length - 1 - Math.abs(e || 0)) >= 0 ? this.conditionStack[e] : "INITIAL"
        },
        pushState: function(e) {
          this.begin(e)
        },
        stateStackSize: function() {
          return this.conditionStack.length
        },
        options: {
          flex: !0,
          "case-insensitive": !0
        },
        performAction: function(e, t, r, n) {
          switch (r) {
            case 0:
              break;
            case 1:
              return 12;
            case 2:
              return 15;
            case 3:
              return 28;
            case 4:
              return 314;
            case 5:
              return 315;
            case 6:
              return 35;
            case 7:
              return 37;
            case 8:
              return 38;
            case 9:
              return 26;
            case 10:
              return 41;
            case 11:
              return 45;
            case 12:
              return 46;
            case 13:
              return 48;
            case 14:
              return 50;
            case 15:
              return 55;
            case 16:
              return 58;
            case 17:
              return 318;
            case 18:
              return 68;
            case 19:
              return 69;
            case 20:
              return 75;
            case 21:
              return 78;
            case 22:
              return 81;
            case 23:
              return 83;
            case 24:
              return 86;
            case 25:
              return 88;
            case 26:
              return 90;
            case 27:
              return 191;
            case 28:
              return 107;
            case 29:
              return 319;
            case 30:
              return 140;
            case 31:
              return 320;
            case 32:
              return 321;
            case 33:
              return 117;
            case 34:
              return 322;
            case 35:
              return 116;
            case 36:
              return 323;
            case 37:
              return 324;
            case 38:
              return 120;
            case 39:
              return 122;
            case 40:
              return 123;
            case 41:
              return 138;
            case 42:
              return 132;
            case 43:
              return 133;
            case 44:
              return 135;
            case 45:
              return 141;
            case 46:
              return 119;
            case 47:
              return 325;
            case 48:
              return 326;
            case 49:
              return 167;
            case 50:
              return 170;
            case 51:
              return 174;
            case 52:
              return 100;
            case 53:
              return 168;
            case 54:
              return 327;
            case 55:
              return 173;
            case 56:
              return 229;
            case 57:
              return 233;
            case 58:
              return 276;
            case 59:
              return 195;
            case 60:
              return 328;
            case 61:
              return 329;
            case 62:
              return 222;
            case 63:
              return 331;
            case 64:
              return 332;
            case 65:
              return 217;
            case 66:
              return 224;
            case 67:
              return 225;
            case 68:
              return 248;
            case 69:
              return 252;
            case 70:
              return 293;
            case 71:
              return 333;
            case 72:
              return 334;
            case 73:
              return 335;
            case 74:
              return 336;
            case 75:
              return 337;
            case 76:
              return 256;
            case 77:
              return 338;
            case 78:
              return 271;
            case 79:
              return 279;
            case 80:
              return 280;
            case 81:
              return 273;
            case 82:
              return 274;
            case 83:
              return 275;
            case 84:
              return 339;
            case 85:
              return 340;
            case 86:
              return 277;
            case 87:
              return 342;
            case 88:
              return 341;
            case 89:
              return 343;
            case 90:
              return 282;
            case 91:
              return 283;
            case 92:
              return 286;
            case 93:
              return 288;
            case 94:
              return 292;
            case 95:
              return 296;
            case 96:
              return 299;
            case 97:
              return 13;
            case 98:
              return 16;
            case 99:
              return 310;
            case 100:
              return 243;
            case 101:
              return 34;
            case 102:
              return 295;
            case 103:
              return 87;
            case 104:
              return 297;
            case 105:
              return 298;
            case 106:
              return 304;
            case 107:
              return 305;
            case 108:
              return 306;
            case 109:
              return 307;
            case 110:
              return 308;
            case 111:
              return 309;
            case 112:
              return "EXPONENT";
            case 113:
              return 300;
            case 114:
              return 301;
            case 115:
              return 302;
            case 116:
              return 303;
            case 117:
              return 93;
            case 118:
              return 244;
            case 119:
              return 6;
            case 120:
              return "INVALID";
            case 121:
              console.log(t.yytext)
          }
        },
        rules: [/^(?:\s+|#[^\n\r]*)/i, /^(?:BASE)/i, /^(?:PREFIX)/i, /^(?:SELECT)/i, /^(?:DISTINCT)/i, /^(?:REDUCED)/i, /^(?:\()/i, /^(?:AS)/i, /^(?:\))/i, /^(?:\*)/i, /^(?:CONSTRUCT)/i, /^(?:WHERE)/i, /^(?:\{)/i, /^(?:\})/i, /^(?:DESCRIBE)/i, /^(?:ASK)/i, /^(?:FROM)/i, /^(?:NAMED)/i, /^(?:GROUP)/i, /^(?:BY)/i, /^(?:HAVING)/i, /^(?:ORDER)/i, /^(?:ASC)/i, /^(?:DESC)/i, /^(?:LIMIT)/i, /^(?:OFFSET)/i, /^(?:VALUES)/i, /^(?:;)/i, /^(?:LOAD)/i, /^(?:SILENT)/i, /^(?:INTO)/i, /^(?:CLEAR)/i, /^(?:DROP)/i, /^(?:CREATE)/i, /^(?:ADD)/i, /^(?:TO)/i, /^(?:MOVE)/i, /^(?:COPY)/i, /^(?:INSERT\s+DATA)/i, /^(?:DELETE\s+DATA)/i, /^(?:DELETE\s+WHERE)/i, /^(?:WITH)/i, /^(?:DELETE)/i, /^(?:INSERT)/i, /^(?:USING)/i, /^(?:DEFAULT)/i, /^(?:GRAPH)/i, /^(?:ALL)/i, /^(?:\.)/i, /^(?:OPTIONAL)/i, /^(?:SERVICE)/i, /^(?:BIND)/i, /^(?:UNDEF)/i, /^(?:MINUS)/i, /^(?:UNION)/i, /^(?:FILTER)/i, /^(?:<<)/i, /^(?:>>)/i, /^(?:,)/i, /^(?:a)/i, /^(?:\|)/i, /^(?:\/)/i, /^(?:\^)/i, /^(?:\?)/i, /^(?:\+)/i, /^(?:!)/i, /^(?:\[)/i, /^(?:\])/i, /^(?:\|\|)/i, /^(?:&&)/i, /^(?:=)/i, /^(?:!=)/i, /^(?:<)/i, /^(?:>)/i, /^(?:<=)/i, /^(?:>=)/i, /^(?:IN)/i, /^(?:NOT)/i, /^(?:-)/i, /^(?:BOUND)/i, /^(?:BNODE)/i, /^(?:(RAND|NOW|UUID|STRUUID))/i, /^(?:(LANG|DATATYPE|IRI|URI|ABS|CEIL|FLOOR|ROUND|STRLEN|STR|UCASE|LCASE|ENCODE_FOR_URI|YEAR|MONTH|DAY|HOURS|MINUTES|SECONDS|TIMEZONE|TZ|MD5|SHA1|SHA256|SHA384|SHA512|isIRI|isURI|isBLANK|isLITERAL|isNUMERIC))/i, /^(?:(LANGMATCHES|CONTAINS|STRSTARTS|STRENDS|STRBEFORE|STRAFTER|STRLANG|STRDT|sameTerm))/i, /^(?:CONCAT)/i, /^(?:COALESCE)/i, /^(?:IF)/i, /^(?:REGEX)/i, /^(?:SUBSTR)/i, /^(?:REPLACE)/i, /^(?:EXISTS)/i, /^(?:COUNT)/i, /^(?:SUM|MIN|MAX|AVG|SAMPLE)/i, /^(?:GROUP_CONCAT)/i, /^(?:SEPARATOR)/i, /^(?:\^\^)/i, /^(?:true|false)/i, /^(?:(<(?:[^<>\"\{\}\|\^`\\\u0000-\u0020])*>))/i, /^(?:((([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])(?:(?:(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])|\.)*(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040]))?)?:))/i, /^(?:(((([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])(?:(?:(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])|\.)*(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040]))?)?:)((?:((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|:|[0-9]|((%([0-9A-Fa-f])([0-9A-Fa-f]))|(\\(_|~|\.|-|!|\$|&|'|\(|\)|\*|\+|,|;|=|\/|\?|#|@|%))))(?:(?:(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])|\.|:|((%([0-9A-Fa-f])([0-9A-Fa-f]))|(\\(_|~|\.|-|!|\$|&|'|\(|\)|\*|\+|,|;|=|\/|\?|#|@|%))))*(?:(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])|:|((%([0-9A-Fa-f])([0-9A-Fa-f]))|(\\(_|~|\.|-|!|\$|&|'|\(|\)|\*|\+|,|;|=|\/|\?|#|@|%)))))?)))/i, /^(?:(_:(?:((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|[0-9])(?:(?:(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])|\.)*(((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|-|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040]))?))/i, /^(?:([\?\$]((?:((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|[0-9])(?:((?:([A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]|[\uD800-\uDB7F][\uDC00-\uDFFF])|_))|[0-9]|\u00B7|[\u0300-\u036F\u203F-\u2040])*)))/i, /^(?:(@[a-zA-Z]+(?:-[a-zA-Z0-9]+)*))/i, /^(?:([0-9]+))/i, /^(?:([0-9]*\.[0-9]+))/i, /^(?:([0-9]+\.[0-9]*([eE][+-]?[0-9]+)|\.([0-9])+([eE][+-]?[0-9]+)|([0-9])+([eE][+-]?[0-9]+)))/i, /^(?:(\+([0-9]+)))/i, /^(?:(\+([0-9]*\.[0-9]+)))/i, /^(?:(\+([0-9]+\.[0-9]*([eE][+-]?[0-9]+)|\.([0-9])+([eE][+-]?[0-9]+)|([0-9])+([eE][+-]?[0-9]+))))/i, /^(?:(-([0-9]+)))/i, /^(?:(-([0-9]*\.[0-9]+)))/i, /^(?:(-([0-9]+\.[0-9]*([eE][+-]?[0-9]+)|\.([0-9])+([eE][+-]?[0-9]+)|([0-9])+([eE][+-]?[0-9]+))))/i, /^(?:([eE][+-]?[0-9]+))/i, /^(?:('(?:(?:[^\u0027\u005C\u000A\u000D])|(\\[tbnrf\\\"']|\\u([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])|\\U([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])))*'))/i, /^(?:("(?:(?:[^\u0022\u005C\u000A\u000D])|(\\[tbnrf\\\"']|\\u([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])|\\U([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])))*"))/i, /^(?:('''(?:(?:'|'')?(?:[^'\\]|(\\[tbnrf\\\"']|\\u([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])|\\U([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f]))))*'''))/i, /^(?:("""(?:(?:"|"")?(?:[^\"\\]|(\\[tbnrf\\\"']|\\u([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])|\\U([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f])([0-9A-Fa-f]))))*"""))/i, /^(?:(\((\u0020|\u0009|\u000D|\u000A)*\)))/i, /^(?:(\[(\u0020|\u0009|\u000D|\u000A)*\]))/i, /^(?:$)/i, /^(?:.)/i, /^(?:.)/i],
        conditions: {
          INITIAL: {
            rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121],
            inclusive: !0
          }
        }
      };

      function Kr() {
        this.yy = {}
      }
      return ur.lexer = Wr, Kr.prototype = ur, ur.Parser = Kr, new Kr
    }();
    t.parser = i, t.Parser = i.Parser, t.parse = function() {
      return i.parse.apply(i, arguments)
    }, t.main = function(n) {
      n[1] || (console.log("Usage: " + n[0] + " FILE"), e.exit(1));
      var i = r(212).readFileSync(r(213).normalize(n[1]), "utf8");
      return t.parser.parse(i)
    }, r.c[r.s] === n && t.main(e.argv.slice(1))
  }).call(this, r(8), r(101)(e))
}, function(e, t, r) {
  "use strict";
  t.byteLength = function(e) {
    var t = c(e),
      r = t[0],
      n = t[1];
    return 3 * (r + n) / 4 - n
  }, t.toByteArray = function(e) {
    var t, r, n = c(e),
      s = n[0],
      o = n[1],
      u = new a(function(e, t, r) {
        return 3 * (t + r) / 4 - r
      }(0, s, o)),
      l = 0,
      h = o > 0 ? s - 4 : s;
    for (r = 0; r < h; r += 4) t = i[e.charCodeAt(r)] << 18 | i[e.charCodeAt(r + 1)] << 12 | i[e.charCodeAt(r + 2)] << 6 | i[e.charCodeAt(r + 3)], u[l++] = t >> 16 & 255, u[l++] = t >> 8 & 255, u[l++] = 255 & t;
    2 === o && (t = i[e.charCodeAt(r)] << 2 | i[e.charCodeAt(r + 1)] >> 4, u[l++] = 255 & t);
    1 === o && (t = i[e.charCodeAt(r)] << 10 | i[e.charCodeAt(r + 1)] << 4 | i[e.charCodeAt(r + 2)] >> 2, u[l++] = t >> 8 & 255, u[l++] = 255 & t);
    return u
  }, t.fromByteArray = function(e) {
    for (var t, r = e.length, i = r % 3, a = [], s = 0, o = r - i; s < o; s += 16383) a.push(l(e, s, s + 16383 > o ? o : s + 16383));
    1 === i ? (t = e[r - 1], a.push(n[t >> 2] + n[t << 4 & 63] + "==")) : 2 === i && (t = (e[r - 2] << 8) + e[r - 1], a.push(n[t >> 10] + n[t >> 4 & 63] + n[t << 2 & 63] + "="));
    return a.join("")
  };
  for (var n = [], i = [], a = "undefined" != typeof Uint8Array ? Uint8Array : Array, s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, u = s.length; o < u; ++o) n[o] = s[o], i[s.charCodeAt(o)] = o;

  function c(e) {
    var t = e.length;
    if (t % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var r = e.indexOf("=");
    return -1 === r && (r = t), [r, r === t ? 0 : 4 - r % 4]
  }

  function l(e, t, r) {
    for (var i, a, s = [], o = t; o < r; o += 3) i = (e[o] << 16 & 16711680) + (e[o + 1] << 8 & 65280) + (255 & e[o + 2]), s.push(n[(a = i) >> 18 & 63] + n[a >> 12 & 63] + n[a >> 6 & 63] + n[63 & a]);
    return s.join("")
  }
  i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63
}, function(e, t) {
  t.read = function(e, t, r, n, i) {
    var a, s, o = 8 * i - n - 1,
      u = (1 << o) - 1,
      c = u >> 1,
      l = -7,
      h = r ? i - 1 : 0,
      d = r ? -1 : 1,
      p = e[t + h];
    for (h += d, a = p & (1 << -l) - 1, p >>= -l, l += o; l > 0; a = 256 * a + e[t + h], h += d, l -= 8);
    for (s = a & (1 << -l) - 1, a >>= -l, l += n; l > 0; s = 256 * s + e[t + h], h += d, l -= 8);
    if (0 === a) a = 1 - c;
    else {
      if (a === u) return s ? NaN : 1 / 0 * (p ? -1 : 1);
      s += Math.pow(2, n), a -= c
    }
    return (p ? -1 : 1) * s * Math.pow(2, a - n)
  }, t.write = function(e, t, r, n, i, a) {
    var s, o, u, c = 8 * a - i - 1,
      l = (1 << c) - 1,
      h = l >> 1,
      d = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
      p = n ? 0 : a - 1,
      f = n ? 1 : -1,
      g = t < 0 || 0 === t && 1 / t < 0 ? 1 : 0;
    for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (o = isNaN(t) ? 1 : 0, s = l) : (s = Math.floor(Math.log(t) / Math.LN2), t * (u = Math.pow(2, -s)) < 1 && (s--, u *= 2), (t += s + h >= 1 ? d / u : d * Math.pow(2, 1 - h)) * u >= 2 && (s++, u /= 2), s + h >= l ? (o = 0, s = l) : s + h >= 1 ? (o = (t * u - 1) * Math.pow(2, i), s += h) : (o = t * Math.pow(2, h - 1) * Math.pow(2, i), s = 0)); i >= 8; e[r + p] = 255 & o, p += f, o /= 256, i -= 8);
    for (s = s << i | o, c += i; c > 0; e[r + p] = 255 & s, p += f, s /= 256, c -= 8);
    e[r + p - f] |= 128 * g
  }
}, function(e, t) {}, function(e, t, r) {
  "use strict";

  function n(e, t) {
    var r = Object.keys(e);
    if (Object.getOwnPropertySymbols) {
      var n = Object.getOwnPropertySymbols(e);
      t && (n = n.filter((function(t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable
      }))), r.push.apply(r, n)
    }
    return r
  }

  function i(e, t, r) {
    return t in e ? Object.defineProperty(e, t, {
      value: r,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[t] = r, e
  }

  function a(e, t) {
    for (var r = 0; r < t.length; r++) {
      var n = t[r];
      n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
    }
  }
  var s = r(11).Buffer,
    o = r(206).inspect,
    u = o && o.custom || "inspect";
  e.exports = function() {
    function e() {
      ! function(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
      }(this, e), this.head = null, this.tail = null, this.length = 0
    }
    var t, r, c;
    return t = e, (r = [{
      key: "push",
      value: function(e) {
        var t = {
          data: e,
          next: null
        };
        this.length > 0 ? this.tail.next = t : this.head = t, this.tail = t, ++this.length
      }
    }, {
      key: "unshift",
      value: function(e) {
        var t = {
          data: e,
          next: this.head
        };
        0 === this.length && (this.tail = t), this.head = t, ++this.length
      }
    }, {
      key: "shift",
      value: function() {
        if (0 !== this.length) {
          var e = this.head.data;
          return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0
      }
    }, {
      key: "join",
      value: function(e) {
        if (0 === this.length) return "";
        for (var t = this.head, r = "" + t.data; t = t.next;) r += e + t.data;
        return r
      }
    }, {
      key: "concat",
      value: function(e) {
        if (0 === this.length) return s.alloc(0);
        for (var t, r, n, i = s.allocUnsafe(e >>> 0), a = this.head, o = 0; a;) t = a.data, r = i, n = o, s.prototype.copy.call(t, r, n), o += a.data.length, a = a.next;
        return i
      }
    }, {
      key: "consume",
      value: function(e, t) {
        var r;
        return e < this.head.data.length ? (r = this.head.data.slice(0, e), this.head.data = this.head.data.slice(e)) : r = e === this.head.data.length ? this.shift() : t ? this._getString(e) : this._getBuffer(e), r
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data
      }
    }, {
      key: "_getString",
      value: function(e) {
        var t = this.head,
          r = 1,
          n = t.data;
        for (e -= n.length; t = t.next;) {
          var i = t.data,
            a = e > i.length ? i.length : e;
          if (a === i.length ? n += i : n += i.slice(0, e), 0 == (e -= a)) {
            a === i.length ? (++r, t.next ? this.head = t.next : this.head = this.tail = null) : (this.head = t, t.data = i.slice(a));
            break
          }++r
        }
        return this.length -= r, n
      }
    }, {
      key: "_getBuffer",
      value: function(e) {
        var t = s.allocUnsafe(e),
          r = this.head,
          n = 1;
        for (r.data.copy(t), e -= r.data.length; r = r.next;) {
          var i = r.data,
            a = e > i.length ? i.length : e;
          if (i.copy(t, t.length - e, 0, a), 0 == (e -= a)) {
            a === i.length ? (++n, r.next ? this.head = r.next : this.head = this.tail = null) : (this.head = r, r.data = i.slice(a));
            break
          }++n
        }
        return this.length -= n, t
      }
    }, {
      key: u,
      value: function(e, t) {
        return o(this, function(e) {
          for (var t = 1; t < arguments.length; t++) {
            var r = null != arguments[t] ? arguments[t] : {};
            t % 2 ? n(Object(r), !0).forEach((function(t) {
              i(e, t, r[t])
            })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : n(Object(r)).forEach((function(t) {
              Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t))
            }))
          }
          return e
        }({}, t, {
          depth: 0,
          customInspect: !1
        }))
      }
    }]) && a(t.prototype, r), c && a(t, c), e
  }()
}, function(e, t) {}, function(e, t, r) {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var n = r(11),
    i = n.Buffer;

  function a(e, t) {
    for (var r in e) t[r] = e[r]
  }

  function s(e, t, r) {
    return i(e, t, r)
  }
  i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? e.exports = n : (a(n, t), t.Buffer = s), s.prototype = Object.create(i.prototype), a(i, s), s.from = function(e, t, r) {
    if ("number" == typeof e) throw new TypeError("Argument must not be a number");
    return i(e, t, r)
  }, s.alloc = function(e, t, r) {
    if ("number" != typeof e) throw new TypeError("Argument must be a number");
    var n = i(e);
    return void 0 !== t ? "string" == typeof r ? n.fill(t, r) : n.fill(t) : n.fill(0), n
  }, s.allocUnsafe = function(e) {
    if ("number" != typeof e) throw new TypeError("Argument must be a number");
    return i(e)
  }, s.allocUnsafeSlow = function(e) {
    if ("number" != typeof e) throw new TypeError("Argument must be a number");
    return n.SlowBuffer(e)
  }
}, function(e, t, r) {
  "use strict";
  (function(t) {
    var n;

    function i(e, t, r) {
      return t in e ? Object.defineProperty(e, t, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : e[t] = r, e
    }
    var a = r(69),
      s = Symbol("lastResolve"),
      o = Symbol("lastReject"),
      u = Symbol("error"),
      c = Symbol("ended"),
      l = Symbol("lastPromise"),
      h = Symbol("handlePromise"),
      d = Symbol("stream");

    function p(e, t) {
      return {
        value: e,
        done: t
      }
    }

    function f(e) {
      var t = e[s];
      if (null !== t) {
        var r = e[d].read();
        null !== r && (e[l] = null, e[s] = null, e[o] = null, t(p(r, !1)))
      }
    }

    function g(e) {
      t.nextTick(f, e)
    }
    var m = Object.getPrototypeOf((function() {})),
      y = Object.setPrototypeOf((i(n = {
        get stream() {
          return this[d]
        },
        next: function() {
          var e = this,
            r = this[u];
          if (null !== r) return Promise.reject(r);
          if (this[c]) return Promise.resolve(p(void 0, !0));
          if (this[d].destroyed) return new Promise((function(r, n) {
            t.nextTick((function() {
              e[u] ? n(e[u]) : r(p(void 0, !0))
            }))
          }));
          var n, i = this[l];
          if (i) n = new Promise(function(e, t) {
            return function(r, n) {
              e.then((function() {
                t[c] ? r(p(void 0, !0)) : t[h](r, n)
              }), n)
            }
          }(i, this));
          else {
            var a = this[d].read();
            if (null !== a) return Promise.resolve(p(a, !1));
            n = new Promise(this[h])
          }
          return this[l] = n, n
        }
      }, Symbol.asyncIterator, (function() {
        return this
      })), i(n, "return", (function() {
        var e = this;
        return new Promise((function(t, r) {
          e[d].destroy(null, (function(e) {
            e ? r(e) : t(p(void 0, !0))
          }))
        }))
      })), n), m);
    e.exports = function(e) {
      var t, r = Object.create(y, (i(t = {}, d, {
        value: e,
        writable: !0
      }), i(t, s, {
        value: null,
        writable: !0
      }), i(t, o, {
        value: null,
        writable: !0
      }), i(t, u, {
        value: null,
        writable: !0
      }), i(t, c, {
        value: e._readableState.endEmitted,
        writable: !0
      }), i(t, h, {
        value: function(e, t) {
          var n = r[d].read();
          n ? (r[l] = null, r[s] = null, r[o] = null, e(p(n, !1))) : (r[s] = e, r[o] = t)
        },
        writable: !0
      }), t));
      return r[l] = null, a(e, (function(e) {
        if (e && "ERR_STREAM_PREMATURE_CLOSE" !== e.code) {
          var t = r[o];
          return null !== t && (r[l] = null, r[s] = null, r[o] = null, t(e)), void(r[u] = e)
        }
        var n = r[s];
        null !== n && (r[l] = null, r[s] = null, r[o] = null, n(p(void 0, !0))), r[c] = !0
      })), e.on("readable", g.bind(null, r)), r
    }
  }).call(this, r(8))
}, function(e, t) {
  e.exports = function() {
    throw new Error("Readable.from is not available in the browser")
  }
}, function(e, t, r) {
  "use strict";
  e.exports = i;
  var n = r(110);

  function i(e) {
    if (!(this instanceof i)) return new i(e);
    n.call(this, e)
  }
  r(12)(i, n), i.prototype._transform = function(e, t, r) {
    r(null, e)
  }
}, function(e, t, r) {
  "use strict";
  var n;
  var i = r(31).codes,
    a = i.ERR_MISSING_ARGS,
    s = i.ERR_STREAM_DESTROYED;

  function o(e) {
    if (e) throw e
  }

  function u(e, t, i, a) {
    a = function(e) {
      var t = !1;
      return function() {
        t || (t = !0, e.apply(void 0, arguments))
      }
    }(a);
    var o = !1;
    e.on("close", (function() {
      o = !0
    })), void 0 === n && (n = r(69)), n(e, {
      readable: t,
      writable: i
    }, (function(e) {
      if (e) return a(e);
      o = !0, a()
    }));
    var u = !1;
    return function(t) {
      if (!o && !u) return u = !0,
        function(e) {
          return e.setHeader && "function" == typeof e.abort
        }(e) ? e.abort() : "function" == typeof e.destroy ? e.destroy() : void a(t || new s("pipe"))
    }
  }

  function c(e) {
    e()
  }

  function l(e, t) {
    return e.pipe(t)
  }

  function h(e) {
    return e.length ? "function" != typeof e[e.length - 1] ? o : e.pop() : o
  }
  e.exports = function() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++) t[r] = arguments[r];
    var n, i = h(t);
    if (Array.isArray(t[0]) && (t = t[0]), t.length < 2) throw new a("streams");
    var s = t.map((function(e, r) {
      var a = r < t.length - 1;
      return u(e, a, r > 0, (function(e) {
        n || (n = e), e && s.forEach(c), a || (s.forEach(c), i(n))
      }))
    }));
    return t.reduce(l)
  }
}, function(e, t) {}, function(e, t) {}, function(e, t) {
  function r(e) {
    this._options = e = e || {};
    var t = e.prefixes || {};
    this._prefixByIri = {};
    var r = [];
    for (var n in t) {
      var i = t[n];
      o(i) && (this._prefixByIri[i] = n, r.push(i))
    }
    var a = r.join("|").replace(/[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&");
    this._prefixRegex = new RegExp("^(" + a + ")([a-zA-Z][\\-_a-zA-Z0-9]*)$"), this._usedPrefixes = {}, this._sparqlStar = e.sparqlStar, this._indent = o(e.indent) ? e.indent : "  ", this._newline = o(e.newline) ? e.newline : "\n"
  }
  r.prototype.toQuery = function(e) {
    var t = "";
    return e.queryType && (t += e.queryType.toUpperCase() + " "), e.reduced && (t += "REDUCED "), e.distinct && (t += "DISTINCT "), e.variables ? t += l(e.variables, void 0, (function(e) {
      return u(e) ? this.toEntity(e) : "(" + this.toExpression(e.expression) + " AS " + s(e.variable) + ")"
    }), this) + " " : e.template && (t += this.group(e.template, !0) + this._newline), e.from && (t += this.graphs("FROM ", e.from.default) + this.graphs("FROM NAMED ", e.from.named)), e.where && (t += "WHERE " + this.group(e.where, !0) + this._newline), e.updates && (t += l(e.updates, ";" + this._newline, this.toUpdate, this)), e.group && (t += "GROUP BY " + l(e.group, void 0, (function(e) {
      var t = o(e.expression) ? e.expression : "(" + this.toExpression(e.expression) + ")";
      return e.variable ? "(" + t + " AS " + s(e.variable) + ")" : t
    }), this) + this._newline), e.having && (t += "HAVING (" + l(e.having, void 0, this.toExpression, this) + ")" + this._newline), e.order && (t += "ORDER BY " + l(e.order, void 0, (function(e) {
      var t = "(" + this.toExpression(e.expression) + ")";
      return e.descending ? "DESC " + t : t
    }), this) + this._newline), e.offset && (t += "OFFSET " + e.offset + this._newline), e.limit && (t += "LIMIT " + e.limit + this._newline), e.values && (t += this.values(e)), (t = this.baseAndPrefixes(e) + t).trim()
  }, r.prototype.baseAndPrefixes = function(e) {
    var t = e.base ? "BASE <" + e.base + ">" + this._newline : "",
      r = "";
    for (var n in e.prefixes)(this._options.allPrefixes || this._usedPrefixes[n]) && (r += "PREFIX " + n + ": <" + e.prefixes[n] + ">" + this._newline);
    return t + r
  }, r.prototype.toPattern = function(e) {
    var t = e.type || e instanceof Array && "array" || (e.subject && e.predicate && e.object ? "triple" : "");
    if (!(t in this)) throw new Error("Unknown entry type: " + t);
    return this[t](e)
  }, r.prototype.triple = function(e) {
    return this.toEntity(e.subject) + " " + this.toEntity(e.predicate) + " " + this.toEntity(e.object) + "."
  }, r.prototype.array = function(e) {
    return l(e, this._newline, this.toPattern, this)
  }, r.prototype.bgp = function(e) {
    return this.encodeTriples(e.triples)
  }, r.prototype.encodeTriples = function(e) {
    if (!e.length) return "";
    for (var t = [], r = void 0, n = void 0, i = 0; i < e.length; i++) {
      var a = e[i];
      c(a.subject, r) ? c(a.predicate, n) ? t.push(",") : (n = a.predicate, t.push(";" + this._newline, this._indent, this.toEntity(n))) : (r && t.push("." + this._newline), r = a.subject, n = a.predicate, t.push(this.toEntity(r), " ", this.toEntity(n))), t.push(" ", this.toEntity(a.object))
    }
    return t.push("."), t.join("")
  }, r.prototype.graph = function(e) {
    return "GRAPH " + this.toEntity(e.name) + " " + this.group(e)
  }, r.prototype.graphs = function(e, t) {
    return t && 0 !== t.length ? l(t, "", (function(t) {
      return e + this.toEntity(t) + this._newline
    }), this) : ""
  }, r.prototype.group = function(e, t) {
    return -1 === (e = !0 !== t ? this.array(e.patterns || e.triples) : this.toPattern("group" !== e.type ? e : e.patterns)).indexOf(this._newline) ? "{ " + e + " }" : "{" + this._newline + this.indent(e) + this._newline + "}"
  }, r.prototype.query = function(e) {
    return this.toQuery(e)
  }, r.prototype.filter = function(e) {
    return "FILTER(" + this.toExpression(e.expression) + ")"
  }, r.prototype.bind = function(e) {
    return "BIND(" + this.toExpression(e.expression) + " AS " + s(e.variable) + ")"
  }, r.prototype.optional = function(e) {
    return "OPTIONAL " + this.group(e)
  }, r.prototype.union = function(e) {
    return l(e.patterns, this._newline + "UNION" + this._newline, (function(e) {
      return this.group(e, !0)
    }), this)
  }, r.prototype.minus = function(e) {
    return "MINUS " + this.group(e)
  }, r.prototype.values = function(e) {
    var t, r, n = Object.keys(e.values.reduce((function(e, t) {
      for (var r in t) e[r] = !0;
      return e
    }), {}));
    return 1 === n.length ? t = r = "" : (t = "(", r = ")"), "VALUES " + t + n.join(" ") + r + " {" + this._newline + l(e.values, this._newline, (function(e) {
      return "  " + t + l(n, void 0, (function(t) {
        return e[t] ? this.toEntity(e[t]) : "UNDEF"
      }), this) + r
    }), this) + this._newline + "}"
  }, r.prototype.service = function(e) {
    return "SERVICE " + (e.silent ? "SILENT " : "") + this.toEntity(e.name) + " " + this.group(e)
  }, r.prototype.toExpression = function(e) {
    if (u(e)) return this.toEntity(e);
    switch (e.type.toLowerCase()) {
      case "aggregate":
        return e.aggregation.toUpperCase() + "(" + (e.distinct ? "DISTINCT " : "") + this.toExpression(e.expression) + (e.separator ? '; SEPARATOR = "' + e.separator.replace(n, i) + '"' : "") + ")";
      case "functioncall":
        return this.toEntity(e.function) + "(" + l(e.args, ", ", this.toExpression, this) + ")";
      case "operation":
        var t = e.operator.toUpperCase(),
          r = e.args || [];
        switch (e.operator.toLowerCase()) {
          case "<":
          case ">":
          case ">=":
          case "<=":
          case "&&":
          case "||":
          case "=":
          case "!=":
          case "+":
          case "-":
          case "*":
          case "/":
            return (u(r[0]) ? this.toEntity(r[0]) : "(" + this.toExpression(r[0]) + ")") + " " + t + " " + (u(r[1]) ? this.toEntity(r[1]) : "(" + this.toExpression(r[1]) + ")");
          case "!":
            return "!(" + this.toExpression(r[0]) + ")";
          case "notin":
            t = "NOT IN";
          case "in":
            return this.toExpression(r[0]) + " " + t + "(" + (o(r[1]) ? r[1] : l(r[1], ", ", this.toExpression, this)) + ")";
          case "notexists":
            t = "NOT EXISTS";
          case "exists":
            return t + " " + this.group(r[0], !0);
          default:
            return t + "(" + l(r, ", ", this.toExpression, this) + ")"
        }
      default:
        throw new Error("Unknown expression type: " + e.type)
    }
  }, r.prototype.toEntity = function(e) {
    if (u(e)) switch (e.termType) {
      case "Wildcard":
        return "*";
      case "Variable":
        return s(e);
      case "BlankNode":
        return "_:" + e.value;
      case "Literal":
        var t = e.value || "",
          r = e.language || "",
          a = e.datatype;
        if (e = '"' + t.replace(n, i) + '"', r) e += "@" + r;
        else if (a) {
          if ("http://www.w3.org/2001/XMLSchema#integer" === a.value && /^\d+$/.test(t)) return t + " ";
          if ("http://www.w3.org/2001/XMLSchema#string" === a.value) return e;
          e += "^^" + this.encodeIRI(a.value)
        }
        return e;
      case "Quad":
        if (!this._sparqlStar) throw new Error("SPARQL* support is not enabled");
        return e.graph && "DefaultGraph" !== e.graph.termType ? "<< GRAPH " + this.toEntity(e.graph) + " { " + this.toEntity(e.subject) + " " + this.toEntity(e.predicate) + " " + this.toEntity(e.object) + " }  >>" : "<< " + this.toEntity(e.subject) + " " + this.toEntity(e.predicate) + " " + this.toEntity(e.object) + " >>";
      default:
        return this.encodeIRI(e.value)
    } else {
      var o = e.items.map(this.toEntity, this),
        c = e.pathType;
      switch (c) {
        case "^":
        case "!":
          return c + o[0];
        case "*":
        case "+":
        case "?":
          return "(" + o[0] + c + ")";
        default:
          return "(" + o.join(c) + ")"
      }
    }
  };
  var n = /["\\\t\n\r\b\f]/g,
    i = function(e) {
      return a[e]
    },
    a = {
      "\\": "\\\\",
      '"': '\\"',
      "\t": "\\t",
      "\n": "\\n",
      "\r": "\\r",
      "\b": "\\b",
      "\f": "\\f"
    };

  function s(e) {
    return "?" + e.value
  }

  function o(e) {
    return "string" == typeof e
  }

  function u(e) {
    return "string" == typeof e.termType
  }

  function c(e, t) {
    if (!e || !u(e)) return !1;
    if (!t || !u(t)) return !1;
    if (e.termType !== t.termType) return !1;
    switch (e.termType) {
      case "Literal":
        return e.value === t.value && e.language === t.language && c(e.datatype, t.datatype);
      case "Quad":
        return c(e.subject, t.subject) && c(e.predicate, t.predicate) && c(e.object, t.object) && c(e.graph, t.graph);
      default:
        return e.value === t.value
    }
  }

  function l(e, t, r, n) {
    return e.map(r, n).join(o(t) ? t : " ")
  }
  r.prototype.encodeIRI = function(e) {
    var t = this._prefixRegex.exec(e);
    if (t) {
      var r = this._prefixByIri[t[1]];
      return this._usedPrefixes[r] = !0, r + ":" + t[2]
    }
    return "<" + e + ">"
  }, r.prototype.toUpdate = function(e) {
    switch (e.type || e.updateType) {
      case "load":
        return "LOAD" + (e.source ? " " + this.toEntity(e.source) : "") + (e.destination ? " INTO GRAPH " + this.toEntity(e.destination) : "");
      case "insert":
        return "INSERT DATA " + this.group(e.insert, !0);
      case "delete":
        return "DELETE DATA " + this.group(e.delete, !0);
      case "deletewhere":
        return "DELETE WHERE " + this.group(e.delete, !0);
      case "insertdelete":
        return (e.graph ? "WITH " + this.toEntity(e.graph) + this._newline : "") + (e.delete.length ? "DELETE " + this.group(e.delete, !0) + this._newline : "") + (e.insert.length ? "INSERT " + this.group(e.insert, !0) + this._newline : "") + (e.using ? this.graphs("USING ", e.using.default) : "") + (e.using ? this.graphs("USING NAMED ", e.using.named) : "") + "WHERE " + this.group(e.where, !0);
      case "add":
      case "copy":
      case "move":
        return e.type.toUpperCase() + (e.source.default ? " DEFAULT " : " ") + "TO " + this.toEntity(e.destination.name);
      case "create":
      case "clear":
      case "drop":
        return e.type.toUpperCase() + (e.silent ? " SILENT " : " ") + (e.graph.default ? "DEFAULT" : e.graph.named ? "NAMED" : e.graph.all ? "ALL" : "GRAPH " + this.toEntity(e.graph.name));
      default:
        throw new Error("Unknown update query type: " + e.type)
    }
  }, r.prototype.indent = function(e) {
    return e.replace(/^/gm, this._indent)
  }, e.exports = function(e = {}) {
    return {
      stringify: function(t) {
        var n = Object.create(e);
        return n.prefixes = t.prefixes, new r(n).toQuery(t)
      },
      createGenerator: function() {
        return new r(e)
      }
    }
  }
}, function(e, t, r) {
  "use strict";
  e.exports = function e(t, r) {
    if (t === r) return !0;
    if (t && r && "object" == typeof t && "object" == typeof r) {
      if (t.constructor !== r.constructor) return !1;
      var n, i, a;
      if (Array.isArray(t)) {
        if ((n = t.length) != r.length) return !1;
        for (i = n; 0 != i--;)
          if (!e(t[i], r[i])) return !1;
        return !0
      }
      if (t.constructor === RegExp) return t.source === r.source && t.flags === r.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === r.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === r.toString();
      if ((n = (a = Object.keys(t)).length) !== Object.keys(r).length) return !1;
      for (i = n; 0 != i--;)
        if (!Object.prototype.hasOwnProperty.call(r, a[i])) return !1;
      for (i = n; 0 != i--;) {
        var s = a[i];
        if (!e(t[s], r[s])) return !1
      }
      return !0
    }
    return t != t && r != r
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.toSparqlJs = t.toSparql = void 0;
  const n = r(52),
    i = r(53),
    a = r(70),
    s = r(4),
    o = r(30).Generator,
    u = r(30).Wildcard,
    c = n.types,
    l = n.expressionTypes;
  let h;
  const d = new i.default;

  function p(e) {
    f();
    let t = g(e = function(e) {
      return O(e, {})
    }(e));
    return "group" === t.type ? t.patterns[0] : t
  }

  function f() {
    h = {
      project: !1,
      extend: [],
      group: [],
      aggregates: [],
      order: []
    }
  }

  function g(e) {
    switch (e.type !== c.EXTEND && e.type !== c.ORDER_BY && e.type !== c.GRAPH && (h.project = !1), e.type) {
      case c.EXPRESSION:
        return m(e);
      case c.ASK:
        return S(e, c.ASK);
      case c.BGP:
        return function(e) {
          let t = e.patterns.map(v);
          return 0 === t.length ? null : {
            type: "bgp",
            triples: t
          }
        }(e);
      case c.CONSTRUCT:
        return function(e) {
          return {
            type: "query",
            prefixes: {},
            queryType: "CONSTRUCT",
            template: e.template.map(v),
            where: a.default.flatten([g(e.input)])
          }
        }(e);
      case c.DESCRIBE:
        return S(e, c.DESCRIBE);
      case c.DISTINCT:
        return function(e) {
          let t = g(e.input);
          return t.patterns[0].distinct = !0, t
        }(e);
      case c.EXTEND:
        return function(e) {
          if (h.project) return h.extend.push(e), g(e.input);
          return a.default.flatten([g(e.input), {
            type: "bind",
            variable: e.variable,
            expression: m(e.expression)
          }])
        }(e);
      case c.FROM:
        return function(e) {
          let t = g(e.input);
          return t.patterns[0].from = {
            default: e.default,
            named: e.named
          }, t
        }(e);
      case c.FILTER:
        return function(e) {
          return {
            type: "group",
            patterns: a.default.flatten([g(e.input), {
              type: "filter",
              expression: m(e.expression)
            }])
          }
        }(e);
      case c.GRAPH:
        return function(e) {
          return {
            type: "graph",
            patterns: a.default.flatten([g(e.input)]),
            name: e.name
          }
        }(e);
      case c.GROUP:
        return function(e) {
          let t = g(e.input),
            r = e.aggregates.map(_);
          return h.aggregates.push(...r), h.group.push(...e.variables), t
        }(e);
      case c.JOIN:
        return function(e) {
          return a.default.flatten([g(e.left), g(e.right)])
        }(e);
      case c.LEFT_JOIN:
        return function(e) {
          let t = {
            type: "optional",
            patterns: [g(e.right)]
          };
          e.expression && t.patterns.push({
            type: "filter",
            expression: m(e.expression)
          });
          return t.patterns = a.default.flatten(t.patterns), a.default.flatten([g(e.left), t])
        }(e);
      case c.MINUS:
        return function(e) {
          let t = g(e.right);
          "group" === t.type && (t = t.patterns);
          return a.default.flatten([g(e.left), {
            type: "minus",
            patterns: t
          }])
        }(e);
      case c.ORDER_BY:
        return function(e) {
          return h.order.push(...e.expressions), g(e.input)
        }(e);
      case c.PATH:
        return function(e) {
          return {
            type: "bgp",
            triples: [{
              subject: e.subject,
              predicate: y(e.predicate),
              object: e.object
            }]
          }
        }(e);
      case c.PATTERN:
        return v(e);
      case c.PROJECT:
        return S(e, c.PROJECT);
      case c.REDUCED:
        return function(e) {
          let t = g(e.input);
          return t.patterns[0].reduced = !0, t
        }(e);
      case c.SERVICE:
        return function(e) {
          let t = g(e.input);
          "group" === t.type && (t = t.patterns);
          Array.isArray(t) || (t = [t]);
          return {
            type: "service",
            name: e.name,
            silent: e.silent,
            patterns: t
          }
        }(e);
      case c.SLICE:
        return function(e) {
          let t = g(e.input),
            r = t;
          t.type && "group" === t.type && (r = t.patterns[0]);
          0 !== e.start && (r.offset = e.start);
          void 0 !== e.length && (r.limit = e.length);
          return t
        }(e);
      case c.UNION:
        return function(e) {
          return {
            type: "union",
            patterns: a.default.flatten([g(e.left), g(e.right)])
          }
        }(e);
      case c.VALUES:
        return function(e) {
          return {
            type: "values",
            values: e.bindings.map(t => {
              let r = {};
              for (let n of e.variables) {
                let e = "?" + n.value;
                t[e] ? r[e] = t[e] : r[e] = void 0
              }
              return r
            })
          }
        }(e);
      case c.COMPOSITE_UPDATE:
        return function(e) {
          return {
            prefixes: {},
            type: "update",
            updates: e.updates.map(e => g(e).updates[0])
          }
        }(e);
      case c.DELETE_INSERT:
        return function(e) {
          let t = e.where,
            r = void 0;
          if (t && t.type === c.FROM) {
            let n = e.where;
            t = n.input, r = {
              default: n.default,
              named: n.named
            }
          }
          const n = [{
            updateType: "insertdelete",
            delete: x(e.delete),
            insert: x(e.insert)
          }];
          r && (n[0].using = r);
          if (!t || t.type === c.BGP && 0 === t.patterns.length) n[0].where = [];
          else {
            const e = {};
            let r = g(O(t, e));
            "group" === r.type ? n[0].where = r.patterns : n[0].where = [r];
            const i = Object.keys(e);
            if (i.length > 0) {
              if (1 !== i.length) throw new Error("This is unexpected and might indicate an error in graph handling for updates.");
              "" !== e[i[0]].graph.value && (n[0].where = [{
                type: "graph",
                patterns: n[0].where,
                name: e[i[0]].graph
              }])
            }
          }
          e.delete || e.where ? e.insert || e.where || (delete n[0].insert, delete n[0].where, e.delete.some(e => "Variable" === e.subject.termType || "Variable" === e.predicate.termType || "Variable" === e.object.termType) ? n[0].updateType = "deletewhere" : n[0].updateType = "delete") : (n[0].updateType = "insert", delete n[0].delete, delete n[0].where);
          return {
            prefixes: {},
            type: "update",
            updates: n
          }
        }(e);
      case c.LOAD:
        return function(e) {
          const t = [{
            type: "load",
            silent: Boolean(e.silent),
            source: e.source
          }];
          e.destination && (t[0].destination = e.destination);
          return {
            prefixes: {},
            type: "update",
            updates: t
          }
        }(e);
      case c.CLEAR:
        return function(e) {
          return T(e, "clear")
        }(e);
      case c.CREATE:
        return function(e) {
          return T(e, "create")
        }(e);
      case c.DROP:
        return function(e) {
          return T(e, "drop")
        }(e);
      case c.ADD:
        return function(e) {
          return E(e, "add")
        }(e);
      case c.MOVE:
        return function(e) {
          return E(e, "move")
        }(e);
      case c.COPY:
        return function(e) {
          return E(e, "copy")
        }(e)
    }
    throw new Error("Unknown Operation type " + e.type)
  }

  function m(e) {
    switch (e.expressionType) {
      case l.AGGREGATE:
        return function(e) {
          let t = {
            expression: m(e.expression),
            type: "aggregate",
            aggregation: e.aggregator,
            distinct: e.distinct
          };
          e.separator && (t.separator = e.separator);
          return t
        }(e);
      case l.EXISTENCE:
        return function(e) {
          return {
            type: "operation",
            operator: e.not ? "notexists" : "exists",
            args: a.default.flatten([g(e.input)])
          }
        }(e);
      case l.NAMED:
        return function(e) {
          return {
            type: "functionCall",
            function: e.name,
            args: e.args.map(m)
          }
        }(e);
      case l.OPERATOR:
        return function(e) {
          if ("desc" === e.operator) {
            let t = {
              expression: m(e.args[0]),
              descending: !0
            };
            return t
          }
          let t = {
            type: "operation",
            operator: e.operator,
            args: e.args.map(m)
          };
          "in" !== t.operator && "notin" !== t.operator || (t.args = [t.args[0]].concat([t.args.slice(1)]));
          return t
        }(e);
      case l.TERM:
        return function(e) {
          return e.term
        }(e);
      case l.WILDCARD:
        return function(e) {
          return e.wildcard
        }(e)
    }
    throw new Error("Unknown Expression Operation type " + e.expressionType)
  }

  function y(e) {
    switch (e.type) {
      case c.ALT:
        return function(e) {
          let t = y(e.left),
            r = y(e.right);
          if ("!" === t.pathType && "!" === r.pathType) return {
            type: "path",
            pathType: "!",
            items: [{
              type: "path",
              pathType: "|",
              items: [].concat(t.items, r.items)
            }]
          };
          return {
            type: "path",
            pathType: "|",
            items: [t, r]
          }
        }(e);
      case c.INV:
        return function(e) {
          if (e.path.type === c.NPS) {
            let t = e.path.iris.map(e => ({
              type: "path",
              pathType: "^",
              items: [e]
            }));
            return t.length <= 1 ? {
              type: "path",
              pathType: "!",
              items: t
            } : {
              type: "path",
              pathType: "!",
              items: [{
                type: "path",
                pathType: "|",
                items: t
              }]
            }
          }
          return {
            type: "path",
            pathType: "^",
            items: [y(e.path)]
          }
        }(e);
      case c.LINK:
        return function(e) {
          return e.iri
        }(e);
      case c.NPS:
        return function(e) {
          return e.iris.length <= 1 ? {
            type: "path",
            pathType: "!",
            items: e.iris
          } : {
            type: "path",
            pathType: "!",
            items: [{
              type: "path",
              pathType: "|",
              items: e.iris
            }]
          }
        }(e);
      case c.ONE_OR_MORE_PATH:
        return function(e) {
          return {
            type: "path",
            pathType: "+",
            items: [y(e.path)]
          }
        }(e);
      case c.SEQ:
        return function(e) {
          return {
            type: "path",
            pathType: "/",
            items: [y(e.left), y(e.right)]
          }
        }(e);
      case c.ZERO_OR_MORE_PATH:
        return function(e) {
          return {
            type: "path",
            pathType: "*",
            items: [y(e.path)]
          }
        }(e);
      case c.ZERO_OR_ONE_PATH:
        return function(e) {
          return {
            type: "path",
            pathType: "?",
            items: [y(e.path)]
          }
        }(e)
    }
    throw new Error("Unknown Path type " + e.type)
  }

  function b(e) {
    return s.termToString(e)
  }

  function _(e) {
    return e
  }

  function v(e) {
    return {
      subject: e.subject,
      predicate: e.predicate,
      object: e.object
    }
  }

  function w(e, t) {
    let r = a.default.isTerm(e) ? b(e) : e;
    if ("string" == typeof r) {
      if (t[r]) return t[r]
    } else if (Array.isArray(e)) e = e.map(e => w(e, t));
    else
      for (let r of Object.keys(e)) e[r] = w(e[r], t);
    return e
  }

  function S(e, t) {
    let r = {
      type: "query",
      prefixes: {}
    };
    t === c.PROJECT ? (r.queryType = "SELECT", r.variables = e.variables) : t === c.ASK ? r.queryType = "ASK" : t === c.DESCRIBE && (r.queryType = "DESCRIBE", r.variables = e.terms);
    let n = h.extend,
      i = h.group,
      s = h.aggregates,
      o = h.order;
    f(), h.project = !0;
    let l = a.default.flatten([g(e.input)]);
    1 === l.length && "group" === l[0].type && (l = l[0].patterns), r.where = l;
    let d = {};
    for (let e of h.aggregates) d[b(e.variable)] = m(e);
    let p = {};
    for (let e = h.extend.length - 1; e >= 0; --e) {
      let t = h.extend[e];
      p[b(t.variable)] = w(m(t.expression), d)
    }
    if (h.group.length > 0 && (r.group = h.group.map(e => {
      let t = b(e);
      if (p[t]) {
        let r = p[t];
        return delete p[t], {
          variable: e,
          expression: r
        }
      }
      return {
        expression: e
      }
    })), h.order.length > 0 && (r.order = h.order.map(g).map(e => e.descending ? e : {
      expression: e
    })), r.variables && (r.variables = r.variables.map(e => {
      let t = b(e);
      return p[t] ? {
        variable: e,
        expression: p[t]
      } : e
    }), 0 === r.variables.length && (r.variables = [new u])), r.where.length > 0 && "filter" === r.where[r.where.length - 1].type) {
      let e = r.where[r.where.length - 1];
      (function e(t, r) {
        return a.default.isTerm(t) ? r.indexOf(b(t)) >= 0 : Array.isArray(t) ? t.some(t => e(t, r)) : t === Object(t) ? Object.keys(t).some(n => e(t[n], r)) : r.indexOf(t) >= 0
      })(e, Object.keys(d)) && (r.having = a.default.flatten([w(e.expression, d)]), r.where.splice(-1))
    }
    return h.extend = n, h.group = i, h.aggregates = s, h.order = o, r = {
      type: "group",
      patterns: [r]
    }, r
  }

  function T(e, t) {
    const r = [{
      type: t,
      silent: Boolean(e.silent)
    }];
    return "DEFAULT" === e.source ? r[0].graph = {
      default: !0
    } : "NAMED" === e.source ? r[0].graph = {
      named: !0
    } : "ALL" === e.source ? r[0].graph = {
      all: !0
    } : r[0].graph = {
      type: "graph",
      name: e.source
    }, {
      prefixes: {},
      type: "update",
      updates: r
    }
  }

  function E(e, t) {
    const r = [{
      type: t,
      silent: Boolean(e.silent)
    }];
    return r[0].source = "DEFAULT" === e.source ? {
      type: "graph",
      default: !0
    } : {
      type: "graph",
      name: e.source
    }, r[0].destination = "DEFAULT" === e.destination ? {
      type: "graph",
      default: !0
    } : {
      type: "graph",
      name: e.destination
    }, {
      prefixes: {},
      type: "update",
      updates: r
    }
  }

  function x(e) {
    if (!e) return [];
    const t = {};
    return e.forEach(e => {
      const r = e.graph.value;
      t[r] || (t[r] = []), t[r].push(e)
    }), Object.keys(t).map(e => "" === e ? {
      type: "bgp",
      triples: t[e].map(v)
    } : {
      type: "graph",
      triples: t[e].map(v),
      name: t[e][0].graph
    })
  }

  function O(e, t) {
    if (Array.isArray(e)) return e.map(e => O(e, t));
    if (!e.type) return e;
    if (e.type === c.DELETE_INSERT) return e;
    if ((e.type === c.PATTERN || e.type === c.PATH) && e.graph) return t[e.graph.value] || (t[e.graph.value] = {
      graph: e.graph,
      values: []
    }), t[e.graph.value].values.push(e), e;
    const r = {},
      n = {},
      i = {};
    for (let t of Object.keys(e)) {
      const a = {};
      r[t] = O(e[t], a);
      const s = Object.keys(a);
      if (s.length > 1) {
        let e = A(a[s[0]].values);
        for (let t = 1; t < s.length; ++t) {
          const r = A(a[s[t]].values);
          e = d.createJoin(e, r)
        }
        return s.map(e => delete a[e]), e
      }
      if (1 === s.length) {
        const e = a[s[0]].graph;
        n[t] = e, i[e.value] = e
      }
    }
    const a = Object.keys(i);
    if (a.length > 0)
      if (1 === a.length && e.type !== c.PROJECT) t[a[0]] = {
        graph: i[a[0]],
        values: [r]
      };
      else
        for (let e of Object.keys(n)) n[e].value.length > 0 && (r[e] = d.createGraph(r[e], n[e]));
    return r
  }

  function A(e) {
    const t = d.createBgp(e),
      r = e[0].graph;
    return 0 === r.value.length ? t : d.createGraph(t, r)
  }
  t.toSparql = function(e, t = {}) {
    return new o(t).stringify(p(e))
  }, t.toSparqlJs = p
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationTypedMediated = void 0;
  const n = r(111);
  class i extends n.ActorQueryOperationTyped {
    constructor(e, t) {
      super(e, t)
    }
  }
  t.ActorQueryOperationTypedMediated = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfResolveQuadPatternSource = void 0;
  const n = r(112);
  class i extends n.ActorRdfResolveQuadPattern {
    constructor(e) {
      super(e)
    }
    async test(e) {
      return !0
    }
    async run(e) {
      const t = await this.getSource(e.context, e.pattern);
      return await this.getOutput(t, e.pattern, e.context)
    }
    async getOutput(e, t, r) {
      return {
        data: e.match(t.subject, t.predicate, t.object, t.graph)
      }
    }
  }
  t.ActorRdfResolveQuadPatternSource = i
}, function(e, t) {}, function(e, t, r) {
  "use strict";
  var n = r(72).Buffer,
    i = r(221);
  e.exports = function() {
    function e() {
      ! function(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
      }(this, e), this.head = null, this.tail = null, this.length = 0
    }
    return e.prototype.push = function(e) {
      var t = {
        data: e,
        next: null
      };
      this.length > 0 ? this.tail.next = t : this.head = t, this.tail = t, ++this.length
    }, e.prototype.unshift = function(e) {
      var t = {
        data: e,
        next: this.head
      };
      0 === this.length && (this.tail = t), this.head = t, ++this.length
    }, e.prototype.shift = function() {
      if (0 !== this.length) {
        var e = this.head.data;
        return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, e
      }
    }, e.prototype.clear = function() {
      this.head = this.tail = null, this.length = 0
    }, e.prototype.join = function(e) {
      if (0 === this.length) return "";
      for (var t = this.head, r = "" + t.data; t = t.next;) r += e + t.data;
      return r
    }, e.prototype.concat = function(e) {
      if (0 === this.length) return n.alloc(0);
      if (1 === this.length) return this.head.data;
      for (var t, r, i, a = n.allocUnsafe(e >>> 0), s = this.head, o = 0; s;) t = s.data, r = a, i = o, t.copy(r, i), o += s.data.length, s = s.next;
      return a
    }, e
  }(), i && i.inspect && i.inspect.custom && (e.exports.prototype[i.inspect.custom] = function() {
    var e = i.inspect({
      length: this.length
    });
    return this.constructor.name + " " + e
  })
}, function(e, t) {}, function(e, t, r) {
  (function(e, t) {
    ! function(e, r) {
      "use strict";
      if (!e.setImmediate) {
        var n, i, a, s, o, u = 1,
          c = {},
          l = !1,
          h = e.document,
          d = Object.getPrototypeOf && Object.getPrototypeOf(e);
        d = d && d.setTimeout ? d : e, "[object process]" === {}.toString.call(e.process) ? n = function(e) {
          t.nextTick((function() {
            f(e)
          }))
        } : ! function() {
          if (e.postMessage && !e.importScripts) {
            var t = !0,
              r = e.onmessage;
            return e.onmessage = function() {
              t = !1
            }, e.postMessage("", "*"), e.onmessage = r, t
          }
        }() ? e.MessageChannel ? ((a = new MessageChannel).port1.onmessage = function(e) {
          f(e.data)
        }, n = function(e) {
          a.port2.postMessage(e)
        }) : h && "onreadystatechange" in h.createElement("script") ? (i = h.documentElement, n = function(e) {
          var t = h.createElement("script");
          t.onreadystatechange = function() {
            f(e), t.onreadystatechange = null, i.removeChild(t), t = null
          }, i.appendChild(t)
        }) : n = function(e) {
          setTimeout(f, 0, e)
        } : (s = "setImmediate$" + Math.random() + "$", o = function(t) {
          t.source === e && "string" == typeof t.data && 0 === t.data.indexOf(s) && f(+t.data.slice(s.length))
        }, e.addEventListener ? e.addEventListener("message", o, !1) : e.attachEvent("onmessage", o), n = function(t) {
          e.postMessage(s + t, "*")
        }), d.setImmediate = function(e) {
          "function" != typeof e && (e = new Function("" + e));
          for (var t = new Array(arguments.length - 1), r = 0; r < t.length; r++) t[r] = arguments[r + 1];
          var i = {
            callback: e,
            args: t
          };
          return c[u] = i, n(u), u++
        }, d.clearImmediate = p
      }

      function p(e) {
        delete c[e]
      }

      function f(e) {
        if (l) setTimeout(f, 0, e);
        else {
          var t = c[e];
          if (t) {
            l = !0;
            try {
              ! function(e) {
                var t = e.callback,
                  r = e.args;
                switch (r.length) {
                  case 0:
                    t();
                    break;
                  case 1:
                    t(r[0]);
                    break;
                  case 2:
                    t(r[0], r[1]);
                    break;
                  case 3:
                    t(r[0], r[1], r[2]);
                    break;
                  default:
                    t.apply(void 0, r)
                }
              }(t)
            } finally {
              p(e), l = !1
            }
          }
        }
      }
    }("undefined" == typeof self ? void 0 === e ? this : e : self)
  }).call(this, r(10), r(8))
}, function(e, t, r) {
  "use strict";
  e.exports = a;
  var n = r(118),
    i = Object.create(r(43));

  function a(e) {
    if (!(this instanceof a)) return new a(e);
    n.call(this, e)
  }
  i.inherits = r(12), i.inherits(a, n), a.prototype._transform = function(e, t, r) {
    r(null, e)
  }
}, function(e, t, r) {
  e.exports = r(73)
}, function(e, t, r) {
  e.exports = r(25)
}, function(e, t, r) {
  e.exports = r(71).Transform
}, function(e, t, r) {
  e.exports = r(71).PassThrough
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorSparqlSerialize = void 0;
  const n = r(34);
  class i extends n.ActorAbstractMediaTyped {
    constructor(e) {
      super(e)
    }
  }
  t.ActorSparqlSerialize = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorAbstractMediaTypedFixed = void 0;
  const n = r(119);
  class i extends n.ActorAbstractMediaTyped {
    constructor(e) {
      super(e);
      const t = this.priorityScale || 0 === this.priorityScale ? this.priorityScale : 1;
      this.mediaTypes && Object.entries(this.mediaTypes).forEach(([e, r], n) => {
        this.mediaTypes[e] = t * r
      }), this.mediaTypes = Object.freeze(this.mediaTypes), this.mediaTypeFormats = Object.freeze(this.mediaTypeFormats)
    }
    async testHandle(e, t, r) {
      if (!(t in this.mediaTypes)) throw new Error("Unrecognized media type: " + t);
      return await this.testHandleChecked(e, r)
    }
    async testMediaType(e) {
      return !0
    }
    async getMediaTypes(e) {
      return this.mediaTypes
    }
    async testMediaTypeFormats(e) {
      return !0
    }
    async getMediaTypeFormats(e) {
      return this.mediaTypeFormats
    }
  }
  t.ActorAbstractMediaTypedFixed = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorSparqlSerializeFixedMediaTypes = void 0;
  const n = r(34);
  class i extends n.ActorAbstractMediaTypedFixed {
    constructor(e) {
      super(e)
    }
    async testHandleChecked(e, t) {
      return !0
    }
  }
  t.ActorSparqlSerializeFixedMediaTypes = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Converter = void 0;
  const n = r(232),
    i = r(74);
  class a {
    constructor(e) {
      (e = e || {
        delimiter: "_"
      }).prefixVariableQuestionMark = !1, this.delimiter = e.delimiter || "_", this.parser = new i.SparqlJsonParser(e), this.materializeRdfJsTerms = e.materializeRdfJsTerms
    }
    static addValueToTree(e, t, r, n, i, s) {
      const o = t[0],
        u = n ? n + s + o : o,
        c = i.singularizeVariables[u];
      if (1 === t.length) c ? e[o] || (e[o] = r) : (e[o] || (e[o] = []), e[o].push(r));
      else {
        let n;
        c ? (e[o] || (e[o] = {}), n = e[o]) : (e[o] || (e[o] = [{}]), n = e[o][0]), a.addValueToTree(n, t.slice(1), r, u, i, s)
      }
    }
    static mergeTrees(e, t) {
      if (typeof e != typeof t) throw new Error(`Two incompatible tree nodes were found: ${typeof e} and ${typeof t}`);
      if (Array.isArray(e) !== Array.isArray(t)) throw new Error(`Two incompatible tree nodes were found: Array?${Array.isArray(e)} and Array?${Array.isArray(t)}`);
      if ("object" == typeof e && "object" == typeof t) {
        if (e.termType && t.termType) return e.equals(t) ? {
          valid: !0,
          result: e
        } : {
          valid: !1,
          result: e
        };
        if (Array.isArray(e) && Array.isArray(t)) {
          if (e.length > 0) {
            const r = [];
            let n = !1;
            for (const i of e) {
              const e = a.mergeTrees(i, t[0]);
              e.valid ? (n = !0, r.push(e.result)) : r.push(i)
            }
            if (n) return {
              valid: !0,
              result: r
            }
          }
          return {
            valid: !0,
            result: e.concat(t)
          }
        } {
          const r = {};
          for (const e in t) r[e] = t[e];
          for (const t in e)
            if (r[t]) {
              const n = a.mergeTrees(e[t], r[t]);
              if (!n.valid) return {
                valid: !1,
                result: e
              };
              r[t] = n.result
            } else r[t] = e[t];
          return {
            valid: !0,
            result: r
          }
        }
      }
      throw new Error(`Unmergable tree types: ${typeof e} and ${typeof t}`)
    }
    static materializeTree(e) {
      if (e.termType) return n.getTermRaw(e);
      if (Array.isArray(e)) return e.map(a.materializeTree); {
        const t = {};
        for (const r in e) t[r] = a.materializeTree(e[r]);
        return t
      }
    }
    sparqlJsonResultsToTree(e, t) {
      return this.bindingsToTree(this.parser.parseJsonResults(e), t || {
        singularizeVariables: {}
      })
    }
    bindingsToTree(e, t) {
      const r = t && t.singularizeVariables[""];
      let n = r ? {} : [];
      for (const i of e) {
        const e = r ? {} : [{}];
        for (const n in i) {
          const s = n.split(this.delimiter),
            o = i[n];
          a.addValueToTree(r ? e : e[0], s, o, "", t, this.delimiter)
        }
        n = a.mergeTrees(n, e).result
      }
      return this.materializeRdfJsTerms && (n = a.materializeTree(n)), n
    }
  }
  t.Converter = a
}, function(e, t, r) {
  "use strict";

  function n(e) {
    for (var r in e) t.hasOwnProperty(r) || (t[r] = e[r])
  }
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  const i = r(5),
    a = r(121),
    s = r(35);
  n(r(121)), n(r(35));
  const o = new i.DataFactory,
    u = new s.Translator;

  function c(e, t) {
    return u.fromRdf(e, t)
  }
  u.registerHandler(new a.TypeHandlerString, a.TypeHandlerString.TYPES.map(e => o.namedNode(e)), ["string"]), u.registerHandler(new a.TypeHandlerBoolean, [a.TypeHandlerBoolean.TYPE].map(e => o.namedNode(e)), ["boolean"]), u.registerHandler(new a.TypeHandlerNumberDouble, a.TypeHandlerNumberDouble.TYPES.map(e => o.namedNode(e)), ["number"]), u.registerHandler(new a.TypeHandlerNumberInteger, a.TypeHandlerNumberInteger.TYPES.map(e => o.namedNode(e)), ["number"]), u.registerHandler(new a.TypeHandlerDate, a.TypeHandlerDate.TYPES.map(e => o.namedNode(e)), ["object"]), t.fromRdf = c, t.toRdf = function(e, t) {
    return t && "namedNode" in t && (t = {
      dataFactory: t
    }), (t = t || {}) && !t.dataFactory && (t.dataFactory = o), u.toRdf(e, t)
  }, t.getTermRaw = function(e, t) {
    return "Literal" === e.termType ? c(e, t) : e.value
  }, t.getSupportedRdfDatatypes = function() {
    return u.getSupportedRdfDatatypes()
  }, t.getSupportedJavaScriptPrimitives = function() {
    return u.getSupportedJavaScriptPrimitives()
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  const n = r(35);
  class i {
    fromRdf(e, t) {
      switch (e.value) {
        case "true":
          return !0;
        case "false":
          return !1;
        case "1":
          return !0;
        case "0":
          return !1
      }
      return t && n.Translator.incorrectRdfDataType(e), !1
    }
    toRdf(e, {
      datatype: t,
      dataFactory: r
    }) {
      return r.literal(e ? "true" : "false", t || r.namedNode(i.TYPE))
    }
  }
  t.TypeHandlerBoolean = i, i.TYPE = "http://www.w3.org/2001/XMLSchema#boolean"
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  const n = r(35);
  class i {
    fromRdf(e, t) {
      switch (t && !e.value.match(i.VALIDATORS[e.datatype.value.substr(33, e.datatype.value.length)]) && n.Translator.incorrectRdfDataType(e), e.datatype.value) {
        case "http://www.w3.org/2001/XMLSchema#gDay":
          return new Date(0, 0, parseInt(e.value, 10));
        case "http://www.w3.org/2001/XMLSchema#gMonthDay":
          const t = e.value.split("-");
          return new Date(0, parseInt(t[0], 10) - 1, parseInt(t[1], 10));
        case "http://www.w3.org/2001/XMLSchema#gYear":
          return new Date(e.value + "-01-01");
        case "http://www.w3.org/2001/XMLSchema#gYearMonth":
          return new Date(e.value + "-01");
        default:
          return new Date(e.value)
      }
    }
    toRdf(e, {
      datatype: t,
      dataFactory: r
    }) {
      if (t = t || r.namedNode(i.TYPES[0]), !(e instanceof Date)) return null;
      const n = e;
      let a;
      switch (t.value) {
        case "http://www.w3.org/2001/XMLSchema#gDay":
          a = String(n.getUTCDate());
          break;
        case "http://www.w3.org/2001/XMLSchema#gMonthDay":
          a = n.getUTCMonth() + 1 + "-" + n.getUTCDate();
          break;
        case "http://www.w3.org/2001/XMLSchema#gYear":
          a = String(n.getUTCFullYear());
          break;
        case "http://www.w3.org/2001/XMLSchema#gYearMonth":
          a = n.getUTCFullYear() + "-" + (n.getUTCMonth() + 1);
          break;
        case "http://www.w3.org/2001/XMLSchema#date":
          a = n.toISOString().replace(/T.*$/, "");
          break;
        default:
          a = n.toISOString()
      }
      return r.literal(a, t)
    }
  }
  t.TypeHandlerDate = i, i.TYPES = ["http://www.w3.org/2001/XMLSchema#dateTime", "http://www.w3.org/2001/XMLSchema#date", "http://www.w3.org/2001/XMLSchema#gDay", "http://www.w3.org/2001/XMLSchema#gMonthDay", "http://www.w3.org/2001/XMLSchema#gYear", "http://www.w3.org/2001/XMLSchema#gYearMonth"], i.VALIDATORS = {
    date: /^[0-9]+-[0-9][0-9]-[0-9][0-9]Z?$/,
    dateTime: /^[0-9]+-[0-9][0-9]-[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9](\.[0-9][0-9][0-9])?((Z?)|([\+-][0-9][0-9]:[0-9][0-9]))$/,
    gDay: /^[0-9]+$/,
    gMonthDay: /^[0-9]+-[0-9][0-9]$/,
    gYear: /^[0-9]+$/,
    gYearMonth: /^[0-9]+-[0-9][0-9]$/
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  const n = r(35);
  class i {
    fromRdf(e, t) {
      const r = parseFloat(e.value);
      return t && isNaN(r) && n.Translator.incorrectRdfDataType(e), r
    }
    toRdf(e, {
      datatype: t,
      dataFactory: r
    }) {
      return t = t || r.namedNode(i.TYPES[0]), isNaN(e) ? r.literal("NaN", t) : isFinite(e) ? e % 1 == 0 ? null : r.literal(e.toExponential(15).replace(/(\d)0*e\+?/, "$1E"), t) : r.literal(e > 0 ? "INF" : "-INF", t)
    }
  }
  t.TypeHandlerNumberDouble = i, i.TYPES = ["http://www.w3.org/2001/XMLSchema#double", "http://www.w3.org/2001/XMLSchema#decimal", "http://www.w3.org/2001/XMLSchema#float"]
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  const n = r(35);
  class i {
    fromRdf(e, t) {
      const r = parseInt(e.value, 10);
      return t && (isNaN(r) || e.value.indexOf(".") >= 0) && n.Translator.incorrectRdfDataType(e), r
    }
    toRdf(e, {
      datatype: t,
      dataFactory: r
    }) {
      return r.literal(String(e), t || (e <= i.MAX_INT && e >= i.MIN_INT ? r.namedNode(i.TYPES[0]) : r.namedNode(i.TYPES[1])))
    }
  }
  t.TypeHandlerNumberInteger = i, i.TYPES = ["http://www.w3.org/2001/XMLSchema#integer", "http://www.w3.org/2001/XMLSchema#long", "http://www.w3.org/2001/XMLSchema#int", "http://www.w3.org/2001/XMLSchema#byte", "http://www.w3.org/2001/XMLSchema#short", "http://www.w3.org/2001/XMLSchema#negativeInteger", "http://www.w3.org/2001/XMLSchema#nonNegativeInteger", "http://www.w3.org/2001/XMLSchema#nonPositiveInteger", "http://www.w3.org/2001/XMLSchema#positiveInteger", "http://www.w3.org/2001/XMLSchema#unsignedByte", "http://www.w3.org/2001/XMLSchema#unsignedInt", "http://www.w3.org/2001/XMLSchema#unsignedLong", "http://www.w3.org/2001/XMLSchema#unsignedShort"], i.MAX_INT = 2147483647, i.MIN_INT = -2147483648
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  class n {
    fromRdf(e) {
      return e.value
    }
    toRdf(e, {
      datatype: t,
      dataFactory: r
    }) {
      return r.literal(e, t)
    }
  }
  t.TypeHandlerString = n, n.TYPES = ["http://www.w3.org/2001/XMLSchema#string", "http://www.w3.org/2001/XMLSchema#normalizedString", "http://www.w3.org/2001/XMLSchema#anyURI", "http://www.w3.org/2001/XMLSchema#base64Binary", "http://www.w3.org/2001/XMLSchema#language", "http://www.w3.org/2001/XMLSchema#Name", "http://www.w3.org/2001/XMLSchema#NCName", "http://www.w3.org/2001/XMLSchema#NMTOKEN", "http://www.w3.org/2001/XMLSchema#token", "http://www.w3.org/2001/XMLSchema#hexBinary", "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString", "http://www.w3.org/2001/XMLSchema#time", "http://www.w3.org/2001/XMLSchema#duration"]
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.SparqlJsonParser = void 0;
  const n = r(5),
    i = r(122);
  t.SparqlJsonParser = class {
    constructor(e) {
      e = e || {}, this.dataFactory = e.dataFactory || new n.DataFactory, this.prefixVariableQuestionMark = !!e.prefixVariableQuestionMark
    }
    parseJsonResults(e) {
      return e.results.bindings.map(e => this.parseJsonBindings(e))
    }
    parseJsonResultsStream(e) {
      e.on("error", e => n.emit("error", e));
      const t = [];
      e.pipe(r(75).parse("head.vars.*")).on("data", e => t.push(this.dataFactory.variable(e))).on("end", () => n.emit("variables", t));
      const n = e.pipe(r(75).parse("results.bindings.*")).pipe(new i.SparqlJsonBindingsTransformer(this));
      return n
    }
    parseJsonBindings(e) {
      const t = {};
      for (const r in e) {
        const n = e[r];
        let i = null;
        switch (n.type) {
          case "bnode":
            i = this.dataFactory.blankNode(n.value);
            break;
          case "literal":
            i = n["xml:lang"] ? this.dataFactory.literal(n.value, n["xml:lang"]) : n.datatype ? this.dataFactory.literal(n.value, this.dataFactory.namedNode(n.datatype)) : this.dataFactory.literal(n.value);
            break;
          case "typed-literal":
            i = this.dataFactory.literal(n.value, this.dataFactory.namedNode(n.datatype));
            break;
          default:
            i = this.dataFactory.namedNode(n.value)
        }
        t[this.prefixVariableQuestionMark ? "?" + r : r] = i
      }
      return t
    }
    parseJsonBoolean(e) {
      if ("boolean" in e) return e.boolean;
      throw new Error("No valid ASK response was found.")
    }
    parseJsonBooleanStream(e) {
      return new Promise((t, n) => {
        e.on("error", n), e.pipe(r(75).parse("boolean")).on("data", t).on("end", () => n(new Error("No valid ASK response was found.")))
      })
    }
  }
}, function(e, t, r) {
  (function(t) {
    var n = r(2);

    function i(e, r, i) {
      e = e || function(e) {
        this.queue(e)
      }, r = r || function() {
        this.queue(null)
      };
      var a = !1,
        s = !1,
        o = [],
        u = !1,
        c = new n;

      function l() {
        for (; o.length && !c.paused;) {
          var e = o.shift();
          if (null === e) return c.emit("end");
          c.emit("data", e)
        }
      }

      function h() {
        c.writable = !1, r.call(c), !c.readable && c.autoDestroy && c.destroy()
      }
      return c.readable = c.writable = !0, c.paused = !1, c.autoDestroy = !(i && !1 === i.autoDestroy), c.write = function(t) {
        return e.call(this, t), !c.paused
      }, c.queue = c.push = function(e) {
        return u || (null === e && (u = !0), o.push(e), l()), c
      }, c.on("end", (function() {
        c.readable = !1, !c.writable && c.autoDestroy && t.nextTick((function() {
          c.destroy()
        }))
      })), c.end = function(e) {
        if (!a) return a = !0, arguments.length && c.write(e), h(), c
      }, c.destroy = function() {
        if (!s) return s = !0, a = !0, o.length = 0, c.writable = c.readable = !1, c.emit("close"), c
      }, c.pause = function() {
        if (!c.paused) return c.paused = !0, c
      }, c.resume = function() {
        return c.paused && (c.paused = !1, c.emit("resume")), l(), c.paused || c.emit("drain"), c
      }, c
    }
    e.exports = i, i.through = i
  }).call(this, r(8))
}, function(e, t, r) {
  const n = new(r(241).LoggerVoid)({}),
    i = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-init/Bus/Init"
    }),
    a = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-http/Bus/Http"
    }),
    s = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-join/Bus/RdfJoin"
    }),
    o = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-parse/Bus/RdfParse"
    }),
    u = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-dereference/Bus/RdfDereference"
    }),
    c = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-parse-html/Bus/RdfParseHtml"
    }),
    l = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-serialize/Bus/RdfSerialize"
    }),
    h = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-resolve-quad-pattern/Bus/RdfResolveQuadPattern"
    }),
    d = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-metadata/Bus/RdfMetadata"
    }),
    p = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-metadata-extract/Bus/RdfMetadataExtract"
    }),
    f = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-resolve-hypermedia/Bus/RdfResolveHypermedia"
    }),
    g = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-rdf-resolve-hypermedia-links/Bus/RdfResolveHypermediaLinks"
    }),
    m = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-http-invalidate/Bus/HttpInvalidate"
    }),
    y = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-optimize-query-operation/Bus/OptimizeQueryOperation"
    }),
    b = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-sparql-parse/Bus/SparqlParse"
    }),
    _ = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-sparql-serialize/Bus/SparqlSerialize"
    }),
    v = new(r(0).Bus)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-context-preprocess/Bus/ContextPreprocess"
    }),
    w = new(r(0).BusIndexed)({
      actorIdentifierFields: ["operationName"],
      actionIdentifierFields: ["operation", "type"],
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/bus-query-operation/Bus/QueryOperation"
    }),
    S = new(r(76).MediatorNumber)({
      field: "time",
      type: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/mediator-number/Mediator/Number/type/TypeMin",
      ignoreErrors: !0,
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/http.json#mediatorHttp",
      bus: a
    }),
    T = new(r(244).ActorHttpNative)({
      agentOptions: '{ "keepAlive": true, "maxSockets": 5 }',
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/http.json#myHttpFetcher",
      bus: a
    }),
    E = new(r(129).ActionObserverHttp)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-sparql-serialize-stats/Actor/SparqlSerialize/Stats/httpObserver/default",
      bus: a
    }),
    x = new(r(16).MediatorRace)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#mediatorRdfJoin",
      bus: s
    }),
    O = new(r(260).ActorRdfJoinSymmetricHash)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/join.json#myRdfJoinActorSymmetricHash",
      bus: s
    }),
    A = new(r(268).ActorRdfJoinNestedLoop)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/join.json#myRdfJoinActorNestedLoop",
      bus: s
    }),
    R = new(r(26).MediatorCombineUnion)({
      field: "mediaTypes",
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/rdf-dereference.json#mediatorRdfParseMediatypes",
      bus: o
    }),
    I = new(r(16).MediatorRace)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/rdf-dereference.json#mediatorRdfParseHandle",
      bus: o
    }),
    N = new(r(271).ActorRdfParseN3)({
      mediaTypes: {
        "application/n-quads": "1.0",
        "application/trig": "0.95",
        "application/n-triples": "0.8",
        "text/turtle": "0.6",
        "text/n3": "0.35"
      },
      mediaTypeFormats: {
        "application/n-quads": "http://www.w3.org/ns/formats/N-Quads",
        "application/trig": "http://www.w3.org/ns/formats/TriG",
        "application/n-triples": "http://www.w3.org/ns/formats/N-Triples",
        "text/turtle": "http://www.w3.org/ns/formats/Turtle",
        "text/n3": "http://www.w3.org/ns/formats/N3"
      },
      priorityScale: "1",
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/rdf-parsers.json#myRdfParserN3",
      bus: o
    }),
    P = new(r(275).ActorRdfParseRdfXml)({
      mediaTypes: {
        "application/rdf+xml": "1.0"
      },
      mediaTypeFormats: {
        "application/rdf+xml": "http://www.w3.org/ns/formats/RDF_XML"
      },
      priorityScale: "5.0E-1",
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/rdf-parsers.json#myRdfParserRdfXml",
      bus: o
    }),
    C = new(r(281).ActorRdfParseXmlRdfa)({
      mediaTypes: {
        "application/xml": "1.0",
        "text/xml": "1.0",
        "image/svg+xml": "1.0"
      },
      mediaTypeFormats: {
        "application/xml": "http://www.w3.org/ns/formats/RDFa",
        "text/xml": "http://www.w3.org/ns/formats/RDFa",
        "image/svg+xml": "http://www.w3.org/ns/formats/RDFa"
      },
      priorityScale: "3.0E-1",
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/rdf-parsers.json#myRdfParserXmlRdfa",
      bus: o
    }),
    D = new(r(26).MediatorCombineUnion)({
      field: "mediaTypes",
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/rdf-parsers.json#mediatorRdfParseMediatypes",
      bus: o
    }),
    j = new(r(16).MediatorRace)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/rdf-parsers.json#mediatorRdfParseHandle",
      bus: o
    }),
    k = new(r(16).MediatorRace)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-hypermedia.json#mediatorRdfDereference",
      bus: u
    }),
    L = new(r(303).ActorRdfParseHtml)({
      busRdfParseHtml: c,
      mediaTypes: {
        "text/html": "1.0",
        "application/xhtml+xml": "0.9"
      },
      mediaTypeFormats: {
        "text/html": "http://www.w3.org/ns/formats/HTML",
        "application/xhtml+xml": "http://www.w3.org/ns/formats/HTML"
      },
      priorityScale: "2.0E-1",
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/rdf-parsers.json#myRdfParserHtml",
      bus: o
    }),
    M = new(r(306).ActorRdfParseHtmlMicrodata)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/rdf-parsers.json#myRdfParserHtmlMicrodata",
      bus: c
    }),
    F = new(r(316).ActorRdfParseHtmlRdfa)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/rdf-parsers.json#myRdfParserHtmlRdfa",
      bus: c
    }),
    B = new(r(325).ActorRdfSerializeN3)({
      mediaTypes: {
        "application/trig": "1.0",
        "application/n-quads": "0.7",
        "text/turtle": "0.6",
        "application/n-triples": "0.3",
        "text/n3": "0.2"
      },
      mediaTypeFormats: {
        "application/trig": "http://www.w3.org/ns/formats/TriG",
        "application/n-quads": "http://www.w3.org/ns/formats/N-Quads",
        "text/turtle": "http://www.w3.org/ns/formats/Turtle",
        "application/n-triples": "http://www.w3.org/ns/formats/N-Triples",
        "text/n3": "http://www.w3.org/ns/formats/N3"
      },
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/rdf-serializers.json#myRdfSerializerN3",
      bus: l
    }),
    q = new(r(329).ActorRdfSerializeJsonLd)({
      jsonStringifyIndentSpaces: 2,
      mediaTypes: {
        "application/ld+json": "1.0"
      },
      mediaTypeFormats: {
        "application/ld+json": "http://www.w3.org/ns/formats/JSON-LD"
      },
      priorityScale: "9.0E-1",
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/rdf-serializers.json#myRdfSerializeJsonLd",
      bus: l
    }),
    U = new(r(16).MediatorRace)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-serializers.json#mediatorRdfSerialize",
      bus: l
    }),
    V = new(r(26).MediatorCombineUnion)({
      field: "mediaTypes",
      name: "_:b0bnode322",
      bus: l
    }),
    H = new(r(26).MediatorCombineUnion)({
      field: "mediaTypeFormats",
      name: "_:b1bnode322",
      bus: l
    }),
    G = new(r(16).MediatorRace)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#mediatorResolveQuadPattern",
      bus: h
    }),
    z = new(r(154).ActorRdfResolveQuadPatternRdfJsSource)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-rdfjs.json#myRdfRdfJsSourceQuadPatternResolver",
      bus: h
    }),
    Q = new(r(16).MediatorRace)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-hypermedia.json#mediatorMetadata",
      bus: d
    }),
    X = new(r(338).ActorRdfMetadataPrimaryTopic)({
      metadataToData: !1,
      dataToMetadataOnInvalidMetadataGraph: !0,
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-hypermedia.json#myRdfMetadataPrimaryTopic",
      bus: d
    }),
    $ = new(r(341).ActorRdfMetadataAll)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-hypermedia.json#myRdfMetadataAll",
      bus: d
    }),
    Y = new(r(26).MediatorCombineUnion)({
      field: "metadata",
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-hypermedia.json#mediatorMetadataExtract",
      bus: p
    }),
    J = new(r(343).ActorRdfMetadataExtractHydraControls)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-hypermedia.json#myRdfMetadataExtractHydraControls",
      bus: p
    }),
    W = new(r(374).ActorRdfMetadataExtractHydraCount)({
      predicates: ["http://www.w3.org/ns/hydra/core#totalItems", "http://rdfs.org/ns/void#triples"],
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-hypermedia.json#myRdfMetadataExtractHydraCount",
      bus: p
    }),
    K = new(r(376).ActorRdfMetadataExtractSparqlService)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-sparql.json#myRdfMetadataExtractSparqlService",
      bus: p
    }),
    Z = new(r(378).ActorRdfResolveHypermediaNone)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-hypermedia.json#myHypermediaNoneResolver",
      bus: f
    }),
    ee = new(r(76).MediatorNumber)({
      field: "filterFactor",
      type: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/mediator-number/Mediator/Number/type/TypeMax",
      ignoreErrors: !0,
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-hypermedia.json#mediatorRdfResolveHypermedia",
      bus: f
    }),
    te = new(r(16).MediatorRace)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-hypermedia.json#mediatorRdfResolveHypermediaLinks",
      bus: g
    }),
    re = new(r(381).ActorRdfResolveHypermediaLinksNext)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-hypermedia.json#myHypermediaLinksNext",
      bus: g
    }),
    ne = new(r(385).ActorHttpInvalidateListenable)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-rdf-resolve-quad-pattern-hypermedia/Actor/RdfResolveQuadPattern/Hypermedia/httpInvalidator#default",
      bus: m
    }),
    ie = new(r(387).MediatorAll)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-init.json#mediatorHttpInvalidate",
      bus: m
    }),
    ae = new(r(167).MediatorCombinePipeline)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-init.json#mediatorOptimizeQueryOperation",
      bus: y
    }),
    se = new(r(390).ActorOptimizeQueryOperationJoinBgp)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-optimize.json#myJoinBgpOptimizer",
      bus: y
    }),
    oe = new(r(16).MediatorRace)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-init.json#mediatorSparqlParse",
      bus: b
    }),
    ue = new(r(394).ActorSparqlParseGraphql)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/graphql-parsers.json#myGraphqlParser",
      bus: b
    }),
    ce = new(r(397).ActorSparqlParseAlgebra)({
      prefixes: {
        rdf: "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
        rdfs: "http://www.w3.org/2000/01/rdf-schema#",
        owl: "http://www.w3.org/2002/07/owl#",
        xsd: "http://www.w3.org/2001/XMLSchema#",
        dc: "http://purl.org/dc/terms/",
        dcterms: "http://purl.org/dc/terms/",
        dc11: "http://purl.org/dc/elements/1.1/",
        foaf: "http://xmlns.com/foaf/0.1/",
        geo: "http://www.w3.org/2003/01/geo/wgs84_pos#",
        dbpedia: "http://dbpedia.org/resource/",
        "dbpedia-owl": "http://dbpedia.org/ontology/",
        dbpprop: "http://dbpedia.org/property/",
        schema: "http://schema.org/",
        skos: "http://www.w3.org/2008/05/skos#"
      },
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-parsers.json#mySparqlParser",
      bus: b
    }),
    le = new(r(16).MediatorRace)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-init.json#mediatorSparqlSerialize",
      bus: _
    }),
    he = new(r(26).MediatorCombineUnion)({
      field: "mediaTypes",
      name: "_:b0bnode316",
      bus: _
    }),
    de = new(r(26).MediatorCombineUnion)({
      field: "mediaTypeFormats",
      name: "_:b1bnode316",
      bus: _
    }),
    pe = new(r(399).ActorSparqlSerializeJson)({
      mediaTypes: {
        "application/json": "1.0"
      },
      mediaTypeFormats: {
        "application/json": "https://comunica.linkeddatafragments.org/#results_JSON"
      },
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-serializers.json#myJsonSparqlSerializer",
      bus: _
    }),
    fe = new(r(401).ActorSparqlSerializeSimple)({
      mediaTypes: {
        simple: "0.9"
      },
      mediaTypeFormats: {
        simple: "https://comunica.linkeddatafragments.org/#results_simple"
      },
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-serializers.json#mySimpleSparqlSerializer",
      bus: _
    }),
    ge = new(r(403).ActorSparqlSerializeSparqlCsv)({
      mediaTypes: {
        "text/csv": "0.75"
      },
      mediaTypeFormats: {
        "text/csv": "http://www.w3.org/ns/formats/SPARQL_Results_CSV"
      },
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-serializers.json#mySparqlCsvSparqlSerializer",
      bus: _
    }),
    me = new(r(405).ActorSparqlSerializeSparqlJson)({
      mediaTypes: {
        "application/sparql-results+json": "0.8"
      },
      mediaTypeFormats: {
        "application/sparql-results+json": "http://www.w3.org/ns/formats/SPARQL_Results_JSON"
      },
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-serializers.json#mySparqlJsonSparqlSerializer",
      bus: _
    }),
    ye = new(r(407).ActorSparqlSerializeSparqlTsv)({
      mediaTypes: {
        "text/tab-separated-values": "0.75"
      },
      mediaTypeFormats: {
        "text/tab-separated-values": "http://www.w3.org/ns/formats/SPARQL_Results_TSV"
      },
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-serializers.json#mySparqlTsvSparqlSerializer",
      bus: _
    }),
    be = new(r(411).ActorSparqlSerializeSparqlXml)({
      mediaTypes: {
        "application/sparql-results+xml": "0.8"
      },
      mediaTypeFormats: {
        "application/sparql-results+xml": "http://www.w3.org/ns/formats/SPARQL_Results_XML"
      },
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-serializers.json#mySparqlXmlSparqlSerializer",
      bus: _
    }),
    _e = new(r(415).ActorSparqlSerializeTable)({
      columnWidth: 50,
      mediaTypes: {
        table: "0.6"
      },
      mediaTypeFormats: {
        table: "https://comunica.linkeddatafragments.org/#results_table"
      },
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-serializers.json#myTableSparqlSerializer",
      bus: _
    }),
    ve = new(r(113).ActorSparqlSerializeTree)({
      mediaTypes: {
        tree: "0.5"
      },
      mediaTypeFormats: {
        tree: "https://comunica.linkeddatafragments.org/#results_tree"
      },
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-serializers.json#myTreeSparqlSerializer",
      bus: _
    }),
    we = new(r(167).MediatorCombinePipeline)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-init.json#mediatorContextPreprocess",
      bus: v
    }),
    Se = new(r(76).MediatorNumber)({
      field: "httpRequests",
      type: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/mediator-number/Mediator/Number/type/TypeMin",
      ignoreErrors: !0,
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#mediatorQueryOperation",
      bus: w
    }),
    Te = new(r(420).ActorQueryOperationBgpEmpty)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myEmptyBgpQueryOperator",
      bus: w
    }),
    Ee = new(r(422).ActorQueryOperationValues)({
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myValuesQueryOperator",
      bus: w
    }),
    xe = new(r(424).ActorRdfParseJsonLd)({
      mediatorHttp: S,
      mediaTypes: {
        "application/ld+json": "1.0",
        "application/json": "0.5"
      },
      mediaTypeFormats: {
        "application/ld+json": "http://www.w3.org/ns/formats/JSON-LD",
        "application/json": "http://www.w3.org/ns/formats/JSON-LD"
      },
      priorityScale: "9.0E-1",
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/rdf-parsers.json#myRdfParserJsonLd",
      bus: o
    }),
    Oe = new(r(443).ActorRdfResolveHypermediaSparql)({
      mediatorHttp: S,
      checkUrlSuffix: !0,
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-sparql.json#mySparqlQuadPatternResolver",
      bus: f
    }),
    Ae = new(r(448).ActorQueryOperationSparqlEndpoint)({
      mediatorHttp: S,
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-sparql.json#mySparqlEndpointResolver",
      bus: w
    }),
    Re = new(r(129).ActorSparqlSerializeStats)({
      httpObserver: E,
      mediaTypes: {
        stats: "0.5"
      },
      mediaTypeFormats: {
        stats: "https://comunica.linkeddatafragments.org/#results_stats"
      },
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-serializers.json#myStatsSparqlSerializer",
      bus: _
    }),
    Ie = new(r(465).ActorRdfJoinMultiSmallest)({
      mediatorJoin: x,
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/join.json#myRdfJoinMultiActor",
      bus: s
    }),
    Ne = new(r(467).ActorRdfDereferenceHttpParse)({
      mediatorHttp: S,
      mediatorRdfParseMediatypes: R,
      mediatorRdfParseHandle: I,
      maxAcceptHeaderLength: 1024,
      maxAcceptHeaderLengthBrowser: 128,
      mediaMappings: {
        ttl: "text/turtle",
        turtle: "text/turtle",
        nt: "application/n-triples",
        ntriples: "application/n-triples",
        nq: "application/n-quads",
        nquads: "application/n-quads",
        rdf: "application/rdf+xml",
        rdfxml: "application/rdf+xml",
        owl: "application/rdf+xml",
        n3: "text/n3",
        trig: "application/trig",
        jsonld: "application/ld+json",
        json: "application/json",
        html: "text/html",
        htm: "text/html",
        xhtml: "application/xhtml+xml",
        xht: "application/xhtml+xml",
        xml: "application/xml",
        svg: "image/svg+xml",
        svgz: "image/svg+xml"
      },
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/rdf-dereference.json#myRdfDereferencer",
      bus: u
    }),
    Pe = new(r(472).ActorRdfParseHtmlScript)({
      mediatorRdfParseMediatypes: D,
      mediatorRdfParseHandle: j,
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/rdf-parsers.json#myRdfParserHtmlScript",
      bus: c
    }),
    Ce = new(r(475).ActorSparqlSerializeRdf)({
      mediatorRdfSerialize: U,
      mediatorMediaTypeCombiner: V,
      mediatorMediaTypeFormatCombiner: H,
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-serializers.json#myRdfSparqlSerializer",
      bus: _
    }),
    De = new(r(477).ActorRdfResolveQuadPatternFederated)({
      mediatorResolveQuadPattern: G,
      skipEmptyPatterns: !1,
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-federated.json#myFederatedQuadPatternResolver",
      bus: h
    }),
    je = new(r(480).ActorQueryOperationQuadpattern)({
      mediatorResolveQuadPattern: G,
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myQuadPatternQueryOperator",
      bus: w
    }),
    ke = new(r(482).ActorRdfResolveHypermediaQpf)({
      mediatorMetadata: Q,
      mediatorMetadataExtract: Y,
      mediatorRdfDereference: k,
      subjectUri: "http://www.w3.org/1999/02/22-rdf-syntax-ns#subject",
      predicateUri: "http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate",
      objectUri: "http://www.w3.org/1999/02/22-rdf-syntax-ns#object",
      graphUri: "http://www.w3.org/ns/sparql-service-description#graph",
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-hypermedia.json#myHypermediaQpfResolver",
      bus: f
    }),
    Le = new(r(485).ActorRdfResolveQuadPatternHypermedia)({
      mediatorRdfDereference: k,
      mediatorMetadata: Q,
      mediatorMetadataExtract: Y,
      mediatorRdfResolveHypermedia: ee,
      mediatorRdfResolveHypermediaLinks: te,
      cacheSize: 100,
      httpInvalidator: ne,
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/resolve-hypermedia.json#myQuadPatternHypermediaResolver",
      bus: h
    }),
    Me = new(r(491).ActorHttpProxy)({
      mediatorHttp: S,
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/http.json#myHttpProxy",
      bus: a,
      beforeActors: [T]
    }),
    Fe = new(r(495).ActorHttpMemento)({
      mediatorHttp: S,
      name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/http-memento.json#myHttpFetcher",
      bus: a,
      beforeActors: [T]
    }),
    Be = new(r(91).ActorInitSparql)({
      mediatorOptimizeQueryOperation: ae,
      mediatorQueryOperation: Se,
      mediatorSparqlParse: oe,
      mediatorSparqlSerialize: le,
      mediatorSparqlSerializeMediaTypeCombiner: he,
      mediatorSparqlSerializeMediaTypeFormatCombiner: de,
      mediatorContextPreprocess: we,
      mediatorHttpInvalidate: ie,
      logger: n,
      contextKeyShortcuts: {
        source: "@comunica/bus-rdf-resolve-quad-pattern:source",
        sources: "@comunica/bus-rdf-resolve-quad-pattern:sources",
        initialBindings: "@comunica/actor-init-sparql:initialBindings",
        queryFormat: "@comunica/actor-init-sparql:queryFormat",
        baseIRI: "@comunica/actor-init-sparql:baseIRI",
        log: "@comunica/core:log",
        datetime: "@comunica/actor-http-memento:datetime",
        queryTimestamp: "@comunica/actor-init-sparql:queryTimestamp",
        httpProxyHandler: "@comunica/actor-http-proxy:httpProxyHandler",
        lenient: "@comunica/actor-init-sparql:lenient",
        httpIncludeCredentials: "@comunica/bus-http:include-credentials",
        httpAuth: "@comunica/bus-http:auth"
      },
      name: "urn:comunica:sparqlinit",
      bus: i
    });
  new(r(497).ActorQueryOperationAsk)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myAskQueryOperator",
    bus: w
  }), new(r(499).ActorQueryOperationService)({
    forceSparqlEndpoint: !1,
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myServiceQueryOperator",
    bus: w
  }), new(r(501).ActorQueryOperationSlice)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#mySliceQueryOperator",
    bus: w
  }), new(r(503).ActorQueryOperationBgpSingle)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#mySingleBgpQueryOperator",
    bus: w
  }), new(r(505).ActorQueryOperationBgpLeftDeepSmallest)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myLeftDeepSmallestBgpQueryOperator",
    bus: w
  }), new(r(507).ActorQueryOperationConstruct)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myConstructQueryOperator",
    bus: w
  }), new(r(510).ActorQueryOperationDescribeSubject)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myDescribeQueryOperator",
    bus: w
  }), new(r(513).ActorQueryOperationDistinctHash)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myDistinctQueryOperator",
    bus: w
  }), new(r(523).ActorQueryOperationExtend)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myExtendQueryOperator",
    bus: w
  }), new(r(541).ActorQueryOperationReducedHash)({
    cacheSize: 100,
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myReducedQueryOperator",
    bus: w
  }), new(r(546).ActorQueryOperationFilterSparqlee)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myFilterQueryOperator",
    bus: w
  }), new(r(548).ActorQueryOperationFromQuad)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myFromQueryOperator",
    bus: w
  }), new(r(550).ActorQueryOperationGroup)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myGroupQueryOperator",
    bus: w
  }), new(r(553).ActorQueryOperationJoin)({
    mediatorJoin: x,
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myJoinQueryOperator",
    bus: w
  }), new(r(555).ActorQueryOperationLeftJoinLeftDeep)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myLeftJoinQueryOperator",
    bus: w
  }), new(r(557).ActorQueryOperationOrderBySparqlee)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myOrderByQueryOperator",
    bus: w
  }), new(r(560).ActorQueryOperationProject)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myProjectQueryOperator",
    bus: w
  }), new(r(180).ActorQueryOperationUnion)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myUnionQueryOperator",
    bus: w
  }), new(r(562).ActorQueryOperationMinus)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperators.json#myMinusQueryOperator",
    bus: w
  }), new(r(565).ActorQueryOperationPathAlt)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperator-path.json#myAltPathOperator",
    bus: w
  }), new(r(567).ActorQueryOperationPathInv)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperator-path.json#myInvPathOperator",
    bus: w
  }), new(r(569).ActorQueryOperationPathLink)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperator-path.json#myLinkPathOperator",
    bus: w
  }), new(r(571).ActorQueryOperationPathNps)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperator-path.json#myNpsPathOperator",
    bus: w
  }), new(r(573).ActorQueryOperationPathOneOrMore)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperator-path.json#myOneOrMorePathOperator",
    bus: w
  }), new(r(575).ActorQueryOperationPathSeq)({
    mediatorJoin: x,
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperator-path.json#mySeqPathOperator",
    bus: w
  }), new(r(577).ActorQueryOperationPathZeroOrMore)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperator-path.json#myZeroOrMorePathOperator",
    bus: w
  }), new(r(579).ActorQueryOperationPathZeroOrOne)({
    mediatorQueryOperation: Se,
    name: "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/actor-init-sparql/^1.0.0/config/sets/sparql-queryoperator-path.json#myZeroOrOnePathOperator",
    bus: w
  });
  e.exports = Be
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(242), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.LoggerVoid = void 0;
  const n = r(0);
  class i extends n.Logger {
    debug() {}
    error() {}
    fatal() {}
    info() {}
    trace() {}
    warn() {}
  }
  t.LoggerVoid = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.MediatorNumber = void 0;
  const n = r(0);
  class i extends n.Mediator {
    constructor(e) {
      super(e), this.indexPicker = this.createIndexPicker()
    }
    createIndexPicker() {
      switch (this.type) {
        case i.MIN:
          return e => e.reduce((e, t, r) => {
            const n = this.getOrDefault(t[this.field], 1 / 0);
            return null !== n && (Number.isNaN(e[0]) || e[0] > n) ? [n, r] : e
          }, [Number.NaN, -1])[1];
        case i.MAX:
          return e => e.reduce((e, t, r) => {
            const n = this.getOrDefault(t[this.field], -1 / 0);
            return null !== n && (Number.isNaN(e[0]) || e[0] < n) ? [n, r] : e
          }, [Number.NaN, -1])[1];
        default:
          throw new Error(`No valid "type" value was given, must be either ${i.MIN} or ${i.MAX}, but got: ${this.type}`)
      }
    }
    getOrDefault(e, t) {
      return void 0 === e ? t : e
    }
    async mediateWith(e, t) {
      let r = t.map(({
                       reply: e
                     }) => e);
      const n = [];
      if (this.ignoreErrors) {
        const e = {};
        e[this.field] = null, r = r.map(t => t.catch(t => (n.push(t), e)))
      }
      const i = await Promise.all(r),
        a = this.indexPicker(i);
      if (a < 0) throw new Error(`All actors rejected their test in ${this.name}\n${n.map(e=>e.message).join("\n")}`);
      return t[a].actor
    }
  }
  t.MediatorNumber = i, i.MIN = "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/mediator-number/Mediator/Number/type/TypeMin", i.MAX = "https://linkedsoftwaredependencies.org/bundles/npm/@comunica/mediator-number/Mediator/Number/type/TypeMax"
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(245), t)
}, function(e, t, r) {
  "use strict";
  (function(e, n, i) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.ActorHttpNative = void 0;
    const a = r(36);
    r(45);
    const s = r(250);
    class o extends a.ActorHttp {
      constructor(e) {
        super(e), this.userAgent = o.createUserAgent(), this.requester = new s.default(e.agentOptions ? JSON.parse(e.agentOptions) : void 0)
      }
      static createUserAgent() {
        return `Comunica/actor-http-native (${void 0===e.navigator?`Node.js ${n.version}; ${n.platform}`:"Browser-"+e.navigator.userAgent})`
      }
      async test(e) {
        return {
          time: 1 / 0
        }
      }
      async run(e) {
        const t = {};
        return e.input.url ? (t.url = e.input.url, Object.assign(t, e.input)) : t.url = e.input, e.init ? (Object.assign(t, e.init), t.headers = new Headers(e.init.headers)) : t.headers = e.input.headers, t.headers || (t.headers = new Headers), t.headers.has("user-agent") || t.headers.append("user-agent", this.userAgent), t.method = t.method || "GET", e.context && e.context.get(a.KEY_CONTEXT_INCLUDE_CREDENTIALS) && (t.withCredentials = !0), e.context && e.context.get(a.KEY_CONTEXT_AUTH) && (t.auth = e.context.get(a.KEY_CONTEXT_AUTH)), this.logInfo(e.context, "Requesting " + t.url, () => ({
          headers: a.ActorHttp.headersToHash(t.headers)
        })), new Promise((e, r) => {
          const n = this.requester.createRequest(t);
          n.on("error", r), n.on("response", n => {
            n.on("error", e => {
              n = null, r(e)
            }), "HEAD" === t.method && n.destroy(), i(() => {
              if (n) {
                n.cancel = () => (n.destroy(), Promise.resolve());
                const r = n.headers,
                  i = {
                    body: n,
                    headers: r,
                    ok: n.statusCode < 300,
                    redirected: t.url !== n.responseUrl,
                    status: n.statusCode,
                    url: r.has("content-location") ? r.get("content-location") : n.responseUrl
                  };
                e(i)
              }
            })
          })
        })
      }
    }
    t.ActorHttpNative = o
  }).call(this, r(10), r(8), r(44).setImmediate)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.KEY_CONTEXT_AUTH = t.KEY_CONTEXT_INCLUDE_CREDENTIALS = t.ActorHttp = void 0;
  const n = r(0);
  class i extends n.Actor {
    constructor(e) {
      super(e)
    }
    static toNodeReadable(e) {
      return r(124)(e) ? e : r(125).toNodeReadable(e)
    }
    static headersToHash(e) {
      const t = {};
      return e.forEach((e, r) => {
        t[r] = e
      }), t
    }
  }
  t.ActorHttp = i, t.KEY_CONTEXT_INCLUDE_CREDENTIALS = "@comunica/bus-http:include-credentials", t.KEY_CONTEXT_AUTH = "@comunica/bus-http:auth"
}, function(e, t, r) {
  "use strict";
  var n = e.exports = function(e) {
    return null !== e && "object" == typeof e && "function" == typeof e.pipe
  };
  n.writable = function(e) {
    return n(e) && !1 !== e.writable && "function" == typeof e._write && "object" == typeof e._writableState
  }, n.readable = function(e) {
    return n(e) && !1 !== e.readable && "function" == typeof e._read && "object" == typeof e._readableState
  }, n.duplex = function(e) {
    return n.writable(e) && n.readable(e)
  }, n.transform = function(e) {
    return n.duplex(e) && "function" == typeof e._transform && "object" == typeof e._transformState
  }
}, function(e, t, r) {
  "use strict";
  (function(t) {
    const n = r(2).Readable,
      i = r(126).ReadableStream;
    t.ReadableStream = t.ReadableStream || i;
    const a = r(249);
    class s extends n {
      constructor(e, t) {
        super(t), this._webStream = e, this._reader = e.getReader(), this._reading = !1
      }
      _read(e) {
        if (this._reading) return;
        this._reading = !0;
        const t = () => {
          this._reader.read().then(r => (this._doneReading && (this._reading = !1, this._reader.releaseLock(), this._doneReading()), r.done ? (this.push(null), this._reading = !1, void this._reader.releaseLock()) : this.push(r.value) ? t(e) : (this._reading = !1, void this._reader.releaseLock())))
        };
        t()
      }
      _destroy(e, t) {
        if (this._reading) {
          new Promise(e => {
            this._doneReading = e
          }).then(() => this._handleDestroy(e, t))
        } else this._handleDestroy(e, t)
      }
      _handleDestroy(e, t) {
        this._webStream.cancel(), super._destroy(e, t)
      }
    }
    e.exports = {
      readable: {
        nodeToWeb: a,
        arrayToWeb: function(e) {
          return new i({
            start(t) {
              for (var r = 0; r < e.length; r++) t.enqueue(e[r]);
              t.close()
            }
          })
        },
        webToNode: function(e) {
          return new s(e)
        }
      }
    }
  }).call(this, r(10))
}, function(e, t) {
  e.exports = function(t) {
    if (!e.exports.WEBSTREAM_SUPPORT) throw new Error("No web ReadableStream support");
    var r = !1,
      n = {};
    return new ReadableStream({
      start: function(e) {
        for (var i in n.data = a, n.end = a, n.end = s, n.close = s, n.error = s, n) t.on(i, n[i]);

        function a(n) {
          r || (e.enqueue(n), t.pause())
        }

        function s(i) {
          if (!r) {
            for (var a in r = !0, n) t.removeListener(a, n[a]);
            i ? e.error(i) : e.close()
          }
        }
        t.pause()
      },
      pull: function() {
        r || t.resume()
      },
      cancel: function() {
        for (var e in r = !0, n) t.removeListener(e, n[e]);
        t.push(null), t.pause(), t.destroy ? t.destroy() : t.close && t.close()
      }
    })
  }, e.exports.WEBSTREAM_SUPPORT = "undefined" != typeof ReadableStream
}, function(e, t, r) {
  "use strict";
  /* ! @license MIT ©2013-2016 Ruben Verborgh, Ghent University - imec */
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  const n = r(22),
    i = r(2),
    a = r(127),
    s = {
      "accept-encoding": !0,
      "user-agent": !0,
      referer: !0
    };
  t.default = class {
    constructor() {
      this.negotiatedResources = {}
    }
    createRequest(e) {
      this.negotiatedResources[this.removeQuery(e.url)] && e.headers.delete("accept-datetime");
      const t = new XMLHttpRequest,
        r = e.headers;
      t.open(e.method, e.url, !0), t.timeout = e.timeout, t.withCredentials = e.withCredentials, r.forEach((e, r) => {
        !(r in s) && e && t.setRequestHeader(r, e)
      });
      const o = new n.EventEmitter;
      return o.abort = () => {
        t.abort()
      }, t.onload = () => {
        var n, s;
        const u = new i.Readable;
        u.push(t.responseText || ""), u.push(null), u.statusCode = t.status, u.responseUrl = t.responseURL;
        const c = this.convertRequestHeadersToFetchHeaders(u.headers);
        u.headers = c;
        const l = t.getAllResponseHeaders() || "",
          h = /^([^\n\r:]+):[\t ]*([^\n\r]*)$/gmu;
        let d = h.exec(l);
        for (; d;) c.set(d[1].toLowerCase(), d[2]), d = h.exec(l);
        if (o.emit("response", u), r.has("accept-datetime") && c.has("memento-datetime")) {
          const t = this.removeQuery(null !== (n = c.get("content-location")) && void 0 !== n ? n : e.url);
          if (!this.negotiatedResources[t]) {
            const e = null !== (s = c.get("link") && a(c.get("link"))) && void 0 !== s ? s : void 0;
            t !== this.removeQuery(e && e.timegate && e.timegate.url) && (this.negotiatedResources[t] = !0)
          }
        }
      }, t.onerror = () => {
        o.emit("error", new Error("Error requesting " + e.url))
      }, t.ontimeout = () => {
        o.emit("error", new Error("Timeout requesting " + e.url))
      }, t.send(), o
    }
    convertRequestHeadersToFetchHeaders(e) {
      const t = new Headers;
      for (const r in e) t.append(r, e[r]);
      return t
    }
    removeQuery(e) {
      return e ? e.replace(/\?.*$/u, "") : ""
    }
  }
}, function(e, t, r) {
  "use strict";

  function n(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
  }
  e.exports = function(e, t, r, a) {
    t = t || "&", r = r || "=";
    var s = {};
    if ("string" != typeof e || 0 === e.length) return s;
    var o = /\+/g;
    e = e.split(t);
    var u = 1e3;
    a && "number" == typeof a.maxKeys && (u = a.maxKeys);
    var c = e.length;
    u > 0 && c > u && (c = u);
    for (var l = 0; l < c; ++l) {
      var h, d, p, f, g = e[l].replace(o, "%20"),
        m = g.indexOf(r);
      m >= 0 ? (h = g.substr(0, m), d = g.substr(m + 1)) : (h = g, d = ""), p = decodeURIComponent(h), f = decodeURIComponent(d), n(s, p) ? i(s[p]) ? s[p].push(f) : s[p] = [s[p], f] : s[p] = f
    }
    return s
  };
  var i = Array.isArray || function(e) {
    return "[object Array]" === Object.prototype.toString.call(e)
  }
}, function(e, t, r) {
  "use strict";
  var n = function(e) {
    switch (typeof e) {
      case "string":
        return e;
      case "boolean":
        return e ? "true" : "false";
      case "number":
        return isFinite(e) ? e : "";
      default:
        return ""
    }
  };
  e.exports = function(e, t, r, o) {
    return t = t || "&", r = r || "=", null === e && (e = void 0), "object" == typeof e ? a(s(e), (function(s) {
      var o = encodeURIComponent(n(s)) + r;
      return i(e[s]) ? a(e[s], (function(e) {
        return o + encodeURIComponent(n(e))
      })).join(t) : o + encodeURIComponent(n(e[s]))
    })).join(t) : o ? encodeURIComponent(n(o)) + r + encodeURIComponent(n(e)) : ""
  };
  var i = Array.isArray || function(e) {
    return "[object Array]" === Object.prototype.toString.call(e)
  };

  function a(e, t) {
    if (e.map) return e.map(t);
    for (var r = [], n = 0; n < e.length; n++) r.push(t(e[n], n));
    return r
  }
  var s = Object.keys || function(e) {
    var t = [];
    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.push(r);
    return t
  }
}, function(e, t, r) {
  "use strict";
  var n = r(254),
    i = r(255);

  function a() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
  }
  t.parse = _, t.resolve = function(e, t) {
    return _(e, !1, !0).resolve(t)
  }, t.resolveObject = function(e, t) {
    return e ? _(e, !1, !0).resolveObject(t) : t
  }, t.format = function(e) {
    i.isString(e) && (e = _(e));
    return e instanceof a ? e.format() : a.prototype.format.call(e)
  }, t.Url = a;
  var s = /^([a-z0-9.+-]+:)/i,
    o = /:[0-9]*$/,
    u = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    c = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"]),
    l = ["'"].concat(c),
    h = ["%", "/", "?", ";", "#"].concat(l),
    d = ["/", "?", "#"],
    p = /^[+a-z0-9A-Z_-]{0,63}$/,
    f = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    g = {
      javascript: !0,
      "javascript:": !0
    },
    m = {
      javascript: !0,
      "javascript:": !0
    },
    y = {
      http: !0,
      https: !0,
      ftp: !0,
      gopher: !0,
      file: !0,
      "http:": !0,
      "https:": !0,
      "ftp:": !0,
      "gopher:": !0,
      "file:": !0
    },
    b = r(128);

  function _(e, t, r) {
    if (e && i.isObject(e) && e instanceof a) return e;
    var n = new a;
    return n.parse(e, t, r), n
  }
  a.prototype.parse = function(e, t, r) {
    if (!i.isString(e)) throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
    var a = e.indexOf("?"),
      o = -1 !== a && a < e.indexOf("#") ? "?" : "#",
      c = e.split(o);
    c[0] = c[0].replace(/\\/g, "/");
    var _ = e = c.join(o);
    if (_ = _.trim(), !r && 1 === e.split("#").length) {
      var v = u.exec(_);
      if (v) return this.path = _, this.href = _, this.pathname = v[1], v[2] ? (this.search = v[2], this.query = t ? b.parse(this.search.substr(1)) : this.search.substr(1)) : t && (this.search = "", this.query = {}), this
    }
    var w = s.exec(_);
    if (w) {
      var S = (w = w[0]).toLowerCase();
      this.protocol = S, _ = _.substr(w.length)
    }
    if (r || w || _.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var T = "//" === _.substr(0, 2);
      !T || w && m[w] || (_ = _.substr(2), this.slashes = !0)
    }
    if (!m[w] && (T || w && !y[w])) {
      for (var E, x, O = -1, A = 0; A < d.length; A++) {
        -1 !== (R = _.indexOf(d[A])) && (-1 === O || R < O) && (O = R)
      } - 1 !== (x = -1 === O ? _.lastIndexOf("@") : _.lastIndexOf("@", O)) && (E = _.slice(0, x), _ = _.slice(x + 1), this.auth = decodeURIComponent(E)), O = -1;
      for (A = 0; A < h.length; A++) {
        var R; - 1 !== (R = _.indexOf(h[A])) && (-1 === O || R < O) && (O = R)
      } - 1 === O && (O = _.length), this.host = _.slice(0, O), _ = _.slice(O), this.parseHost(), this.hostname = this.hostname || "";
      var I = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
      if (!I)
        for (var N = this.hostname.split(/\./), P = (A = 0, N.length); A < P; A++) {
          var C = N[A];
          if (C && !C.match(p)) {
            for (var D = "", j = 0, k = C.length; j < k; j++) C.charCodeAt(j) > 127 ? D += "x" : D += C[j];
            if (!D.match(p)) {
              var L = N.slice(0, A),
                M = N.slice(A + 1),
                F = C.match(f);
              F && (L.push(F[1]), M.unshift(F[2])), M.length && (_ = "/" + M.join(".") + _), this.hostname = L.join(".");
              break
            }
          }
        }
      this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), I || (this.hostname = n.toASCII(this.hostname));
      var B = this.port ? ":" + this.port : "",
        q = this.hostname || "";
      this.host = q + B, this.href += this.host, I && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== _[0] && (_ = "/" + _))
    }
    if (!g[S])
      for (A = 0, P = l.length; A < P; A++) {
        var U = l[A];
        if (-1 !== _.indexOf(U)) {
          var V = encodeURIComponent(U);
          V === U && (V = escape(U)), _ = _.split(U).join(V)
        }
      }
    var H = _.indexOf("#"); - 1 !== H && (this.hash = _.substr(H), _ = _.slice(0, H));
    var G = _.indexOf("?");
    if (-1 !== G ? (this.search = _.substr(G), this.query = _.substr(G + 1), t && (this.query = b.parse(this.query)), _ = _.slice(0, G)) : t && (this.search = "", this.query = {}), _ && (this.pathname = _), y[S] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
      B = this.pathname || "";
      var z = this.search || "";
      this.path = B + z
    }
    return this.href = this.format(), this
  }, a.prototype.format = function() {
    var e = this.auth || "";
    e && (e = (e = encodeURIComponent(e)).replace(/%3A/i, ":"), e += "@");
    var t = this.protocol || "",
      r = this.pathname || "",
      n = this.hash || "",
      a = !1,
      s = "";
    this.host ? a = e + this.host : this.hostname && (a = e + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (a += ":" + this.port)), this.query && i.isObject(this.query) && Object.keys(this.query).length && (s = b.stringify(this.query));
    var o = this.search || s && "?" + s || "";
    return t && ":" !== t.substr(-1) && (t += ":"), this.slashes || (!t || y[t]) && !1 !== a ? (a = "//" + (a || ""), r && "/" !== r.charAt(0) && (r = "/" + r)) : a || (a = ""), n && "#" !== n.charAt(0) && (n = "#" + n), o && "?" !== o.charAt(0) && (o = "?" + o), t + a + (r = r.replace(/[?#]/g, (function(e) {
      return encodeURIComponent(e)
    }))) + (o = o.replace("#", "%23")) + n
  }, a.prototype.resolve = function(e) {
    return this.resolveObject(_(e, !1, !0)).format()
  }, a.prototype.resolveObject = function(e) {
    if (i.isString(e)) {
      var t = new a;
      t.parse(e, !1, !0), e = t
    }
    for (var r = new a, n = Object.keys(this), s = 0; s < n.length; s++) {
      var o = n[s];
      r[o] = this[o]
    }
    if (r.hash = e.hash, "" === e.href) return r.href = r.format(), r;
    if (e.slashes && !e.protocol) {
      for (var u = Object.keys(e), c = 0; c < u.length; c++) {
        var l = u[c];
        "protocol" !== l && (r[l] = e[l])
      }
      return y[r.protocol] && r.hostname && !r.pathname && (r.path = r.pathname = "/"), r.href = r.format(), r
    }
    if (e.protocol && e.protocol !== r.protocol) {
      if (!y[e.protocol]) {
        for (var h = Object.keys(e), d = 0; d < h.length; d++) {
          var p = h[d];
          r[p] = e[p]
        }
        return r.href = r.format(), r
      }
      if (r.protocol = e.protocol, e.host || m[e.protocol]) r.pathname = e.pathname;
      else {
        for (var f = (e.pathname || "").split("/"); f.length && !(e.host = f.shift()););
        e.host || (e.host = ""), e.hostname || (e.hostname = ""), "" !== f[0] && f.unshift(""), f.length < 2 && f.unshift(""), r.pathname = f.join("/")
      }
      if (r.search = e.search, r.query = e.query, r.host = e.host || "", r.auth = e.auth, r.hostname = e.hostname || e.host, r.port = e.port, r.pathname || r.search) {
        var g = r.pathname || "",
          b = r.search || "";
        r.path = g + b
      }
      return r.slashes = r.slashes || e.slashes, r.href = r.format(), r
    }
    var _ = r.pathname && "/" === r.pathname.charAt(0),
      v = e.host || e.pathname && "/" === e.pathname.charAt(0),
      w = v || _ || r.host && e.pathname,
      S = w,
      T = r.pathname && r.pathname.split("/") || [],
      E = (f = e.pathname && e.pathname.split("/") || [], r.protocol && !y[r.protocol]);
    if (E && (r.hostname = "", r.port = null, r.host && ("" === T[0] ? T[0] = r.host : T.unshift(r.host)), r.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && ("" === f[0] ? f[0] = e.host : f.unshift(e.host)), e.host = null), w = w && ("" === f[0] || "" === T[0])), v) r.host = e.host || "" === e.host ? e.host : r.host, r.hostname = e.hostname || "" === e.hostname ? e.hostname : r.hostname, r.search = e.search, r.query = e.query, T = f;
    else if (f.length) T || (T = []), T.pop(), T = T.concat(f), r.search = e.search, r.query = e.query;
    else if (!i.isNullOrUndefined(e.search)) {
      if (E) r.hostname = r.host = T.shift(), (I = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@")) && (r.auth = I.shift(), r.host = r.hostname = I.shift());
      return r.search = e.search, r.query = e.query, i.isNull(r.pathname) && i.isNull(r.search) || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r
    }
    if (!T.length) return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
    for (var x = T.slice(-1)[0], O = (r.host || e.host || T.length > 1) && ("." === x || ".." === x) || "" === x, A = 0, R = T.length; R >= 0; R--) "." === (x = T[R]) ? T.splice(R, 1) : ".." === x ? (T.splice(R, 1), A++) : A && (T.splice(R, 1), A--);
    if (!w && !S)
      for (; A--; A) T.unshift("..");
    !w || "" === T[0] || T[0] && "/" === T[0].charAt(0) || T.unshift(""), O && "/" !== T.join("/").substr(-1) && T.push("");
    var I, N = "" === T[0] || T[0] && "/" === T[0].charAt(0);
    E && (r.hostname = r.host = N ? "" : T.length ? T.shift() : "", (I = !!(r.host && r.host.indexOf("@") > 0) && r.host.split("@")) && (r.auth = I.shift(), r.host = r.hostname = I.shift()));
    return (w = w || r.host && T.length) && !N && T.unshift(""), T.length ? r.pathname = T.join("/") : (r.pathname = null, r.path = null), i.isNull(r.pathname) && i.isNull(r.search) || (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = e.auth || r.auth, r.slashes = r.slashes || e.slashes, r.href = r.format(), r
  }, a.prototype.parseHost = function() {
    var e = this.host,
      t = o.exec(e);
    t && (":" !== (t = t[0]) && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e)
  }
}, function(e, t, r) {
  (function(e, n) {
    var i; /*! https://mths.be/punycode v1.4.1 by @mathias */
    ! function(a) {
      t && t.nodeType, e && e.nodeType;
      var s = "object" == typeof n && n;
      s.global !== s && s.window !== s && s.self;
      var o, u = 2147483647,
        c = /^xn--/,
        l = /[^\x20-\x7E]/,
        h = /[\x2E\u3002\uFF0E\uFF61]/g,
        d = {
          overflow: "Overflow: input needs wider integers to process",
          "not-basic": "Illegal input >= 0x80 (not a basic code point)",
          "invalid-input": "Invalid input"
        },
        p = Math.floor,
        f = String.fromCharCode;

      function g(e) {
        throw new RangeError(d[e])
      }

      function m(e, t) {
        for (var r = e.length, n = []; r--;) n[r] = t(e[r]);
        return n
      }

      function y(e, t) {
        var r = e.split("@"),
          n = "";
        return r.length > 1 && (n = r[0] + "@", e = r[1]), n + m((e = e.replace(h, ".")).split("."), t).join(".")
      }

      function b(e) {
        for (var t, r, n = [], i = 0, a = e.length; i < a;)(t = e.charCodeAt(i++)) >= 55296 && t <= 56319 && i < a ? 56320 == (64512 & (r = e.charCodeAt(i++))) ? n.push(((1023 & t) << 10) + (1023 & r) + 65536) : (n.push(t), i--) : n.push(t);
        return n
      }

      function _(e) {
        return m(e, (function(e) {
          var t = "";
          return e > 65535 && (t += f((e -= 65536) >>> 10 & 1023 | 55296), e = 56320 | 1023 & e), t += f(e)
        })).join("")
      }

      function v(e, t) {
        return e + 22 + 75 * (e < 26) - ((0 != t) << 5)
      }

      function w(e, t, r) {
        var n = 0;
        for (e = r ? p(e / 700) : e >> 1, e += p(e / t); e > 455; n += 36) e = p(e / 35);
        return p(n + 36 * e / (e + 38))
      }

      function S(e) {
        var t, r, n, i, a, s, o, c, l, h, d, f = [],
          m = e.length,
          y = 0,
          b = 128,
          v = 72;
        for ((r = e.lastIndexOf("-")) < 0 && (r = 0), n = 0; n < r; ++n) e.charCodeAt(n) >= 128 && g("not-basic"), f.push(e.charCodeAt(n));
        for (i = r > 0 ? r + 1 : 0; i < m;) {
          for (a = y, s = 1, o = 36; i >= m && g("invalid-input"), ((c = (d = e.charCodeAt(i++)) - 48 < 10 ? d - 22 : d - 65 < 26 ? d - 65 : d - 97 < 26 ? d - 97 : 36) >= 36 || c > p((u - y) / s)) && g("overflow"), y += c * s, !(c < (l = o <= v ? 1 : o >= v + 26 ? 26 : o - v)); o += 36) s > p(u / (h = 36 - l)) && g("overflow"), s *= h;
          v = w(y - a, t = f.length + 1, 0 == a), p(y / t) > u - b && g("overflow"), b += p(y / t), y %= t, f.splice(y++, 0, b)
        }
        return _(f)
      }

      function T(e) {
        var t, r, n, i, a, s, o, c, l, h, d, m, y, _, S, T = [];
        for (m = (e = b(e)).length, t = 128, r = 0, a = 72, s = 0; s < m; ++s)(d = e[s]) < 128 && T.push(f(d));
        for (n = i = T.length, i && T.push("-"); n < m;) {
          for (o = u, s = 0; s < m; ++s)(d = e[s]) >= t && d < o && (o = d);
          for (o - t > p((u - r) / (y = n + 1)) && g("overflow"), r += (o - t) * y, t = o, s = 0; s < m; ++s)
            if ((d = e[s]) < t && ++r > u && g("overflow"), d == t) {
              for (c = r, l = 36; !(c < (h = l <= a ? 1 : l >= a + 26 ? 26 : l - a)); l += 36) S = c - h, _ = 36 - h, T.push(f(v(h + S % _, 0))), c = p(S / _);
              T.push(f(v(c, 0))), a = w(r, y, n == i), r = 0, ++n
            }++ r, ++t
        }
        return T.join("")
      }
      o = {
        version: "1.4.1",
        ucs2: {
          decode: b,
          encode: _
        },
        decode: S,
        encode: T,
        toASCII: function(e) {
          return y(e, (function(e) {
            return l.test(e) ? "xn--" + T(e) : e
          }))
        },
        toUnicode: function(e) {
          return y(e, (function(e) {
            return c.test(e) ? S(e.slice(4).toLowerCase()) : e
          }))
        }
      }, void 0 === (i = function() {
        return o
      }.call(t, r, t, e)) || (e.exports = i)
    }()
  }).call(this, r(101)(e), r(10))
}, function(e, t, r) {
  "use strict";
  e.exports = {
    isString: function(e) {
      return "string" == typeof e
    },
    isObject: function(e) {
      return "object" == typeof e && null !== e
    },
    isNull: function(e) {
      return null === e
    },
    isNullOrUndefined: function(e) {
      return null == e
    }
  }
}, function(e, t) {
  e.exports = function() {
    for (var e = {}, t = 0; t < arguments.length; t++) {
      var n = arguments[t];
      for (var i in n) r.call(n, i) && (e[i] = n[i])
    }
    return e
  };
  var r = Object.prototype.hasOwnProperty
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActionObserverHttp = void 0;
  const n = r(0);
  class i extends n.ActionObserver {
    constructor(e) {
      super(e), this.requests = 0, this.bus.subscribeObserver(this)
    }
    onRun(e, t, r) {
      this.requests++
    }
  }
  t.ActionObserverHttp = i
}, function(e, t, r) {
  "use strict";
  (function(e) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.ActorSparqlSerializeStats = void 0;
    const n = r(2),
      i = r(15);
    class a extends i.ActorSparqlSerializeFixedMediaTypes {
      constructor(e) {
        super(e)
      }
      async testHandleChecked(e, t) {
        if (!["bindings", "quads"].includes(e.type)) throw new Error("This actor can only handle bindings streams or quad streams.");
        return !0
      }
      pushHeader(e) {
        const t = ["Result", "Delay (ms)", "HTTP requests"].join(",");
        e.push(t + "\n")
      }
      pushStat(e, t, r) {
        const n = [r, this.delay(t), this.httpObserver.requests].join(",");
        e.push(n + "\n")
      }
      pushFooter(e, t) {
        const r = ["TOTAL", this.delay(t), this.httpObserver.requests].join(",");
        e.push(r + "\n"), e.push(null)
      }
      async runHandle(t, r, i) {
        const a = new n.Readable;
        a._read = () => {};
        const s = "bindings" === t.type ? t.bindingsStream : t.quadStream,
          o = e.hrtime();
        let u = 1;
        return this.pushHeader(a), s.on("error", e => a.emit("error", e)), s.on("data", () => this.pushStat(a, o, u++)), s.on("end", () => this.pushFooter(a, o)), {
          data: a
        }
      }
      delay(t) {
        const r = e.hrtime(t);
        return 1e3 * r[0] + r[1] / 1e6
      }
    }
    t.ActorSparqlSerializeStats = a
  }).call(this, r(8))
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.MediatorRace = void 0;
  const n = r(0);
  class i extends n.Mediator {
    constructor(e) {
      super(e)
    }
    mediateWith(e, t) {
      return new Promise((e, r) => {
        const n = [];
        for (const i of t) i.reply.then(() => {
          e(i.actor)
        }).catch(e => {
          n.push(e), n.length === t.length && r(new Error(`${this.name} mediated over all rejecting actors:\n${n.map(e=>e.message).join("\n")}`))
        })
      })
    }
  }
  t.MediatorRace = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(261), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfJoinSymmetricHash = void 0;
  const n = r(1),
    i = r(55),
    a = r(130);
  class s extends i.ActorRdfJoin {
    constructor(e) {
      super(e, 2)
    }
    static hash(e, t) {
      return t.filter(t => e.has(t)).map(t => e.get(t).value).join("")
    }
    async getOutput(e) {
      const t = i.ActorRdfJoin.overlappingVariables(e);
      return {
        type: "bindings",
        bindingsStream: new a.SymmetricHashJoin(e.entries[0].bindingsStream, e.entries[1].bindingsStream, e => s.hash(e, t), i.ActorRdfJoin.join),
        variables: i.ActorRdfJoin.joinVariables(e),
        canContainUndefs: !1
      }
    }
    async getIterations(e) {
      return (await n.getMetadata(e.entries[0])).totalItems + (await n.getMetadata(e.entries[1])).totalItems
    }
  }
  t.ActorRdfJoinSymmetricHash = s
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfJoin = void 0;
  const n = r(0),
    i = r(3);
  class a extends n.Actor {
    constructor(e, t, r, n) {
      super(e), this.limitEntries = null != t ? t : 1 / 0, this.limitEntriesMin = null != r && r, this.canHandleUndefs = null != n && n
    }
    static overlappingVariables(e) {
      const t = e.entries.map(e => e.variables);
      let r = t[0];
      for (const e of t.slice(1)) r = r.filter(t => e.includes(t));
      return r
    }
    static joinVariables(e) {
      const t = e.entries.map(e => e.variables).reduce((e, t) => [...e, ...t], []);
      return [...new Set(t)]
    }
    static join(...e) {
      try {
        return e.reduce((e, t) => e.mergeWith((e, t) => {
          if (!e.equals(t)) throw new Error("Join failure");
          return e
        }, t))
      } catch (e) {
        return null
      }
    }
    static async iteratorsHaveMetadata(e, t) {
      return Promise.all(e.entries.map(async e => {
        if (!e.metadata) throw new Error("Missing metadata");
        const r = await e.metadata();
        if (!(t in r)) throw new Error("Missing metadata value")
      })).then(() => !0).catch(() => !1)
    }
    async test(e) {
      if (e.entries.length <= 1) return {
        iterations: 0
      };
      if (this.limitEntriesMin ? e.entries.length < this.limitEntries : e.entries.length > this.limitEntries) throw new Error(`${this.name} requires ${this.limitEntries} sources at ${this.limitEntriesMin?"least":"most"}. The input contained ${e.entries.length}.`);
      for (const t of e.entries)
        if ("bindings" !== t.type) throw new Error(`Invalid type of a join entry: Expected 'bindings' but got '${t.type}'`);
      if (!this.canHandleUndefs)
        for (const t of e.entries)
          if (t.canContainUndefs) throw new Error(`Actor ${this.name} can not join streams containing undefs`);
      return await a.iteratorsHaveMetadata(e, "totalItems") ? {
        iterations: await this.getIterations(e)
      } : {
        iterations: 1 / 0
      }
    }
    async run(e) {
      if (0 === e.entries.length) return {
        bindingsStream: new i.ArrayIterator([], {
          autoStart: !1
        }),
        metadata: () => Promise.resolve({
          totalItems: 0
        }),
        type: "bindings",
        variables: [],
        canContainUndefs: !1
      };
      if (1 === e.entries.length) return e.entries[0];
      const t = this.getOutput(e);

      function r() {
        return Promise.all(e.entries.map(e => e.metadata())).then(e => e.reduce((e, t) => e * t.totalItems, 1))
      }
      if (await a.iteratorsHaveMetadata(e, "totalItems")) {
        const e = await t;
        if (e.metadata) {
          const t = e.metadata;
          e.metadata = () => t().then(async e => ("totalItems" in e || (e.totalItems = await r()), e))
        } else e.metadata = () => r().then(e => ({
          totalItems: e
        }));
        return e
      }
      return t
    }
  }
  t.ActorRdfJoin = a
}, function(e, t, r) {
  let n = r(3),
    i = n.MultiTransformIterator,
    a = n.SimpleTransformIterator;
  e.exports = class extends i {
    constructor(e, t, r) {
      super(e), this.funRight = t, this.funJoin = r
    }
    _createTransformer(e) {
      return new a(this.funRight(e), {
        transform: (t, r) => {
          let n = this.funJoin(e, t);
          null !== n && this._push(n), r()
        }
      })
    }
  }
}, function(e, t, r) {
  let n = r(3).AsyncIterator;
  e.exports = class extends n {
    constructor(e, t, r, n) {
      super(), this.addedDataListener = !1, this.left = e, this.right = t, this.funHash = r, this.funJoin = n, this.leftMap = new Map, this.match = null, this.matches = [], this.matchIdx = 0, this.readable = !1, this.left.on("end", function() {
        if (this.leftMap.size <= 0) return this.close();
        this.readable = !0, this.right.on("readable", () => this.readable = !0), this.right.on("end", () => {
          this.hasResults() || this._end()
        })
      }.bind(this)), this.on("newListener", e => {
        "data" !== e || this.addedDataListener || (this.addedDataListener = !0, this._addDataListener())
      })
    }
    hasResults() {
      return !this.right.ended || this.matchIdx < this.matches.length
    }
    close() {
      super.close(), this.left.close(), this.right.close()
    }
    read() {
      if (this.addedDataListener || (this.addedDataListener = !0, this._addDataListener()), this.ended || !this.readable) return null;
      for (; this.matchIdx < this.matches.length;) {
        let e = this.matches[this.matchIdx++],
          t = this.funJoin(e, this.match);
        if (null !== t) return t
      }
      if (this.hasResults() || this._end(), this.match = this.right.read(), null === this.match) return this.readable = !1, null;
      let e = this.funHash(this.match);
      return this.matches = this.leftMap.get(e) || [], this.matchIdx = 0, this.read()
    }
    _addDataListener() {
      this.left.on("data", function(e) {
        let t = this.funHash(e);
        this.leftMap.has(t) || this.leftMap.set(t, []);
        this.leftMap.get(t).push(e)
      }.bind(this))
    }
  }
}, function(e, t, r) {
  let n = r(3),
    i = n.MultiTransformIterator,
    a = n.SimpleTransformIterator;
  e.exports = class extends i {
    constructor(e, t, r, n) {
      super(e, n), this.right = t, this.funJoin = r, this.on("end", () => this.right.close())
    }
    close() {
      super.close(), this.right.close()
    }
    _createTransformer(e) {
      return new a(this.right.clone(), {
        transform: (t, r) => {
          let n = this.funJoin(e, t);
          null !== n && this._push(n), r()
        }
      })
    }
  }
}, function(e, t, r) {
  let n = r(3).AsyncIterator;
  e.exports = class extends n {
    constructor(e, t, r, n) {
      super(), this.left = e, this.right = t, this.funHash = r, this.funJoin = n, this.usedLeft = !1, this.leftMap = new Map, this.rightMap = new Map, this.on("end", () => this._cleanup()), this.match = null, this.matches = [], this.matchIdx = 0, (this.left.readable || this.right.readable) && (this.readable = !0), this.left.on("readable", () => this.readable = !0), this.right.on("readable", () => this.readable = !0), this.left.on("end", () => {
        this.hasResults() || this._end()
      }), this.right.on("end", () => {
        this.hasResults() || this._end()
      })
    }
    hasResults() {
      return !this.left.ended || !this.right.ended || this.matchIdx < this.matches.length
    }
    _cleanup() {
      this.leftMap = null, this.rightMap = null, this.matches = null
    }
    close() {
      super.close(), this.left.close(), this.right.close()
    }
    read() {
      if (this.ended) return null;
      for (; this.matchIdx < this.matches.length;) {
        let e = this.matches[this.matchIdx++],
          t = this.usedLeft ? this.funJoin(this.match, e) : this.funJoin(e, this.match);
        if (null !== t) return t
      }
      this.hasResults() || this._end();
      let e = null;
      for (let t = 0; t < 2 && (e = this.usedLeft ? this.right.read() : this.left.read(), this.usedLeft = !this.usedLeft, null === e); ++t);
      if (null === e) return this.readable = !1, null;
      let t = this.funHash(e),
        r = this.usedLeft ? this.leftMap : this.rightMap;
      return r.has(t) || r.set(t, []), r.get(t).push(e), this.match = e, this.matches = (this.usedLeft ? this.rightMap : this.leftMap).get(t) || [], this.matchIdx = 0, this.read()
    }
  }
}, function(e, t, r) {
  let n = r(3).AsyncIterator;
  e.exports = class extends n {
    constructor(e) {
      super(), Array.isArray(e) || (e = Array.prototype.slice.call(arguments)), this.streams = e;
      for (let t of e) t.on("readable", () => this.emit("readable")), t.on("end", () => this._removeStream(t));
      0 === this.streams.length && this.close(), this.idx = this.streams.length - 1
    }
    _removeStream(e) {
      let t = this.streams.indexOf(e);
      t < 0 || (this.streams.splice(t, 1), this.idx >= this.streams.length && --this.idx, 0 === this.streams.length && this._end())
    }
    close() {
      super.close();
      for (let e of this.streams) e.close()
    }
    read() {
      for (let e = 0; e < this.streams.length; ++e) {
        this.idx = (this.idx + 1) % this.streams.length;
        let e = this.streams[this.idx].read();
        if (null !== e) return e
      }
      return null
    }
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(269), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfJoinNestedLoop = void 0;
  const n = r(1),
    i = r(55),
    a = r(130);
  class s extends i.ActorRdfJoin {
    constructor(e) {
      super(e, 2, void 0, !0)
    }
    async getOutput(e) {
      return {
        type: "bindings",
        bindingsStream: new a.NestedLoopJoin(e.entries[0].bindingsStream, e.entries[1].bindingsStream, i.ActorRdfJoin.join, {
          autoStart: !1
        }),
        variables: i.ActorRdfJoin.joinVariables(e),
        canContainUndefs: e.entries.reduce((e, t) => e || t.canContainUndefs, !1)
      }
    }
    async getIterations(e) {
      return (await n.getMetadata(e.entries[0])).totalItems * (await n.getMetadata(e.entries[1])).totalItems
    }
  }
  t.ActorRdfJoinNestedLoop = s
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.MediatorCombineUnion = void 0;
  const n = r(0);
  class i extends n.Mediator {
    constructor(e) {
      super(e), this.combiner = this.createCombiner()
    }
    async mediate(e) {
      let t;
      try {
        t = this.publish(e)
      } catch (e) {
        t = []
      }
      await Promise.all(t.map(({
                                 reply: e
                               }) => e));
      const r = await Promise.all(t.map(t => t.actor.runObservable(e)));
      return this.combiner(r)
    }
    mediateWith() {
      throw new Error("Method not supported.")
    }
    createCombiner() {
      return e => {
        const t = {};
        return t[this.field] = {}, [{}].concat(e.map(e => e[this.field])).forEach((e, r, n) => {
          t[this.field] = Object.assign(Object.assign({}, e), t[this.field])
        }), t
      }
    }
  }
  t.MediatorCombineUnion = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(272), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfParseN3 = void 0;
  const n = r(46),
    i = r(41);
  class a extends n.ActorRdfParseFixedMediaTypes {
    constructor(e) {
      super(e)
    }
    async runHandle(e, t, r) {
      e.input.on("error", e => n.emit("error", e));
      const n = e.input.pipe(new i.StreamParser({
        baseIRI: e.baseIRI
      }));
      return {
        quads: n,
        triples: "text/turtle" === t || "application/n-triples" === t || "text/n3" === t
      }
    }
  }
  t.ActorRdfParseN3 = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfParse = void 0;
  const n = r(34);
  class i extends n.ActorAbstractMediaTyped {
    constructor(e) {
      super(e)
    }
  }
  t.ActorRdfParse = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfParseFixedMediaTypes = void 0;
  const n = r(34);
  class i extends n.ActorAbstractMediaTypedFixed {
    constructor(e) {
      super(e)
    }
    async testHandleChecked(e) {
      return !0
    }
  }
  t.ActorRdfParseFixedMediaTypes = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(276), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfParseRdfXml = void 0;
  const n = r(46),
    i = r(277);
  class a extends n.ActorRdfParseFixedMediaTypes {
    constructor(e) {
      super(e)
    }
    async runHandle(e, t, r) {
      e.input.on("error", e => n.emit("error", e));
      const n = e.input.pipe(new i.RdfXmlParser({
        baseIRI: e.baseIRI
      }));
      return {
        quads: n,
        triples: !0
      }
    }
  }
  t.ActorRdfParseRdfXml = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }),
    function(e) {
      for (var r in e) t.hasOwnProperty(r) || (t[r] = e[r])
    }(r(278))
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  const n = r(13),
    i = r(131),
    a = r(2),
    s = r(280),
    o = r(5);
  class u extends a.Transform {
    constructor(e) {
      super({
        readableObjectMode: !0
      }), this.activeTagStack = [], this.nodeIds = {}, e && (Object.assign(this, e), this.options = e), this.dataFactory || (this.dataFactory = new o.DataFactory), this.baseIRI || (this.baseIRI = ""), this.defaultGraph || (this.defaultGraph = this.dataFactory.defaultGraph()), this.saxStream = i.createStream(this.strict, {
        xmlns: !1,
        position: this.trackPosition
      }), this.strict || (this.saxStream._parser.looseCase = "toString"), this.attachSaxListeners()
    }
    static parseNamespace(e, t) {
      const r = {};
      let n = !1;
      for (const t in e.attributes) t.startsWith("xmlns") && (5 === t.length ? (n = !0, r[""] = e.attributes[t]) : ":" === t.charAt(5) && (n = !0, r[t.substr(6)] = e.attributes[t]));
      const i = t && t.ns ? t.ns : [u.DEFAULT_NS];
      return n ? i.concat([r]) : i
    }
    static expandPrefixedTerm(e, t, r) {
      const n = e.indexOf(":");
      let i, a;
      n >= 0 ? (i = e.substr(0, n), a = e.substr(n + 1)) : (i = "", a = e);
      let o = null,
        u = null;
      for (let e = t.length - 1; e >= 0; e--) {
        const r = t[e][i];
        if (r) {
          o = r;
          break
        }
        u || (u = t[e][""])
      }
      if (!o) {
        if (i && "xmlns" !== i) throw new s.ParseError(r, `The prefix '${i}' in term '${e}' was not bound.`);
        o = u || ""
      }
      return {
        prefix: i,
        local: a,
        uri: o
      }
    }
    static isValidIri(e) {
      return u.IRI_REGEX.test(e)
    }
    import(e) {
      const t = new a.PassThrough({
        readableObjectMode: !0
      });
      e.on("error", e => r.emit("error", e)), e.on("data", e => t.push(e)), e.on("end", () => t.push(null));
      const r = t.pipe(new u(this.options));
      return r
    }
    _transform(e, t, r) {
      try {
        this.saxStream.write(e, t)
      } catch (e) {
        return r(e)
      }
      r()
    }
    newParseError(e) {
      return new s.ParseError(this, e)
    }
    valueToUri(e, t) {
      return this.uriToNamedNode(n.resolve(e, t.baseIRI))
    }
    uriToNamedNode(e) {
      if (!u.isValidIri(e)) throw this.newParseError("Invalid URI: " + e);
      return this.dataFactory.namedNode(e)
    }
    validateNcname(e) {
      if (!u.NCNAME_MATCHER.test(e)) throw this.newParseError("Not a valid NCName: " + e)
    }
    attachSaxListeners() {
      this.saxStream.on("error", e => this.emit("error", e)), this.saxStream.on("opentag", this.onTag.bind(this)), this.saxStream.on("text", this.onText.bind(this)), this.saxStream.on("closetag", this.onCloseTag.bind(this)), this.saxStream.on("doctype", this.onDoctype.bind(this))
    }
    onTag(e) {
      const t = this.activeTagStack.length ? this.activeTagStack[this.activeTagStack.length - 1] : null;
      let r = c.RESOURCE;
      if (t && (t.hadChildren = !0, r = t.childrenParseType), t && t.childrenStringTags) {
        const r = e.name;
        let n = "";
        for (const t in e.attributes) n += ` ${t}="${e.attributes[t]}"`;
        const i = `<${`${r}${n}`}>`;
        t.childrenStringTags.push(i);
        const a = {
          childrenStringTags: t.childrenStringTags
        };
        return a.childrenStringEmitClosingTag = `</${r}>`, void this.activeTagStack.push(a)
      }
      const n = {};
      t ? (n.language = t.language, n.baseIRI = t.baseIRI) : n.baseIRI = this.baseIRI, this.activeTagStack.push(n), n.ns = u.parseNamespace(e, t), r === c.RESOURCE ? this.onTagResource(e, n, t, !t) : this.onTagProperty(e, n, t)
    }
    onTagResource(e, t, r, i) {
      const a = u.expandPrefixedTerm(e.name, t.ns, this);
      t.childrenParseType = c.PROPERTY;
      let s = !0;
      if (a.uri === u.RDF) {
        if (!i && u.FORBIDDEN_NODE_ELEMENTS.indexOf(a.local) >= 0) throw this.newParseError("Illegal node element name: " + a.local);
        switch (a.local) {
          case "RDF":
            t.childrenParseType = c.RESOURCE;
          case "Description":
            s = !1
        }
      }
      const o = [],
        l = [];
      let h = null,
        d = !1,
        p = !1,
        f = null;
      for (const i in e.attributes) {
        const a = e.attributes[i],
          s = u.expandPrefixedTerm(i, t.ns, this);
        if (r && s.uri === u.RDF) switch (s.local) {
          case "about":
            if (h) throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, while ${a} and ${h} where found.`);
            h = a;
            continue;
          case "ID":
            if (h) throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, while ${a} and ${h} where found.`);
            this.validateNcname(a), h = "#" + a, d = !0;
            continue;
          case "nodeID":
            if (h) throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, while ${a} and ${h} where found.`);
            this.validateNcname(a), h = a, p = !0;
            continue;
          case "bagID":
            throw this.newParseError("rdf:bagID is not supported.");
          case "type":
            f = a;
            continue;
          case "aboutEach":
            throw this.newParseError("rdf:aboutEach is not supported.");
          case "aboutEachPrefix":
            throw this.newParseError("rdf:aboutEachPrefix is not supported.");
          case "li":
            throw this.newParseError("rdf:li on node elements are not supported.")
        } else if (s.uri === u.XML) {
          if ("lang" === s.local) {
            t.language = "" === a ? null : a.toLowerCase();
            continue
          }
          if ("base" === s.local) {
            t.baseIRI = n.resolve(a, t.baseIRI);
            continue
          }
        }
        "xml" !== s.prefix && s.uri && (o.push(this.uriToNamedNode(s.uri + s.local)), l.push(a))
      }
      if (null !== h && (t.subject = p ? this.dataFactory.blankNode(h) : this.valueToUri(h, t), d && this.claimNodeId(t.subject)), t.subject || (t.subject = this.dataFactory.blankNode()), s) {
        const e = this.uriToNamedNode(a.uri + a.local);
        this.emitTriple(t.subject, this.dataFactory.namedNode(u.RDF + "type"), e, r ? r.reifiedStatementId : null)
      }
      if (r) {
        if (r.predicate)
          if (r.childrenCollectionSubject) {
            const e = this.dataFactory.blankNode();
            this.emitTriple(r.childrenCollectionSubject, r.childrenCollectionPredicate, e, r.reifiedStatementId), this.emitTriple(e, this.dataFactory.namedNode(u.RDF + "first"), t.subject, t.reifiedStatementId), r.childrenCollectionSubject = e, r.childrenCollectionPredicate = this.dataFactory.namedNode(u.RDF + "rest")
          } else {
            this.emitTriple(r.subject, r.predicate, t.subject, r.reifiedStatementId);
            for (let e = 0; e < r.predicateSubPredicates.length; e++) this.emitTriple(t.subject, r.predicateSubPredicates[e], r.predicateSubObjects[e], null);
            r.predicateSubPredicates = [], r.predicateSubObjects = [], r.predicateEmitted = !0
          } for (let e = 0; e < o.length; e++) {
          const n = this.dataFactory.literal(l[e], t.datatype || t.language);
          this.emitTriple(t.subject, o[e], n, r.reifiedStatementId)
        }
        f && this.emitTriple(t.subject, this.dataFactory.namedNode(u.RDF + "type"), this.uriToNamedNode(f), null)
      }
    }
    onTagProperty(e, t, r) {
      const n = u.expandPrefixedTerm(e.name, t.ns, this);
      if (t.childrenParseType = c.RESOURCE, t.subject = r.subject, n.uri === u.RDF && "li" === n.local ? (r.listItemCounter || (r.listItemCounter = 1), t.predicate = this.uriToNamedNode(n.uri + "_" + r.listItemCounter++)) : t.predicate = this.uriToNamedNode(n.uri + n.local), n.uri === u.RDF && u.FORBIDDEN_PROPERTY_ELEMENTS.indexOf(n.local) >= 0) throw this.newParseError("Illegal property element name: " + n.local);
      t.predicateSubPredicates = [], t.predicateSubObjects = [];
      let i = !1,
        a = !1,
        s = null,
        o = !0;
      const l = [],
        h = [];
      for (const r in e.attributes) {
        const n = e.attributes[r],
          d = u.expandPrefixedTerm(r, t.ns, this);
        if (d.uri === u.RDF) switch (d.local) {
          case "resource":
            if (s) throw this.newParseError(`Found both rdf:resource (${n}) and rdf:nodeID (${s}).`);
            if (i) throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:resource (${n})`);
            t.hadChildren = !0, s = n, o = !1;
            continue;
          case "datatype":
            if (a) throw this.newParseError(`Found both non-rdf:* property attributes and rdf:datatype (${n}).`);
            if (i) throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${n})`);
            t.datatype = this.valueToUri(n, t);
            continue;
          case "nodeID":
            if (a) throw this.newParseError(`Found both non-rdf:* property attributes and rdf:nodeID (${n}).`);
            if (t.hadChildren) throw this.newParseError(`Found both rdf:resource and rdf:nodeID (${n}).`);
            if (i) throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID (${n})`);
            this.validateNcname(n), t.hadChildren = !0, s = n, o = !0;
            continue;
          case "bagID":
            throw this.newParseError("rdf:bagID is not supported.");
          case "parseType":
            if (a) throw this.newParseError("rdf:parseType is not allowed when non-rdf:* property attributes are present");
            if (t.datatype) throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${t.datatype.value})`);
            if (s) throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID or rdf:resource (${s})`);
            if ("Resource" === n) {
              i = !0, t.childrenParseType = c.PROPERTY;
              const e = this.dataFactory.blankNode();
              this.emitTriple(t.subject, t.predicate, e, t.reifiedStatementId), t.subject = e, t.predicate = null
            } else "Collection" === n ? (i = !0, t.hadChildren = !0, t.childrenCollectionSubject = t.subject, t.childrenCollectionPredicate = t.predicate, o = !1) : "Literal" === n && (i = !0, t.childrenTagsToString = !0, t.childrenStringTags = []);
            continue;
          case "ID":
            this.validateNcname(n), t.reifiedStatementId = this.valueToUri("#" + n, t), this.claimNodeId(t.reifiedStatementId);
            continue
        } else if (d.uri === u.XML && "lang" === d.local) {
          t.language = "" === n ? null : n.toLowerCase();
          continue
        } if ("xml" !== d.prefix && "xmlns" !== d.prefix && d.uri) {
          if (i || t.datatype) throw this.newParseError("Found illegal rdf:* properties on property element with attribute: " + n);
          t.hadChildren = !0, a = !0, l.push(this.uriToNamedNode(d.uri + d.local)), h.push(this.dataFactory.literal(n, t.datatype || t.language))
        }
      }
      if (null !== s) {
        const e = t.subject;
        t.subject = o ? this.dataFactory.blankNode(s) : this.valueToUri(s, t), this.emitTriple(e, t.predicate, t.subject, t.reifiedStatementId);
        for (let e = 0; e < l.length; e++) this.emitTriple(t.subject, l[e], h[e], null);
        t.predicateEmitted = !0
      } else o && (t.predicateSubPredicates = l, t.predicateSubObjects = h, t.predicateEmitted = !1)
    }
    emitTriple(e, t, r, n) {
      this.push(this.dataFactory.quad(e, t, r, this.defaultGraph)), n && (this.push(this.dataFactory.quad(n, this.dataFactory.namedNode(u.RDF + "type"), this.dataFactory.namedNode(u.RDF + "Statement"), this.defaultGraph)), this.push(this.dataFactory.quad(n, this.dataFactory.namedNode(u.RDF + "subject"), e, this.defaultGraph)), this.push(this.dataFactory.quad(n, this.dataFactory.namedNode(u.RDF + "predicate"), t, this.defaultGraph)), this.push(this.dataFactory.quad(n, this.dataFactory.namedNode(u.RDF + "object"), r, this.defaultGraph)))
    }
    claimNodeId(e) {
      if (!this.allowDuplicateRdfIds) {
        if (this.nodeIds[e.value]) throw this.newParseError(`Found multiple occurrences of rdf:ID='${e.value}'.`);
        this.nodeIds[e.value] = !0
      }
    }
    onText(e) {
      const t = this.activeTagStack.length ? this.activeTagStack[this.activeTagStack.length - 1] : null;
      t && (t.childrenStringTags ? t.childrenStringTags.push(e) : t.predicate && (t.text = e))
    }
    onCloseTag() {
      const e = this.activeTagStack.pop();
      if (e.childrenStringEmitClosingTag && e.childrenStringTags.push(e.childrenStringEmitClosingTag), e.childrenTagsToString && (e.datatype = this.dataFactory.namedNode(u.RDF + "XMLLiteral"), e.text = e.childrenStringTags.join(""), e.hadChildren = !1), e.childrenCollectionSubject) this.emitTriple(e.childrenCollectionSubject, e.childrenCollectionPredicate, this.dataFactory.namedNode(u.RDF + "nil"), e.reifiedStatementId);
      else if (e.predicate)
        if (e.hadChildren || e.childrenParseType === c.PROPERTY) {
          if (!e.predicateEmitted) {
            const t = this.dataFactory.blankNode();
            this.emitTriple(e.subject, e.predicate, t, e.reifiedStatementId);
            for (let r = 0; r < e.predicateSubPredicates.length; r++) this.emitTriple(t, e.predicateSubPredicates[r], e.predicateSubObjects[r], null)
          }
        } else this.emitTriple(e.subject, e.predicate, this.dataFactory.literal(e.text || "", e.datatype || e.language), e.reifiedStatementId)
    }
    onDoctype(e) {
      e.replace(/<!ENTITY\s+([^\s]+)\s+["']([^"']+)["']\s*>/g, (e, t, r) => (this.saxStream._parser.ENTITIES[t] = r, ""))
    }
  }
  var c;
  t.RdfXmlParser = u, u.IRI_REGEX = /^([A-Za-z][A-Za-z0-9+-.]*):[^ "<>{}|\\\[\]`]*$/, u.MIME_TYPE = "application/rdf+xml", u.RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#", u.XML = "http://www.w3.org/XML/1998/namespace", u.XMLNS = "http://www.w3.org/2000/xmlns/", u.DEFAULT_NS = {
    xml: u.XML
  }, u.FORBIDDEN_NODE_ELEMENTS = ["RDF", "ID", "about", "bagID", "parseType", "resource", "nodeID", "li", "aboutEach", "aboutEachPrefix"], u.FORBIDDEN_PROPERTY_ELEMENTS = ["Description", "RDF", "ID", "about", "bagID", "parseType", "resource", "nodeID", "aboutEach", "aboutEachPrefix"], u.NCNAME_MATCHER = /^([A-Za-z\xC0-\xD6\xD8-\xF6\u{F8}-\u{2FF}\u{370}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}_])([A-Za-z\xC0-\xD6\xD8-\xF6\u{F8}-\u{2FF}\u{370}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}_\-.0-9#xB7\u{0300}-\u{036F}\u{203F}-\u{2040}])*$/u,
    function(e) {
      e[e.RESOURCE = 0] = "RESOURCE", e[e.PROPERTY = 1] = "PROPERTY"
    }(c = t.ParseType || (t.ParseType = {}))
}, function(e, t, r) {
  "use strict";

  function n(e) {
    const t = [];
    let r = 0;
    for (; r < e.length;) switch (e[r]) {
      case "/":
        if ("." === e[r + 1])
          if ("." === e[r + 2]) {
            if (!a(e[r + 3])) {
              t.push([]), r++;
              break
            }
            t.pop(), e[r + 3] || t.push([]), r += 3
          } else {
            if (!a(e[r + 2])) {
              t.push([]), r++;
              break
            }
            e[r + 2] || t.push([]), r += 2
          }
        else t.push([]), r++;
        break;
      case "#":
      case "?":
        t.length || t.push([]), t[t.length - 1].push(e.substr(r)), r = e.length;
        break;
      default:
        t.length || t.push([]), t[t.length - 1].push(e[r]), r++
    }
    return "/" + t.map(e => e.join("")).join("/")
  }

  function i(e, t) {
    let r = t + 1;
    t >= 0 ? "/" === e[t + 1] && "/" === e[t + 2] && (r = t + 3) : "/" === e[0] && "/" === e[1] && (r = 2);
    const i = e.indexOf("/", r);
    if (i < 0) return e;
    return e.substr(0, i) + n(e.substr(i))
  }

  function a(e) {
    return !e || "#" === e || "?" === e || "/" === e
  }
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.resolve = function(e, t) {
    const r = (t = t || "").indexOf("#");
    if (r > 0 && (t = t.substr(0, r)), !e.length) {
      if (t.indexOf(":") < 0) throw new Error(`Found invalid baseIRI '${t}' for value '${e}'`);
      return t
    }
    if (e.startsWith("?")) {
      const r = t.indexOf("?");
      return r > 0 && (t = t.substr(0, r)), t + e
    }
    if (e.startsWith("#")) return t + e;
    if (!t.length) {
      const t = e.indexOf(":");
      if (t < 0) throw new Error(`Found invalid relative IRI '${e}' for a missing baseIRI`);
      return i(e, t)
    }
    const a = e.indexOf(":");
    if (a >= 0) return i(e, a);
    const s = t.indexOf(":");
    if (s < 0) throw new Error(`Found invalid baseIRI '${t}' for value '${e}'`);
    const o = t.substr(0, s + 1);
    if (0 === e.indexOf("//")) return o + i(e, a);
    let u;
    if (t.indexOf("//", s) === s + 1) {
      if (u = t.indexOf("/", s + 3), u < 0) return t.length > s + 3 ? t + "/" + i(e, a) : o + i(e, a)
    } else if (u = t.indexOf("/", s + 1), u < 0) return o + i(e, a);
    if (0 === e.indexOf("/")) return t.substr(0, u) + n(e);
    let c = t.substr(u);
    const l = c.lastIndexOf("/");
    return l >= 0 && l < c.length - 1 && (c = c.substr(0, l + 1), "." === e[0] && "." !== e[1] && "/" !== e[1] && e[2] && (e = e.substr(1))), e = n(e = c + e), t.substr(0, u) + e
  }, t.removeDotSegments = n, t.removeDotSegmentsOfPath = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  class n extends Error {
    constructor(e, t) {
      const r = e.saxStream._parser;
      super(e.trackPosition ? `Line ${r.line+1} column ${r.column+1}: ${t}` : t)
    }
  }
  t.ParseError = n
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(282), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfParseXmlRdfa = void 0;
  const n = r(46),
    i = r(283);
  class a extends n.ActorRdfParseFixedMediaTypes {
    constructor(e) {
      super(e)
    }
    async runHandle(e, t, r) {
      var n;
      const a = null !== (n = e.headers && e.headers.get("content-language")) && void 0 !== n ? n : void 0;
      e.input.on("error", e => s.emit("error", e));
      const s = e.input.pipe(new i.RdfaParser({
        baseIRI: e.baseIRI,
        profile: "xml",
        language: a
      }));
      return {
        quads: s,
        triples: !0
      }
    }
  }
  t.ActorRdfParseXmlRdfa = a
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(284), t), i(r(285), t), i(r(286), t), i(r(287), t), i(r(79), t), i(r(139), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.RdfaParser = void 0;
  const n = r(288),
    i = r(2),
    a = r(301),
    s = r(302),
    o = r(79),
    u = r(139);
  class c extends i.Transform {
    constructor(e) {
      super({
        readableObjectMode: !0
      }), this.activeTagStack = [], e = e || {}, this.options = e, this.util = new u.Util(e.dataFactory, e.baseIRI), this.defaultGraph = e.defaultGraph || this.util.dataFactory.defaultGraph();
      const t = e.contentType ? u.Util.contentTypeToProfile(e.contentType) : e.profile || "";
      this.features = e.features || o.RDFA_FEATURES[t], this.htmlParseListener = e.htmlParseListener, this.rdfaPatterns = this.features.copyRdfaPatterns ? {} : null, this.pendingRdfaPatternCopies = this.features.copyRdfaPatterns ? {} : null, this.parser = this.initializeParser("xml" === t), this.activeTagStack.push({
        incompleteTriples: [],
        inlist: !1,
        language: e.language,
        listMapping: {},
        listMappingLocal: {},
        name: "",
        prefixesAll: Object.assign(Object.assign({}, s["@context"]), this.features.xhtmlInitialContext ? a["@context"] : {}),
        prefixesCustom: {},
        skipElement: !1,
        vocab: e.vocab
      })
    }
    import(e) {
      const t = new i.PassThrough({
        readableObjectMode: !0
      });
      e.on("error", e => r.emit("error", e)), e.on("data", e => t.push(e)), e.on("end", () => t.push(null));
      const r = t.pipe(new c(this.options));
      return r
    }
    _transform(e, t, r) {
      this.parser.write(e), r()
    }
    _flush(e) {
      this.parser.end(), e()
    }
    onTagOpen(e, t) {
      let r = this.activeTagStack.length - 1;
      for (; r > 0 && this.activeTagStack[r].skipElement;) r--;
      let n = this.activeTagStack[r];
      r !== this.activeTagStack.length - 1 && (n = Object.assign(Object.assign({}, n), {
        language: this.activeTagStack[this.activeTagStack.length - 1].language,
        prefixesAll: this.activeTagStack[this.activeTagStack.length - 1].prefixesAll,
        prefixesCustom: this.activeTagStack[this.activeTagStack.length - 1].prefixesCustom,
        vocab: this.activeTagStack[this.activeTagStack.length - 1].vocab
      }));
      const i = {
        collectChildTags: n.collectChildTags,
        incompleteTriples: [],
        inlist: "inlist" in t,
        listMapping: [],
        listMappingLocal: n.listMapping,
        localBaseIRI: n.localBaseIRI,
        name: e,
        prefixesAll: null,
        prefixesCustom: null,
        skipElement: !1
      };
      if (this.activeTagStack.push(i), i.collectChildTags) {
        for (const e of Object.keys(n.prefixesCustom).sort()) {
          const r = n.prefixesCustom[e],
            i = "" === e ? "xmlns" : "xmlns:" + e;
          i in t || (t[i] = r)
        }
        const r = Object.keys(t).map(e => `${e}="${t[e]}"`).join(" ");
        if (i.text = [`<${e}${r?" "+r:""}>`], this.features.skipHandlingXmlLiteralChildren) return
      }
      let a, s, o, c = !0,
        l = !0;
      if (this.features.onlyAllowUriRelRevIfProperty && ("property" in t && "rel" in t && (c = !1, t.rel.indexOf(":") < 0 && delete t.rel), "property" in t && "rev" in t && (l = !1, t.rev.indexOf(":") < 0 && delete t.rev)), this.features.copyRdfaPatterns) {
        if (n.collectedPatternTag) {
          const r = {
            attributes: t,
            children: [],
            name: e,
            referenced: !1,
            rootPattern: !1,
            text: []
          };
          return n.collectedPatternTag.children.push(r), void(i.collectedPatternTag = r)
        }
        if ("rdfa:Pattern" === t.typeof) return void(i.collectedPatternTag = {
          attributes: t,
          children: [],
          name: e,
          parentTag: n,
          referenced: !1,
          rootPattern: !0,
          text: []
        });
        if ("rdfa:copy" === t.property) {
          const e = t.resource || t.href || t.src;
          return void(this.rdfaPatterns[e] ? this.emitPatternCopy(n, this.rdfaPatterns[e], e) : (this.pendingRdfaPatternCopies[e] || (this.pendingRdfaPatternCopies[e] = []), this.pendingRdfaPatternCopies[e].push(n)))
        }
      }
      if (this.features.baseTag && "base" === e && t.href && (this.util.baseIRI = this.util.getBaseIRI(t.href)), this.features.xmlBase && t["xml:base"] && (i.localBaseIRI = this.util.getBaseIRI(t["xml:base"])), this.features.timeTag && "time" === e && !t.datatype && (i.interpretObjectAsTime = !0), "vocab" in t ? t.vocab ? (i.vocab = t.vocab, this.emitTriple(this.util.getBaseIriTerm(i), this.util.dataFactory.namedNode(u.Util.RDFA + "usesVocabulary"), this.util.dataFactory.namedNode(i.vocab))) : i.vocab = this.activeTagStack[0].vocab : i.vocab = n.vocab, i.prefixesCustom = u.Util.parsePrefixes(t, n.prefixesCustom, this.features.xmlnsPrefixMappings), i.prefixesAll = Object.keys(i.prefixesCustom).length > 0 ? Object.assign(Object.assign({}, n.prefixesAll), i.prefixesCustom) : n.prefixesAll, this.features.roleAttribute && t.role) {
        const e = t.id ? this.util.createIri("#" + t.id, i, !1, !1, !1) : this.util.createBlankNode(),
          r = i.vocab;
        i.vocab = "http://www.w3.org/1999/xhtml/vocab#";
        for (const r of this.util.createVocabIris(t.role, i, !0, !1)) this.emitTriple(e, this.util.dataFactory.namedNode("http://www.w3.org/1999/xhtml/vocab#role"), r);
        i.vocab = r
      }
      "xml:lang" in t || this.features.langAttribute && "lang" in t ? i.language = t["xml:lang"] || t.lang : i.language = n.language;
      const h = 2 === this.activeTagStack.length;
      if ("rel" in t || "rev" in t ? ("about" in t ? (a = this.util.createIri(t.about, i, !1, !0, !0), i.explicitNewSubject = !!a, "typeof" in t && (o = a)) : h ? a = !0 : n.object && (a = n.object), "resource" in t && (s = this.util.createIri(t.resource, i, !1, !0, !0)), s || ("href" in t || "src" in t ? s = this.util.createIri(t.href || t.src, i, !1, !1, !0) : !("typeof" in t) || "about" in t || this.isInheritSubjectInHeadBody(e) || (s = this.util.createBlankNode())), "typeof" in t && !("about" in t) && (o = this.isInheritSubjectInHeadBody(e) ? a : s)) : !("property" in t) || "content" in t || "datatype" in t ? (("about" in t || "resource" in t) && (a = this.util.createIri(t.about || t.resource, i, !1, !0, !0), i.explicitNewSubject = !!a), a || !("href" in t) && !("src" in t) || (a = this.util.createIri(t.href || t.src, i, !1, !1, !0), i.explicitNewSubject = !!a), a || (h ? a = !0 : this.isInheritSubjectInHeadBody(e) ? a = n.object : "typeof" in t ? (a = this.util.createBlankNode(), i.explicitNewSubject = !0) : n.object && (a = n.object, "property" in t || (i.skipElement = !0))), "typeof" in t && (o = a)) : ("about" in t ? (a = this.util.createIri(t.about, i, !1, !0, !0), i.explicitNewSubject = !!a) : h ? a = !0 : n.object && (a = n.object), "typeof" in t && ("about" in t && (o = this.util.createIri(t.about, i, !1, !0, !0)), !o && h && (o = !0), !o && "resource" in t && (o = this.util.createIri(t.resource, i, !1, !0, !0)), o || !("href" in t) && !("src" in t) || (o = this.util.createIri(t.href || t.src, i, !1, !1, !0)), !o && this.isInheritSubjectInHeadBody(e) && (o = a), o || (o = this.util.createBlankNode()), s = o)), o)
        for (const e of this.util.createVocabIris(t.typeof, i, !0, !0)) this.emitTriple(this.util.getResourceOrBaseIri(o, i), this.util.dataFactory.namedNode(u.Util.RDF + "type"), e);
      if (a && (i.listMapping = {}), s) {
        if ("rel" in t && "inlist" in t)
          for (const e of this.util.createVocabIris(t.rel, i, c, !1)) this.addListMapping(i, a, e, s);
        if (!("rel" in t) || !("inlist" in t)) {
          if ("rel" in t)
            for (const e of this.util.createVocabIris(t.rel, i, c, !1)) this.emitTriple(this.util.getResourceOrBaseIri(a, i), e, this.util.getResourceOrBaseIri(s, i));
          if ("rev" in t)
            for (const e of this.util.createVocabIris(t.rev, i, l, !1)) this.emitTriple(this.util.getResourceOrBaseIri(s, i), e, this.util.getResourceOrBaseIri(a, i))
        }
      }
      if (!s) {
        if ("rel" in t)
          if ("inlist" in t)
            for (const e of this.util.createVocabIris(t.rel, i, c, !1)) this.addListMapping(i, a, e, null), i.incompleteTriples.push({
              predicate: e,
              reverse: !1,
              list: !0
            });
          else
            for (const e of this.util.createVocabIris(t.rel, i, c, !1)) i.incompleteTriples.push({
              predicate: e,
              reverse: !1
            });
        if ("rev" in t)
          for (const e of this.util.createVocabIris(t.rev, i, l, !1)) i.incompleteTriples.push({
            predicate: e,
            reverse: !0
          });
        i.incompleteTriples.length > 0 && (s = this.util.createBlankNode())
      }
      if ("property" in t) {
        let e;
        if (i.predicates = this.util.createVocabIris(t.property, i, !0, !1), "datatype" in t ? (i.datatype = this.util.createIri(t.datatype, i, !0, !0, !1), i.datatype && (i.datatype.value === u.Util.RDF + "XMLLiteral" || this.features.htmlDatatype && i.datatype.value === u.Util.RDF + "HTML") && (i.collectChildTags = !0)) : ("rev" in t || "rel" in t || "content" in t || ("resource" in t && (e = this.util.createIri(t.resource, i, !1, !0, !0)), !e && "href" in t && (e = this.util.createIri(t.href, i, !1, !1, !0)), !e && "src" in t && (e = this.util.createIri(t.src, i, !1, !1, !0))), "typeof" in t && !("about" in t) && (e = o)), "content" in t) {
          const e = this.util.createLiteral(t.content, i);
          if ("inlist" in t)
            for (const t of i.predicates) this.addListMapping(i, a, t, e);
          else {
            const t = this.util.getResourceOrBaseIri(a, i);
            for (const r of i.predicates) this.emitTriple(t, r, e)
          }
          i.predicates = null
        } else if (this.features.datetimeAttribute && "datetime" in t) {
          i.interpretObjectAsTime = !0;
          const e = this.util.createLiteral(t.datetime, i);
          if ("inlist" in t)
            for (const t of i.predicates) this.addListMapping(i, a, t, e);
          else {
            const t = this.util.getResourceOrBaseIri(a, i);
            for (const r of i.predicates) this.emitTriple(t, r, e)
          }
          i.predicates = null
        } else if (e) {
          const r = this.util.getResourceOrBaseIri(e, i);
          if ("inlist" in t)
            for (const e of i.predicates) this.addListMapping(i, a, e, r);
          else {
            const e = this.util.getResourceOrBaseIri(a, i);
            for (const t of i.predicates) this.emitTriple(e, t, r)
          }
          i.predicates = null
        }
      }
      let d = !1;
      if (!i.skipElement && a && n.incompleteTriples.length > 0) {
        d = !0;
        const e = this.util.getResourceOrBaseIri(n.subject, i),
          t = this.util.getResourceOrBaseIri(a, i);
        for (const r of n.incompleteTriples)
          if (r.reverse) this.emitTriple(t, r.predicate, e);
          else if (r.list) {
            let e = null;
            for (let t = this.activeTagStack.length - 1; t >= 0; t--)
              if (this.activeTagStack[t].inlist) {
                e = this.activeTagStack[t];
                break
              } this.addListMapping(e, a, r.predicate, t)
          } else this.emitTriple(e, r.predicate, t)
      }!d && n.incompleteTriples.length > 0 && (i.incompleteTriples = i.incompleteTriples.concat(n.incompleteTriples)), i.subject = a || n.subject, i.object = s || a
    }
    onText(e) {
      const t = this.activeTagStack[this.activeTagStack.length - 1];
      this.features.copyRdfaPatterns && t.collectedPatternTag ? t.collectedPatternTag.text.push(e) : (t.text || (t.text = []), t.text.push(e))
    }
    onTagClose() {
      const e = this.activeTagStack[this.activeTagStack.length - 1],
        t = this.activeTagStack[this.activeTagStack.length - 2];
      if (!(e.collectChildTags && t.collectChildTags && this.features.skipHandlingXmlLiteralChildren)) {
        if (this.features.copyRdfaPatterns && e.collectedPatternTag && e.collectedPatternTag.rootPattern) {
          const t = e.collectedPatternTag.attributes.resource;
          if (delete e.collectedPatternTag.attributes.resource, delete e.collectedPatternTag.attributes.typeof, this.rdfaPatterns[t] = e.collectedPatternTag, this.pendingRdfaPatternCopies[t]) {
            for (const r of this.pendingRdfaPatternCopies[t]) this.emitPatternCopy(r, e.collectedPatternTag, t);
            delete this.pendingRdfaPatternCopies[t]
          }
          return void this.activeTagStack.pop()
        }
        if (e.predicates) {
          const r = this.util.getResourceOrBaseIri(e.subject, e);
          let n = e.text || [];
          e.collectChildTags && t.collectChildTags && (n = n.slice(1));
          const i = this.util.createLiteral(n.join(""), e);
          if (e.inlist)
            for (const t of e.predicates) this.addListMapping(e, r, t, i);
          else
            for (const t of e.predicates) this.emitTriple(r, t, i);
          t.predicates || (e.text = null)
        }
        if (e.object && Object.keys(e.listMapping).length > 0) {
          const t = this.util.getResourceOrBaseIri(e.object, e);
          for (const r in e.listMapping) {
            const n = this.util.dataFactory.namedNode(r),
              i = e.listMapping[r];
            if (i.length > 0) {
              const r = i.map(() => this.util.createBlankNode());
              for (let t = 0; t < i.length; t++) {
                const n = this.util.getResourceOrBaseIri(i[t], e);
                this.emitTriple(r[t], this.util.dataFactory.namedNode(u.Util.RDF + "first"), n), this.emitTriple(r[t], this.util.dataFactory.namedNode(u.Util.RDF + "rest"), t < i.length - 1 ? r[t + 1] : this.util.dataFactory.namedNode(u.Util.RDF + "nil"))
              }
              this.emitTriple(t, n, r[0])
            } else this.emitTriple(t, n, this.util.dataFactory.namedNode(u.Util.RDF + "nil"))
          }
        }
      }
      this.activeTagStack.pop(), e.collectChildTags && e.text && e.text.push(`</${e.name}>`), e.text && t && (t.text ? t.text = t.text.concat(e.text) : t.text = e.text)
    }
    onEnd() {
      if (this.features.copyRdfaPatterns) {
        this.features.copyRdfaPatterns = !1;
        for (const e in this.rdfaPatterns) {
          const t = this.rdfaPatterns[e];
          t.referenced || (t.attributes.typeof = "rdfa:Pattern", t.attributes.resource = e, this.emitPatternCopy(t.parentTag, t, e), t.referenced = !1, delete t.attributes.typeof, delete t.attributes.resource)
        }
        for (const e in this.pendingRdfaPatternCopies)
          for (const t of this.pendingRdfaPatternCopies[e]) this.activeTagStack.push(t), this.onTagOpen("link", {
            property: "rdfa:copy",
            href: e
          }), this.onTagClose(), this.activeTagStack.pop();
        this.features.copyRdfaPatterns = !0
      }
    }
    isInheritSubjectInHeadBody(e) {
      return this.features.inheritSubjectInHeadBody && ("head" === e || "body" === e)
    }
    addListMapping(e, t, r, n) {
      if (e.explicitNewSubject) {
        const i = this.util.createBlankNode();
        this.emitTriple(this.util.getResourceOrBaseIri(t, e), r, i), this.emitTriple(i, this.util.dataFactory.namedNode(u.Util.RDF + "first"), this.util.getResourceOrBaseIri(n, e)), this.emitTriple(i, this.util.dataFactory.namedNode(u.Util.RDF + "rest"), this.util.dataFactory.namedNode(u.Util.RDF + "nil"))
      } else {
        let t = e.listMappingLocal[r.value];
        t || (e.listMappingLocal[r.value] = t = []), n && t.push(n)
      }
    }
    emitTriple(e, t, r) {
      "NamedNode" === e.termType && e.value.indexOf(":") < 0 || "NamedNode" === t.termType && t.value.indexOf(":") < 0 || "NamedNode" === r.termType && r.value.indexOf(":") < 0 || this.push(this.util.dataFactory.quad(e, t, r, this.defaultGraph))
    }
    emitPatternCopy(e, t, r) {
      if (this.activeTagStack.push(e), t.referenced = !0, t.constructedBlankNodes) {
        let e = 0;
        this.util.blankNodeFactory = () => t.constructedBlankNodes[e++]
      } else t.constructedBlankNodes = [], this.util.blankNodeFactory = () => {
        const e = this.util.dataFactory.blankNode();
        return t.constructedBlankNodes.push(e), e
      };
      this.emitPatternCopyAbsolute(t, !0, r), this.util.blankNodeFactory = null, this.activeTagStack.pop()
    }
    emitPatternCopyAbsolute(e, t, r) {
      if (t || "rdfa:copy" !== e.attributes.property || e.attributes.href !== r) {
        this.onTagOpen(e.name, e.attributes);
        for (const t of e.text) this.onText(t);
        for (const t of e.children) this.emitPatternCopyAbsolute(t, !1, r);
        this.onTagClose()
      }
    }
    initializeParser(e) {
      return new n.Parser({
        onclosetag: () => {
          try {
            this.onTagClose(), this.htmlParseListener && this.htmlParseListener.onTagClose()
          } catch (e) {
            this.emit("error", e)
          }
        },
        onend: () => {
          try {
            this.onEnd(), this.htmlParseListener && this.htmlParseListener.onEnd()
          } catch (e) {
            this.emit("error", e)
          }
        },
        onopentag: (e, t) => {
          try {
            this.onTagOpen(e, t), this.htmlParseListener && this.htmlParseListener.onTagOpen(e, t)
          } catch (e) {
            this.emit("error", e)
          }
        },
        ontext: e => {
          try {
            this.onText(e), this.htmlParseListener && this.htmlParseListener.onText(e)
          } catch (e) {
            this.emit("error", e)
          }
        }
      }, {
        decodeEntities: !0,
        recognizeSelfClosing: !0,
        xmlMode: e
      })
    }
  }
  t.RdfaParser = c
}, function(e, t, r) {
  "use strict";

  function n(e) {
    for (var r in e) t.hasOwnProperty(r) || (t[r] = e[r])
  }
  var i = this && this.__importStar || function(e) {
    if (e && e.__esModule) return e;
    var t = {};
    if (null != e)
      for (var r in e) Object.hasOwnProperty.call(e, r) && (t[r] = e[r]);
    return t.default = e, t
  };
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  var a = r(132);
  t.Parser = a.Parser;
  var s = r(58);
  t.DomHandler = s.DomHandler, t.DefaultHandler = s.DomHandler, t.parseDOM = function(e, t) {
    var r = new s.DomHandler(void 0, t);
    return new a.Parser(r, t).end(e), r.dom
  }, t.createDomStream = function(e, t, r) {
    var n = new s.DomHandler(e, t, r);
    return new a.Parser(n, t)
  };
  var o = r(133);
  t.Tokenizer = o.default;
  var u = i(r(59));
  t.ElementType = u, t.EVENTS = {
    attribute: 2,
    cdatastart: 0,
    cdataend: 0,
    text: 1,
    processinginstruction: 2,
    comment: 1,
    commentend: 0,
    closetag: 1,
    opentag: 2,
    opentagname: 1,
    error: 1,
    end: 0
  }, n(r(135)), n(r(298)), n(r(299));
  var c = i(r(60));
  t.DomUtils = c;
  var l = r(135);
  t.RssHandler = l.FeedHandler
}, function(e) {
  e.exports = JSON.parse('{"0":65533,"128":8364,"130":8218,"131":402,"132":8222,"133":8230,"134":8224,"135":8225,"136":710,"137":8240,"138":352,"139":8249,"140":338,"142":381,"145":8216,"146":8217,"147":8220,"148":8221,"149":8226,"150":8211,"151":8212,"152":732,"153":8482,"154":353,"155":8250,"156":339,"158":382,"159":376}')
}, function(e, t, r) {
  "use strict";
  var n = this && this.__importDefault || function(e) {
    return e && e.__esModule ? e : {
      default: e
    }
  };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.getText = t.getInnerHTML = t.getOuterHTML = void 0;
  var i = r(37),
    a = n(r(291));

  function s(e, t) {
    return a.default(e, t)
  }
  t.getOuterHTML = s, t.getInnerHTML = function(e, t) {
    return i.hasChildren(e) ? e.children.map((function(e) {
      return s(e, t)
    })).join("") : ""
  }, t.getText = function e(t) {
    return Array.isArray(t) ? t.map(e).join("") : i.isTag(t) ? "br" === t.name ? "\n" : e(t.children) : i.isCDATA(t) ? e(t.children) : i.isText(t) ? t.data : ""
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__assign || function() {
      return (n = Object.assign || function(e) {
        for (var t, r = 1, n = arguments.length; r < n; r++)
          for (var i in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
        return e
      }).apply(this, arguments)
    },
    i = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    a = this && this.__setModuleDefault || (Object.create ? function(e, t) {
      Object.defineProperty(e, "default", {
        enumerable: !0,
        value: t
      })
    } : function(e, t) {
      e.default = t
    }),
    s = this && this.__importStar || function(e) {
      if (e && e.__esModule) return e;
      var t = {};
      if (null != e)
        for (var r in e) "default" !== r && Object.prototype.hasOwnProperty.call(e, r) && i(t, e, r);
      return a(t, e), t
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  var o = s(r(59)),
    u = r(292),
    c = r(293),
    l = new Set(["style", "script", "xmp", "iframe", "noembed", "noframes", "plaintext", "noscript"]);
  var h = new Set(["area", "base", "basefont", "br", "col", "command", "embed", "frame", "hr", "img", "input", "isindex", "keygen", "link", "meta", "param", "source", "track", "wbr"]);

  function d(e, t) {
    void 0 === t && (t = {});
    for (var r = Array.isArray(e) || e.cheerio ? e : [e], n = "", i = 0; i < r.length; i++) n += p(r[i], t);
    return n
  }

  function p(e, t) {
    switch (e.type) {
      case "root":
        return d(e.children, t);
      case o.Directive:
        return "<" + e.data + ">";
      case o.Comment:
        return function(e) {
          return "\x3c!--" + e.data + "--\x3e"
        }(e);
      case o.CDATA:
        return function(e) {
          return "<![CDATA[" + e.children[0].data + "]]>"
        }(e);
      default:
        return o.isTag(e) ? function(e, t) {
          var r;
          "foreign" === t.xmlMode && (e.name = null !== (r = c.elementNames.get(e.name)) && void 0 !== r ? r : e.name, e.parent && f.has(e.parent.name) && (t = n(n({}, t), {
            xmlMode: !1
          })));
          !t.xmlMode && g.has(e.name) && (t = n(n({}, t), {
            xmlMode: "foreign"
          }));
          var i = "<" + e.name,
            a = function(e, t) {
              if (e) return Object.keys(e).map((function(r) {
                var n, i, a = null !== (n = e[r]) && void 0 !== n ? n : "";
                return "foreign" === t.xmlMode && (r = null !== (i = c.attributeNames.get(r)) && void 0 !== i ? i : r), t.emptyAttrs || t.xmlMode || "" !== a ? r + '="' + (t.decodeEntities ? u.encodeXML(a) : a.replace(/"/g, "&quot;")) + '"' : r
              })).join(" ")
            }(e.attribs, t);
          a && (i += " " + a);
          0 === e.children.length && (t.xmlMode ? !1 !== t.selfClosingTags : t.selfClosingTags && h.has(e.name)) ? (t.xmlMode || (i += " "), i += "/>") : (i += ">", e.children.length > 0 && (i += d(e.children, t)), !t.xmlMode && h.has(e.name) || (i += "</" + e.name + ">"));
          return i
        }(e, t) : function(e, t) {
          var r = e.data || "";
          !t.decodeEntities || e.parent && l.has(e.parent.name) || (r = u.encodeXML(r));
          return r
        }(e, t)
    }
  }
  t.default = d;
  var f = new Set(["mi", "mo", "mn", "ms", "mtext", "annotation-xml", "foreignObject", "desc", "title"]),
    g = new Set(["svg", "math"])
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.encode = t.decodeStrict = t.decode = void 0;
  var n = r(136),
    i = r(137);
  t.decode = function(e, t) {
    return (!t || t <= 0 ? n.decodeXML : n.decodeHTML)(e)
  }, t.decodeStrict = function(e, t) {
    return (!t || t <= 0 ? n.decodeXML : n.decodeHTMLStrict)(e)
  }, t.encode = function(e, t) {
    return (!t || t <= 0 ? i.encodeXML : i.encodeHTML)(e)
  };
  var a = r(137);
  Object.defineProperty(t, "encodeXML", {
    enumerable: !0,
    get: function() {
      return a.encodeXML
    }
  }), Object.defineProperty(t, "encodeHTML", {
    enumerable: !0,
    get: function() {
      return a.encodeHTML
    }
  }), Object.defineProperty(t, "escape", {
    enumerable: !0,
    get: function() {
      return a.escape
    }
  }), Object.defineProperty(t, "encodeHTML4", {
    enumerable: !0,
    get: function() {
      return a.encodeHTML
    }
  }), Object.defineProperty(t, "encodeHTML5", {
    enumerable: !0,
    get: function() {
      return a.encodeHTML
    }
  });
  var s = r(136);
  Object.defineProperty(t, "decodeXML", {
    enumerable: !0,
    get: function() {
      return s.decodeXML
    }
  }), Object.defineProperty(t, "decodeHTML", {
    enumerable: !0,
    get: function() {
      return s.decodeHTML
    }
  }), Object.defineProperty(t, "decodeHTMLStrict", {
    enumerable: !0,
    get: function() {
      return s.decodeHTMLStrict
    }
  }), Object.defineProperty(t, "decodeHTML4", {
    enumerable: !0,
    get: function() {
      return s.decodeHTML
    }
  }), Object.defineProperty(t, "decodeHTML5", {
    enumerable: !0,
    get: function() {
      return s.decodeHTML
    }
  }), Object.defineProperty(t, "decodeHTML4Strict", {
    enumerable: !0,
    get: function() {
      return s.decodeHTMLStrict
    }
  }), Object.defineProperty(t, "decodeHTML5Strict", {
    enumerable: !0,
    get: function() {
      return s.decodeHTMLStrict
    }
  }), Object.defineProperty(t, "decodeXMLStrict", {
    enumerable: !0,
    get: function() {
      return s.decodeXML
    }
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.attributeNames = t.elementNames = void 0, t.elementNames = new Map([
    ["altglyph", "altGlyph"],
    ["altglyphdef", "altGlyphDef"],
    ["altglyphitem", "altGlyphItem"],
    ["animatecolor", "animateColor"],
    ["animatemotion", "animateMotion"],
    ["animatetransform", "animateTransform"],
    ["clippath", "clipPath"],
    ["feblend", "feBlend"],
    ["fecolormatrix", "feColorMatrix"],
    ["fecomponenttransfer", "feComponentTransfer"],
    ["fecomposite", "feComposite"],
    ["feconvolvematrix", "feConvolveMatrix"],
    ["fediffuselighting", "feDiffuseLighting"],
    ["fedisplacementmap", "feDisplacementMap"],
    ["fedistantlight", "feDistantLight"],
    ["fedropshadow", "feDropShadow"],
    ["feflood", "feFlood"],
    ["fefunca", "feFuncA"],
    ["fefuncb", "feFuncB"],
    ["fefuncg", "feFuncG"],
    ["fefuncr", "feFuncR"],
    ["fegaussianblur", "feGaussianBlur"],
    ["feimage", "feImage"],
    ["femerge", "feMerge"],
    ["femergenode", "feMergeNode"],
    ["femorphology", "feMorphology"],
    ["feoffset", "feOffset"],
    ["fepointlight", "fePointLight"],
    ["fespecularlighting", "feSpecularLighting"],
    ["fespotlight", "feSpotLight"],
    ["fetile", "feTile"],
    ["feturbulence", "feTurbulence"],
    ["foreignobject", "foreignObject"],
    ["glyphref", "glyphRef"],
    ["lineargradient", "linearGradient"],
    ["radialgradient", "radialGradient"],
    ["textpath", "textPath"]
  ]), t.attributeNames = new Map([
    ["definitionurl", "definitionURL"],
    ["attributename", "attributeName"],
    ["attributetype", "attributeType"],
    ["basefrequency", "baseFrequency"],
    ["baseprofile", "baseProfile"],
    ["calcmode", "calcMode"],
    ["clippathunits", "clipPathUnits"],
    ["diffuseconstant", "diffuseConstant"],
    ["edgemode", "edgeMode"],
    ["filterunits", "filterUnits"],
    ["glyphref", "glyphRef"],
    ["gradienttransform", "gradientTransform"],
    ["gradientunits", "gradientUnits"],
    ["kernelmatrix", "kernelMatrix"],
    ["kernelunitlength", "kernelUnitLength"],
    ["keypoints", "keyPoints"],
    ["keysplines", "keySplines"],
    ["keytimes", "keyTimes"],
    ["lengthadjust", "lengthAdjust"],
    ["limitingconeangle", "limitingConeAngle"],
    ["markerheight", "markerHeight"],
    ["markerunits", "markerUnits"],
    ["markerwidth", "markerWidth"],
    ["maskcontentunits", "maskContentUnits"],
    ["maskunits", "maskUnits"],
    ["numoctaves", "numOctaves"],
    ["pathlength", "pathLength"],
    ["patterncontentunits", "patternContentUnits"],
    ["patterntransform", "patternTransform"],
    ["patternunits", "patternUnits"],
    ["pointsatx", "pointsAtX"],
    ["pointsaty", "pointsAtY"],
    ["pointsatz", "pointsAtZ"],
    ["preservealpha", "preserveAlpha"],
    ["preserveaspectratio", "preserveAspectRatio"],
    ["primitiveunits", "primitiveUnits"],
    ["refx", "refX"],
    ["refy", "refY"],
    ["repeatcount", "repeatCount"],
    ["repeatdur", "repeatDur"],
    ["requiredextensions", "requiredExtensions"],
    ["requiredfeatures", "requiredFeatures"],
    ["specularconstant", "specularConstant"],
    ["specularexponent", "specularExponent"],
    ["spreadmethod", "spreadMethod"],
    ["startoffset", "startOffset"],
    ["stddeviation", "stdDeviation"],
    ["stitchtiles", "stitchTiles"],
    ["surfacescale", "surfaceScale"],
    ["systemlanguage", "systemLanguage"],
    ["tablevalues", "tableValues"],
    ["targetx", "targetX"],
    ["targety", "targetY"],
    ["textlength", "textLength"],
    ["viewbox", "viewBox"],
    ["viewtarget", "viewTarget"],
    ["xchannelselector", "xChannelSelector"],
    ["ychannelselector", "yChannelSelector"],
    ["zoomandpan", "zoomAndPan"]
  ])
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.nextElementSibling = t.getName = t.hasAttrib = t.getAttributeValue = t.getSiblings = t.getParent = t.getChildren = void 0;
  var n = r(37),
    i = [];

  function a(e) {
    var t;
    return null !== (t = e.children) && void 0 !== t ? t : i
  }

  function s(e) {
    return e.parent || null
  }
  t.getChildren = a, t.getParent = s, t.getSiblings = function(e) {
    var t = s(e);
    if (null != t) return a(t);
    for (var r = [e], n = e.prev, i = e.next; null != n;) r.unshift(n), n = n.prev;
    for (; null != i;) r.push(i), i = i.next;
    return r
  }, t.getAttributeValue = function(e, t) {
    var r;
    return null === (r = e.attribs) || void 0 === r ? void 0 : r[t]
  }, t.hasAttrib = function(e, t) {
    return null != e.attribs && Object.prototype.hasOwnProperty.call(e.attribs, t) && null != e.attribs[t]
  }, t.getName = function(e) {
    return e.name
  }, t.nextElementSibling = function(e) {
    for (var t = e.next; null !== t && !n.isTag(t);) t = t.next;
    return t
  }
}, function(e, t, r) {
  "use strict";

  function n(e) {
    if (e.prev && (e.prev.next = e.next), e.next && (e.next.prev = e.prev), e.parent) {
      var t = e.parent.children;
      t.splice(t.lastIndexOf(e), 1)
    }
  }
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.prepend = t.prependChild = t.append = t.appendChild = t.replaceElement = t.removeElement = void 0, t.removeElement = n, t.replaceElement = function(e, t) {
    var r = t.prev = e.prev;
    r && (r.next = t);
    var n = t.next = e.next;
    n && (n.prev = t);
    var i = t.parent = e.parent;
    if (i) {
      var a = i.children;
      a[a.lastIndexOf(e)] = t
    }
  }, t.appendChild = function(e, t) {
    if (n(t), t.next = null, t.parent = e, e.children.push(t) > 1) {
      var r = e.children[e.children.length - 2];
      r.next = t, t.prev = r
    } else t.prev = null
  }, t.append = function(e, t) {
    n(t);
    var r = e.parent,
      i = e.next;
    if (t.next = i, t.prev = e, e.next = t, t.parent = r, i) {
      if (i.prev = t, r) {
        var a = r.children;
        a.splice(a.lastIndexOf(i), 0, t)
      }
    } else r && r.children.push(t)
  }, t.prependChild = function(e, t) {
    if (n(t), t.parent = e, t.prev = null, 1 !== e.children.unshift(t)) {
      var r = e.children[1];
      r.prev = t, t.next = r
    } else t.next = null
  }, t.prepend = function(e, t) {
    n(t);
    var r = e.parent;
    if (r) {
      var i = r.children;
      i.splice(i.indexOf(e), 0, t)
    }
    e.prev && (e.prev.next = t), t.parent = r, t.prev = e.prev, t.next = e, e.prev = t
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.getElementsByTagType = t.getElementsByTagName = t.getElementById = t.getElements = t.testElement = void 0;
  var n = r(138),
    i = r(37),
    a = {
      tag_name: function(e) {
        return "function" == typeof e ? function(t) {
          return i.isTag(t) && e(t.name)
        } : "*" === e ? i.isTag : function(t) {
          return i.isTag(t) && t.name === e
        }
      },
      tag_type: function(e) {
        return "function" == typeof e ? function(t) {
          return e(t.type)
        } : function(t) {
          return t.type === e
        }
      },
      tag_contains: function(e) {
        return "function" == typeof e ? function(t) {
          return i.isText(t) && e(t.data)
        } : function(t) {
          return i.isText(t) && t.data === e
        }
      }
    };

  function s(e, t) {
    return "function" == typeof t ? function(r) {
      return i.isTag(r) && t(r.attribs[e])
    } : function(r) {
      return i.isTag(r) && r.attribs[e] === t
    }
  }

  function o(e, t) {
    return function(r) {
      return e(r) || t(r)
    }
  }

  function u(e) {
    var t = Object.keys(e).map((function(t) {
      var r = e[t];
      return t in a ? a[t](r) : s(t, r)
    }));
    return 0 === t.length ? null : t.reduce(o)
  }
  t.testElement = function(e, t) {
    var r = u(e);
    return !r || r(t)
  }, t.getElements = function(e, t, r, i) {
    void 0 === i && (i = 1 / 0);
    var a = u(e);
    return a ? n.filter(a, t, r, i) : []
  }, t.getElementById = function(e, t, r) {
    return void 0 === r && (r = !0), Array.isArray(t) || (t = [t]), n.findOne(s("id", e), t, r)
  }, t.getElementsByTagName = function(e, t, r, i) {
    return void 0 === r && (r = !0), void 0 === i && (i = 1 / 0), n.filter(a.tag_name(e), t, r, i)
  }, t.getElementsByTagType = function(e, t, r, i) {
    return void 0 === r && (r = !0), void 0 === i && (i = 1 / 0), n.filter(a.tag_type(e), t, r, i)
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.uniqueSort = t.compareDocumentPosition = t.removeSubsets = void 0;
  var n = r(37);

  function i(e, t) {
    var r = [],
      i = [];
    if (e === t) return 0;
    for (var a = n.hasChildren(e) ? e : e.parent; a;) r.unshift(a), a = a.parent;
    for (a = n.hasChildren(t) ? t : t.parent; a;) i.unshift(a), a = a.parent;
    for (var s = Math.min(r.length, i.length), o = 0; o < s && r[o] === i[o];) o++;
    if (0 === o) return 1;
    var u = r[o - 1],
      c = u.children,
      l = r[o],
      h = i[o];
    return c.indexOf(l) > c.indexOf(h) ? u === t ? 20 : 4 : u === e ? 10 : 2
  }
  t.removeSubsets = function(e) {
    for (var t = e.length; --t >= 0;) {
      var r = e[t];
      if (t > 0 && e.lastIndexOf(r, t - 1) >= 0) e.splice(t, 1);
      else
        for (var n = r.parent; n; n = n.parent)
          if (e.includes(n)) {
            e.splice(t, 1);
            break
          }
    }
    return e
  }, t.compareDocumentPosition = i, t.uniqueSort = function(e) {
    return (e = e.filter((function(e, t, r) {
      return !r.includes(e, t + 1)
    }))).sort((function(e, t) {
      var r = i(e, t);
      return 2 & r ? -1 : 4 & r ? 1 : 0
    })), e
  }
}, function(e, t) {}, function(e, t, r) {
  "use strict";
  var n, i = this && this.__extends || (n = function(e, t) {
      return (n = Object.setPrototypeOf || {
          __proto__: []
        }
        instanceof Array && function(e, t) {
          e.__proto__ = t
        } || function(e, t) {
          for (var r in t) t.hasOwnProperty(r) && (e[r] = t[r])
        })(e, t)
    }, function(e, t) {
      function r() {
        this.constructor = e
      }
      n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
    }),
    a = this && this.__importDefault || function(e) {
      return e && e.__esModule ? e : {
        default: e
      }
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  var s = function(e) {
    function t(t) {
      void 0 === t && (t = {});
      var r = e.call(this, (function(e) {
        for (var t, n = [], i = 1; i < arguments.length; i++) n[i - 1] = arguments[i];
        r.events.push([e].concat(n)), r._cbs[e] && (t = r._cbs)[e].apply(t, n)
      })) || this;
      return r._cbs = t, r.events = [], r
    }
    return i(t, e), t.prototype.onreset = function() {
      this.events = [], this._cbs.onreset && this._cbs.onreset()
    }, t.prototype.restart = function() {
      var e;
      this._cbs.onreset && this._cbs.onreset();
      for (var t = 0; t < this.events.length; t++) {
        var r = this.events[t],
          n = r[0],
          i = r.slice(1);
        this._cbs[n] && (e = this._cbs)[n].apply(e, i)
      }
    }, t
  }(a(r(300)).default);
  t.CollectingHandler = s
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  var n = function() {
    function e(e) {
      this._func = e
    }
    return e.prototype.onattribute = function(e, t) {
      this._func("onattribute", e, t)
    }, e.prototype.oncdatastart = function() {
      this._func("oncdatastart")
    }, e.prototype.oncdataend = function() {
      this._func("oncdataend")
    }, e.prototype.ontext = function(e) {
      this._func("ontext", e)
    }, e.prototype.onprocessinginstruction = function(e, t) {
      this._func("onprocessinginstruction", e, t)
    }, e.prototype.oncomment = function(e) {
      this._func("oncomment", e)
    }, e.prototype.oncommentend = function() {
      this._func("oncommentend")
    }, e.prototype.onclosetag = function(e) {
      this._func("onclosetag", e)
    }, e.prototype.onopentag = function(e, t) {
      this._func("onopentag", e, t)
    }, e.prototype.onopentagname = function(e) {
      this._func("onopentagname", e)
    }, e.prototype.onerror = function(e) {
      this._func("onerror", e)
    }, e.prototype.onend = function() {
      this._func("onend")
    }, e.prototype.onparserinit = function(e) {
      this._func("onparserinit", e)
    }, e.prototype.onreset = function() {
      this._func("onreset")
    }, e
  }();
  t.default = n
}, function(e) {
  e.exports = JSON.parse('{"@context":{"alternate":"http://www.w3.org/1999/xhtml/vocab#alternate","appendix":"http://www.w3.org/1999/xhtml/vocab#appendix","cite":"http://www.w3.org/1999/xhtml/vocab#cite","bookmark":"http://www.w3.org/1999/xhtml/vocab#bookmark","contents":"http://www.w3.org/1999/xhtml/vocab#contents","chapter":"http://www.w3.org/1999/xhtml/vocab#chapter","copyright":"http://www.w3.org/1999/xhtml/vocab#copyright","first":"http://www.w3.org/1999/xhtml/vocab#first","glossary":"http://www.w3.org/1999/xhtml/vocab#glossary","help":"http://www.w3.org/1999/xhtml/vocab#help","icon":"http://www.w3.org/1999/xhtml/vocab#icon","index":"http://www.w3.org/1999/xhtml/vocab#index","last":"http://www.w3.org/1999/xhtml/vocab#last","license":"http://www.w3.org/1999/xhtml/vocab#license","meta":"http://www.w3.org/1999/xhtml/vocab#meta","next":"http://www.w3.org/1999/xhtml/vocab#next","prev":"http://www.w3.org/1999/xhtml/vocab#prev","previous":"http://www.w3.org/1999/xhtml/vocab#previous","section":"http://www.w3.org/1999/xhtml/vocab#section","start":"http://www.w3.org/1999/xhtml/vocab#start","stylesheet":"http://www.w3.org/1999/xhtml/vocab#stylesheet","subsection":"http://www.w3.org/1999/xhtml/vocab#subsection","top":"http://www.w3.org/1999/xhtml/vocab#top","up":"http://www.w3.org/1999/xhtml/vocab#up","p3pv1":"http://www.w3.org/1999/xhtml/vocab#p3pv1"}}')
}, function(e) {
  e.exports = JSON.parse('{"@context":{"as":"https://www.w3.org/ns/activitystreams#","cat":"http://www.w3.org/ns/dcat#","cc":"http://creativecommons.org/ns#","cnt":"http://www.w3.org/2008/content#","csvw":"http://www.w3.org/ns/csvw#","ctag":"http://commontag.org/ns#","dc":"http://purl.org/dc/terms/","dc11":"http://purl.org/dc/elements/1.1/","dcat":"http://www.w3.org/ns/dcat#","dcterms":"http://purl.org/dc/terms/","dqv":"http://www.w3.org/ns/dqv#","duv":"https://www.w3.org/TR/vocab-duv#","earl":"http://www.w3.org/ns/earl#","foaf":"http://xmlns.com/foaf/0.1/","gldp":"http://www.w3.org/ns/people#","gr":"http://purl.org/goodrelations/v1#","grddl":"http://www.w3.org/2003/g/data-view#","ht":"http://www.w3.org/2006/http#","ical":"http://www.w3.org/2002/12/cal/icaltzd#","ldp":"http://www.w3.org/ns/ldp#","ma":"http://www.w3.org/ns/ma-ont#","oa":"http://www.w3.org/ns/oa#","odrl":"http://www.w3.org/ns/odrl/2/","og":"http://ogp.me/ns#","org":"http://www.w3.org/ns/org#","owl":"http://www.w3.org/2002/07/owl#","prov":"http://www.w3.org/ns/prov#","ptr":"http://www.w3.org/2009/pointers#","qb":"http://purl.org/linked-data/cube#","rev":"http://purl.org/stuff/rev#","rdf":"http://www.w3.org/1999/02/22-rdf-syntax-ns#","rdfa":"http://www.w3.org/ns/rdfa#","rdfs":"http://www.w3.org/2000/01/rdf-schema#","rif":"http://www.w3.org/2007/rif#","rr":"http://www.w3.org/ns/r2rml#","schema":"http://schema.org/","sd":"http://www.w3.org/ns/sparql-service-description#","sioc":"http://rdfs.org/sioc/ns#","skos":"http://www.w3.org/2004/02/skos/core#","skosxl":"http://www.w3.org/2008/05/skos-xl#","ssn":"http://www.w3.org/ns/ssn/","sosa":"http://www.w3.org/ns/sosa/","time":"http://www.w3.org/2006/time#","v":"http://rdf.data-vocabulary.org/#","vcard":"http://www.w3.org/2006/vcard/ns#","void":"http://rdfs.org/ns/void#","wdr":"http://www.w3.org/2007/05/powder#","wdrs":"http://www.w3.org/2007/05/powder-s#","xhv":"http://www.w3.org/1999/xhtml/vocab#","xml":"http://www.w3.org/XML/1998/namespace","xsd":"http://www.w3.org/2001/XMLSchema#","describedby":"http://www.w3.org/2007/05/powder-s#describedby","license":"http://www.w3.org/1999/xhtml/vocab#license","role":"http://www.w3.org/1999/xhtml/vocab#role"}}')
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(304), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfParseHtml = void 0;
  const n = r(2),
    i = r(46),
    a = r(305);
  class s extends i.ActorRdfParseFixedMediaTypes {
    constructor(e) {
      super(e)
    }
    async runHandle(e, t, r) {
      const i = new n.Readable({
        objectMode: !0
      });
      return i._read = async () => {
        i._read = () => {};
        let t = 1;

        function n(e) {
          i.emit("error", e)
        }

        function s() {
          0 == --t && i.push(null)
        }
        const o = {
          baseIRI: e.baseIRI,
          context: r,
          emit: function(e) {
            i.emit("data", e)
          },
          end: s,
          error: n,
          headers: e.headers
        };
        Promise.all(this.busRdfParseHtml.publish(o)).then(async r => {
          t += r.length;
          const i = [];
          for (const e of r) {
            const {
              htmlParseListener: t
            } = await e.actor.run(o);
            i.push(t)
          }
          const u = new a.WritableStream({
            onclosetag() {
              try {
                for (const e of i) e.onTagClose()
              } catch (e) {
                n(e)
              }
            },
            onend() {
              try {
                for (const e of i) e.onEnd()
              } catch (e) {
                n(e)
              }
              s()
            },
            onopentag(e, t) {
              try {
                for (const r of i) r.onTagOpen(e, t)
              } catch (e) {
                n(e)
              }
            },
            ontext(e) {
              try {
                for (const t of i) t.onText(e)
              } catch (e) {
                n(e)
              }
            }
          }, {
            decodeEntities: !0,
            recognizeSelfClosing: !0,
            xmlMode: !1
          });
          e.input.on("error", n), e.input.pipe(u)
        }).catch(n)
      }, {
        quads: i
      }
    }
  }
  t.ActorRdfParseHtml = s
}, function(e, t, r) {
  "use strict";
  var n, i = this && this.__extends || (n = function(e, t) {
    return (n = Object.setPrototypeOf || {
        __proto__: []
      }
      instanceof Array && function(e, t) {
        e.__proto__ = t
      } || function(e, t) {
        for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && (e[r] = t[r])
      })(e, t)
  }, function(e, t) {
    function r() {
      this.constructor = e
    }
    n(e, t), e.prototype = null === t ? Object.create(t) : (r.prototype = t.prototype, new r)
  });
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.WritableStream = void 0;
  var a = r(80),
    s = r(2),
    o = r(33);
  var u = function(e) {
    function t(t, r) {
      var n = e.call(this, {
        decodeStrings: !1
      }) || this;
      return n._decoder = new o.StringDecoder, n._parser = new a.Parser(t, r), n
    }
    return i(t, e), t.prototype._write = function(e, t, r) {
      this._parser.write(function(e, t) {
        return "buffer" === t
      }(0, t) ? this._decoder.write(e) : e), r()
    }, t.prototype._final = function(e) {
      this._parser.end(this._decoder.end()), e()
    }, t
  }(s.Writable);
  t.WritableStream = u
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(307), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfParseHtmlMicrodata = void 0;
  const n = r(81),
    i = r(309);
  class a extends n.ActorRdfParseHtml {
    constructor(e) {
      super(e)
    }
    async test(e) {
      return !0
    }
    async run(e) {
      const t = e.headers ? e.headers.get("content-type") : null,
        r = null == t ? void 0 : t.includes("xml"),
        n = new i.MicrodataRdfParser({
          baseIRI: e.baseIRI,
          xmlMode: r
        });
      n.on("error", e.error), n.on("data", e.emit);
      const a = n.onEnd;
      return n.onEnd = () => {
        a.call(n), e.end()
      }, {
        htmlParseListener: n
      }
    }
  }
  t.ActorRdfParseHtmlMicrodata = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfParseHtml = void 0;
  const n = r(0);
  class i extends n.Actor {
    constructor(e) {
      super(e)
    }
  }
  t.ActorRdfParseHtml = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(310), t), i(r(141), t), i(r(142), t), i(r(143), t), i(r(144), t), i(r(311), t), i(r(312), t), i(r(313), t), i(r(314), t), i(r(61), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.MicrodataRdfParser = void 0;
  const n = r(2),
    i = r(145),
    a = r(141),
    s = r(142),
    o = r(143),
    u = r(144),
    c = r(61),
    l = r(315);
  class h extends n.Transform {
    constructor(e) {
      super({
        readableObjectMode: !0
      }), this.itemScopeStack = [], this.textBufferStack = [], this.isEmittingReferences = !1, this.pendingItemRefsDomain = {}, this.pendingItemRefsRangeFinalized = {}, this.pendingItemRefsRangeCollecting = {}, e = e || {}, this.options = e, this.util = new c.Util(e.dataFactory, e.baseIRI), this.defaultGraph = e.defaultGraph || this.util.dataFactory.defaultGraph(), this.htmlParseListener = e.htmlParseListener, this.vocabRegistry = e.vocabRegistry || l, this.parser = this.initializeParser(!!e.xmlMode)
    }
    import(e) {
      const t = new n.PassThrough({
        readableObjectMode: !0
      });
      e.on("error", e => r.emit("error", e)), e.on("data", e => t.push(e)), e.on("end", () => t.push(null));
      const r = t.pipe(new h(this.options));
      return r
    }
    _transform(e, t, r) {
      this.parser.write(e), r()
    }
    _flush(e) {
      this.parser.end(), e()
    }
    getItemScope(e) {
      let t = this.itemScopeStack.length - (e ? 2 : 1);
      for (; t > 0 && !this.itemScopeStack[t];) t--;
      return this.itemScopeStack[t]
    }
    getDepth() {
      return this.itemScopeStack.length
    }
    onTagOpen(e, t) {
      if (!this.isEmittingReferences) {
        if ("id" in t) {
          const e = t.id;
          this.pendingItemRefsRangeCollecting[e] = {
            events: [],
            counter: 0,
            ids: []
          }
        }
        for (const r of Object.values(this.pendingItemRefsRangeCollecting)) r.counter++, r.events.push({
          type: "open",
          name: e,
          attributes: t
        })
      }
      let r;
      if (this.textBufferStack.push(void 0), "itemscope" in t) {
        let e;
        if (this.emittingReferencesItemScopeIdGenerator) e = this.emittingReferencesItemScopeIdGenerator();
        else {
          e = "itemid" in t && this.util.createSubject(t.itemid) || this.util.dataFactory.blankNode();
          for (const t of Object.values(this.pendingItemRefsRangeCollecting)) t.ids.push(e)
        }
        r = {
          subject: e
        }, this.isEmittingReferences && (r.blockEmission = !0);
        const n = this.getItemScope();
        n && n.vocab && (r.vocab = n.vocab), this.itemScopeStack.push(r)
      } else r = this.getItemScope(), this.itemScopeStack.push(void 0);
      if (r) {
        if ("itemtype" in t)
          for (const e of this.util.createVocabIris(t.itemtype, r, !1)) r.vocab || (r.vocab = this.util.deriveVocab(e.value, this.vocabRegistry)), r.blockEmission || this.emitTriple(r.subject, this.util.dataFactory.namedNode(c.Util.RDF + "type"), e);
        if ("lang" in t && (r.language = t.lang), "xml:lang" in t && (r.language = t["xml:lang"]), "itemscope" in t && !this.isEmittingReferences && "itemref" in t)
          for (const e of t.itemref.split(/\s+/u)) e in this.pendingItemRefsDomain || (this.pendingItemRefsDomain[e] = []), this.pendingItemRefsDomain[e].push(r), this.tryToEmitReferences(e, r)
      }
      "itemprop" in t && this.handleItemProperties(t.itemprop, !1, r, e, t), "itemprop-reverse" in t && this.handleItemProperties(t["itemprop-reverse"], !0, r, e, t)
    }
    onText(e) {
      if (!this.isEmittingReferences)
        for (const t of Object.values(this.pendingItemRefsRangeCollecting)) t.events.push({
          type: "text",
          data: e
        });
      for (const t of this.textBufferStack) t && t.push(e)
    }
    onTagClose() {
      if (!this.isEmittingReferences)
        for (const [e, t] of Object.entries(this.pendingItemRefsRangeCollecting)) t.counter--, t.events.push({
          type: "close"
        }), 0 === t.counter && (this.pendingItemRefsRangeFinalized[e] = t, delete this.pendingItemRefsRangeCollecting[e], this.tryToEmitReferences(e));
      const e = this.getItemScope(!0);
      if (e) {
        const t = this.getDepth();
        if (e.predicates && t in e.predicates)
          for (const [r, n] of Object.entries(e.predicates[t])) {
            const i = this.util.createLiteral(this.textBufferStack[t].join(""), e);
            this.emitPredicateTriples(e, n, i, "reverse" === r), delete e.predicates[t][r]
          }
      }
      this.itemScopeStack.pop(), this.textBufferStack.pop()
    }
    onEnd() {}
    initializeParser(e) {
      return new i.Parser({
        onclosetag: () => {
          try {
            this.onTagClose(), this.htmlParseListener && this.htmlParseListener.onTagClose()
          } catch (e) {
            this.emit("error", e)
          }
        },
        onend: () => {
          try {
            this.onEnd(), this.htmlParseListener && this.htmlParseListener.onEnd()
          } catch (e) {
            this.emit("error", e)
          }
        },
        onopentag: (e, t) => {
          try {
            this.onTagOpen(e, t), this.htmlParseListener && this.htmlParseListener.onTagOpen(e, t)
          } catch (e) {
            this.emit("error", e)
          }
        },
        ontext: e => {
          try {
            this.onText(e), this.htmlParseListener && this.htmlParseListener.onText(e)
          } catch (e) {
            this.emit("error", e)
          }
        }
      }, {
        decodeEntities: !0,
        recognizeSelfClosing: !0,
        xmlMode: e
      })
    }
    handleItemProperties(e, t, r, n, i) {
      const a = this.getItemScope(!0);
      if (a) {
        const s = this.getDepth(),
          o = this.util.createVocabIris(e, a, !0);
        a.predicates || (a.predicates = {}), a.predicates[s] || (a.predicates[s] = {});
        const u = t ? "reverse" : "forward";
        a.predicates[s][u] = o;
        for (const t of this.util.getVocabularyExpansionType(e, a, this.vocabRegistry)) o.push(t);
        if (r && "itemscope" in i) this.emitPredicateTriples(a, o, r.subject, t), delete a.predicates[s][u];
        else
          for (const e of h.ITEM_PROPERTY_HANDLERS)
            if (e.canHandle(n, i)) {
              const r = e.getObject(i, this.util, a);
              this.emitPredicateTriples(a, o, r, t), delete a.predicates[s][u]
            } a.predicates[s][u] && (this.textBufferStack[s] = [])
      }
    }
    emitPredicateTriples(e, t, r, n) {
      if (!e.blockEmission)
        for (const i of t) n ? "Literal" !== r.termType && this.emitTriple(r, i, e.subject) : this.emitTriple(e.subject, i, r)
    }
    emitTriple(e, t, r) {
      this.push(this.util.dataFactory.quad(e, t, r, this.defaultGraph))
    }
    tryToEmitReferences(e, t) {
      const r = this.pendingItemRefsRangeFinalized[e];
      if (r) {
        let n;
        if (t) {
          n = [t];
          const r = this.pendingItemRefsDomain[e].indexOf(t);
          this.pendingItemRefsDomain[e].splice(r, 1)
        } else n = this.pendingItemRefsDomain[e], delete this.pendingItemRefsDomain[e];
        if (n) {
          const e = this.itemScopeStack,
            t = this.textBufferStack;
          this.isEmittingReferences = !0;
          for (const e of n) {
            this.itemScopeStack = [e], this.textBufferStack = [void 0];
            const t = r.ids.slice();
            this.emittingReferencesItemScopeIdGenerator = () => t.shift();
            for (const e of r.events) switch (e.type) {
              case "open":
                this.onTagOpen(e.name, e.attributes);
                break;
              case "text":
                this.onText(e.data);
                break;
              case "close":
                this.onTagClose()
            }
          }
          this.emittingReferencesItemScopeIdGenerator = void 0, this.itemScopeStack = e, this.textBufferStack = t, this.isEmittingReferences = !1
        }
      }
    }
  }
  t.MicrodataRdfParser = h, h.ITEM_PROPERTY_HANDLERS = [new a.ItemPropertyHandlerContent, new u.ItemPropertyHandlerUrl("a", "href"), new u.ItemPropertyHandlerUrl("area", "href"), new u.ItemPropertyHandlerUrl("audio", "src"), new u.ItemPropertyHandlerUrl("embed", "src"), new u.ItemPropertyHandlerUrl("iframe", "src"), new u.ItemPropertyHandlerUrl("img", "src"), new u.ItemPropertyHandlerUrl("link", "href"), new u.ItemPropertyHandlerUrl("object", "data"), new u.ItemPropertyHandlerUrl("source", "src"), new u.ItemPropertyHandlerUrl("track", "src"), new u.ItemPropertyHandlerUrl("video", "src"), new s.ItemPropertyHandlerNumber("data", "value"), new s.ItemPropertyHandlerNumber("meter", "value"), new o.ItemPropertyHandlerTime]
}, function(e) {
  e.exports = JSON.parse('{"http://schema.org/":{"properties":{"additionalType":{"subPropertyOf":"http://www.w3.org/1999/02/22-rdf-syntax-ns#type"}}},"http://microformats.org/profile/hcard":{}}')
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(317), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfParseHtmlRdfa = void 0;
  const n = r(81),
    i = r(318);
  class a extends n.ActorRdfParseHtml {
    constructor(e) {
      super(e)
    }
    async test(e) {
      return !0
    }
    async run(e) {
      var t;
      const r = e.headers ? e.headers.get("content-type") : null,
        n = null !== (t = e.headers && e.headers.get("content-language")) && void 0 !== t ? t : void 0,
        a = r && r.includes("xml") ? "xhtml" : "html",
        s = new i.RdfaParser({
          baseIRI: e.baseIRI,
          profile: a,
          language: n
        });
      s.on("error", e.error), s.on("data", e.emit);
      const o = s.onEnd;
      return s.onEnd = () => {
        o.call(s), e.end()
      }, {
        htmlParseListener: s
      }
    }
  }
  t.ActorRdfParseHtmlRdfa = a
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(319), t), i(r(320), t), i(r(321), t), i(r(322), t), i(r(82), t), i(r(147), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.RdfaParser = void 0;
  const n = r(145),
    i = r(2),
    a = r(323),
    s = r(324),
    o = r(82),
    u = r(147);
  class c extends i.Transform {
    constructor(e) {
      super({
        readableObjectMode: !0
      }), this.activeTagStack = [], e = e || {}, this.options = e, this.util = new u.Util(e.dataFactory, e.baseIRI), this.defaultGraph = e.defaultGraph || this.util.dataFactory.defaultGraph();
      const t = e.contentType ? u.Util.contentTypeToProfile(e.contentType) : e.profile || "";
      this.features = e.features || o.RDFA_FEATURES[t], this.htmlParseListener = e.htmlParseListener, this.rdfaPatterns = this.features.copyRdfaPatterns ? {} : null, this.pendingRdfaPatternCopies = this.features.copyRdfaPatterns ? {} : null, this.parser = this.initializeParser("xml" === t), this.activeTagStack.push({
        incompleteTriples: [],
        inlist: !1,
        language: e.language,
        listMapping: {},
        listMappingLocal: {},
        name: "",
        prefixesAll: Object.assign(Object.assign({}, s["@context"]), this.features.xhtmlInitialContext ? a["@context"] : {}),
        prefixesCustom: {},
        skipElement: !1,
        vocab: e.vocab
      })
    }
    import(e) {
      const t = new i.PassThrough({
        readableObjectMode: !0
      });
      e.on("error", e => r.emit("error", e)), e.on("data", e => t.push(e)), e.on("end", () => t.push(null));
      const r = t.pipe(new c(this.options));
      return r
    }
    _transform(e, t, r) {
      this.parser.write(e), r()
    }
    _flush(e) {
      this.parser.end(), e()
    }
    onTagOpen(e, t) {
      let r = this.activeTagStack.length - 1;
      for (; r > 0 && this.activeTagStack[r].skipElement;) r--;
      let n = this.activeTagStack[r];
      r !== this.activeTagStack.length - 1 && (n = Object.assign(Object.assign({}, n), {
        language: this.activeTagStack[this.activeTagStack.length - 1].language,
        prefixesAll: this.activeTagStack[this.activeTagStack.length - 1].prefixesAll,
        prefixesCustom: this.activeTagStack[this.activeTagStack.length - 1].prefixesCustom,
        vocab: this.activeTagStack[this.activeTagStack.length - 1].vocab
      }));
      const i = {
        collectChildTags: n.collectChildTags,
        incompleteTriples: [],
        inlist: "inlist" in t,
        listMapping: [],
        listMappingLocal: n.listMapping,
        localBaseIRI: n.localBaseIRI,
        name: e,
        prefixesAll: null,
        prefixesCustom: null,
        skipElement: !1
      };
      if (this.activeTagStack.push(i), i.collectChildTags) {
        for (const e of Object.keys(n.prefixesCustom).sort()) {
          const r = n.prefixesCustom[e],
            i = "" === e ? "xmlns" : "xmlns:" + e;
          i in t || (t[i] = r)
        }
        const r = Object.keys(t).map(e => `${e}="${t[e]}"`).join(" ");
        if (i.text = [`<${e}${r?" "+r:""}>`], this.features.skipHandlingXmlLiteralChildren) return
      }
      let a, s, o, c = !0,
        l = !0;
      if (this.features.onlyAllowUriRelRevIfProperty && ("property" in t && "rel" in t && (c = !1, t.rel.indexOf(":") < 0 && delete t.rel), "property" in t && "rev" in t && (l = !1, t.rev.indexOf(":") < 0 && delete t.rev)), this.features.copyRdfaPatterns) {
        if (n.collectedPatternTag) {
          const r = {
            attributes: t,
            children: [],
            name: e,
            referenced: !1,
            rootPattern: !1,
            text: []
          };
          return n.collectedPatternTag.children.push(r), void(i.collectedPatternTag = r)
        }
        if ("rdfa:Pattern" === t.typeof) return void(i.collectedPatternTag = {
          attributes: t,
          children: [],
          name: e,
          parentTag: n,
          referenced: !1,
          rootPattern: !0,
          text: []
        });
        if ("rdfa:copy" === t.property) {
          const e = t.resource || t.href || t.src;
          return void(this.rdfaPatterns[e] ? this.emitPatternCopy(n, this.rdfaPatterns[e], e) : (this.pendingRdfaPatternCopies[e] || (this.pendingRdfaPatternCopies[e] = []), this.pendingRdfaPatternCopies[e].push(n)))
        }
      }
      if (this.features.baseTag && "base" === e && t.href && (this.util.baseIRI = this.util.getBaseIRI(t.href)), this.features.xmlBase && t["xml:base"] && (i.localBaseIRI = this.util.getBaseIRI(t["xml:base"])), this.features.timeTag && "time" === e && !t.datatype && (i.interpretObjectAsTime = !0), "vocab" in t ? t.vocab ? (i.vocab = t.vocab, this.emitTriple(this.util.getBaseIriTerm(i), this.util.dataFactory.namedNode(u.Util.RDFA + "usesVocabulary"), this.util.dataFactory.namedNode(i.vocab))) : i.vocab = this.activeTagStack[0].vocab : i.vocab = n.vocab, i.prefixesCustom = u.Util.parsePrefixes(t, n.prefixesCustom, this.features.xmlnsPrefixMappings), i.prefixesAll = Object.keys(i.prefixesCustom).length > 0 ? Object.assign(Object.assign({}, n.prefixesAll), i.prefixesCustom) : n.prefixesAll, this.features.roleAttribute && t.role) {
        const e = t.id ? this.util.createIri("#" + t.id, i, !1, !1, !1) : this.util.createBlankNode(),
          r = i.vocab;
        i.vocab = "http://www.w3.org/1999/xhtml/vocab#";
        for (const r of this.util.createVocabIris(t.role, i, !0, !1)) this.emitTriple(e, this.util.dataFactory.namedNode("http://www.w3.org/1999/xhtml/vocab#role"), r);
        i.vocab = r
      }
      "xml:lang" in t || this.features.langAttribute && "lang" in t ? i.language = t["xml:lang"] || t.lang : i.language = n.language;
      const h = 2 === this.activeTagStack.length;
      if ("rel" in t || "rev" in t ? ("about" in t ? (a = this.util.createIri(t.about, i, !1, !0, !0), i.explicitNewSubject = !!a, "typeof" in t && (o = a)) : h ? a = !0 : n.object && (a = n.object), "resource" in t && (s = this.util.createIri(t.resource, i, !1, !0, !0)), s || ("href" in t || "src" in t ? s = this.util.createIri(t.href || t.src, i, !1, !1, !0) : !("typeof" in t) || "about" in t || this.isInheritSubjectInHeadBody(e) || (s = this.util.createBlankNode())), "typeof" in t && !("about" in t) && (o = this.isInheritSubjectInHeadBody(e) ? a : s)) : !("property" in t) || "content" in t || "datatype" in t ? (("about" in t || "resource" in t) && (a = this.util.createIri(t.about || t.resource, i, !1, !0, !0), i.explicitNewSubject = !!a), a || !("href" in t) && !("src" in t) || (a = this.util.createIri(t.href || t.src, i, !1, !1, !0), i.explicitNewSubject = !!a), a || (h ? a = !0 : this.isInheritSubjectInHeadBody(e) ? a = n.object : "typeof" in t ? (a = this.util.createBlankNode(), i.explicitNewSubject = !0) : n.object && (a = n.object, "property" in t || (i.skipElement = !0))), "typeof" in t && (o = a)) : ("about" in t ? (a = this.util.createIri(t.about, i, !1, !0, !0), i.explicitNewSubject = !!a) : h ? a = !0 : n.object && (a = n.object), "typeof" in t && ("about" in t && (o = this.util.createIri(t.about, i, !1, !0, !0)), !o && h && (o = !0), !o && "resource" in t && (o = this.util.createIri(t.resource, i, !1, !0, !0)), o || !("href" in t) && !("src" in t) || (o = this.util.createIri(t.href || t.src, i, !1, !1, !0)), !o && this.isInheritSubjectInHeadBody(e) && (o = a), o || (o = this.util.createBlankNode()), s = o)), o)
        for (const e of this.util.createVocabIris(t.typeof, i, !0, !0)) this.emitTriple(this.util.getResourceOrBaseIri(o, i), this.util.dataFactory.namedNode(u.Util.RDF + "type"), e);
      if (a && (i.listMapping = {}), s) {
        if ("rel" in t && "inlist" in t)
          for (const e of this.util.createVocabIris(t.rel, i, c, !1)) this.addListMapping(i, a, e, s);
        if (!("rel" in t) || !("inlist" in t)) {
          if ("rel" in t)
            for (const e of this.util.createVocabIris(t.rel, i, c, !1)) this.emitTriple(this.util.getResourceOrBaseIri(a, i), e, this.util.getResourceOrBaseIri(s, i));
          if ("rev" in t)
            for (const e of this.util.createVocabIris(t.rev, i, l, !1)) this.emitTriple(this.util.getResourceOrBaseIri(s, i), e, this.util.getResourceOrBaseIri(a, i))
        }
      }
      if (!s) {
        if ("rel" in t)
          if ("inlist" in t)
            for (const e of this.util.createVocabIris(t.rel, i, c, !1)) this.addListMapping(i, a, e, null), i.incompleteTriples.push({
              predicate: e,
              reverse: !1,
              list: !0
            });
          else
            for (const e of this.util.createVocabIris(t.rel, i, c, !1)) i.incompleteTriples.push({
              predicate: e,
              reverse: !1
            });
        if ("rev" in t)
          for (const e of this.util.createVocabIris(t.rev, i, l, !1)) i.incompleteTriples.push({
            predicate: e,
            reverse: !0
          });
        i.incompleteTriples.length > 0 && (s = this.util.createBlankNode())
      }
      if ("property" in t) {
        let e;
        if (i.predicates = this.util.createVocabIris(t.property, i, !0, !1), "datatype" in t ? (i.datatype = this.util.createIri(t.datatype, i, !0, !0, !1), i.datatype && (i.datatype.value === u.Util.RDF + "XMLLiteral" || this.features.htmlDatatype && i.datatype.value === u.Util.RDF + "HTML") && (i.collectChildTags = !0)) : ("rev" in t || "rel" in t || "content" in t || ("resource" in t && (e = this.util.createIri(t.resource, i, !1, !0, !0)), !e && "href" in t && (e = this.util.createIri(t.href, i, !1, !1, !0)), !e && "src" in t && (e = this.util.createIri(t.src, i, !1, !1, !0))), "typeof" in t && !("about" in t) && (e = o)), "content" in t) {
          const e = this.util.createLiteral(t.content, i);
          if ("inlist" in t)
            for (const t of i.predicates) this.addListMapping(i, a, t, e);
          else {
            const t = this.util.getResourceOrBaseIri(a, i);
            for (const r of i.predicates) this.emitTriple(t, r, e)
          }
          i.predicates = null
        } else if (this.features.datetimeAttribute && "datetime" in t) {
          i.interpretObjectAsTime = !0;
          const e = this.util.createLiteral(t.datetime, i);
          if ("inlist" in t)
            for (const t of i.predicates) this.addListMapping(i, a, t, e);
          else {
            const t = this.util.getResourceOrBaseIri(a, i);
            for (const r of i.predicates) this.emitTriple(t, r, e)
          }
          i.predicates = null
        } else if (e) {
          const r = this.util.getResourceOrBaseIri(e, i);
          if ("inlist" in t)
            for (const e of i.predicates) this.addListMapping(i, a, e, r);
          else {
            const e = this.util.getResourceOrBaseIri(a, i);
            for (const t of i.predicates) this.emitTriple(e, t, r)
          }
          i.predicates = null
        }
      }
      let d = !1;
      if (!i.skipElement && a && n.incompleteTriples.length > 0) {
        d = !0;
        const e = this.util.getResourceOrBaseIri(n.subject, i),
          t = this.util.getResourceOrBaseIri(a, i);
        for (const r of n.incompleteTriples)
          if (r.reverse) this.emitTriple(t, r.predicate, e);
          else if (r.list) {
            let e = null;
            for (let t = this.activeTagStack.length - 1; t >= 0; t--)
              if (this.activeTagStack[t].inlist) {
                e = this.activeTagStack[t];
                break
              } this.addListMapping(e, a, r.predicate, t)
          } else this.emitTriple(e, r.predicate, t)
      }!d && n.incompleteTriples.length > 0 && (i.incompleteTriples = i.incompleteTriples.concat(n.incompleteTriples)), i.subject = a || n.subject, i.object = s || a
    }
    onText(e) {
      const t = this.activeTagStack[this.activeTagStack.length - 1];
      this.features.copyRdfaPatterns && t.collectedPatternTag ? t.collectedPatternTag.text.push(e) : (t.text || (t.text = []), t.text.push(e))
    }
    onTagClose() {
      const e = this.activeTagStack[this.activeTagStack.length - 1],
        t = this.activeTagStack[this.activeTagStack.length - 2];
      if (!(e.collectChildTags && t.collectChildTags && this.features.skipHandlingXmlLiteralChildren)) {
        if (this.features.copyRdfaPatterns && e.collectedPatternTag && e.collectedPatternTag.rootPattern) {
          const t = e.collectedPatternTag.attributes.resource;
          if (delete e.collectedPatternTag.attributes.resource, delete e.collectedPatternTag.attributes.typeof, this.rdfaPatterns[t] = e.collectedPatternTag, this.pendingRdfaPatternCopies[t]) {
            for (const r of this.pendingRdfaPatternCopies[t]) this.emitPatternCopy(r, e.collectedPatternTag, t);
            delete this.pendingRdfaPatternCopies[t]
          }
          return void this.activeTagStack.pop()
        }
        if (e.predicates) {
          const r = this.util.getResourceOrBaseIri(e.subject, e);
          let n = e.text || [];
          e.collectChildTags && t.collectChildTags && (n = n.slice(1));
          const i = this.util.createLiteral(n.join(""), e);
          if (e.inlist)
            for (const t of e.predicates) this.addListMapping(e, r, t, i);
          else
            for (const t of e.predicates) this.emitTriple(r, t, i);
          t.predicates || (e.text = null)
        }
        if (e.object && Object.keys(e.listMapping).length > 0) {
          const t = this.util.getResourceOrBaseIri(e.object, e);
          for (const r in e.listMapping) {
            const n = this.util.dataFactory.namedNode(r),
              i = e.listMapping[r];
            if (i.length > 0) {
              const r = i.map(() => this.util.createBlankNode());
              for (let t = 0; t < i.length; t++) {
                const n = this.util.getResourceOrBaseIri(i[t], e);
                this.emitTriple(r[t], this.util.dataFactory.namedNode(u.Util.RDF + "first"), n), this.emitTriple(r[t], this.util.dataFactory.namedNode(u.Util.RDF + "rest"), t < i.length - 1 ? r[t + 1] : this.util.dataFactory.namedNode(u.Util.RDF + "nil"))
              }
              this.emitTriple(t, n, r[0])
            } else this.emitTriple(t, n, this.util.dataFactory.namedNode(u.Util.RDF + "nil"))
          }
        }
      }
      this.activeTagStack.pop(), e.collectChildTags && e.text && e.text.push(`</${e.name}>`), e.text && t && (t.text ? t.text = t.text.concat(e.text) : t.text = e.text)
    }
    onEnd() {
      if (this.features.copyRdfaPatterns) {
        this.features.copyRdfaPatterns = !1;
        for (const e in this.rdfaPatterns) {
          const t = this.rdfaPatterns[e];
          t.referenced || (t.attributes.typeof = "rdfa:Pattern", t.attributes.resource = e, this.emitPatternCopy(t.parentTag, t, e), t.referenced = !1, delete t.attributes.typeof, delete t.attributes.resource)
        }
        for (const e in this.pendingRdfaPatternCopies)
          for (const t of this.pendingRdfaPatternCopies[e]) this.activeTagStack.push(t), this.onTagOpen("link", {
            property: "rdfa:copy",
            href: e
          }), this.onTagClose(), this.activeTagStack.pop();
        this.features.copyRdfaPatterns = !0
      }
    }
    isInheritSubjectInHeadBody(e) {
      return this.features.inheritSubjectInHeadBody && ("head" === e || "body" === e)
    }
    addListMapping(e, t, r, n) {
      if (e.explicitNewSubject) {
        const i = this.util.createBlankNode();
        this.emitTriple(this.util.getResourceOrBaseIri(t, e), r, i), this.emitTriple(i, this.util.dataFactory.namedNode(u.Util.RDF + "first"), this.util.getResourceOrBaseIri(n, e)), this.emitTriple(i, this.util.dataFactory.namedNode(u.Util.RDF + "rest"), this.util.dataFactory.namedNode(u.Util.RDF + "nil"))
      } else {
        let t = e.listMappingLocal[r.value];
        t || (e.listMappingLocal[r.value] = t = []), n && t.push(n)
      }
    }
    emitTriple(e, t, r) {
      "NamedNode" === e.termType && e.value.indexOf(":") < 0 || "NamedNode" === t.termType && t.value.indexOf(":") < 0 || "NamedNode" === r.termType && r.value.indexOf(":") < 0 || this.push(this.util.dataFactory.quad(e, t, r, this.defaultGraph))
    }
    emitPatternCopy(e, t, r) {
      if (this.activeTagStack.push(e), t.referenced = !0, t.constructedBlankNodes) {
        let e = 0;
        this.util.blankNodeFactory = () => t.constructedBlankNodes[e++]
      } else t.constructedBlankNodes = [], this.util.blankNodeFactory = () => {
        const e = this.util.dataFactory.blankNode();
        return t.constructedBlankNodes.push(e), e
      };
      this.emitPatternCopyAbsolute(t, !0, r), this.util.blankNodeFactory = null, this.activeTagStack.pop()
    }
    emitPatternCopyAbsolute(e, t, r) {
      if (t || "rdfa:copy" !== e.attributes.property || e.attributes.href !== r) {
        this.onTagOpen(e.name, e.attributes);
        for (const t of e.text) this.onText(t);
        for (const t of e.children) this.emitPatternCopyAbsolute(t, !1, r);
        this.onTagClose()
      }
    }
    initializeParser(e) {
      return new n.Parser({
        onclosetag: () => {
          try {
            this.onTagClose(), this.htmlParseListener && this.htmlParseListener.onTagClose()
          } catch (e) {
            this.emit("error", e)
          }
        },
        onend: () => {
          try {
            this.onEnd(), this.htmlParseListener && this.htmlParseListener.onEnd()
          } catch (e) {
            this.emit("error", e)
          }
        },
        onopentag: (e, t) => {
          try {
            this.onTagOpen(e, t), this.htmlParseListener && this.htmlParseListener.onTagOpen(e, t)
          } catch (e) {
            this.emit("error", e)
          }
        },
        ontext: e => {
          try {
            this.onText(e), this.htmlParseListener && this.htmlParseListener.onText(e)
          } catch (e) {
            this.emit("error", e)
          }
        }
      }, {
        decodeEntities: !0,
        recognizeSelfClosing: !0,
        xmlMode: e
      })
    }
  }
  t.RdfaParser = c
}, function(e) {
  e.exports = JSON.parse('{"@context":{"alternate":"http://www.w3.org/1999/xhtml/vocab#alternate","appendix":"http://www.w3.org/1999/xhtml/vocab#appendix","cite":"http://www.w3.org/1999/xhtml/vocab#cite","bookmark":"http://www.w3.org/1999/xhtml/vocab#bookmark","contents":"http://www.w3.org/1999/xhtml/vocab#contents","chapter":"http://www.w3.org/1999/xhtml/vocab#chapter","copyright":"http://www.w3.org/1999/xhtml/vocab#copyright","first":"http://www.w3.org/1999/xhtml/vocab#first","glossary":"http://www.w3.org/1999/xhtml/vocab#glossary","help":"http://www.w3.org/1999/xhtml/vocab#help","icon":"http://www.w3.org/1999/xhtml/vocab#icon","index":"http://www.w3.org/1999/xhtml/vocab#index","last":"http://www.w3.org/1999/xhtml/vocab#last","license":"http://www.w3.org/1999/xhtml/vocab#license","meta":"http://www.w3.org/1999/xhtml/vocab#meta","next":"http://www.w3.org/1999/xhtml/vocab#next","prev":"http://www.w3.org/1999/xhtml/vocab#prev","previous":"http://www.w3.org/1999/xhtml/vocab#previous","section":"http://www.w3.org/1999/xhtml/vocab#section","start":"http://www.w3.org/1999/xhtml/vocab#start","stylesheet":"http://www.w3.org/1999/xhtml/vocab#stylesheet","subsection":"http://www.w3.org/1999/xhtml/vocab#subsection","top":"http://www.w3.org/1999/xhtml/vocab#top","up":"http://www.w3.org/1999/xhtml/vocab#up","p3pv1":"http://www.w3.org/1999/xhtml/vocab#p3pv1"}}')
}, function(e) {
  e.exports = JSON.parse('{"@context":{"as":"https://www.w3.org/ns/activitystreams#","cat":"http://www.w3.org/ns/dcat#","cc":"http://creativecommons.org/ns#","cnt":"http://www.w3.org/2008/content#","csvw":"http://www.w3.org/ns/csvw#","ctag":"http://commontag.org/ns#","dc":"http://purl.org/dc/terms/","dc11":"http://purl.org/dc/elements/1.1/","dcat":"http://www.w3.org/ns/dcat#","dcterms":"http://purl.org/dc/terms/","dqv":"http://www.w3.org/ns/dqv#","duv":"https://www.w3.org/TR/vocab-duv#","earl":"http://www.w3.org/ns/earl#","foaf":"http://xmlns.com/foaf/0.1/","gldp":"http://www.w3.org/ns/people#","gr":"http://purl.org/goodrelations/v1#","grddl":"http://www.w3.org/2003/g/data-view#","ht":"http://www.w3.org/2006/http#","ical":"http://www.w3.org/2002/12/cal/icaltzd#","ldp":"http://www.w3.org/ns/ldp#","ma":"http://www.w3.org/ns/ma-ont#","oa":"http://www.w3.org/ns/oa#","odrl":"http://www.w3.org/ns/odrl/2/","og":"http://ogp.me/ns#","org":"http://www.w3.org/ns/org#","owl":"http://www.w3.org/2002/07/owl#","prov":"http://www.w3.org/ns/prov#","ptr":"http://www.w3.org/2009/pointers#","qb":"http://purl.org/linked-data/cube#","rev":"http://purl.org/stuff/rev#","rdf":"http://www.w3.org/1999/02/22-rdf-syntax-ns#","rdfa":"http://www.w3.org/ns/rdfa#","rdfs":"http://www.w3.org/2000/01/rdf-schema#","rif":"http://www.w3.org/2007/rif#","rr":"http://www.w3.org/ns/r2rml#","schema":"http://schema.org/","sd":"http://www.w3.org/ns/sparql-service-description#","sioc":"http://rdfs.org/sioc/ns#","skos":"http://www.w3.org/2004/02/skos/core#","skosxl":"http://www.w3.org/2008/05/skos-xl#","ssn":"http://www.w3.org/ns/ssn/","sosa":"http://www.w3.org/ns/sosa/","time":"http://www.w3.org/2006/time#","v":"http://rdf.data-vocabulary.org/#","vcard":"http://www.w3.org/2006/vcard/ns#","void":"http://rdfs.org/ns/void#","wdr":"http://www.w3.org/2007/05/powder#","wdrs":"http://www.w3.org/2007/05/powder-s#","xhv":"http://www.w3.org/1999/xhtml/vocab#","xml":"http://www.w3.org/XML/1998/namespace","xsd":"http://www.w3.org/2001/XMLSchema#","describedby":"http://www.w3.org/2007/05/powder-s#describedby","license":"http://www.w3.org/1999/xhtml/vocab#license","role":"http://www.w3.org/1999/xhtml/vocab#role"}}')
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(326), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfSerializeN3 = void 0;
  const n = r(148),
    i = r(41);
  class a extends n.ActorRdfSerializeFixedMediaTypes {
    constructor(e) {
      super(e)
    }
    async runHandle(e, t, r) {
      return {
        data: new i.StreamWriter({
          format: t
        }).import(e.quadStream),
        triples: "text/turtle" === t || "application/n-triples" === t || "text/n3" === t
      }
    }
  }
  t.ActorRdfSerializeN3 = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfSerialize = void 0;
  const n = r(34);
  class i extends n.ActorAbstractMediaTyped {
    constructor(e) {
      super(e)
    }
  }
  t.ActorRdfSerialize = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfSerializeFixedMediaTypes = void 0;
  const n = r(34);
  class i extends n.ActorAbstractMediaTypedFixed {
    constructor(e) {
      super(e)
    }
    async testHandleChecked(e) {
      return !0
    }
  }
  t.ActorRdfSerializeFixedMediaTypes = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(330), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfSerializeJsonLd = void 0;
  const n = r(148),
    i = r(331);
  class a extends n.ActorRdfSerializeFixedMediaTypes {
    constructor(e) {
      super(e)
    }
    async runHandle(e, t, r) {
      return {
        data: new i.JsonLdSerializer({
          space: " ".repeat(this.jsonStringifyIndentSpaces)
        }).import(e.quadStream)
      }
    }
  }
  t.ActorRdfSerializeJsonLd = a
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(332), t), i(r(153), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.JsonLdSerializer = void 0;
  const n = r(9),
    i = r(2),
    a = r(335),
    s = r(153);
  class o extends i.Transform {
    constructor(e = {}) {
      super({
        objectMode: !0
      }), this.indentation = 0, this.options = e, this.options.baseIRI && !this.options.context && (this.options.context = {
        "@base": this.options.baseIRI
      }), this.options.context ? (this.originalContext = this.options.context, this.context = (new n.ContextParser).parse(this.options.context, {
        baseIRI: this.options.baseIRI
      })) : this.context = Promise.resolve(new n.JsonLdContextNormalized({}))
    }
    import(e) {
      const t = new i.PassThrough({
        objectMode: !0
      });
      e.on("error", e => r.emit("error", e)), e.on("data", e => t.push(e)), e.on("end", () => t.push(null));
      const r = t.pipe(new o(this.options));
      return r
    }
    _transform(e, t, r) {
      this.context.then(t => {
        this.transformQuad(e, t), r()
      }).catch(r)
    }
    async list(e) {
      const t = await this.context;
      return {
        "@list": e.map(e => s.Util.termToValue(e, t, this.options))
      }
    }
    _flush(e) {
      return this.opened || this.pushDocumentStart(), this.lastPredicate && this.endPredicate(), this.lastSubject && this.endSubject(), this.lastGraph && "DefaultGraph" !== this.lastGraph.termType && this.endGraph(), this.endDocument(), e(null, null)
    }
    transformQuad(e, t) {
      this.opened || this.pushDocumentStart();
      const r = this.lastGraph && "DefaultGraph" !== this.lastGraph.termType && this.lastGraph.equals(e.subject);
      if (!(r || this.lastGraph && e.graph.equals(this.lastGraph))) {
        let r = "DefaultGraph" !== e.graph.termType && this.lastSubject && this.lastSubject.equals(e.graph);
        this.lastGraph && ("DefaultGraph" !== this.lastGraph.termType ? (this.endPredicate(), this.endSubject(), this.endGraph(!0), r = !1) : r ? (this.endPredicate(!0), this.lastSubject = null) : (this.endPredicate(), this.endSubject(!0))), "DefaultGraph" !== e.graph.termType && (r || this.pushId(e.graph, t), this.pushSeparator(this.options.space ? a.SeparatorType.GRAPH_FIELD_NONCOMPACT : a.SeparatorType.GRAPH_FIELD_COMPACT), this.indentation++), this.lastGraph = e.graph
      }
      this.lastSubject && e.subject.equals(this.lastSubject) || (r ? (this.endPredicate(), this.endSubject(), this.indentation--, this.pushSeparator(a.SeparatorType.ARRAY_END_COMMA), this.lastGraph = e.graph) : (this.lastSubject && (this.endPredicate(), this.endSubject(!0)), this.pushId(e.subject, t)), this.lastSubject = e.subject), this.lastPredicate && e.predicate.equals(this.lastPredicate) || (this.lastPredicate && this.endPredicate(!0), this.pushPredicate(e.predicate, t)), this.pushObject(e.object, t)
    }
    pushDocumentStart() {
      this.opened = !0, this.originalContext && !this.options.excludeContext ? (this.pushSeparator(a.SeparatorType.OBJECT_START), this.indentation++, this.pushSeparator(a.SeparatorType.CONTEXT_FIELD), this.pushIndented(JSON.stringify(this.originalContext, null, this.options.space) + ","), this.pushSeparator(this.options.space ? a.SeparatorType.GRAPH_FIELD_NONCOMPACT : a.SeparatorType.GRAPH_FIELD_COMPACT), this.indentation++) : (this.pushSeparator(a.SeparatorType.ARRAY_START), this.indentation++)
    }
    pushId(e, t) {
      const r = "BlankNode" === e.termType ? "_:" + e.value : t.compactIri(e.value, !1);
      this.pushSeparator(a.SeparatorType.OBJECT_START), this.indentation++, this.pushIndented(this.options.space ? `"@id": "${r}",` : `"@id":"${r}",`)
    }
    pushPredicate(e, t) {
      let r = e.value;
      this.options.useRdfType || r !== s.Util.RDF_TYPE || (r = "@type", this.objectOptions = Object.assign(Object.assign({}, this.options), {
        compactIds: !0,
        vocab: !0
      }));
      const n = t.compactIri(r, !0);
      this.pushIndented(this.options.space ? `"${n}": [` : `"${n}":[`), this.indentation++, this.lastPredicate = e
    }
    pushObject(e, t) {
      let r;
      this.hadObjectForPredicate ? this.pushSeparator(a.SeparatorType.COMMA) : this.hadObjectForPredicate = !0;
      try {
        r = e["@list"] ? e : s.Util.termToValue(e, t, this.objectOptions || this.options)
      } catch (e) {
        return this.emit("error", e)
      }
      this.pushIndented(JSON.stringify(r, null, this.options.space))
    }
    endDocument() {
      this.opened = !1, this.originalContext && !this.options.excludeContext ? (this.indentation--, this.pushSeparator(a.SeparatorType.ARRAY_END), this.indentation--, this.pushSeparator(a.SeparatorType.OBJECT_END)) : (this.indentation--, this.pushSeparator(a.SeparatorType.ARRAY_END))
    }
    endPredicate(e) {
      this.indentation--, this.pushSeparator(e ? a.SeparatorType.ARRAY_END_COMMA : a.SeparatorType.ARRAY_END), this.hadObjectForPredicate = !1, this.objectOptions = null, this.lastPredicate = null
    }
    endSubject(e) {
      this.indentation--, this.pushSeparator(e ? a.SeparatorType.OBJECT_END_COMMA : a.SeparatorType.OBJECT_END), this.lastSubject = null
    }
    endGraph(e) {
      this.indentation--, this.pushSeparator(a.SeparatorType.ARRAY_END), this.indentation--, this.pushSeparator(e ? a.SeparatorType.OBJECT_END_COMMA : a.SeparatorType.OBJECT_END), this.lastGraph = null
    }
    pushSeparator(e) {
      this.pushIndented(e.label)
    }
    pushIndented(e) {
      const t = this.getIndentPrefix(),
        r = e.split("\n").map(e => t + e).join("\n");
      this.push(r), this.options.space && this.push("\n")
    }
    getIndentPrefix() {
      return this.options.space ? this.options.space.repeat(this.indentation) : ""
    }
  }
  t.JsonLdSerializer = o
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.SeparatorType = void 0;
  class n {
    constructor(e) {
      this.label = e
    }
  }
  t.SeparatorType = n, n.COMMA = new n(","), n.OBJECT_START = new n("{"), n.OBJECT_END = new n("}"), n.OBJECT_END_COMMA = new n("},"), n.ARRAY_START = new n("["), n.ARRAY_END = new n("]"), n.ARRAY_END_COMMA = new n("],"), n.GRAPH_FIELD_NONCOMPACT = new n('"@graph": ['), n.GRAPH_FIELD_COMPACT = new n('"@graph":['), n.CONTEXT_FIELD = new n('"@context":')
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfResolveQuadPatternRdfJsSource = void 0;
  const n = r(21),
    i = r(155);
  class a extends n.ActorRdfResolveQuadPatternSource {
    constructor(e) {
      super(e)
    }
    async test(e) {
      if (!this.hasContextSingleSourceOfType("rdfjsSource", e.context)) throw new Error(this.name + " requires a single source with an rdfjsSource to be present in the context.");
      const t = this.getContextSource(e.context);
      if (!t || "string" == typeof t || !("match" in t) && !t.value.match) throw new Error(this.name + " received an invalid rdfjsSource.");
      return !0
    }
    async getSource(e) {
      const t = this.getContextSource(e);
      return new i.RdfJsQuadSource("match" in t ? t : t.value)
    }
  }
  t.ActorRdfResolveQuadPatternRdfJsSource = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  })
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(339), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfMetadataPrimaryTopic = void 0;
  const n = r(2),
    i = r(156);
  class a extends i.ActorRdfMetadata {
    constructor(e) {
      super(e)
    }
    async test(e) {
      if (e.triples) throw new Error("This actor only supports non-triple quad streams.");
      return !0
    }
    async run(e) {
      const t = new n.Readable({
          objectMode: !0
        }),
        r = new n.Readable({
          objectMode: !0
        }),
        i = () => {
          t._read = r._read = () => {}, e.quads.on("error", e => {
            t.emit("error", e), r.emit("error", e)
          });
          const n = {};
          let i;
          const a = {};
          e.quads.on("data", t => {
            "http://rdfs.org/ns/void#subset" === t.predicate.value && t.object.value === e.url ? i = t.subject.value : "http://xmlns.com/foaf/0.1/primaryTopic" === t.predicate.value && (a[t.object.value] = t.subject.value);
            let r = n[t.graph.value];
            r || (r = n[t.graph.value] = []), r.push(t)
          }), e.quads.on("end", () => {
            const e = i ? a[i] : void 0;
            for (const i in n)
              if (i === e) {
                for (const e of n[i]) r.push(e);
                if (this.metadataToData)
                  for (const e of n[i]) t.push(e)
              } else {
                for (const e of n[i]) t.push(e);
                if (!e && this.dataToMetadataOnInvalidMetadataGraph)
                  for (const e of n[i]) r.push(e)
              } t.push(null), r.push(null)
          })
        };
      return t._read = r._read = () => {
        i()
      }, {
        data: t,
        metadata: r
      }
    }
  }
  t.ActorRdfMetadataPrimaryTopic = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfMetadataQuadPredicate = void 0;
  const n = r(2),
    i = r(157);
  class a extends i.ActorRdfMetadata {
    constructor(e) {
      super(e)
    }
    async run(e) {
      const t = new n.Readable({
          objectMode: !0
        }),
        r = new n.Readable({
          objectMode: !0
        }),
        i = () => {
          t._read = r._read = () => {}, e.quads.on("error", e => {
            t.emit("error", e), r.emit("error", e)
          });
          const n = {};
          e.quads.on("data", i => {
            this.isMetadata(i, e.url, n) ? r.push(i) : t.push(i)
          }), e.quads.on("end", () => {
            t.push(null), r.push(null)
          })
        };
      return t._read = r._read = () => {
        i()
      }, {
        data: t,
        metadata: r
      }
    }
  }
  t.ActorRdfMetadataQuadPredicate = a
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(342), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfMetadataAll = void 0;
  const n = r(2),
    i = r(156);
  class a extends i.ActorRdfMetadata {
    constructor(e) {
      super(e)
    }
    async test(e) {
      return !0
    }
    async run(e) {
      const t = new n.Readable({
          objectMode: !0
        }),
        r = new n.Readable({
          objectMode: !0
        });
      return t._read = r._read = () => {
        t._read = r._read = () => {}, e.quads.on("error", e => {
          t.emit("error", e), r.emit("error", e)
        }), e.quads.on("data", e => {
          t.push(e), r.push(e)
        }), e.quads.on("end", () => {
          t.push(null), r.push(null)
        })
      }, {
        data: t,
        metadata: r
      }
    }
  }
  t.ActorRdfMetadataAll = a
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(344), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfMetadataExtractHydraControls = void 0;
  const n = r(85),
    i = r(373);
  class a extends n.ActorRdfMetadataExtract {
    constructor(e) {
      super(e), this.parsedUriTemplateCache = {}
    }
    async test(e) {
      return !0
    }
    getLinks(e, t) {
      return a.LINK_TYPES.reduce((r, n) => {
        const i = t[n] || t[n + "Page"],
          a = i && i[e];
        return r[n] = a && a.length > 0 ? a[0] : null, r
      }, {})
    }
    parseUriTemplateCached(e) {
      const t = this.parsedUriTemplateCache[e];
      return t || (this.parsedUriTemplateCache[e] = i.parse(e))
    }
    getSearchForms(e) {
      const t = e.search,
        r = [];
      if (t)
        for (const n in t)
          for (const i of t[n]) {
            const t = (e.template || {})[i] || [];
            if (1 !== t.length) throw new Error("Expected 1 hydra:template for " + i);
            const a = t[0],
              s = this.parseUriTemplateCached(a),
              o = ((e.mapping || {})[i] || []).reduce((t, r) => {
                const n = ((e.variable || {})[r] || [])[0],
                  i = ((e.property || {})[r] || [])[0];
                if (!n) throw new Error("Expected a hydra:variable for " + r);
                if (!i) throw new Error("Expected a hydra:property for " + r);
                return t[i] = n, t
              }, {}),
              u = e => s.expand(Object.keys(e).reduce((t, r) => (t[o[r]] = e[r], t), {}));
            r.push({
              dataset: n,
              template: a,
              mappings: o,
              getUri: u
            })
          }
      return {
        values: r
      }
    }
    getHydraProperties(e) {
      return new Promise((t, r) => {
        e.on("error", r);
        const n = {};
        e.on("data", e => {
          if (e.predicate.value.startsWith(a.HYDRA)) {
            const t = e.predicate.value.slice(a.HYDRA.length),
              r = n[t] || (n[t] = {});
            (r[e.subject.value] || (r[e.subject.value] = [])).push(e.object.value)
          }
        }), e.on("end", () => t(n))
      })
    }
    async run(e) {
      const t = {},
        r = await this.getHydraProperties(e.metadata);
      return Object.assign(t, this.getLinks(e.url, r)), t.searchForms = this.getSearchForms(r), {
        metadata: t
      }
    }
  }
  t.ActorRdfMetadataExtractHydraControls = a, a.HYDRA = "http://www.w3.org/ns/hydra/core#", a.LINK_TYPES = ["first", "next", "previous", "last"]
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfMetadataExtractQuery = void 0;
  const n = r(346),
    i = r(163),
    a = r(158),
    s = r(164);
  class o extends a.ActorRdfMetadataExtract {
    constructor(e, t, r) {
      super(r), this.graphqlClient = new n.Client({
        context: e,
        queryEngine: new s.GraphQlQueryEngine(this.queryEngine)
      }), this.sparqlOperation = this.graphqlClient.graphQlToSparql({
        query: t
      })
    }
    async queryData(e, t) {
      const r = await i.storeStream(e),
        {
          data: n
        } = await this.graphqlClient.query(Object.assign(Object.assign({}, await this.sparqlOperation), {
          queryEngineOptions: {
            source: {
              type: "rdfjsSource",
              value: r
            },
            initialBindings: t
          }
        }));
      return n
    }
  }
  t.ActorRdfMetadataExtractQuery = o
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || t.hasOwnProperty(r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(347), t), i(r(371), t)
}, function(e, t, r) {
  "use strict";
  var n = this && this.__awaiter || function(e, t, r, n) {
    return new(r || (r = Promise))((function(i, a) {
      function s(e) {
        try {
          u(n.next(e))
        } catch (e) {
          a(e)
        }
      }

      function o(e) {
        try {
          u(n.throw(e))
        } catch (e) {
          a(e)
        }
      }

      function u(e) {
        var t;
        e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
          e(t)
        }))).then(s, o)
      }
      u((n = n.apply(e, t || [])).next())
    }))
  };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Client = void 0;
  const i = r(159),
    a = r(9),
    s = r(120);
  t.Client = class {
    constructor(e) {
      this.context = (e.contextParser || new a.ContextParser).parse(e.context, {
        baseIRI: e.baseIRI
      }), this.queryEngine = e.queryEngine, this.graphqlToSparqlConverter = e.graphqlToSparqlConverter || new i.Converter({
        dataFactory: e.dataFactory,
        requireContext: !0
      }), this.sparqlJsonToTreeConverter = e.sparqlJsonToTreeConverter || new s.Converter({
        dataFactory: e.dataFactory,
        materializeRdfJsTerms: !0
      })
    }
    query(e) {
      return n(this, void 0, void 0, (function*() {
        const {
          sparqlAlgebra: t,
          singularizeVariables: r
        } = "query" in e ? yield this.graphQlToSparql({
          query: e.query,
          variables: e.variables
        }): e, n = yield this.queryEngine.query(t, e.queryEngineOptions);
        return {
          data: this.sparqlJsonToTreeConverter.sparqlJsonResultsToTree(n, {
            singularizeVariables: r
          })
        }
      }))
    }
    graphQlToSparql({
                      query: e,
                      variables: t
                    }) {
      return n(this, void 0, void 0, (function*() {
        const t = {},
          r = {
            singularizeVariables: t,
            variablesDict: {}
          };
        return {
          sparqlAlgebra: yield this.graphqlToSparqlConverter.graphqlToSparqlAlgebra(e, (yield this.context).getContextRaw(), r),
          singularizeVariables: t
        }
      }))
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.DirectiveNodeHandlerInclude = void 0;
  const n = r(38);
  class i extends n.DirectiveNodeHandlerAdapter {
    constructor(e, t) {
      super("include", e, t)
    }
    handle(e, t) {
      const r = this.getDirectiveConditionalValue(e.directive, t);
      return "Literal" === r.termType && "false" === r.value ? {
        ignore: !0
      } : {}
    }
  }
  t.DirectiveNodeHandlerInclude = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.DirectiveNodeHandlerOptional = void 0;
  const n = r(38);
  class i extends n.DirectiveNodeHandlerAdapter {
    constructor(e, t) {
      super("optional", e, t)
    }
    handle(e, t) {
      return {
        operationOverrider: e => this.util.operationFactory.createLeftJoin(this.util.operationFactory.createBgp([]), e)
      }
    }
  }
  t.DirectiveNodeHandlerOptional = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.DirectiveNodeHandlerPlural = void 0;
  const n = r(48),
    i = r(38);
  class a extends i.DirectiveNodeHandlerAdapter {
    constructor(e, t) {
      super("plural", e, t)
    }
    handle(e, t) {
      return this.isDirectiveScopeAll(e.directive) && (t.singularizeState = n.SingularizeState.PLURAL), delete t.singularizeVariables[this.util.nameToVariable(e.fieldLabel, t).value], {}
    }
  }
  t.DirectiveNodeHandlerPlural = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.DirectiveNodeHandlerSingle = void 0;
  const n = r(48),
    i = r(38);
  class a extends i.DirectiveNodeHandlerAdapter {
    constructor(e, t) {
      super("single", e, t)
    }
    handle(e, t) {
      return this.isDirectiveScopeAll(e.directive) && (t.singularizeState = n.SingularizeState.SINGLE), t.singularizeVariables[this.util.nameToVariable(e.fieldLabel, t).value] = !0, {}
    }
  }
  t.DirectiveNodeHandlerSingle = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.DirectiveNodeHandlerSkip = void 0;
  const n = r(38);
  class i extends n.DirectiveNodeHandlerAdapter {
    constructor(e, t) {
      super("skip", e, t)
    }
    handle(e, t) {
      const r = this.getDirectiveConditionalValue(e.directive, t);
      return "Literal" === r.termType && "true" === r.value ? {
        ignore: !0
      } : {}
    }
  }
  t.DirectiveNodeHandlerSkip = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(17), t), i(r(354), t), i(r(355), t), i(r(356), t), i(r(357), t), i(r(358), t), i(r(359), t), i(r(360), t), i(r(361), t), i(r(362), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeValueHandlerBoolean = void 0;
  const n = r(17);
  class i extends n.NodeValueHandlerAdapter {
    constructor(e, t) {
      super("BooleanValue", e, t), this.datatype = this.util.dataFactory.namedNode("http://www.w3.org/2001/XMLSchema#boolean")
    }
    handle(e, t, r) {
      return {
        terms: [this.util.dataFactory.literal(e.value ? "true" : "false", this.datatype)]
      }
    }
  }
  t.NodeValueHandlerBoolean = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeValueHandlerEnum = void 0;
  const n = r(17);
  class i extends n.NodeValueHandlerAdapter {
    constructor(e, t) {
      super("EnumValue", e, t)
    }
    handle(e, t, r) {
      return {
        terms: [this.util.valueToNamedNode(e.value, r.context)]
      }
    }
  }
  t.NodeValueHandlerEnum = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeValueHandlerFloat = void 0;
  const n = r(17);
  class i extends n.NodeValueHandlerAdapter {
    constructor(e, t) {
      super("FloatValue", e, t), this.datatype = this.util.dataFactory.namedNode("http://www.w3.org/2001/XMLSchema#float")
    }
    handle(e, t, r) {
      return {
        terms: [this.util.dataFactory.literal(e.value, this.datatype)]
      }
    }
  }
  t.NodeValueHandlerFloat = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeValueHandlerInt = void 0;
  const n = r(17);
  class i extends n.NodeValueHandlerAdapter {
    constructor(e, t) {
      super("IntValue", e, t), this.datatype = this.util.dataFactory.namedNode("http://www.w3.org/2001/XMLSchema#integer")
    }
    handle(e, t, r) {
      return {
        terms: [this.util.dataFactory.literal(e.value, this.datatype)]
      }
    }
  }
  t.NodeValueHandlerInt = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeValueHandlerList = void 0;
  const n = r(17);
  class i extends n.NodeValueHandlerAdapter {
    constructor(e, t) {
      super("ListValue", e, t), this.nodeFirst = this.util.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#first"), this.nodeRest = this.util.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#rest"), this.nodeNil = this.util.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#nil")
    }
    handle(e, t, r) {
      const n = [];
      let i = [];
      for (const a of e.values) {
        const e = this.util.handleNodeValue(a, t, r);
        for (const t of e.terms) n.push(t);
        e.auxiliaryPatterns && (i = i.concat(e.auxiliaryPatterns))
      }
      if (this.settings.arraysToRdfLists) {
        const e = this.util.dataFactory.blankNode();
        let t = e,
          a = n.length;
        for (const e of n) {
          i.push(this.util.operationFactory.createPattern(t, this.nodeFirst, e, r.graph));
          const n = 0 == --a ? this.nodeNil : this.util.dataFactory.blankNode();
          i.push(this.util.operationFactory.createPattern(t, this.nodeRest, n, r.graph)), t = n
        }
        return {
          terms: [e],
          auxiliaryPatterns: i
        }
      }
      return {
        terms: n,
        auxiliaryPatterns: i
      }
    }
  }
  t.NodeValueHandlerList = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeValueHandlerNull = void 0;
  const n = r(17);
  class i extends n.NodeValueHandlerAdapter {
    constructor(e, t) {
      super("NullValue", e, t), this.nil = this.util.dataFactory.namedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#nil")
    }
    handle(e, t, r) {
      return {
        terms: [this.nil]
      }
    }
  }
  t.NodeValueHandlerNull = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeValueHandlerObject = void 0;
  const n = r(17);
  class i extends n.NodeValueHandlerAdapter {
    constructor(e, t) {
      super("ObjectValue", e, t)
    }
    handle(e, t, r) {
      const n = this.util.dataFactory.blankNode();
      let i = [];
      for (const a of e.fields) {
        const e = this.util.handleNodeValue(a.value, t, r);
        for (const t of e.terms) i.push(this.util.createQuadPattern(n, a.name, t, r.graph, r.context));
        e.auxiliaryPatterns && (i = i.concat(e.auxiliaryPatterns))
      }
      return {
        terms: [n],
        auxiliaryPatterns: i
      }
    }
  }
  t.NodeValueHandlerObject = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeValueHandlerString = void 0;
  const n = r(17);
  class i extends n.NodeValueHandlerAdapter {
    constructor(e, t) {
      super("StringValue", e, t)
    }
    handle(e, t, r) {
      const n = r.context.getContextRaw()[t];
      let i = null,
        a = null;
      return n && "string" != typeof n && (n["@language"] ? i = n["@language"] : n["@type"] && (a = this.util.dataFactory.namedNode(n["@type"]))), {
        terms: [this.util.dataFactory.literal(e.value, i || a)]
      }
    }
  }
  t.NodeValueHandlerString = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeValueHandlerVariable = void 0;
  const n = r(17);
  class i extends n.NodeValueHandlerAdapter {
    constructor(e, t) {
      super("Variable", e, t)
    }
    handle(e, t, r) {
      const n = e.name.value,
        i = r.variablesDict[n],
        a = r.variablesMetaDict[n];
      if (!i) {
        if (r.ignoreUnknownVariables || a && !a.mandatory) {
          const e = this.util.dataFactory.variable(n);
          return r.terminalVariables.map(e => e.value).indexOf(n) < 0 && r.terminalVariables.push(e), {
            terms: [e]
          }
        }
        throw new Error("Undefined variable: " + n)
      }
      if ("Variable" === i.kind) throw new Error("Variable refers to another variable: " + n);
      if (a)
        if (a.list) {
          if ("ListValue" !== i.kind) throw new Error(`Expected a list, but got ${i.kind} for ${n}`);
          if (a.type) {
            const e = i;
            for (const t of e.values)
              if (t.kind !== a.type) throw new Error(`Expected ${a.type}, but got ${t.kind} for ${n}`)
          }
        } else a.type;
      return this.util.handleNodeValue(i, t, r)
    }
  }
  t.NodeValueHandlerVariable = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeHandlerDefinitionFragment = void 0;
  const n = r(86);
  class i extends n.NodeHandlerDefinitionAdapter {
    constructor(e, t) {
      super("FragmentDefinition", e, t)
    }
    handle(e, t) {
      throw new Error("Illegal state: fragment definitions must be indexed and removed before processing")
    }
  }
  t.NodeHandlerDefinitionFragment = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeHandlerDefinitionOperation = void 0;
  const n = r(86);
  class i extends n.NodeHandlerDefinitionAdapter {
    constructor(e, t) {
      super("OperationDefinition", e, t)
    }
    handle(e, t) {
      if ("query" !== e.operation) throw new Error("Unsupported definition operation: " + e.operation);
      if (e.variableDefinitions)
        for (const r of e.variableDefinitions) {
          const e = r.variable.name.value;
          r.defaultValue && (t.variablesDict[e] || (t.variablesDict[e] = r.defaultValue));
          let n = r.type;
          const i = "NonNullType" === n.kind;
          i && (n = n.type);
          const a = "ListType" === n.kind;
          a && (n = n.type);
          const s = n.name.value;
          t.variablesMetaDict[e] = {
            mandatory: i,
            list: a,
            type: s
          }
        }
      const r = this.getDirectiveOutputs(e.directives, e.name ? e.name.value : "", t);
      if (!r) return this.util.operationFactory.createBgp([]);
      const n = this.util.joinOperations(e.selectionSet.selections.map(e => this.util.handleNode(e, t)));
      return this.handleDirectiveOutputs(r, n)
    }
  }
  t.NodeHandlerDefinitionOperation = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeHandlerDocument = void 0;
  const n = r(6),
    i = r(62);
  class a extends i.NodeHandlerAdapter {
    constructor(e, t) {
      super("Document", e, t)
    }
    handle(e, t) {
      const r = this.util.operationFactory.createProject(e.definitions.map(e => {
        const r = this.getNodeQuadContextDefinitionNode(e, Object.assign(Object.assign({}, t), {
            ignoreUnknownVariables: !0
          })),
          n = Object.assign(Object.assign({}, t), {
            graph: r.graph || t.graph,
            subject: r.subject || this.util.dataFactory.blankNode()
          });
        let i = this.util.handleNode(e, n);
        return r && r.auxiliaryPatterns && (i = this.util.joinOperations([i, this.util.operationFactory.createBgp(r.auxiliaryPatterns)])), i
      }).reduce((e, t) => t ? e ? this.util.operationFactory.createUnion(e, t) : t : e, null), t.terminalVariables);
      return this.translateBlankNodesToVariables(r)
    }
    getNodeQuadContextDefinitionNode(e, t) {
      return "OperationDefinition" === e.kind ? this.getNodeQuadContextSelectionSet(e.selectionSet, e.name ? e.name.value : "", t) : null
    }
    translateBlankNodesToVariables(e) {
      const t = this,
        r = {},
        i = Array.from(e.variables).reduce((e, t) => (e[t.value] = !0, e), {});
      return n.Util.mapOperation(e, {
        path: (e, t) => ({
          recurse: !1,
          result: t.createPath(a(e.subject), e.predicate, a(e.object), a(e.graph))
        }),
        pattern: (e, t) => ({
          recurse: !1,
          result: t.createPattern(a(e.subject), a(e.predicate), a(e.object), a(e.graph))
        })
      });

      function a(e) {
        if ("BlankNode" === e.termType) {
          let a = r[e.value];
          return a || (a = n.Util.createUniqueVariable(e.value, i, t.util.dataFactory), i[a.value] = !0, r[e.value] = a), a
        }
        return e
      }
    }
  }
  t.NodeHandlerDocument = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeHandlerSelectionField = void 0;
  const n = r(63);
  class i extends n.NodeHandlerSelectionAdapter {
    constructor(e, t) {
      super("Field", e, t)
    }
    handle(e, t) {
      return this.fieldToOperation(t, e, !0)
    }
  }
  t.NodeHandlerSelectionField = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeHandlerSelectionFragmentSpread = void 0;
  const n = r(63);
  class i extends n.NodeHandlerSelectionAdapter {
    constructor(e, t) {
      super("FragmentSpread", e, t)
    }
    handle(e, t) {
      const r = t.fragmentDefinitions[e.name.value];
      if (!r) throw new Error("Undefined fragment definition: " + e.name.value);
      const n = {
          alias: null,
          arguments: null,
          directives: r.directives,
          kind: "Field",
          name: e.name,
          selectionSet: r.selectionSet
        },
        i = [this.util.newTypePattern(t.subject, r.typeCondition, t)];
      return this.util.operationFactory.createLeftJoin(this.util.operationFactory.createBgp([]), this.fieldToOperation(t, n, !1, i))
    }
  }
  t.NodeHandlerSelectionFragmentSpread = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NodeHandlerSelectionInlineFragment = void 0;
  const n = r(63);
  class i extends n.NodeHandlerSelectionAdapter {
    constructor(e, t) {
      super("InlineFragment", e, t)
    }
    handle(e, t) {
      const r = {
          alias: null,
          arguments: null,
          directives: e.directives,
          kind: "Field",
          name: {
            kind: "Name",
            value: t.subject.value
          },
          selectionSet: e.selectionSet
        },
        n = e.typeCondition ? [this.util.newTypePattern(t.subject, e.typeCondition, t)] : [];
      return this.util.operationFactory.createLeftJoin(this.util.operationFactory.createBgp([]), this.fieldToOperation(t, r, !1, n))
    }
  }
  t.NodeHandlerSelectionInlineFragment = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__awaiter || function(e, t, r, n) {
    return new(r || (r = Promise))((function(i, a) {
      function s(e) {
        try {
          u(n.next(e))
        } catch (e) {
          a(e)
        }
      }

      function o(e) {
        try {
          u(n.throw(e))
        } catch (e) {
          a(e)
        }
      }

      function u(e) {
        var t;
        e.done ? i(e.value) : (t = e.value, t instanceof r ? t : new r((function(e) {
          e(t)
        }))).then(s, o)
      }
      u((n = n.apply(e, t || [])).next())
    }))
  };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Converter = void 0;
  const i = r(581),
    a = r(160),
    s = r(161),
    o = r(48),
    u = r(162);
  class c {
    constructor(e) {
      (e = e || {}).variableDelimiter = e.variableDelimiter || "_", e.expressionVariableCounter = e.expressionVariableCounter || 0, this.util = new u.Util(e), this.initializeNodeHandlers(e)
    }
    static registerNodeHandlers(e, t) {
      e.registerNodeHandler(new a.NodeHandlerDocument(e, t)), e.registerNodeHandler(new a.NodeHandlerDefinitionOperation(e, t)), e.registerNodeHandler(new a.NodeHandlerDefinitionFragment(e, t)), e.registerNodeHandler(new a.NodeHandlerSelectionFragmentSpread(e, t)), e.registerNodeHandler(new a.NodeHandlerSelectionInlineFragment(e, t)), e.registerNodeHandler(new a.NodeHandlerSelectionField(e, t))
    }
    static registerNodeValueHandlers(e, t) {
      e.registerNodeValueHandler(new a.NodeValueHandlerVariable(e, t)), e.registerNodeValueHandler(new a.NodeValueHandlerInt(e, t)), e.registerNodeValueHandler(new a.NodeValueHandlerFloat(e, t)), e.registerNodeValueHandler(new a.NodeValueHandlerString(e, t)), e.registerNodeValueHandler(new a.NodeValueHandlerBoolean(e, t)), e.registerNodeValueHandler(new a.NodeValueHandlerNull(e, t)), e.registerNodeValueHandler(new a.NodeValueHandlerEnum(e, t)), e.registerNodeValueHandler(new a.NodeValueHandlerList(e, t)), e.registerNodeValueHandler(new a.NodeValueHandlerObject(e, t))
    }
    static registerDirectiveNodeHandlers(e, t) {
      e.registerDirectiveNodeHandler(new s.DirectiveNodeHandlerInclude(e, t)), e.registerDirectiveNodeHandler(new s.DirectiveNodeHandlerOptional(e, t)), e.registerDirectiveNodeHandler(new s.DirectiveNodeHandlerPlural(e, t)), e.registerDirectiveNodeHandler(new s.DirectiveNodeHandlerSingle(e, t)), e.registerDirectiveNodeHandler(new s.DirectiveNodeHandlerSkip(e, t))
    }
    graphqlToSparqlAlgebra(e, t, r) {
      return n(this, void 0, void 0, (function*() {
        return this.graphqlToSparqlAlgebraRawContext(e, yield this.util.contextParser.parse(t), r)
      }))
    }
    graphqlToSparqlAlgebraRawContext(e, t, r) {
      r = r || {};
      const n = "string" == typeof e ? i.parse(e) : e,
        a = {
          context: t,
          fragmentDefinitions: this.indexFragments(n),
          graph: this.util.dataFactory.defaultGraph(),
          path: [],
          singularizeState: o.SingularizeState.PLURAL,
          singularizeVariables: r.singularizeVariables || {},
          subject: null,
          terminalVariables: [],
          variablesDict: r.variablesDict || {},
          variablesMetaDict: {}
        };
      return this.util.handleNode(n, a)
    }
    indexFragments(e) {
      const t = {},
        r = [];
      for (const n of e.definitions) "FragmentDefinition" === n.kind ? t[n.name.value] = n : r.push(n);
      return e.definitions = r, t
    }
    initializeNodeHandlers(e) {
      c.registerNodeHandlers(this.util, e), c.registerNodeValueHandlers(this.util, e), c.registerDirectiveNodeHandlers(this.util, e)
    }
  }
  t.Converter = c
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  })
}, function(e, t, r) {
  (function(t) {
    ! function() {
      var r;
      r = "object" == typeof window && window ? window : t, e.exports ? e.exports = r.Promise ? r.Promise : s : r.Promise || (r.Promise = s);
      var n = r.setImmediate || function(e) {
        setTimeout(e, 1)
      };

      function i(e, t) {
        return function() {
          e.apply(t, arguments)
        }
      }
      var a = Array.isArray || function(e) {
        return "[object Array]" === Object.prototype.toString.call(e)
      };

      function s(e) {
        if ("object" != typeof this) throw new TypeError("Promises must be constructed via new");
        if ("function" != typeof e) throw new TypeError("not a function");
        this._state = null, this._value = null, this._deferreds = [], d(e, i(u, this), i(c, this))
      }

      function o(e) {
        var t = this;
        null !== this._state ? n((function() {
          var r = t._state ? e.onFulfilled : e.onRejected;
          if (null !== r) {
            var n;
            try {
              n = r(t._value)
            } catch (t) {
              return void e.reject(t)
            }
            e.resolve(n)
          } else(t._state ? e.resolve : e.reject)(t._value)
        })) : this._deferreds.push(e)
      }

      function u(e) {
        try {
          if (e === this) throw new TypeError("A promise cannot be resolved with itself.");
          if (e && ("object" == typeof e || "function" == typeof e)) {
            var t = e.then;
            if ("function" == typeof t) return void d(i(t, e), i(u, this), i(c, this))
          }
          this._state = !0, this._value = e, l.call(this)
        } catch (e) {
          c.call(this, e)
        }
      }

      function c(e) {
        this._state = !1, this._value = e, l.call(this)
      }

      function l() {
        for (var e = 0, t = this._deferreds.length; e < t; e++) o.call(this, this._deferreds[e]);
        this._deferreds = null
      }

      function h(e, t, r, n) {
        this.onFulfilled = "function" == typeof e ? e : null, this.onRejected = "function" == typeof t ? t : null, this.resolve = r, this.reject = n
      }

      function d(e, t, r) {
        var n = !1;
        try {
          e((function(e) {
            n || (n = !0, t(e))
          }), (function(e) {
            n || (n = !0, r(e))
          }))
        } catch (e) {
          if (n) return;
          n = !0, r(e)
        }
      }
      s.prototype.catch = function(e) {
        return this.then(null, e)
      }, s.prototype.then = function(e, t) {
        var r = this;
        return new s((function(n, i) {
          o.call(r, new h(e, t, n, i))
        }))
      }, s.all = function() {
        var e = Array.prototype.slice.call(1 === arguments.length && a(arguments[0]) ? arguments[0] : arguments);
        return new s((function(t, r) {
          if (0 === e.length) return t([]);
          var n = e.length;

          function i(a, s) {
            try {
              if (s && ("object" == typeof s || "function" == typeof s)) {
                var o = s.then;
                if ("function" == typeof o) return void o.call(s, (function(e) {
                  i(a, e)
                }), r)
              }
              e[a] = s, 0 == --n && t(e)
            } catch (e) {
              r(e)
            }
          }
          for (var a = 0; a < e.length; a++) i(a, e[a])
        }))
      }, s.resolve = function(e) {
        return e && "object" == typeof e && e.constructor === s ? e : new s((function(t) {
          t(e)
        }))
      }, s.reject = function(e) {
        return new s((function(t, r) {
          r(e)
        }))
      }, s.race = function(e) {
        return new s((function(t, r) {
          for (var n = 0, i = e.length; n < i; n++) e[n].then(t, r)
        }))
      }
    }()
  }).call(this, r(10))
}, function(e, t, r) {
  ! function(t) {
    "use strict";
    var r = function() {
        function e(e) {
          this.options = e
        }
        return e.prototype.toString = function() {
          return JSON && JSON.stringify ? JSON.stringify(this.options) : this.options
        }, e
      }(),
      n = function() {
        function e(t) {
          return "function" == typeof Object.freeze ? function(t) {
            if ("object" != typeof t || null === t) return t;
            var r, n;
            for (n in Object.freeze(t), t) t.hasOwnProperty(n) && "object" == typeof(r = t[n]) && e(r);
            return t
          }(t) : t
        }
        return {
          isArray: function(e) {
            return "[object Array]" === Object.prototype.toString.apply(e)
          },
          isString: function(e) {
            return "[object String]" === Object.prototype.toString.apply(e)
          },
          isNumber: function(e) {
            return "[object Number]" === Object.prototype.toString.apply(e)
          },
          isBoolean: function(e) {
            return "[object Boolean]" === Object.prototype.toString.apply(e)
          },
          join: function(e, t) {
            var r, n = "",
              i = !0;
            for (r = 0; r < e.length; r += 1) i ? i = !1 : n += t, n += e[r];
            return n
          },
          map: function(e, t) {
            for (var r = [], n = 0; n < e.length; n += 1) r.push(t(e[n]));
            return r
          },
          filter: function(e, t) {
            for (var r = [], n = 0; n < e.length; n += 1) t(e[n]) && r.push(e[n]);
            return r
          },
          deepFreeze: e
        }
      }(),
      i = function() {
        function e(e) {
          return e >= "0" && e <= "9"
        }
        return {
          isAlpha: function(e) {
            return e >= "a" && e <= "z" || e >= "A" && e <= "Z"
          },
          isDigit: e,
          isHexDigit: function(t) {
            return e(t) || t >= "a" && t <= "f" || t >= "A" && t <= "F"
          }
        }
      }(),
      a = function() {
        var e = function(e) {
            return unescape(encodeURIComponent(e))
          },
          t = function(e) {
            return e <= 127 ? 1 : 194 <= e && e <= 223 ? 2 : 224 <= e && e <= 239 ? 3 : 240 <= e && e <= 244 ? 4 : 0
          },
          r = function(e) {
            return 128 <= e && e <= 191
          };

        function n(e, t) {
          return "%" === e.charAt(t) && i.isHexDigit(e.charAt(t + 1)) && i.isHexDigit(e.charAt(t + 2))
        }

        function a(e, t) {
          return parseInt(e.substr(t, 2), 16)
        }
        return {
          encodeCharacter: function(t) {
            var r, n, i = "",
              a = e(t);
            for (n = 0; n < a.length; n += 1) i += "%" + ((r = a.charCodeAt(n)) < 16 ? "0" : "") + r.toString(16).toUpperCase();
            return i
          },
          isPctEncoded: function(e) {
            if (!n(e, 0)) return !1;
            var i = a(e, 1),
              s = t(i);
            if (0 === s) return !1;
            for (var o = 1; o < s; o += 1)
              if (!n(e, 3 * o) || !r(a(e, 3 * o + 1))) return !1;
            return !0
          },
          pctCharAt: function(e, i) {
            var s = e.charAt(i);
            if (!n(e, i)) return s;
            var o = a(e, i + 1),
              u = t(o);
            if (0 === u) return s;
            for (var c = 1; c < u; c += 1)
              if (!n(e, i + 3 * c) || !r(a(e, i + 3 * c + 1))) return s;
            return e.substr(i, 3 * u)
          }
        }
      }(),
      s = {
        isVarchar: function(e) {
          return i.isAlpha(e) || i.isDigit(e) || "_" === e || a.isPctEncoded(e)
        },
        isUnreserved: function(e) {
          return i.isAlpha(e) || i.isDigit(e) || "-" === e || "." === e || "_" === e || "~" === e
        },
        isReserved: function(e) {
          return ":" === e || "/" === e || "?" === e || "#" === e || "[" === e || "]" === e || "@" === e || "!" === e || "$" === e || "&" === e || "(" === e || ")" === e || "*" === e || "+" === e || "," === e || ";" === e || "=" === e || "'" === e
        }
      },
      o = function() {
        function e(e, t) {
          var r, n = "",
            i = "";
          for ("number" != typeof e && "boolean" != typeof e || (e = e.toString()), r = 0; r < e.length; r += i.length) i = e.charAt(r), n += s.isUnreserved(i) || t && s.isReserved(i) ? i : a.encodeCharacter(i);
          return n
        }
        return {
          encode: e,
          encodePassReserved: function(t) {
            return e(t, !0)
          },
          encodeLiteral: function(e) {
            var t, r = "",
              n = "";
            for (t = 0; t < e.length; t += n.length)(n = a.pctCharAt(e, t)).length > 1 ? r += n : r += s.isReserved(n) || s.isUnreserved(n) ? n : a.encodeCharacter(n);
            return r
          },
          encodeLiteralCharacter: function(e, t) {
            var r = a.pctCharAt(e, t);
            return r.length > 1 || s.isReserved(r) || s.isUnreserved(r) ? r : a.encodeCharacter(r)
          }
        }
      }(),
      u = function() {
        var e = {};

        function t(t) {
          e[t] = {
            symbol: t,
            separator: "?" === t ? "&" : "" === t || "+" === t || "#" === t ? "," : t,
            named: ";" === t || "&" === t || "?" === t,
            ifEmpty: "&" === t || "?" === t ? "=" : "",
            first: "+" === t ? "" : t,
            encode: "+" === t || "#" === t ? o.encodePassReserved : o.encode,
            toString: function() {
              return this.symbol
            }
          }
        }
        return t(""), t("+"), t("#"), t("."), t("/"), t(";"), t("?"), t("&"), {
          valueOf: function(t) {
            return e[t] ? e[t] : "=,!@|".indexOf(t) >= 0 ? null : e[""]
          }
        }
      }();

    function c(e) {
      var t;
      if (null == e) return !1;
      if (n.isArray(e)) return e.length > 0;
      if ("string" == typeof e || "number" == typeof e || "boolean" == typeof e) return !0;
      for (t in e)
        if (e.hasOwnProperty(t) && c(e[t])) return !0;
      return !1
    }
    var l = function() {
        function e(e) {
          this.literal = o.encodeLiteral(e)
        }
        return e.prototype.expand = function() {
          return this.literal
        }, e.prototype.toString = e.prototype.expand, e
      }(),
      h = function() {
        function e(e) {
          var t, n, o = [],
            c = null,
            l = null,
            h = null,
            p = "";

          function f() {
            var t = e.substring(l, n);
            if (0 === t.length) throw new r({
              expressionText: e,
              message: "a varname must be specified",
              position: n
            });
            c = {
              varname: t,
              exploded: !1,
              maxLength: null
            }, l = null
          }

          function g() {
            if (h === n) throw new r({
              expressionText: e,
              message: "after a ':' you have to specify the length",
              position: n
            });
            c.maxLength = parseInt(e.substring(h, n), 10), h = null
          }
          for (t = function(t) {
            var i = u.valueOf(t);
            if (null === i) throw new r({
              expressionText: e,
              message: "illegal use of reserved operator",
              position: n,
              operator: t
            });
            return i
          }(e.charAt(0)), n = t.symbol.length, l = n; n < e.length; n += p.length) {
            if (p = a.pctCharAt(e, n), null !== l) {
              if ("." === p) {
                if (l === n) throw new r({
                  expressionText: e,
                  message: "a varname MUST NOT start with a dot",
                  position: n
                });
                continue
              }
              if (s.isVarchar(p)) continue;
              f()
            }
            if (null !== h) {
              if (n === h && "0" === p) throw new r({
                expressionText: e,
                message: "A :prefix must not start with digit 0",
                position: n
              });
              if (i.isDigit(p)) {
                if (n - h >= 4) throw new r({
                  expressionText: e,
                  message: "A :prefix must have max 4 digits",
                  position: n
                });
                continue
              }
              g()
            }
            if (":" !== p)
              if ("*" !== p) {
                if ("," !== p) throw new r({
                  expressionText: e,
                  message: "illegal character",
                  character: p,
                  position: n
                });
                o.push(c), c = null, l = n + 1
              } else {
                if (null === c) throw new r({
                  expressionText: e,
                  message: "exploded without varspec",
                  position: n
                });
                if (c.exploded) throw new r({
                  expressionText: e,
                  message: "exploded twice",
                  position: n
                });
                if (c.maxLength) throw new r({
                  expressionText: e,
                  message: "an explode (*) MUST NOT follow to a prefix",
                  position: n
                });
                c.exploded = !0
              }
            else {
              if (null !== c.maxLength) throw new r({
                expressionText: e,
                message: "only one :maxLength is allowed per varspec",
                position: n
              });
              if (c.exploded) throw new r({
                expressionText: e,
                message: "an exploeded varspec MUST NOT be varspeced",
                position: n
              });
              h = n + 1
            }
          }
          return null !== l && f(), null !== h && g(), o.push(c), new d(e, t, o)
        }
        return function(t) {
          var n, i, a = [],
            s = null,
            o = 0;
          for (n = 0; n < t.length; n += 1)
            if (i = t.charAt(n), null === o) {
              if (null === s) throw new Error("reached unreachable code");
              if ("{" === i) throw new r({
                templateText: t,
                message: "brace already opened",
                position: n
              });
              if ("}" === i) {
                if (s + 1 === n) throw new r({
                  templateText: t,
                  message: "empty braces",
                  position: s
                });
                try {
                  a.push(e(t.substring(s + 1, n)))
                } catch (e) {
                  if (e.prototype === r.prototype) throw new r({
                    templateText: t,
                    message: e.options.message,
                    position: s + e.options.position,
                    details: e.options
                  });
                  throw e
                }
                s = null, o = n + 1
              }
            } else {
              if ("}" === i) throw new r({
                templateText: t,
                message: "unopened brace closed",
                position: n
              });
              "{" === i && (o < n && a.push(new l(t.substring(o, n))), o = null, s = n)
            } if (null !== s) throw new r({
            templateText: t,
            message: "unclosed brace",
            position: s
          });
          return o < t.length && a.push(new l(t.substr(o))), new p(t, a)
        }
      }(),
      d = function() {
        function e(e) {
          return JSON && JSON.stringify ? JSON.stringify(e) : e
        }

        function t(e) {
          if (!c(e)) return !0;
          if (n.isString(e)) return "" === e;
          if (n.isNumber(e) || n.isBoolean(e)) return !1;
          if (n.isArray(e)) return 0 === e.length;
          for (var t in e)
            if (e.hasOwnProperty(t)) return !1;
          return !0
        }

        function r(e) {
          var t, r = [];
          for (t in e) e.hasOwnProperty(t) && r.push({
            name: t,
            value: e[t]
          });
          return r
        }

        function i(e, t, r) {
          this.templateText = e, this.operator = t, this.varspecs = r
        }

        function a(e, t, r) {
          var n = "";
          if (r = r.toString(), t.named) {
            if (n += o.encodeLiteral(e.varname), "" === r) return n += t.ifEmpty;
            n += "="
          }
          return null !== e.maxLength && (r = r.substr(0, e.maxLength)), n += t.encode(r)
        }

        function s(e) {
          return c(e.value)
        }

        function u(e, i, a) {
          var u = [],
            l = "";
          if (i.named) {
            if (l += o.encodeLiteral(e.varname), t(a)) return l += i.ifEmpty;
            l += "="
          }
          return n.isArray(a) ? (u = a, u = n.filter(u, c), u = n.map(u, i.encode), l += n.join(u, ",")) : (u = r(a), u = n.filter(u, s), u = n.map(u, (function(e) {
            return i.encode(e.name) + "," + i.encode(e.value)
          })), l += n.join(u, ",")), l
        }

        function l(e, i, a) {
          var u = [];
          return n.isArray(a) ? (u = a, u = n.filter(u, c), u = n.map(u, (function(r) {
            var n = o.encodeLiteral(e.varname);
            return t(r) ? n += i.ifEmpty : n += "=" + i.encode(r), n
          }))) : (u = r(a), u = n.filter(u, s), u = n.map(u, (function(e) {
            var r = o.encodeLiteral(e.name);
            return t(e.value) ? r += i.ifEmpty : r += "=" + i.encode(e.value), r
          }))), n.join(u, i.separator)
        }

        function h(e, t) {
          var i = [],
            a = "";
          return n.isArray(t) ? (i = t, i = n.filter(i, c), i = n.map(i, e.encode), a += n.join(i, e.separator)) : (i = r(t), i = n.filter(i, (function(e) {
            return c(e.value)
          })), i = n.map(i, (function(t) {
            return e.encode(t.name) + "=" + e.encode(t.value)
          })), a += n.join(i, e.separator)), a
        }
        return i.prototype.toString = function() {
          return this.templateText
        }, i.prototype.expand = function(r) {
          var i, s, o, d = [],
            p = this.operator;
          for (i = 0; i < this.varspecs.length; i += 1)
            if (null != (o = r[(s = this.varspecs[i]).varname]))
              if (s.exploded && !0, n.isArray(o), "string" == typeof o || "number" == typeof o || "boolean" == typeof o) d.push(a(s, p, o));
              else {
                if (s.maxLength && c(o)) throw new Error("Prefix modifiers are not applicable to variables that have composite values. You tried to expand " + this + " with " + e(o));
                s.exploded ? c(o) && (p.named ? d.push(l(s, p, o)) : d.push(h(p, o))) : !p.named && t(o) || d.push(u(s, p, o))
              } return 0 === d.length ? "" : p.first + n.join(d, p.separator)
        }, i
      }(),
      p = function() {
        function e(e, t) {
          this.templateText = e, this.expressions = t, n.deepFreeze(this)
        }
        return e.prototype.toString = function() {
          return this.templateText
        }, e.prototype.expand = function(e) {
          var t, r = "";
          for (t = 0; t < this.expressions.length; t += 1) r += this.expressions[t].expand(e);
          return r
        }, e.parse = h, e.UriTemplateError = r, e
      }();
    ! function(t) {
      e.exports = t
    }(p)
  }()
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(375), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfMetadataExtractHydraCount = void 0;
  const n = r(85);
  class i extends n.ActorRdfMetadataExtract {
    constructor(e) {
      super(e)
    }
    async test(e) {
      return !0
    }
    run(e) {
      return new Promise((t, r) => {
        e.metadata.on("error", r), e.metadata.on("data", e => {
          this.predicates.includes(e.predicate.value) && t({
            metadata: {
              totalItems: Number.parseInt(e.object.value, 10)
            }
          })
        }), e.metadata.on("end", () => {
          t({
            metadata: {
              totalItems: 1 / 0
            }
          })
        })
      })
    }
  }
  t.ActorRdfMetadataExtractHydraCount = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(377), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfMetadataExtractSparqlService = void 0;
  const n = r(85),
    i = r(13);
  class a extends n.ActorRdfMetadataExtract {
    constructor(e) {
      super(e)
    }
    async test(e) {
      return !0
    }
    async run(e) {
      return new Promise((t, r) => {
        e.metadata.on("error", r);
        const n = {};
        e.metadata.on("data", t => {
          "http://www.w3.org/ns/sparql-service-description#endpoint" !== t.predicate.value || "BlankNode" !== t.subject.termType && t.subject.value !== e.url ? "http://www.w3.org/ns/sparql-service-description#defaultGraph" === t.predicate.value && (n.defaultGraph = t.object.value) : n.sparqlService = "Literal" === t.object.termType ? i.resolve(t.object.value, e.url) : t.object.value
        }), e.metadata.on("end", () => {
          t({
            metadata: n
          })
        })
      })
    }
  }
  t.ActorRdfMetadataExtractSparqlService = a
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(379), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfResolveHypermediaNone = void 0;
  const n = r(154),
    i = r(87),
    a = r(163);
  class s extends i.ActorRdfResolveHypermedia {
    constructor(e) {
      super(e, "file")
    }
    async testMetadata(e) {
      return {
        filterFactor: 0
      }
    }
    async run(e) {
      return this.logInfo(e.context, "Identified as file source: " + e.url), {
        source: new n.RdfJsQuadSource(await a.storeStream(e.quads))
      }
    }
  }
  t.ActorRdfResolveHypermediaNone = s
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfResolveHypermedia = void 0;
  const n = r(0);
  class i extends n.Actor {
    constructor(e, t) {
      super(e), this.sourceType = t
    }
    async test(e) {
      if (e.forceSourceType && this.sourceType !== e.forceSourceType) throw new Error(`Actor ${this.name} is not able to handle source type ${e.forceSourceType}.`);
      return this.testMetadata(e)
    }
  }
  t.ActorRdfResolveHypermedia = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(382), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfResolveHypermediaLinksNext = void 0;
  const n = r(383);
  class i extends n.ActorRdfResolveHypermediaLinks {
    constructor(e) {
      super(e)
    }
    async test(e) {
      if (!e.metadata.next) throw new Error(`Actor ${this.name} requires a 'next' metadata entry.`);
      return !0
    }
    async run(e) {
      return {
        urls: [e.metadata.next]
      }
    }
  }
  t.ActorRdfResolveHypermediaLinksNext = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(384), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfResolveHypermediaLinks = void 0;
  const n = r(0);
  class i extends n.Actor {
    constructor(e) {
      super(e)
    }
  }
  t.ActorRdfResolveHypermediaLinks = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(166), t), i(r(386), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorHttpInvalidateListenable = void 0;
  const n = r(166);
  class i extends n.ActorHttpInvalidate {
    constructor(e) {
      super(e), this.invalidateListeners = []
    }
    addInvalidateListener(e) {
      this.invalidateListeners.push(e)
    }
    async test(e) {
      return !0
    }
    async run(e) {
      for (const t of this.invalidateListeners) t(e);
      return !0
    }
  }
  t.ActorHttpInvalidateListenable = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(388), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.MediatorAll = void 0;
  const n = r(0);
  class i extends n.Mediator {
    constructor(e) {
      super(e)
    }
    async mediate(e) {
      const t = [];
      let r;
      try {
        r = this.publish(e)
      } catch (e) {
        r = []
      }
      for (const e of r) try {
        await e.reply, t.push(e.actor)
      } catch (e) {}
      return (await Promise.all(t.map(t => t.runObservable(e))))[0]
    }
    async mediateWith() {
      throw new Error("Unsupported operation: MediatorAll#mediateWith")
    }
  }
  t.MediatorAll = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.MediatorCombinePipeline = void 0;
  const n = r(0);
  class i extends n.Mediator {
    constructor(e) {
      super(e)
    }
    async mediate(e) {
      let t;
      try {
        t = this.publish(e)
      } catch (t) {
        return e
      }
      await Promise.all(t.map(({
                                 reply: e
                               }) => e));
      let r = e;
      for (const e of t.map(e => e.actor)) r = await e.runObservable(r);
      return r
    }
    mediateWith() {
      throw new Error("Method not supported.")
    }
  }
  t.MediatorCombinePipeline = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(391), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorOptimizeQueryOperationJoinBgp = void 0;
  const n = r(392),
    i = r(6);
  class a extends n.ActorOptimizeQueryOperation {
    constructor(e) {
      super(e)
    }
    async test(e) {
      return !0
    }
    async run(e) {
      return {
        operation: i.Util.mapOperation(e.operation, {
          join: (e, t) => "bgp" === e.left.type && "bgp" === e.right.type ? {
            recurse: !1,
            result: t.createBgp(e.left.patterns.concat(e.right.patterns))
          } : {
            recurse: !1,
            result: e
          }
        })
      }
    }
  }
  t.ActorOptimizeQueryOperationJoinBgp = a
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(393), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorOptimizeQueryOperation = void 0;
  const n = r(0);
  class i extends n.Actor {
    constructor(e) {
      super(e)
    }
  }
  t.ActorOptimizeQueryOperation = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(395), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorSparqlParseGraphql = void 0;
  const n = r(168),
    i = r(159);
  class a extends n.ActorSparqlParse {
    constructor(e) {
      super(e), this.graphqlToSparql = new i.Converter({
        requireContext: !0
      })
    }
    async test(e) {
      if ("graphql" !== e.queryFormat) throw new Error("This actor can only parse GraphQL queries");
      return !0
    }
    async run(e) {
      const t = e.context && e.context.has("@context") ? e.context.get("@context") : {},
        r = {
          singularizeVariables: e.context && e.context.get("@comunica/actor-init-sparql:singularizeVariables")
        };
      return {
        operation: await this.graphqlToSparql.graphqlToSparqlAlgebra(e.query, t, r)
      }
    }
  }
  t.ActorSparqlParseGraphql = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorSparqlParse = void 0;
  const n = r(0);
  class i extends n.Actor {
    constructor(e) {
      super(e)
    }
  }
  t.ActorSparqlParse = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(398), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorSparqlParseAlgebra = void 0;
  const n = r(168),
    i = r(6),
    a = r(30);
  class s extends n.ActorSparqlParse {
    constructor(e) {
      super(e), this.prefixes = Object.freeze(this.prefixes)
    }
    async test(e) {
      if (e.queryFormat && "sparql" !== e.queryFormat) throw new Error("This actor can only parse SPARQL queries");
      return !0
    }
    async run(e) {
      const t = new a.Parser({
        prefixes: this.prefixes,
        baseIRI: e.baseIRI
      });
      t._resetBlanks();
      const r = t.parse(e.query);
      return {
        baseIRI: "query" === r.type ? r.base : void 0,
        operation: i.translate(r, {
          quads: !0,
          prefixes: this.prefixes,
          blankToVariable: !0,
          baseIRI: e.baseIRI
        })
      }
    }
  }
  t.ActorSparqlParseAlgebra = s
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(400), t)
}, function(e, t, r) {
  "use strict";
  (function(e) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.ActorSparqlSerializeJson = void 0;
    const n = r(2),
      i = r(15),
      a = r(4);
    class s extends i.ActorSparqlSerializeFixedMediaTypes {
      constructor(e) {
        super(e)
      }
      async testHandleChecked(e, t) {
        if (!["bindings", "quads", "boolean"].includes(e.type)) throw new Error("This actor can only handle bindings or quad streams.");
        return !0
      }
      async runHandle(t, r, i) {
        const s = new n.Readable;
        s._read = () => {};
        let o = !0;
        if ("bindings" === t.type) {
          const e = t.bindingsStream;
          s.push("["), e.on("error", e => s.emit("error", e)), e.on("data", e => {
            s.push(o ? "\n" : ",\n"), s.push(JSON.stringify(e.map(a.termToString))), o = !1
          }), e.on("end", () => {
            s.push(o ? "]\n" : "\n]\n"), s.push(null)
          })
        } else if ("quads" === t.type) {
          const e = t.quadStream;
          s.push("["), e.on("error", e => s.emit("error", e)), e.on("data", e => {
            s.push(o ? "\n" : ",\n"), s.push(JSON.stringify(a.quadToStringQuad(e))), o = !1
          }), e.on("end", () => {
            s.push(o ? "]\n" : "\n]\n"), s.push(null)
          })
        } else try {
          s.push(JSON.stringify(await t.booleanResult) + "\n"), s.push(null)
        } catch (t) {
          e(() => s.emit("error", t))
        }
        return {
          data: s
        }
      }
    }
    t.ActorSparqlSerializeJson = s
  }).call(this, r(44).setImmediate)
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(402), t)
}, function(e, t, r) {
  "use strict";
  (function(e) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.ActorSparqlSerializeSimple = void 0;
    const n = r(2),
      i = r(15);
    class a extends i.ActorSparqlSerializeFixedMediaTypes {
      constructor(e) {
        super(e)
      }
      async testHandleChecked(e, t) {
        if (!["bindings", "quads", "boolean"].includes(e.type)) throw new Error("This actor can only handle bindings streams, quad streams or booleans.");
        return !0
      }
      async runHandle(t, r, i) {
        const a = new n.Readable;
        let s;
        if (a._read = () => {}, "bindings" === t.type) s = t.bindingsStream, s.on("error", e => a.emit("error", e)), s.on("data", e => a.push(e.map((e, t) => `${t}: ${e.value}`).join("\n") + "\n\n")), s.on("end", () => a.push(null));
        else if ("quads" === t.type) s = t.quadStream, s.on("error", e => a.emit("error", e)), s.on("data", e => a.push(`subject: ${e.subject.value}\npredicate: ${e.predicate.value}\nobject: ${e.object.value}\ngraph: ${e.graph.value}\n\n`)), s.on("end", () => a.push(null));
        else try {
            a.push(JSON.stringify(await t.booleanResult) + "\n"), a.push(null)
          } catch (t) {
            e(() => a.emit("error", t))
          }
        return {
          data: a
        }
      }
    }
    t.ActorSparqlSerializeSimple = a
  }).call(this, r(44).setImmediate)
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(404), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorSparqlSerializeSparqlCsv = void 0;
  const n = r(2),
    i = r(15);
  class a extends i.ActorSparqlSerializeFixedMediaTypes {
    constructor(e) {
      super(e)
    }
    static bindingToCsvBindings(e) {
      if (!e) return "";
      let t = e.value;
      return t = "Literal" === e.termType ? "" + t : "BlankNode" === e.termType ? "_:" + t : `<${t}>`, /[",\n\r]/u.exec(t) && (t = `"${t.replace(/"/gu,'""')}"`), t
    }
    async testHandleChecked(e, t) {
      if ("bindings" !== e.type) throw new Error("This actor can only handle bindings streams.");
      return !0
    }
    async runHandle(e, t, r) {
      const i = e,
        s = new n.Readable;
      return s._read = () => {}, s.push(i.variables.map(e => e.slice(1)).join(",") + "\r\n"), i.bindingsStream.on("error", e => {
        s.emit("error", e)
      }), i.bindingsStream.on("data", e => {
        s.push(i.variables.map(t => a.bindingToCsvBindings(e.get(t))).join(",") + "\r\n")
      }), i.bindingsStream.on("end", () => {
        s.push(null)
      }), {
        data: s
      }
    }
  }
  t.ActorSparqlSerializeSparqlCsv = a
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(406), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorSparqlSerializeSparqlJson = void 0;
  const n = r(2),
    i = r(15);
  class a extends i.ActorSparqlSerializeFixedMediaTypes {
    constructor(e) {
      super(e)
    }
    static bindingToJsonBindings(e) {
      if ("Literal" === e.termType) {
        const t = e,
          r = {
            value: t.value,
            type: "literal"
          },
          {
            language: n
          } = t,
          {
            datatype: i
          } = t;
        return n ? r["xml:lang"] = n : i && "http://www.w3.org/2001/XMLSchema#string" !== i.value && (r.datatype = i.value), r
      }
      return "BlankNode" === e.termType ? {
        value: e.value,
        type: "bnode"
      } : {
        value: e.value,
        type: "uri"
      }
    }
    async testHandleChecked(e, t) {
      if (!["bindings", "boolean"].includes(e.type)) throw new Error("This actor can only handle bindings streams or booleans.");
      return !0
    }
    async runHandle(e, t, r) {
      const i = new n.Readable;
      i._read = () => {};
      const s = {};
      "bindings" === e.type && e.variables.length > 0 && (s.vars = e.variables.map(e => e.slice(1))), i.push(`{"head": ${JSON.stringify(s)},\n`);
      let o = !0;
      if ("bindings" === e.type) {
        const t = e.bindingsStream;
        t.on("error", e => {
          i.emit("error", e)
        }), t.on("data", e => {
          o ? i.push('"results": { "bindings": [\n') : i.push(",\n");
          const t = e.filter((e, t) => Boolean(e) && t.startsWith("?"));
          i.push(JSON.stringify(t.mapEntries(([e, t]) => [e.slice(1), a.bindingToJsonBindings(t)]).toJSON())), o = !1
        }), t.on("end", () => {
          o ? i.push('"results": { "bindings": [] }}\n') : i.push("\n]}}\n"), i.push(null)
        })
      } else try {
        i.push(`"boolean":${await e.booleanResult}\n}\n`), i.push(null)
      } catch (e) {
        i.once("newListener", () => i.emit("error", e))
      }
      return {
        data: i
      }
    }
  }
  t.ActorSparqlSerializeSparqlJson = a
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(408), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorSparqlSerializeSparqlTsv = void 0;
  const n = r(2),
    i = r(15),
    a = r(409);
  class s extends i.ActorSparqlSerializeFixedMediaTypes {
    constructor(e) {
      super(e)
    }
    static bindingToTsvBindings(e) {
      return e ? a.termToString(e).replace(/\t/gu, "\\t").replace(/\n/gu, "\\n").replace(/\r/gu, "\\r") : ""
    }
    async testHandleChecked(e, t) {
      if ("bindings" !== e.type) throw new Error("This actor can only handle bindings streams.");
      return !0
    }
    async runHandle(e, t, r) {
      const i = e,
        a = new n.Readable;
      return a._read = () => {}, a.push(i.variables.map(e => e.slice(1)).join("\t") + "\n"), i.bindingsStream.on("error", e => {
        a.emit("error", e)
      }), i.bindingsStream.on("data", e => {
        a.push(i.variables.map(t => s.bindingToTsvBindings(e.get(t))).join("\t") + "\n")
      }), i.bindingsStream.on("end", () => {
        a.push(null)
      }), {
        data: a
      }
    }
  }
  t.ActorSparqlSerializeSparqlTsv = s
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.termToString = t.stringToTerm = t.stringQuadToQuad = t.quadToStringQuad = t.getLiteralValue = t.getLiteralType = t.getLiteralLanguage = void 0;
  const n = r(410);
  Object.defineProperty(t, "getLiteralLanguage", {
    enumerable: !0,
    get: function() {
      return n.getLiteralLanguage
    }
  }), Object.defineProperty(t, "getLiteralType", {
    enumerable: !0,
    get: function() {
      return n.getLiteralType
    }
  }), Object.defineProperty(t, "getLiteralValue", {
    enumerable: !0,
    get: function() {
      return n.getLiteralValue
    }
  }), Object.defineProperty(t, "quadToStringQuad", {
    enumerable: !0,
    get: function() {
      return n.quadToStringQuad
    }
  }), Object.defineProperty(t, "stringQuadToQuad", {
    enumerable: !0,
    get: function() {
      return n.stringQuadToQuad
    }
  }), Object.defineProperty(t, "stringToTerm", {
    enumerable: !0,
    get: function() {
      return n.stringToTerm
    }
  }), Object.defineProperty(t, "termToString", {
    enumerable: !0,
    get: function() {
      return n.termToString
    }
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.stringQuadToQuad = t.quadToStringQuad = t.stringToTerm = t.getLiteralLanguage = t.getLiteralType = t.getLiteralValue = t.termToString = void 0;
  const n = new(r(5).DataFactory);

  function i(e) {
    if (e) switch (e.termType) {
      case "NamedNode":
        return "<" + e.value + ">";
      case "BlankNode":
        return "_:" + e.value;
      case "Literal":
        const t = e;
        return '"' + t.value.replace(/"/gu, '\\"') + '"' + (t.datatype && "http://www.w3.org/2001/XMLSchema#string" !== t.datatype.value && "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" !== t.datatype.value ? "^^<" + t.datatype.value + ">" : "") + (t.language ? "@" + t.language : "");
      case "Quad":
        return `<<${i(e.subject)} ${i(e.predicate)} ${i(e.object)}${"DefaultGraph"===e.graph.termType?"":" "+i(e.graph)}>>`;
      case "Variable":
        return "?" + e.value;
      case "DefaultGraph":
        return e.value
    }
  }

  function a(e) {
    const t = /^"([^]*)"((\^\^.*)|(@.*))?$/.exec(e);
    if (!t) throw new Error(e + " is not a literal");
    return t[1].replace(/\\"/gu, '"')
  }

  function s(e) {
    const t = /^"[^]*"(?:\^\^<([^"]+)>|(@)[^@"]+)?$/.exec(e);
    if (!t) throw new Error(e + " is not a literal");
    return t[1] || (t[2] ? "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" : "http://www.w3.org/2001/XMLSchema#string")
  }

  function o(e) {
    const t = /^"[^]*"(?:@([^@"]+)|\^\^[^"]+)?$/.exec(e);
    if (!t) throw new Error(e + " is not a literal");
    return t[1] ? t[1].toLowerCase() : ""
  }

  function u(e, t) {
    if (t = t || n, !e || !e.length) return t.defaultGraph();
    switch (e[0]) {
      case "_":
        return t.blankNode(e.substr(2));
      case "?":
        if (!t.variable) throw new Error("Missing 'variable()' method on the given DataFactory");
        return t.variable(e.substr(1));
      case '"':
        const r = o(e),
          n = t.namedNode(s(e));
        return t.literal(a(e), r || n);
      case "<":
      default:
        if (e.startsWith("<<") && e.endsWith(">>")) {
          const r = e.slice(2, -2),
            n = [];
          let i = 0,
            a = 0;
          for (let t = 0; t < r.length; t++) {
            const s = r[t];
            if ("<" === s && i++, ">" === s) {
              if (0 === i) throw new Error("Found closing tag without opening tag in " + e);
              i--
            }
            " " === s && 0 === i && (n.push(r.slice(a, t)), a = t + 1)
          }
          if (0 !== i) throw new Error("Found opening tag without closing tag in " + e);
          if (n.push(r.slice(a, r.length)), 3 !== n.length && 4 !== n.length) throw new Error("Nested quad syntax error " + e);
          return t.quad(u(n[0]), u(n[1]), u(n[2]), n[3] ? u(n[3]) : void 0)
        }
        if ("<" !== e.charAt(0) || ">" !== e.charAt(e.length - 1)) throw new Error("Detected invalid iri for named node (must be wrapped in <>): " + e);
        return t.namedNode(e.substring(1, e.length - 1))
    }
  }
  t.termToString = i, t.getLiteralValue = a, t.getLiteralType = s, t.getLiteralLanguage = o, t.stringToTerm = u, t.quadToStringQuad = function(e) {
    return {
      subject: i(e.subject),
      predicate: i(e.predicate),
      object: i(e.object),
      graph: i(e.graph)
    }
  }, t.stringQuadToQuad = function(e, t) {
    return (t = t || n).quad(u(e.subject, t), u(e.predicate, t), u(e.object, t), u(e.graph, t))
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(412), t)
}, function(e, t, r) {
  "use strict";
  (function(e) {
    Object.defineProperty(t, "__esModule", {
      value: !0
    }), t.ActorSparqlSerializeSparqlXml = void 0;
    const n = r(2),
      i = r(15),
      a = r(413);
    class s extends i.ActorSparqlSerializeFixedMediaTypes {
      constructor(e) {
        super(e)
      }
      static bindingToXmlBindings(e, t) {
        let r;
        if ("Literal" === e.termType) {
          const t = e;
          r = {
            literal: t.value
          };
          const {
            language: n
          } = t, {
            datatype: i
          } = t;
          n ? r.literal = [{
            _attr: {
              "xml:lang": n
            }
          }, r.literal] : i && "http://www.w3.org/2001/XMLSchema#string" !== i.value && (r.literal = [{
            _attr: {
              datatype: i.value
            }
          }, r.literal])
        } else r = "BlankNode" === e.termType ? {
          bnode: e.value
        } : {
          uri: e.value
        };
        return {
          binding: [{
            _attr: {
              name: t.slice(1)
            }
          }, r]
        }
      }
      async testHandleChecked(e, t) {
        if (!["bindings", "boolean"].includes(e.type)) throw new Error("This actor can only handle bindings streams or booleans.");
        return !0
      }
      async runHandle(t, r, i) {
        const o = new n.Readable;
        o._read = () => {};
        const u = a.element({
          _attr: {
            xlmns: "http://www.w3.org/2005/sparql-results#"
          }
        });
        if (a({
          sparql: u
        }, {
          stream: !0,
          indent: "  ",
          declaration: !0
        }).on("data", e => o.push(e + "\n")), "bindings" === t.type && t.variables.length > 0 && u.push({
          head: t.variables.map(e => ({
            variable: {
              _attr: {
                name: e.slice(1)
              }
            }
          }))
        }), "bindings" === t.type) {
          const r = a.element({});
          u.push({
            results: r
          });
          const n = t.bindingsStream;
          n.on("error", e => {
            o.emit("error", e)
          }), n.on("data", e => {
            const t = e.filter((e, t) => Boolean(e) && t.startsWith("?"));
            r.push({
              result: t.map(s.bindingToXmlBindings)
            })
          }), n.on("end", () => {
            r.close(), u.close(), e(() => o.push(null))
          })
        } else try {
          u.push({
            boolean: await t.booleanResult
          }), u.close(), e(() => o.push(null))
        } catch (t) {
          e(() => o.emit("error", t))
        }
        return {
          data: o
        }
      }
    }
    t.ActorSparqlSerializeSparqlXml = s
  }).call(this, r(44).setImmediate)
}, function(e, t, r) {
  (function(t) {
    var n = r(414),
      i = r(2).Stream;

    function a(e, t, r) {
      r = r || 0;
      var i, s, o = (i = t, new Array(r || 0).join(i || "")),
        u = e;
      if ("object" == typeof e && ((u = e[s = Object.keys(e)[0]]) && u._elem)) return u._elem.name = s, u._elem.icount = r, u._elem.indent = t, u._elem.indents = o, u._elem.interrupt = u, u._elem;
      var c, l = [],
        h = [];

      function d(e) {
        Object.keys(e).forEach((function(t) {
          l.push(function(e, t) {
            return e + '="' + n(t) + '"'
          }(t, e[t]))
        }))
      }
      switch (typeof u) {
        case "object":
          if (null === u) break;
          u._attr && d(u._attr), u._cdata && h.push(("<![CDATA[" + u._cdata).replace(/\]\]>/g, "]]]]><![CDATA[>") + "]]>"), u.forEach && (c = !1, h.push(""), u.forEach((function(e) {
            "object" == typeof e ? "_attr" == Object.keys(e)[0] ? d(e._attr) : h.push(a(e, t, r + 1)) : (h.pop(), c = !0, h.push(n(e)))
          })), c || h.push(""));
          break;
        default:
          h.push(n(u))
      }
      return {
        name: s,
        interrupt: !1,
        attributes: l,
        content: h,
        icount: r,
        indents: o,
        indent: t
      }
    }

    function s(e, t, r) {
      if ("object" != typeof t) return e(!1, t);
      var n = t.interrupt ? 1 : t.content.length;

      function i() {
        for (; t.content.length;) {
          var i = t.content.shift();
          if (void 0 !== i) {
            if (a(i)) return;
            s(e, i)
          }
        }
        e(!1, (n > 1 ? t.indents : "") + (t.name ? "</" + t.name + ">" : "") + (t.indent && !r ? "\n" : "")), r && r()
      }

      function a(t) {
        return !!t.interrupt && (t.interrupt.append = e, t.interrupt.end = i, t.interrupt = !1, e(!0), !0)
      }
      if (e(!1, t.indents + (t.name ? "<" + t.name : "") + (t.attributes.length ? " " + t.attributes.join(" ") : "") + (n ? t.name ? ">" : "" : t.name ? "/>" : "") + (t.indent && n > 1 ? "\n" : "")), !n) return e(!1, t.indent ? "\n" : "");
      a(t) || i()
    }
    e.exports = function(e, r) {
      "object" != typeof r && (r = {
        indent: r
      });
      var n, o, u = r.stream ? new i : null,
        c = "",
        l = !1,
        h = r.indent ? !0 === r.indent ? "    " : r.indent : "",
        d = !0;

      function p(e) {
        d ? t.nextTick(e) : e()
      }

      function f(e, t) {
        if (void 0 !== t && (c += t), e && !l && (u = u || new i, l = !0), e && l) {
          var r = c;
          p((function() {
            u.emit("data", r)
          })), c = ""
        }
      }

      function g(e, t) {
        s(f, a(e, h, h ? 1 : 0), t)
      }

      function m() {
        if (u) {
          var e = c;
          p((function() {
            u.emit("data", e), u.emit("end"), u.readable = !1, u.emit("close")
          }))
        }
      }
      return p((function() {
        d = !1
      })), r.declaration && (n = r.declaration, o = {
        version: "1.0",
        encoding: n.encoding || "UTF-8"
      }, n.standalone && (o.standalone = n.standalone), g({
        "?xml": {
          _attr: o
        }
      }), c = c.replace("/>", "?>")), e && e.forEach ? e.forEach((function(t, r) {
        var n;
        r + 1 === e.length && (n = m), g(t, n)
      })) : g(e, m), u ? (u.readable = !0, u) : c
    }, e.exports.element = e.exports.Element = function() {
      var e = Array.prototype.slice.call(arguments),
        t = {
          _elem: a(e),
          push: function(e) {
            if (!this.append) throw new Error("not assigned to a parent!");
            var t = this,
              r = this._elem.indent;
            s(this.append, a(e, r, this._elem.icount + (r ? 1 : 0)), (function() {
              t.append(!0)
            }))
          },
          close: function(e) {
            void 0 !== e && this.push(e), this.end && this.end()
          }
        };
      return t
    }
  }).call(this, r(8))
}, function(e, t) {
  var r = {
    "&": "&amp;",
    '"': "&quot;",
    "'": "&apos;",
    "<": "&lt;",
    ">": "&gt;"
  };
  e.exports = function(e) {
    return e && e.replace ? e.replace(/([&"<>'])/g, (function(e, t) {
      return r[t]
    })) : e
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(416), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorSparqlSerializeTable = void 0;
  const n = r(2),
    i = r(15),
    a = r(18);
  class s extends i.ActorSparqlSerializeFixedMediaTypes {
    constructor(e) {
      super(e), this.padding = s.repeat(" ", this.columnWidth)
    }
    static repeat(e, t) {
      return new Array(t + 1).join(e)
    }
    async testHandleChecked(e, t) {
      if (!["bindings", "quads"].includes(e.type)) throw new Error("This actor can only handle bindings or quad streams.");
      return !0
    }
    pad(e) {
      return e.length <= this.columnWidth ? e + this.padding.slice(e.length) : e.slice(0, this.columnWidth - 1) + "…"
    }
    pushHeader(e, t) {
      const r = t.map(e => this.pad(e)).join(" ");
      e.push(`${r}\n${s.repeat("-",r.length)}\n`)
    }
    pushRow(e, t, r) {
      e.push(t.map(e => r.has(e) ? r.get(e).value : "").map(e => this.pad(e)).join(" ") + "\n")
    }
    async runHandle(e, t, r) {
      const i = new n.Readable;
      let s;
      if (i._read = () => {}, "bindings" === e.type) {
        s = e.bindingsStream;
        const t = e.variables;
        this.pushHeader(i, t), s.on("error", e => i.emit("error", e)), s.on("data", e => this.pushRow(i, t, e))
      } else s = e.quadStream, this.pushHeader(i, a.QUAD_TERM_NAMES), s.on("error", e => i.emit("error", e)), s.on("data", e => i.push(a.getTerms(e).map(e => this.pad(e.value)).join(" ") + "\n"));
      return s.on("end", () => i.push(null)), {
        data: i
      }
    }
  }
  t.ActorSparqlSerializeTable = s
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  });
  const n = new(r(5).DataFactory);

  function i(e, t) {
    return t && "DefaultGraph" === e.graph.termType ? [e.subject, e.predicate, e.object] : [e.subject, e.predicate, e.object, e.graph]
  }

  function a(e, t) {
    return !t || "Variable" === t.termType || "Quad" === t.termType && "Quad" === e.termType && o(e, t) || t.equals(e)
  }

  function s(e, t, r, n, i) {
    return a(e.subject, t) && a(e.predicate, r) && a(e.object, n) && a(e.graph, i)
  }

  function o(e, t) {
    return s(e, t.subject, t.predicate, t.object, t.graph)
  }
  t.QUAD_TERM_NAMES = ["subject", "predicate", "object", "graph"], t.TRIPLE_TERM_NAMES = ["subject", "predicate", "object"], t.getTerms = i, t.getTermsNested = function e(t, r) {
    const n = [];
    for (const a of i(t, r)) "Quad" === a.termType ? e(a, r).forEach(e => n.push(e)) : n.push(a);
    return n
  }, t.getNamedTerms = function(e) {
    return [{
      key: "subject",
      value: e.subject
    }, {
      key: "predicate",
      value: e.predicate
    }, {
      key: "object",
      value: e.object
    }, {
      key: "graph",
      value: e.graph
    }]
  }, t.collectNamedTerms = function(e, t, r) {
    const i = {};
    return e.forEach(e => i[e.key] = e.value), t && (i.subject = i.subject || t("subject"), i.predicate = i.predicate || t("predicate"), i.object = i.object || t("object"), i.graph = i.graph || t("graph")), (r || n).quad(i.subject, i.predicate, i.object, i.graph)
  }, t.forEachTerms = function(e, t) {
    t(e.subject, "subject"), t(e.predicate, "predicate"), t(e.object, "object"), t(e.graph, "graph")
  }, t.filterTerms = function(e, t) {
    const r = [];
    return t(e.subject, "subject") && r.push(e.subject), t(e.predicate, "predicate") && r.push(e.predicate), t(e.object, "object") && r.push(e.object), t(e.graph, "graph") && r.push(e.graph), r
  }, t.filterQuadTermNames = function(e, t) {
    const r = [];
    return t(e.subject, "subject") && r.push("subject"), t(e.predicate, "predicate") && r.push("predicate"), t(e.object, "object") && r.push("object"), t(e.graph, "graph") && r.push("graph"), r
  }, t.mapTerms = function(e, t, r) {
    return (r || n).quad(t(e.subject, "subject"), t(e.predicate, "predicate"), t(e.object, "object"), t(e.graph, "graph"))
  }, t.reduceTerms = function(e, t, r) {
    let n = r;
    return n = t(n, e.subject, "subject"), n = t(n, e.predicate, "predicate"), n = t(n, e.object, "object"), t(n, e.graph, "graph")
  }, t.everyTerms = function(e, t) {
    return t(e.subject, "subject") && t(e.predicate, "predicate") && t(e.object, "object") && t(e.graph, "graph")
  }, t.someTerms = function(e, t) {
    return t(e.subject, "subject") || t(e.predicate, "predicate") || t(e.object, "object") || t(e.graph, "graph")
  }, t.matchTerm = a, t.matchPattern = s, t.matchPatternComplete = o
}, function(e, t, r) {
  "use strict";

  function n(e, t) {
    return e.filter(e => e.termType === t)
  }
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.TERM_TYPES = ["NamedNode", "BlankNode", "Literal", "Variable", "DefaultGraph", "Quad"], t.uniqTerms = function(e) {
    return r(419)(e, (e, t) => e.equals(t))
  }, t.getTermsOfType = n, t.getNamedNodes = function(e) {
    return n(e, "NamedNode")
  }, t.getBlankNodes = function(e) {
    return n(e, "BlankNode")
  }, t.getLiterals = function(e) {
    return n(e, "Literal")
  }, t.getVariables = function(e) {
    return n(e, "Variable")
  }, t.getDefaultGraphs = function(e) {
    return n(e, "DefaultGraph")
  }, t.getQuads = function(e) {
    return n(e, "Quad")
  }
}, function(e, t, r) {
  (function(t) {
    var r = /^\[object .+?Constructor\]$/,
      n = "object" == typeof t && t && t.Object === Object && t,
      i = "object" == typeof self && self && self.Object === Object && self,
      a = n || i || Function("return this")();

    function s(e, t) {
      return !!(e ? e.length : 0) && function(e, t, r) {
        if (t != t) return function(e, t, r, n) {
          var i = e.length,
            a = r + (n ? 1 : -1);
          for (; n ? a-- : ++a < i;)
            if (t(e[a], a, e)) return a;
          return -1
        }(e, u, r);
        var n = r - 1,
          i = e.length;
        for (; ++n < i;)
          if (e[n] === t) return n;
        return -1
      }(e, t, 0) > -1
    }

    function o(e, t, r) {
      for (var n = -1, i = e ? e.length : 0; ++n < i;)
        if (r(t, e[n])) return !0;
      return !1
    }

    function u(e) {
      return e != e
    }

    function c(e, t) {
      return e.has(t)
    }

    function l(e) {
      var t = -1,
        r = Array(e.size);
      return e.forEach((function(e) {
        r[++t] = e
      })), r
    }
    var h, d = Array.prototype,
      p = Function.prototype,
      f = Object.prototype,
      g = a["__core-js_shared__"],
      m = (h = /[^.]+$/.exec(g && g.keys && g.keys.IE_PROTO || "")) ? "Symbol(src)_1." + h : "",
      y = p.toString,
      b = f.hasOwnProperty,
      _ = f.toString,
      v = RegExp("^" + y.call(b).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
      w = d.splice,
      S = D(a, "Map"),
      T = D(a, "Set"),
      E = D(Object, "create");

    function x(e) {
      var t = -1,
        r = e ? e.length : 0;
      for (this.clear(); ++t < r;) {
        var n = e[t];
        this.set(n[0], n[1])
      }
    }

    function O(e) {
      var t = -1,
        r = e ? e.length : 0;
      for (this.clear(); ++t < r;) {
        var n = e[t];
        this.set(n[0], n[1])
      }
    }

    function A(e) {
      var t = -1,
        r = e ? e.length : 0;
      for (this.clear(); ++t < r;) {
        var n = e[t];
        this.set(n[0], n[1])
      }
    }

    function R(e) {
      var t = -1,
        r = e ? e.length : 0;
      for (this.__data__ = new A; ++t < r;) this.add(e[t])
    }

    function I(e, t) {
      for (var r, n, i = e.length; i--;)
        if ((r = e[i][0]) === (n = t) || r != r && n != n) return i;
      return -1
    }

    function N(e) {
      return !(!j(e) || (t = e, m && m in t)) && (function(e) {
        var t = j(e) ? _.call(e) : "";
        return "[object Function]" == t || "[object GeneratorFunction]" == t
      }(e) || function(e) {
        var t = !1;
        if (null != e && "function" != typeof e.toString) try {
          t = !!(e + "")
        } catch (e) {}
        return t
      }(e) ? v : r).test(function(e) {
        if (null != e) {
          try {
            return y.call(e)
          } catch (e) {}
          try {
            return e + ""
          } catch (e) {}
        }
        return ""
      }(e));
      var t
    }
    x.prototype.clear = function() {
      this.__data__ = E ? E(null) : {}
    }, x.prototype.delete = function(e) {
      return this.has(e) && delete this.__data__[e]
    }, x.prototype.get = function(e) {
      var t = this.__data__;
      if (E) {
        var r = t[e];
        return "__lodash_hash_undefined__" === r ? void 0 : r
      }
      return b.call(t, e) ? t[e] : void 0
    }, x.prototype.has = function(e) {
      var t = this.__data__;
      return E ? void 0 !== t[e] : b.call(t, e)
    }, x.prototype.set = function(e, t) {
      return this.__data__[e] = E && void 0 === t ? "__lodash_hash_undefined__" : t, this
    }, O.prototype.clear = function() {
      this.__data__ = []
    }, O.prototype.delete = function(e) {
      var t = this.__data__,
        r = I(t, e);
      return !(r < 0) && (r == t.length - 1 ? t.pop() : w.call(t, r, 1), !0)
    }, O.prototype.get = function(e) {
      var t = this.__data__,
        r = I(t, e);
      return r < 0 ? void 0 : t[r][1]
    }, O.prototype.has = function(e) {
      return I(this.__data__, e) > -1
    }, O.prototype.set = function(e, t) {
      var r = this.__data__,
        n = I(r, e);
      return n < 0 ? r.push([e, t]) : r[n][1] = t, this
    }, A.prototype.clear = function() {
      this.__data__ = {
        hash: new x,
        map: new(S || O),
        string: new x
      }
    }, A.prototype.delete = function(e) {
      return C(this, e).delete(e)
    }, A.prototype.get = function(e) {
      return C(this, e).get(e)
    }, A.prototype.has = function(e) {
      return C(this, e).has(e)
    }, A.prototype.set = function(e, t) {
      return C(this, e).set(e, t), this
    }, R.prototype.add = R.prototype.push = function(e) {
      return this.__data__.set(e, "__lodash_hash_undefined__"), this
    }, R.prototype.has = function(e) {
      return this.__data__.has(e)
    };
    var P = T && 1 / l(new T([, -0]))[1] == 1 / 0 ? function(e) {
      return new T(e)
    } : function() {};

    function C(e, t) {
      var r, n, i = e.__data__;
      return ("string" == (n = typeof(r = t)) || "number" == n || "symbol" == n || "boolean" == n ? "__proto__" !== r : null === r) ? i["string" == typeof t ? "string" : "hash"] : i.map
    }

    function D(e, t) {
      var r = function(e, t) {
        return null == e ? void 0 : e[t]
      }(e, t);
      return N(r) ? r : void 0
    }

    function j(e) {
      var t = typeof e;
      return !!e && ("object" == t || "function" == t)
    }
    e.exports = function(e, t) {
      return e && e.length ? function(e, t, r) {
        var n = -1,
          i = s,
          a = e.length,
          u = !0,
          h = [],
          d = h;
        if (r) u = !1, i = o;
        else if (a >= 200) {
          var p = t ? null : P(e);
          if (p) return l(p);
          u = !1, i = c, d = new R
        } else d = t ? [] : h;
        e: for (; ++n < a;) {
          var f = e[n],
            g = t ? t(f) : f;
          if (f = r || 0 !== f ? f : 0, u && g == g) {
            for (var m = d.length; m--;)
              if (d[m] === g) continue e;
            t && d.push(g), h.push(f)
          } else i(d, g, r) || (d !== h && d.push(g), h.push(f))
        }
        return h
      }(e, void 0, t) : []
    }
  }).call(this, r(10))
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(421), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationBgpEmpty = void 0;
  const n = r(1),
    i = r(3),
    a = r(4),
    s = r(18);
  class o extends n.ActorQueryOperationTyped {
    constructor(e) {
      super(e, "bgp")
    }
    static getVariables(e) {
      return s.uniqTerms(e.map(e => s.getTerms(e).filter(e => "Variable" === e.termType)).reduce((e, t) => e.concat(t), [])).map(e => a.termToString(e))
    }
    async testOperation(e, t) {
      if (e.patterns.length > 0) throw new Error(`Actor ${this.name} can only operate on empty BGPs.`);
      return !0
    }
    async runOperation(e, t) {
      return {
        bindingsStream: new i.SingletonIterator(n.Bindings({})),
        metadata: () => Promise.resolve({
          totalItems: 1
        }),
        type: "bindings",
        variables: o.getVariables(e.patterns),
        canContainUndefs: !1
      }
    }
  }
  t.ActorQueryOperationBgpEmpty = o
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(423), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationValues = void 0;
  const n = r(1),
    i = r(3),
    a = r(4);
  class s extends n.ActorQueryOperationTyped {
    constructor(e) {
      super(e, "values")
    }
    async testOperation(e, t) {
      return !0
    }
    async runOperation(e, t) {
      const r = new i.ArrayIterator(e.bindings.map(e => n.Bindings(e))),
        s = e.variables.map(e => a.termToString(e)),
        o = e.bindings.some(e => s.some(t => !(t in e)));
      return {
        type: "bindings",
        bindingsStream: r,
        metadata: () => Promise.resolve({
          totalItems: e.bindings.length
        }),
        variables: s,
        canContainUndefs: o
      }
    }
  }
  t.ActorQueryOperationValues = s
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(425), t), i(r(171), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.KEY_CONTEXT_STRICTVALUES = t.KEY_CONTEXT_DOCUMENTLOADER = t.ActorRdfParseJsonLd = void 0;
  const n = r(46),
    i = r(426),
    a = r(171);
  class s extends n.ActorRdfParseFixedMediaTypes {
    constructor(e) {
      super(e)
    }
    async testHandle(e, t, r) {
      if (r && r.has("@comunica/actor-rdf-parse-html-script:processing-html-script") && "application/ld+json" !== t) throw new Error("JSON-LD in script tags can only have media type 'application/ld+json'");
      if (!(t in this.mediaTypes) && !t.endsWith("+json")) throw new Error("Unrecognized media type: " + t);
      return await this.testHandleChecked(e)
    }
    async runHandle(e, r, n) {
      return {
        quads: i.JsonLdParser.fromHttpResponse(e.baseIRI, r, e.headers, {
          documentLoader: n && n.get(t.KEY_CONTEXT_DOCUMENTLOADER) || new a.DocumentLoaderMediated(this.mediatorHttp, n),
          strictValues: n && n.get(t.KEY_CONTEXT_STRICTVALUES)
        }).import(e.input)
      }
    }
  }
  t.ActorRdfParseJsonLd = s, t.KEY_CONTEXT_DOCUMENTLOADER = "@comunica/actor-rdf-parse-jsonld:documentLoader", t.KEY_CONTEXT_STRICTVALUES = "@comunica/actor-rdf-parse-jsonld:strictValues"
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(169), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.EntryHandlerArrayValue = void 0;
  const n = r(27);
  t.EntryHandlerArrayValue = class {
    isPropertyHandler() {
      return !1
    }
    isStackProcessor() {
      return !0
    }
    async validate(e, t, r, n, i) {
      return this.test(e, t, null, r, n)
    }
    async test(e, t, r, n, i) {
      return "number" == typeof n[i]
    }
    async handle(e, t, r, i, a, s) {
      let o = await t.unaliasKeywordParent(i, s);
      if ("@list" === o) {
        let r = null,
          n = 0;
        for (let e = s - 2; e > 0; e--) {
          const t = i[e];
          if ("string" == typeof t || "number" == typeof t) {
            n = e, r = t;
            break
          }
        }
        if (null !== r) {
          const o = await t.valueToTerm(await e.getContext(i), r, a, s, i);
          for (const r of o) await this.handleListElement(e, t, r, a, s, i.slice(0, n), n);
          0 === o.length && await this.handleListElement(e, t, null, a, s, i.slice(0, n), n)
        }
      } else if ("@set" === o) await e.newOnValueJob(i.slice(0, -2), a, s - 2, !1);
      else if (void 0 !== o && "@type" !== o) {
        for (let e = s - 1; e > 0; e--)
          if ("number" != typeof i[e]) {
            o = await t.unaliasKeyword(i[e], i, e);
            break
          } const r = await e.getContext(i.slice(0, -1));
        if ("@list" in n.Util.getContextValueContainer(r, o)) {
          e.emittedStack[s + 1] = !0;
          const r = await t.valueToTerm(await e.getContext(i), o, a, s, i);
          for (const n of r) await this.handleListElement(e, t, n, a, s, i.slice(0, -1), s - 1);
          0 === r.length && await this.handleListElement(e, t, null, a, s, i.slice(0, -1), s - 1)
        } else e.shiftStack(s, 1), await e.newOnValueJob(i.slice(0, -1), a, s - 1, !1), e.contextTree.removeContext(i.slice(0, -1))
      }
    }
    async handleListElement(e, t, r, n, i, a, s) {
      let o = e.listPointerStack[i];
      if (null !== n && null !== (await t.unaliasKeywords(n, a, i))["@value"]) {
        if (o && o.value) {
          const r = t.dataFactory.blankNode();
          e.emitQuad(i, t.dataFactory.quad(o.value, t.rdfRest, r, t.getDefaultGraph())), o.value = r
        } else {
          const e = t.dataFactory.blankNode();
          o = {
            value: e,
            listRootDepth: s,
            listId: e
          }
        }
        r && e.emitQuad(i, t.dataFactory.quad(o.value, t.rdfFirst, r, t.getDefaultGraph()))
      } else o || (o = {
        listRootDepth: s,
        listId: t.rdfNil
      });
      e.listPointerStack[i] = o
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ContainerHandlerIdentifier = void 0;
  t.ContainerHandlerIdentifier = class {
    canCombineWithGraph() {
      return !0
    }
    async handle(e, t, r, n, i, a) {
      let s;
      if (t.emittedStack[a + 1] && t.idStack[a + 1]) s = t.idStack[a + 1][0];
      else {
        const e = null !== await r.getContainerKey(n[a], n, a) ? await r.resourceToTerm(await t.getContext(n), n[a]) : r.dataFactory.blankNode();
        if (!e) return void(t.emittedStack[a] = !1);
        s = e, t.idStack[a + 1] = [s]
      }
      let o = t.idStack[a];
      o || (o = t.idStack[a] = []), o.some(e => e.equals(s)) || o.push(s), await t.handlePendingContainerFlushBuffers() || (t.emittedStack[a] = !1)
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ContainerHandlerIndex = void 0;
  const n = r(9),
    i = r(64),
    a = r(27);
  t.ContainerHandlerIndex = class {
    canCombineWithGraph() {
      return !0
    }
    async handle(e, t, r, s, o, u) {
      if (!Array.isArray(o)) {
        const c = "@graph" in e,
          l = await t.getContext(s),
          h = s[u - 1],
          d = a.Util.getContextValueIndex(l, h);
        if (d) {
          if (n.Util.isPotentialKeyword(d)) throw new n.ErrorCoded("Keywords can not be used as @index value, got: " + d, n.ERROR_CODES.INVALID_TERM_DEFINITION);
          if ("string" != typeof d) throw new n.ErrorCoded("@index values must be strings, got: " + d, n.ERROR_CODES.INVALID_TERM_DEFINITION);
          if ("object" != typeof o) {
            if ("@id" !== a.Util.getContextValueType(l, h)) throw new n.ErrorCoded("Property-based index containers require nodes as values or strings with @type: @id, but got: " + o, n.ERROR_CODES.INVALID_VALUE_OBJECT);
            const e = r.resourceToTerm(l, o);
            e && (t.idStack[u + 1] = [e])
          }
          const e = r.createVocabOrBaseTerm(l, d);
          if (e) {
            const n = await r.valueToTerm(l, d, await r.getContainerKey(s[u], s, u), u, s);
            if (c) {
              const i = await r.getGraphContainerValue(s, u + 1);
              for (const a of n) t.emitQuad(u, r.dataFactory.quad(i, e, a, r.getDefaultGraph()))
            } else
              for (const a of n) await i.EntryHandlerPredicate.handlePredicateObject(t, r, s, u + 1, e, a, !1)
          }
        }
        const p = c ? 2 : 1;
        await t.newOnValueJob(s.slice(0, s.length - p), o, u - p, !0), await t.handlePendingContainerFlushBuffers()
      }
      t.emittedStack[u] = !1
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ContainerHandlerLanguage = void 0;
  const n = r(9);
  t.ContainerHandlerLanguage = class {
    canCombineWithGraph() {
      return !1
    }
    async handle(e, t, r, i, a, s) {
      const o = await r.getContainerKey(i[s], i, s);
      if (Array.isArray(a)) a = a.map(e => ({
        "@value": e,
        "@language": o
      }));
      else {
        if ("string" != typeof a) throw new n.ErrorCoded(`Got invalid language map value, got '${JSON.stringify(a)}', but expected string`, n.ERROR_CODES.INVALID_LANGUAGE_MAP_VALUE);
        a = {
          "@value": a,
          "@language": o
        }
      }
      await t.newOnValueJob(i.slice(0, i.length - 1), a, s - 1, !0), t.emittedStack[s] = !1
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ContainerHandlerType = void 0;
  const n = r(64),
    i = r(27);
  t.ContainerHandlerType = class {
    canCombineWithGraph() {
      return !1
    }
    async handle(e, t, r, a, s, o) {
      if (!Array.isArray(s)) {
        if ("string" == typeof s) {
          const e = await t.getContext(a),
            n = "@vocab" === i.Util.getContextValueType(e, a[o - 1]) ? await r.createVocabOrBaseTerm(e, s) : await r.resourceToTerm(e, s);
          if (n) {
            const e = {
              "@id": "NamedNode" === n.termType ? n.value : s
            };
            await t.newOnValueJob(a.slice(0, a.length - 1), e, o - 1, !0), t.idStack[o + 1] = [n]
          }
        } else {
          const e = !!t.idStack[o + 1];
          e || delete t.idStack[o], await t.newOnValueJob(a.slice(0, a.length - 1), s, o - 1, !0), e || (t.idStack[o + 1] = t.idStack[o])
        }
        const e = await r.getContainerKey(a[o], a, o),
          u = null !== e ? r.createVocabOrBaseTerm(await t.getContext(a), e) : null;
        u && await n.EntryHandlerPredicate.handlePredicateObject(t, r, a, o + 1, r.rdfType, u, !1), await t.handlePendingContainerFlushBuffers()
      }
      t.emittedStack[o] = !1
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.EntryHandlerInvalidFallback = void 0;
  t.EntryHandlerInvalidFallback = class {
    isPropertyHandler() {
      return !1
    }
    isStackProcessor() {
      return !0
    }
    async validate(e, t, r, n, i) {
      return !1
    }
    async test(e, t, r, n, i) {
      return !0
    }
    async handle(e, t, r, n, i, a) {
      e.emittedStack[a] = !1
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.EntryHandlerKeywordContext = void 0;
  const n = r(9),
    i = r(28);
  class a extends i.EntryHandlerKeyword {
    constructor() {
      super("@context")
    }
    isStackProcessor() {
      return !1
    }
    async handle(e, t, r, i, a, s) {
      e.streamingProfile && (e.processingStack[s] || e.processingType[s] || void 0 !== e.idStack[s]) && e.emitError(new n.ErrorCoded("Found an out-of-order context, while streaming is enabled.(disable `streamingProfile`)", n.ERROR_CODES.INVALID_STREAMING_KEY_ORDER));
      const o = e.getContext(i),
        u = e.parseContext(a, (await o).getContextRaw());
      e.contextTree.setContext(i.slice(0, -1), u), e.emitContext(a), await e.validateContext(await u)
    }
  }
  t.EntryHandlerKeywordContext = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.EntryHandlerKeywordGraph = void 0;
  const n = r(28);
  class i extends n.EntryHandlerKeyword {
    constructor() {
      super("@graph")
    }
    async handle(e, t, r, n, i, a) {
      e.graphStack[a + 1] = !0
    }
  }
  t.EntryHandlerKeywordGraph = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.EntryHandlerKeywordId = void 0;
  const n = r(9),
    i = r(28);
  class a extends i.EntryHandlerKeyword {
    constructor() {
      super("@id")
    }
    isStackProcessor() {
      return !1
    }
    async handle(e, t, r, i, a, s) {
      "string" != typeof a && e.emitError(new n.ErrorCoded(`Found illegal @id '${a}'`, n.ERROR_CODES.INVALID_ID_VALUE));
      const o = await t.getPropertiesDepth(i, s);
      void 0 !== e.idStack[o] && (e.idStack[o][0].listHead ? e.emitError(new n.ErrorCoded(`Found illegal neighbouring entries next to @list for key: '${i[s-1]}'`, n.ERROR_CODES.INVALID_SET_OR_LIST_OBJECT)) : e.emitError(new n.ErrorCoded(`Found duplicate @ids '${e.idStack[o][0].value}' and '${a}'`, n.ERROR_CODES.COLLIDING_KEYWORDS))), e.idStack[o] = t.nullableTermToArray(await t.resourceToTerm(await e.getContext(i), a))
    }
  }
  t.EntryHandlerKeywordId = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.EntryHandlerKeywordIncluded = void 0;
  const n = r(9),
    i = r(28);
  class a extends i.EntryHandlerKeyword {
    constructor() {
      super("@included")
    }
    async handle(e, t, r, i, a, s) {
      "object" != typeof a && e.emitError(new n.ErrorCoded(`Found illegal @included '${a}'`, n.ERROR_CODES.INVALID_INCLUDED_VALUE));
      const o = await t.unaliasKeywords(a, i, s, await e.getContext(i));
      "@value" in o && e.emitError(new n.ErrorCoded(`Found an illegal @included @value node '${JSON.stringify(a)}'`, n.ERROR_CODES.INVALID_INCLUDED_VALUE)), "@list" in o && e.emitError(new n.ErrorCoded(`Found an illegal @included @list node '${JSON.stringify(a)}'`, n.ERROR_CODES.INVALID_INCLUDED_VALUE)), e.emittedStack[s] = !1
    }
  }
  t.EntryHandlerKeywordIncluded = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.EntryHandlerKeywordNest = void 0;
  const n = r(9),
    i = r(28);
  class a extends i.EntryHandlerKeyword {
    constructor() {
      super("@nest")
    }
    async handle(e, t, r, i, a, s) {
      "object" != typeof a && e.emitError(new n.ErrorCoded(`Found invalid @nest entry for '${r}': '${a}'`, n.ERROR_CODES.INVALID_NEST_VALUE)), "@value" in await t.unaliasKeywords(a, i, s, await e.getContext(i)) && e.emitError(new n.ErrorCoded(`Found an invalid @value node for '${r}'`, n.ERROR_CODES.INVALID_NEST_VALUE)), e.emittedStack[s] = !1
    }
  }
  t.EntryHandlerKeywordNest = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.EntryHandlerKeywordType = void 0;
  const n = r(9),
    i = r(27),
    a = r(64),
    s = r(28);
  class o extends s.EntryHandlerKeyword {
    constructor() {
      super("@type")
    }
    isStackProcessor() {
      return !1
    }
    async handle(e, t, r, s, o, u) {
      const c = s[u],
        l = await e.getContext(s),
        h = t.rdfType,
        d = i.Util.isPropertyReverse(l, c, await t.unaliasKeywordParent(s, u)),
        p = Array.isArray(o) ? o : [o];
      for (const r of p) {
        "string" != typeof r && e.emitError(new n.ErrorCoded(`Found illegal @type '${r}'`, n.ERROR_CODES.INVALID_TYPE_VALUE));
        const i = t.createVocabOrBaseTerm(l, r);
        i && await a.EntryHandlerPredicate.handlePredicateObject(e, t, s, u, h, i, d)
      }
      let f = Promise.resolve(l),
        g = !1;
      for (const t of p.sort()) {
        const r = i.Util.getContextValue(l, "@context", t, null);
        r && (g = !0, f = f.then(t => e.parseContext(r, t.getContextRaw())))
      }!e.streamingProfile || !g && e.streamingProfileAllowOutOfOrderPlainType || !e.processingStack[u] && !e.idStack[u] || e.emitError(new n.ErrorCoded("Found an out-of-order type-scoped context, while streaming is enabled.(disable `streamingProfile`)", n.ERROR_CODES.INVALID_STREAMING_KEY_ORDER)), g && (f = f.then(e => ("@propagate" in e.getContextRaw() || (e.getContextRaw()["@propagate"] = !1), !1 === e.getContextRaw()["@propagate"] && (e.getContextRaw()["@__propagateFallback"] = l.getContextRaw()), e)), e.contextTree.setContext(s.slice(0, s.length - 1), f)), e.processingType[u] = !0
    }
  }
  t.EntryHandlerKeywordType = o
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.EntryHandlerKeywordUnknownFallback = void 0;
  const n = r(9);
  class i {
    isPropertyHandler() {
      return !1
    }
    isStackProcessor() {
      return !0
    }
    async validate(e, t, r, i, a) {
      const s = await t.unaliasKeyword(r[i], r, i);
      return !!n.Util.isPotentialKeyword(s) && !(!a && "@list" === s)
    }
    async test(e, t, r, i, a) {
      return n.Util.isPotentialKeyword(r)
    }
    async handle(e, t, r, a, s, o) {
      const u = i.VALID_KEYWORDS_TYPES[r];
      void 0 !== u ? u && typeof s !== u.type && e.emitError(new n.ErrorCoded(`Invalid value type for '${r}' with value '${s}'`, u.errorCode)) : e.strictValues && e.emitError(new Error(`Unknown keyword '${r}' with value '${s}'`)), e.emittedStack[o] = !1
    }
  }
  t.EntryHandlerKeywordUnknownFallback = i, i.VALID_KEYWORDS_TYPES = {
    "@index": {
      type: "string",
      errorCode: n.ERROR_CODES.INVALID_INDEX_VALUE
    },
    "@list": null,
    "@reverse": {
      type: "object",
      errorCode: n.ERROR_CODES.INVALID_REVERSE_VALUE
    },
    "@set": null,
    "@value": null
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.EntryHandlerKeywordValue = void 0;
  const n = r(28);
  class i extends n.EntryHandlerKeyword {
    constructor() {
      super("@value")
    }
    async test(e, t, r, n, i) {
      return "@value" === await t.unaliasKeyword(n[i], n.slice(0, n.length - 1), i - 1, !0)
    }
    async handle(e, t, r, n, i, a) {
      e.literalStack[a] = !0, delete e.unidentifiedValuesBuffer[a], delete e.unidentifiedGraphsBuffer[a], e.emittedStack[a] = !1
    }
  }
  t.EntryHandlerKeywordValue = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ParsingContext = void 0;
  const n = r(9),
    i = r(47),
    a = r(442),
    s = r(169);
  class o {
    constructor(e) {
      this.contextParser = new n.ContextParser({
        documentLoader: e.documentLoader
      }), this.streamingProfile = !!e.streamingProfile, this.baseIRI = e.baseIRI, this.produceGeneralizedRdf = !!e.produceGeneralizedRdf, this.allowSubjectList = !!e.allowSubjectList, this.processingMode = e.processingMode || s.JsonLdParser.DEFAULT_PROCESSING_MODE, this.strictValues = !!e.strictValues, this.validateValueIndexes = !!e.validateValueIndexes, this.defaultGraph = e.defaultGraph, this.rdfDirection = e.rdfDirection, this.normalizeLanguageTags = e.normalizeLanguageTags, this.streamingProfileAllowOutOfOrderPlainType = e.streamingProfileAllowOutOfOrderPlainType, this.topLevelProperties = !1, this.activeProcessingMode = parseFloat(this.processingMode), this.processingStack = [], this.processingType = [], this.emittedStack = [], this.idStack = [], this.graphStack = [], this.graphContainerTermStack = [], this.listPointerStack = [], this.contextTree = new a.ContextTree, this.literalStack = [], this.validationStack = [], this.unaliasedKeywordCacheStack = [], this.jsonLiteralStack = [], this.unidentifiedValuesBuffer = [], this.unidentifiedGraphsBuffer = [], this.pendingContainerFlushBuffers = [], this.parser = e.parser, e.context ? (this.rootContext = this.parseContext(e.context), this.rootContext.then(e => this.validateContext(e))) : this.rootContext = Promise.resolve(new n.JsonLdContextNormalized(this.baseIRI ? {
        "@base": this.baseIRI,
        "@__baseDocument": !0
      } : {}))
    }
    async parseContext(e, t, r) {
      return this.contextParser.parse(e, {
        baseIRI: this.baseIRI,
        ignoreProtection: r,
        normalizeLanguageTags: this.normalizeLanguageTags,
        parentContext: t,
        processingMode: this.activeProcessingMode
      })
    }
    validateContext(e) {
      const t = e.getContextRaw()["@version"];
      if (t) {
        if (this.activeProcessingMode && t > this.activeProcessingMode) throw new i.ErrorCoded(`Unsupported JSON-LD version '${t}' under active processing mode ${this.activeProcessingMode}.`, i.ERROR_CODES.PROCESSING_MODE_CONFLICT);
        if (this.activeProcessingMode && t < this.activeProcessingMode) throw new i.ErrorCoded(`Invalid JSON-LD version ${t} under active processing mode ${this.activeProcessingMode}.`, i.ERROR_CODES.INVALID_VERSION_VALUE);
        this.activeProcessingMode = t
      }
    }
    async getContext(e, t = 1) {
      const r = e;
      for (;
        "number" == typeof e[e.length - 1];) e = e.slice(0, e.length - 1);
      t && (e = e.slice(0, -t));
      const i = await this.getContextPropagationAware(e);
      let a = i.context.getContextRaw();
      for (let e = i.depth; e < r.length - t; e++) {
        const i = r[e],
          s = a[i];
        if (s && "object" == typeof s && "@context" in s) {
          const o = (await this.parseContext(s, a, !0)).getContextRaw(),
            u = !(i in o) || o[i]["@context"]["@propagate"];
          !1 === u && e !== r.length - 1 - t || (a = o, delete a["@propagate"], a[i] = Object.assign({}, a[i]), "@id" in s && (a[i]["@id"] = s["@id"]), delete a[i]["@context"], !1 !== u && this.contextTree.setContext(r.slice(0, e + t), Promise.resolve(new n.JsonLdContextNormalized(a))))
        }
      }
      return new n.JsonLdContextNormalized(a)
    }
    async getContextPropagationAware(e) {
      const t = e.length;
      let r, i = null;
      do {
        r = !1, i && "@__propagateFallback" in i.context.getContextRaw() ? i.context = new n.JsonLdContextNormalized(i.context.getContextRaw()["@__propagateFallback"]) : (i && (e = e.slice(0, i.depth - 1)), i = await this.contextTree.getContext(e) || {
          context: await this.rootContext,
          depth: 0
        });
        const t = e[e.length - 1];
        if (t in i.context.getContextRaw()) {
          const e = i.context.getContextRaw()[t];
          e && "object" == typeof e && "@context" in e && (r = !0)
        }
      } while (i.depth > 0 && !1 === i.context.getContextRaw()["@propagate"] && i.depth !== t && !r);
      return 0 === i.depth && !1 === i.context.getContextRaw()["@propagate"] && i.depth !== t && (i.context = new n.JsonLdContextNormalized({})), i
    }
    async newOnValueJob(e, t, r, n) {
      await this.parser.newOnValueJob(e, t, r, n)
    }
    async handlePendingContainerFlushBuffers() {
      if (this.pendingContainerFlushBuffers.length > 0) {
        for (const e of this.pendingContainerFlushBuffers) await this.parser.flushBuffer(e.depth, e.keys), this.parser.flushStacks(e.depth);
        return this.pendingContainerFlushBuffers.splice(0, this.pendingContainerFlushBuffers.length), !0
      }
      return !1
    }
    emitQuad(e, t) {
      1 === e && (this.topLevelProperties = !0), this.parser.push(t)
    }
    emitError(e) {
      this.parser.emit("error", e)
    }
    emitContext(e) {
      this.parser.emit("context", e)
    }
    getUnidentifiedValueBufferSafe(e) {
      let t = this.unidentifiedValuesBuffer[e];
      return t || (t = [], this.unidentifiedValuesBuffer[e] = t), t
    }
    getUnidentifiedGraphBufferSafe(e) {
      let t = this.unidentifiedGraphsBuffer[e];
      return t || (t = [], this.unidentifiedGraphsBuffer[e] = t), t
    }
    getExpandOptions() {
      return o.EXPAND_OPTIONS[this.activeProcessingMode]
    }
    shiftStack(e, t) {
      const r = this.idStack[e + t];
      if (r && (this.idStack[e] = r, this.emittedStack[e] = !0, delete this.idStack[e + t]), this.pendingContainerFlushBuffers.length)
        for (const r of this.pendingContainerFlushBuffers) r.depth >= e + t && (r.depth -= t, r.keys.splice(e, t));
      this.unidentifiedValuesBuffer[e + t] && (this.unidentifiedValuesBuffer[e] = this.unidentifiedValuesBuffer[e + t], delete this.unidentifiedValuesBuffer[e + t])
    }
  }
  t.ParsingContext = o, o.EXPAND_OPTIONS = {
    1: {
      allowPrefixForcing: !1,
      allowPrefixNonGenDelims: !1,
      allowVocabRelativeToBase: !1
    },
    1.1: {
      allowPrefixForcing: !0,
      allowPrefixNonGenDelims: !1,
      allowVocabRelativeToBase: !0
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ContextTree = void 0;
  class n {
    constructor() {
      this.subTrees = {}
    }
    getContext(e) {
      if (e.length > 0) {
        const [t, ...r] = e, n = this.subTrees[t];
        if (n) {
          const e = n.getContext(r);
          if (e) return e.then(({
                                  context: e,
                                  depth: t
                                }) => ({
            context: e,
            depth: t + 1
          }))
        }
      }
      return this.context ? this.context.then(e => ({
        context: e,
        depth: 0
      })) : null
    }
    setContext(e, t) {
      if (0 === e.length) this.context = t;
      else {
        const [r, ...i] = e;
        let a = this.subTrees[r];
        a || (a = this.subTrees[r] = new n), a.setContext(i, t)
      }
    }
    removeContext(e) {
      this.setContext(e, null)
    }
  }
  t.ContextTree = n
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(444), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfResolveHypermediaSparql = void 0;
  const n = r(87),
    i = r(445);
  class a extends n.ActorRdfResolveHypermedia {
    constructor(e) {
      super(e, "sparql")
    }
    async testMetadata(e) {
      if (!(e.forceSourceType || e.metadata.sparqlService || this.checkUrlSuffix && e.url.endsWith("/sparql"))) throw new Error(`Actor ${this.name} could not detect a SPARQL service description or URL ending on /sparql.`);
      return {
        filterFactor: 1
      }
    }
    async run(e) {
      this.logInfo(e.context, "Identified as sparql source: " + e.url);
      return {
        source: new i.RdfSourceSparql(e.metadata.sparqlService || e.url, e.context, this.mediatorHttp)
      }
    }
  }
  t.ActorRdfResolveHypermediaSparql = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.RdfSourceSparql = void 0;
  const n = r(446),
    i = r(18),
    a = r(6);
  class s {
    constructor(e, t, r) {
      this.url = e, this.context = t, this.mediatorHttp = r
    }
    queryBindings(e, t, r) {
      return new n.AsyncIteratorJsonBindings(e, t, r, this.mediatorHttp)
    }
    match(e, t, r, a) {
      const o = n.ActorRdfResolveQuadPatternSparqlJson.replaceBlankNodes(s.FACTORY.createPattern(e, t, r, a)),
        u = n.ActorRdfResolveQuadPatternSparqlJson.patternToCountQuery(o),
        c = n.ActorRdfResolveQuadPatternSparqlJson.patternToSelectQuery(o);
      new Promise(e => {
        const t = this.queryBindings(this.url, u, this.context);
        t.on("data", t => {
          const r = t.get("?count");
          if (r) {
            const t = Number.parseInt(r.value, 10);
            return Number.isNaN(t) ? e({
              totalItems: 1 / 0
            }) : e({
              totalItems: t
            })
          }
          return e({
            totalItems: 1 / 0
          })
        }), t.on("error", () => e({
          totalItems: 1 / 0
        })), t.on("end", () => e({
          totalItems: 1 / 0
        }))
      }).then(e => l.setProperty("metadata", e));
      const l = this.queryBindings(this.url, c, this.context).map(e => i.mapTerms(o, t => {
        if ("Variable" === t.termType) {
          const r = e.get("?" + t.value);
          return r || l.destroy(new Error(`The endpoint ${this.url} failed to provide a binding for ${t.value}.`)), r
        }
        return t
      }));
      return l
    }
  }
  t.RdfSourceSparql = s, s.FACTORY = new a.Factory
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(447), t), i(r(172), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfResolveQuadPatternSparqlJson = void 0;
  const n = r(21),
    i = r(3),
    a = r(5),
    s = r(18),
    o = r(6),
    u = r(172),
    c = new a.DataFactory;
  class l extends n.ActorRdfResolveQuadPattern {
    constructor(e) {
      super(e)
    }
    static replaceBlankNodes(e) {
      const t = s.getVariables(s.getTerms(e)).map(e => e.value),
        r = {};
      let n = !1;
      const i = s.mapTerms(e, e => {
        if ("BlankNode" === e.termType) {
          let i = e.value;
          if (r[i]) i = r[i];
          else {
            if (t.includes(i)) {
              let e = 0;
              for (; t.includes(`${i}${e}`);) ++e;
              i += e
            }
            r[e.value] = i, t.push(i)
          }
          return n = !0, c.variable(i)
        }
        return e
      });
      return n ? i : e
    }
    static patternToBgp(e) {
      return l.FACTORY.createBgp([l.FACTORY.createPattern(e.subject, e.predicate, e.object, e.graph)])
    }
    static patternToSelectQuery(e) {
      const t = s.getVariables(s.getTerms(e));
      return o.toSparql(l.FACTORY.createProject(l.patternToBgp(e), t))
    }
    static patternToCountQuery(e) {
      return o.toSparql(l.FACTORY.createProject(l.FACTORY.createExtend(l.FACTORY.createGroup(l.patternToBgp(e), [], [l.FACTORY.createBoundAggregate(c.variable("var0"), "count", l.FACTORY.createWildcardExpression(), !1)]), c.variable("count"), l.FACTORY.createTermExpression(c.variable("var0"))), [c.variable("count")]))
    }
    async test(e) {
      if (!this.hasContextSingleSourceOfType("sparql", e.context)) throw new Error(this.name + " requires a single source with a 'sparql' endpoint to be present in the context.");
      return !0
    }
    async run(e) {
      const t = this.getContextSourceUrl(this.getContextSource(e.context)),
        r = l.replaceBlankNodes(e.pattern),
        n = l.patternToSelectQuery(r),
        a = l.patternToCountQuery(r);
      this.queryBindings(t, a, e.context).then(e => new Promise(t => {
        e.on("data", e => {
          const r = e.get("?count");
          if (r) {
            const e = Number.parseInt(r.value, 10);
            return Number.isNaN(e) ? t({
              totalItems: 1 / 0
            }) : t({
              totalItems: e
            })
          }
          return t({
            totalItems: 1 / 0
          })
        }), e.on("error", () => t({
          totalItems: 1 / 0
        })), e.on("end", () => t({
          totalItems: 1 / 0
        }))
      })).then(e => o.setProperty("metadata", e)).catch(e => {
        o.destroy(e), o.setProperty("metadata", {
          totalItems: 1 / 0
        })
      });
      const o = new i.TransformIterator(async () => (await this.queryBindings(t, n, e.context)).map(e => s.mapTerms(r, r => {
        if ("Variable" === r.termType) {
          const n = e.get("?" + r.value);
          return n || o.emit("error", new Error(`The endpoint ${t} failed to provide a binding for ${r.value}`)), n
        }
        return r
      })), {
        autoStart: !1
      });
      return {
        data: o
      }
    }
    async queryBindings(e, t, r) {
      return new u.AsyncIteratorJsonBindings(e, t, r, this.mediatorHttp)
    }
  }
  t.ActorRdfResolveQuadPatternSparqlJson = l, l.FACTORY = new o.Factory
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(449), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationSparqlEndpoint = void 0;
  const n = r(1),
    i = r(21),
    a = r(450),
    s = r(3),
    o = r(452),
    u = r(4),
    c = r(6);
  class l extends n.ActorQueryOperation {
    constructor(e) {
      super(e), this.endpointFetcher = new o.SparqlEndpointFetcher({
        fetch: (e, t) => this.mediatorHttp.mediate({
          input: e,
          init: t,
          context: this.lastContext
        }),
        prefixVariableQuestionMark: !0
      })
    }
    async test(e) {
      if (!e.operation) throw new Error("Missing field 'operation' in a query operation action.");
      const t = await a.DataSourceUtils.getSingleSource(e.context);
      if (t && "sparql" === i.getDataSourceType(t)) return {
        httpRequests: 1
      };
      throw new Error(this.name + " requires a single source with a 'sparql' endpoint to be present in the context.")
    }
    async run(e) {
      const t = await a.DataSourceUtils.getSingleSource(e.context);
      if (!t) throw new Error("Illegal state: undefined sparql endpoint source.");
      const r = i.getDataSourceValue(t);
      let n, s, o;
      this.lastContext = e.context;
      try {
        n = c.toSparql(e.operation), s = this.endpointFetcher.getQueryType(n)
      } catch (e) {}
      switch (s && "UNKNOWN" !== s || (o = c.Util.inScopeVariables(e.operation), n = c.toSparql(l.FACTORY.createProject(e.operation, o)), s = "SELECT"), s) {
        case "SELECT":
          return o || (o = c.Util.inScopeVariables(e.operation)), this.executeQuery(r, n, !1, o);
        case "CONSTRUCT":
          return this.executeQuery(r, n, !0);
        case "ASK":
          return {
            type: "boolean", booleanResult: this.endpointFetcher.fetchAsk(r, n)
          }
      }
    }
    executeQuery(e, t, r, i) {
      const a = r ? this.endpointFetcher.fetchTriples(e, t) : this.endpointFetcher.fetchBindings(e, t);
      let o = 0;
      const c = s.wrap(a, {
        autoStart: !1,
        maxBufferSize: 1 / 0
      }).map(e => (o++, r ? e : n.Bindings(e)));
      a.then(e => e.on("end", () => c.emit("metadata", {
        totalItems: o
      })), () => {});
      const h = l.cachifyMetadata(() => new Promise((e, t) => {
        c._fillBuffer(), c.on("error", t), c.on("end", () => t(new Error("No metadata was found"))), c.on("metadata", e)
      }));
      return r ? {
        type: "quads",
        quadStream: c,
        metadata: h
      } : {
        type: "bindings",
        bindingsStream: c,
        metadata: h,
        variables: i.map(e => u.termToString(e)),
        canContainUndefs: !0
      }
    }
  }
  t.ActorQueryOperationSparqlEndpoint = l, l.FACTORY = new c.Factory
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(451), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.DataSourceUtils = void 0;
  const n = r(21);
  t.DataSourceUtils = {
    async getSingleSource(e) {
      if (e && e.has(n.KEY_CONTEXT_SOURCE)) return e.get(n.KEY_CONTEXT_SOURCE);
      if (e && e.has(n.KEY_CONTEXT_SOURCES)) {
        const t = e.get(n.KEY_CONTEXT_SOURCES);
        if (1 === t.length) return t[0]
      }
    },
    async getSingleSourceType(e) {
      const t = await this.getSingleSource(e);
      return t ? n.getDataSourceType(t) : void 0
    },
    async singleSourceHasType(e, t) {
      const r = await this.getSingleSourceType(e);
      return !!r && r === t
    }
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(453), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.SparqlEndpointFetcher = void 0, r(45);
  const n = r(30),
    i = r(74),
    a = r(454),
    s = r(41),
    o = r(124),
    u = r(125).toNodeReadable;
  class c {
    constructor(e) {
      e = e || {}, this.fetchCb = e.fetch, this.sparqlJsonParser = new i.SparqlJsonParser(e), this.sparqlXmlParser = new a.SparqlXmlParser(e), this.sparqlParsers = {
        [c.CONTENTTYPE_SPARQL_JSON]: {
          parseBooleanStream: e => this.sparqlJsonParser.parseJsonBooleanStream(e),
          parseResultsStream: e => this.sparqlJsonParser.parseJsonResultsStream(e)
        },
        [c.CONTENTTYPE_SPARQL_XML]: {
          parseBooleanStream: e => this.sparqlXmlParser.parseXmlBooleanStream(e),
          parseResultsStream: e => this.sparqlXmlParser.parseXmlResultsStream(e)
        }
      }
    }
    getQueryType(e) {
      const t = (new n.Parser).parse(e);
      return "query" === t.type ? "DESCRIBE" === t.queryType ? "CONSTRUCT" : t.queryType : "UNKNOWN"
    }
    async fetchBindings(e, t) {
      const [r, n] = await this.fetchRawStream(e, t, c.CONTENTTYPE_SPARQL), i = this.sparqlParsers[r];
      if (!i) throw new Error("Unknown SPARQL results content type: " + r);
      return i.parseResultsStream(n)
    }
    async fetchAsk(e, t) {
      const [r, n] = await this.fetchRawStream(e, t, c.CONTENTTYPE_SPARQL), i = this.sparqlParsers[r];
      if (!i) throw new Error("Unknown SPARQL results content type: " + r);
      return i.parseBooleanStream(n)
    }
    async fetchTriples(e, t) {
      return (await this.fetchRawStream(e, t, c.CONTENTTYPE_TURTLE))[1].pipe(new s.StreamParser({
        format: c.CONTENTTYPE_TURTLE
      }))
    }
    async fetchRawStream(e, t, r) {
      const n = e + "?query=" + encodeURIComponent(t),
        i = new Headers;
      i.append("Accept", r);
      const a = await (this.fetchCb || fetch)(n, {
          headers: i
        }),
        s = o(a.body) ? a.body : u(a.body);
      let c = a.headers.get("Content-Type") || "";
      if (c.indexOf(";") > 0 && (c = c.substr(0, c.indexOf(";"))), !a.ok) throw new Error("Invalid SPARQL endpoint (" + e + ") response: " + a.statusText);
      return [c, s]
    }
  }
  t.SparqlEndpointFetcher = c, c.CONTENTTYPE_SPARQL_JSON = "application/sparql-results+json", c.CONTENTTYPE_SPARQL_XML = "application/sparql-results+xml", c.CONTENTTYPE_SPARQL = `${c.CONTENTTYPE_SPARQL_JSON};q=1.0,${c.CONTENTTYPE_SPARQL_XML};q=0.7`, c.CONTENTTYPE_TURTLE = "text/turtle"
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(455), t), i(r(173), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.SparqlXmlParser = void 0;
  const n = r(5),
    i = r(173),
    a = r(456);
  t.SparqlXmlParser = class {
    constructor(e) {
      e = e || {}, this.dataFactory = e.dataFactory || new n.DataFactory, this.prefixVariableQuestionMark = !!e.prefixVariableQuestionMark
    }
    parseXmlResultsStream(e) {
      const t = [];
      e.pipe(a({
        strict: !0,
        tag: "variable"
      })).on("data", e => t.push(this.dataFactory.variable(e.attribs.name))).on("error", () => {}).on("finish", () => r.emit("variables", t));
      const r = e.pipe(a({
        strict: !0,
        tag: "result"
      })).on("error", e => r.emit("error", e)).pipe(new i.SparqlXmlBindingsTransformer(this));
      return e.on("error", e => r.emit("error", e)), r
    }
    parseXmlBindings(e) {
      const t = {};
      if (e.children) {
        const r = Array.isArray(e.children.binding) ? e.children.binding : [e.children.binding];
        for (const e of r)
          if (e.attribs && e.children) {
            const r = e.attribs.name;
            let n = null;
            if (e.children.bnode) n = this.dataFactory.blankNode(e.children.bnode.value);
            else if (e.children.literal) {
              const t = e.children.literal.value || "",
                r = e.children.literal.attribs;
              n = r && r["xml:lang"] ? this.dataFactory.literal(t, r["xml:lang"]) : r && r.datatype ? this.dataFactory.literal(t, this.dataFactory.namedNode(r.datatype)) : this.dataFactory.literal(t)
            } else n = this.dataFactory.namedNode(e.children.uri.value);
            t[this.prefixVariableQuestionMark ? "?" + r : r] = n
          }
      }
      return t
    }
    parseXmlBooleanStream(e) {
      return new Promise((t, r) => {
        e.on("error", r), e.pipe(a({
          strict: !0,
          tag: "boolean"
        })).on("error", r).on("data", e => t("true" === e.value)).on("end", () => r(new Error("No valid ASK response was found.")))
      })
    }
  }
}, function(e, t, r) {
  e.exports = r(457)
}, function(e, t, r) {
  var n = r(2).Transform,
    i = r(458),
    a = r(131),
    s = r(461),
    o = r(462)("sax-stream");

  function u(e) {
    if (!(this instanceof u)) return new u(e);
    n.call(this, {
      highWaterMark: e.highWaterMark || 350,
      objectMode: !0
    }), this.records = [], this.error = null, this.parser = this.createSaxParser(e)
  }
  e.exports = u, i.inherits(u, n), u.prototype.createSaxParser = function(e) {
    var t, r = this,
      n = a.parser(e.strict || !1, function(e) {
        return ["trim", "normalize", "lowercase", "xmlns", "position", "strictEntities", "noscript"].reduce((function(t, r) {
          return r in e && (t[r] = e[r]), t
        }), {
          position: !1
        })
      }(e)),
      i = function(t) {
        return t === e.tag
      },
      u = function(e, t) {
        r.records.push(t)
      };
    return Array.isArray(e.tag) && (i = function(t) {
      return -1 !== e.tag.indexOf(t)
    }, u = function(e, t) {
      r.records.push({
        tag: e,
        record: t
      })
    }), n.onopentag = function(e) {
      o('Open "%s"', e.name), t ? t = s.addChild(t, e.name) : i(e.name) && (t = {}), t && Object.keys(e.attributes).length && (t.attribs = e.attributes)
    }, n.onclosetag = function(e) {
      o('Closed "%s"', e), i(e) && !t.parent ? (o("Emitting record", t), u(e, t), t = void 0) : t && (t = t.parent)
    }, n.ontext = function(e) {
      t && s.addText(t, e)
    }, n.oncdata = function(e) {
      t && s.concatText(t, e)
    }, n.onerror = function(e) {
      r.error = e
    }, n.onend = function() {
      o("onend - flushing remaining items"), r.pushAll(r.callback), r.callback = null
    }, n
  }, u.prototype.pushAll = function(e) {
    if (this.error) return e(this.error), void(this.error = null);
    o("pushing %d", this.records.length), this.records.forEach(this.push.bind(this)), this.records.length = 0, e()
  }, u.prototype._transform = function(e, t, r) {
    this.parser.write(e.toString()), this.pushAll(r)
  }, u.prototype._flush = function(e) {
    this.callback = e, this.parser.close()
  }
}, function(e, t, r) {
  (function(e) {
    var n = Object.getOwnPropertyDescriptors || function(e) {
        for (var t = Object.keys(e), r = {}, n = 0; n < t.length; n++) r[t[n]] = Object.getOwnPropertyDescriptor(e, t[n]);
        return r
      },
      i = /%[sdj%]/g;
    t.format = function(e) {
      if (!y(e)) {
        for (var t = [], r = 0; r < arguments.length; r++) t.push(o(arguments[r]));
        return t.join(" ")
      }
      r = 1;
      for (var n = arguments, a = n.length, s = String(e).replace(i, (function(e) {
        if ("%%" === e) return "%";
        if (r >= a) return e;
        switch (e) {
          case "%s":
            return String(n[r++]);
          case "%d":
            return Number(n[r++]);
          case "%j":
            try {
              return JSON.stringify(n[r++])
            } catch (e) {
              return "[Circular]"
            }
          default:
            return e
        }
      })), u = n[r]; r < a; u = n[++r]) g(u) || !v(u) ? s += " " + u : s += " " + o(u);
      return s
    }, t.deprecate = function(r, n) {
      if (void 0 !== e && !0 === e.noDeprecation) return r;
      if (void 0 === e) return function() {
        return t.deprecate(r, n).apply(this, arguments)
      };
      var i = !1;
      return function() {
        if (!i) {
          if (e.throwDeprecation) throw new Error(n);
          e.traceDeprecation ? console.trace(n) : console.error(n), i = !0
        }
        return r.apply(this, arguments)
      }
    };
    var a, s = {};

    function o(e, r) {
      var n = {
        seen: [],
        stylize: c
      };
      return arguments.length >= 3 && (n.depth = arguments[2]), arguments.length >= 4 && (n.colors = arguments[3]), f(r) ? n.showHidden = r : r && t._extend(n, r), b(n.showHidden) && (n.showHidden = !1), b(n.depth) && (n.depth = 2), b(n.colors) && (n.colors = !1), b(n.customInspect) && (n.customInspect = !0), n.colors && (n.stylize = u), l(n, e, n.depth)
    }

    function u(e, t) {
      var r = o.styles[t];
      return r ? "[" + o.colors[r][0] + "m" + e + "[" + o.colors[r][1] + "m" : e
    }

    function c(e, t) {
      return e
    }

    function l(e, r, n) {
      if (e.customInspect && r && T(r.inspect) && r.inspect !== t.inspect && (!r.constructor || r.constructor.prototype !== r)) {
        var i = r.inspect(n, e);
        return y(i) || (i = l(e, i, n)), i
      }
      var a = function(e, t) {
        if (b(t)) return e.stylize("undefined", "undefined");
        if (y(t)) {
          var r = "'" + JSON.stringify(t).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return e.stylize(r, "string")
        }
        if (m(t)) return e.stylize("" + t, "number");
        if (f(t)) return e.stylize("" + t, "boolean");
        if (g(t)) return e.stylize("null", "null")
      }(e, r);
      if (a) return a;
      var s = Object.keys(r),
        o = function(e) {
          var t = {};
          return e.forEach((function(e, r) {
            t[e] = !0
          })), t
        }(s);
      if (e.showHidden && (s = Object.getOwnPropertyNames(r)), S(r) && (s.indexOf("message") >= 0 || s.indexOf("description") >= 0)) return h(r);
      if (0 === s.length) {
        if (T(r)) {
          var u = r.name ? ": " + r.name : "";
          return e.stylize("[Function" + u + "]", "special")
        }
        if (_(r)) return e.stylize(RegExp.prototype.toString.call(r), "regexp");
        if (w(r)) return e.stylize(Date.prototype.toString.call(r), "date");
        if (S(r)) return h(r)
      }
      var c, v = "",
        E = !1,
        x = ["{", "}"];
      (p(r) && (E = !0, x = ["[", "]"]), T(r)) && (v = " [Function" + (r.name ? ": " + r.name : "") + "]");
      return _(r) && (v = " " + RegExp.prototype.toString.call(r)), w(r) && (v = " " + Date.prototype.toUTCString.call(r)), S(r) && (v = " " + h(r)), 0 !== s.length || E && 0 != r.length ? n < 0 ? _(r) ? e.stylize(RegExp.prototype.toString.call(r), "regexp") : e.stylize("[Object]", "special") : (e.seen.push(r), c = E ? function(e, t, r, n, i) {
        for (var a = [], s = 0, o = t.length; s < o; ++s) R(t, String(s)) ? a.push(d(e, t, r, n, String(s), !0)) : a.push("");
        return i.forEach((function(i) {
          i.match(/^\d+$/) || a.push(d(e, t, r, n, i, !0))
        })), a
      }(e, r, n, o, s) : s.map((function(t) {
        return d(e, r, n, o, t, E)
      })), e.seen.pop(), function(e, t, r) {
        if (e.reduce((function(e, t) {
          return t.indexOf("\n") >= 0 && 0, e + t.replace(/\u001b\[\d\d?m/g, "").length + 1
        }), 0) > 60) return r[0] + ("" === t ? "" : t + "\n ") + " " + e.join(",\n  ") + " " + r[1];
        return r[0] + t + " " + e.join(", ") + " " + r[1]
      }(c, v, x)) : x[0] + v + x[1]
    }

    function h(e) {
      return "[" + Error.prototype.toString.call(e) + "]"
    }

    function d(e, t, r, n, i, a) {
      var s, o, u;
      if ((u = Object.getOwnPropertyDescriptor(t, i) || {
        value: t[i]
      }).get ? o = u.set ? e.stylize("[Getter/Setter]", "special") : e.stylize("[Getter]", "special") : u.set && (o = e.stylize("[Setter]", "special")), R(n, i) || (s = "[" + i + "]"), o || (e.seen.indexOf(u.value) < 0 ? (o = g(r) ? l(e, u.value, null) : l(e, u.value, r - 1)).indexOf("\n") > -1 && (o = a ? o.split("\n").map((function(e) {
        return "  " + e
      })).join("\n").substr(2) : "\n" + o.split("\n").map((function(e) {
        return "   " + e
      })).join("\n")) : o = e.stylize("[Circular]", "special")), b(s)) {
        if (a && i.match(/^\d+$/)) return o;
        (s = JSON.stringify("" + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.substr(1, s.length - 2), s = e.stylize(s, "name")) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = e.stylize(s, "string"))
      }
      return s + ": " + o
    }

    function p(e) {
      return Array.isArray(e)
    }

    function f(e) {
      return "boolean" == typeof e
    }

    function g(e) {
      return null === e
    }

    function m(e) {
      return "number" == typeof e
    }

    function y(e) {
      return "string" == typeof e
    }

    function b(e) {
      return void 0 === e
    }

    function _(e) {
      return v(e) && "[object RegExp]" === E(e)
    }

    function v(e) {
      return "object" == typeof e && null !== e
    }

    function w(e) {
      return v(e) && "[object Date]" === E(e)
    }

    function S(e) {
      return v(e) && ("[object Error]" === E(e) || e instanceof Error)
    }

    function T(e) {
      return "function" == typeof e
    }

    function E(e) {
      return Object.prototype.toString.call(e)
    }

    function x(e) {
      return e < 10 ? "0" + e.toString(10) : e.toString(10)
    }
    t.debuglog = function(r) {
      if (b(a) && (a = e.env.NODE_DEBUG || ""), r = r.toUpperCase(), !s[r])
        if (new RegExp("\\b" + r + "\\b", "i").test(a)) {
          var n = e.pid;
          s[r] = function() {
            var e = t.format.apply(t, arguments);
            console.error("%s %d: %s", r, n, e)
          }
        } else s[r] = function() {};
      return s[r]
    }, t.inspect = o, o.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, o.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      regexp: "red"
    }, t.isArray = p, t.isBoolean = f, t.isNull = g, t.isNullOrUndefined = function(e) {
      return null == e
    }, t.isNumber = m, t.isString = y, t.isSymbol = function(e) {
      return "symbol" == typeof e
    }, t.isUndefined = b, t.isRegExp = _, t.isObject = v, t.isDate = w, t.isError = S, t.isFunction = T, t.isPrimitive = function(e) {
      return null === e || "boolean" == typeof e || "number" == typeof e || "string" == typeof e || "symbol" == typeof e || void 0 === e
    }, t.isBuffer = r(459);
    var O = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

    function A() {
      var e = new Date,
        t = [x(e.getHours()), x(e.getMinutes()), x(e.getSeconds())].join(":");
      return [e.getDate(), O[e.getMonth()], t].join(" ")
    }

    function R(e, t) {
      return Object.prototype.hasOwnProperty.call(e, t)
    }
    t.log = function() {
      console.log("%s - %s", A(), t.format.apply(t, arguments))
    }, t.inherits = r(460), t._extend = function(e, t) {
      if (!t || !v(t)) return e;
      for (var r = Object.keys(t), n = r.length; n--;) e[r[n]] = t[r[n]];
      return e
    };
    var I = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;

    function N(e, t) {
      if (!e) {
        var r = new Error("Promise was rejected with a falsy value");
        r.reason = e, e = r
      }
      return t(e)
    }
    t.promisify = function(e) {
      if ("function" != typeof e) throw new TypeError('The "original" argument must be of type Function');
      if (I && e[I]) {
        var t;
        if ("function" != typeof(t = e[I])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(t, I, {
          value: t,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), t
      }

      function t() {
        for (var t, r, n = new Promise((function(e, n) {
          t = e, r = n
        })), i = [], a = 0; a < arguments.length; a++) i.push(arguments[a]);
        i.push((function(e, n) {
          e ? r(e) : t(n)
        }));
        try {
          e.apply(this, i)
        } catch (e) {
          r(e)
        }
        return n
      }
      return Object.setPrototypeOf(t, Object.getPrototypeOf(e)), I && Object.defineProperty(t, I, {
        value: t,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(t, n(e))
    }, t.promisify.custom = I, t.callbackify = function(t) {
      if ("function" != typeof t) throw new TypeError('The "original" argument must be of type Function');

      function r() {
        for (var r = [], n = 0; n < arguments.length; n++) r.push(arguments[n]);
        var i = r.pop();
        if ("function" != typeof i) throw new TypeError("The last argument must be of type Function");
        var a = this,
          s = function() {
            return i.apply(a, arguments)
          };
        t.apply(this, r).then((function(t) {
          e.nextTick(s, null, t)
        }), (function(t) {
          e.nextTick(N, t, s)
        }))
      }
      return Object.setPrototypeOf(r, Object.getPrototypeOf(t)), Object.defineProperties(r, n(t)), r
    }
  }).call(this, r(8))
}, function(e, t) {
  e.exports = function(e) {
    return e && "object" == typeof e && "function" == typeof e.copy && "function" == typeof e.fill && "function" == typeof e.readUInt8
  }
}, function(e, t) {
  "function" == typeof Object.create ? e.exports = function(e, t) {
    e.super_ = t, e.prototype = Object.create(t.prototype, {
      constructor: {
        value: e,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    })
  } : e.exports = function(e, t) {
    e.super_ = t;
    var r = function() {};
    r.prototype = t.prototype, e.prototype = new r, e.prototype.constructor = e
  }
}, function(e, t) {
  function r(e, t) {
    var n;
    if (e && (Array.isArray(e) && (e = e[0]), Array.isArray(t) || (t = t.split("/")), n = t.shift(), e.children)) return e = e.children[n], t.length ? r(e, t) : e
  }
  t.child = r, t.value = function(e, t) {
    return (e = r(e, t)) && e.value
  }, t.attr = function(e, t, n) {
    return (e = r(e, t)) && e.attribs && e.attribs[n]
  }, t.addChild = function(e, t) {
    var r = {
      parent: e
    };
    return e.children = e.children || {}, e.children[t] ? (Array.isArray(e.children[t]) || (e.children[t] = [e.children[t]]), e.children[t].push(r)) : e.children[t] = r, r
  }, t.addText = function(e, t) {
    return e.value = t, e
  }, t.concatText = function(e, t) {
    return e.value = (e.value || "") + t, e
  }
}, function(e, t, r) {
  (function(n) {
    function i() {
      var e;
      try {
        e = t.storage.debug
      } catch (e) {}
      return !e && void 0 !== n && "env" in n && (e = n.env.DEBUG), e
    }(t = e.exports = r(463)).log = function() {
      return "object" == typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments)
    }, t.formatArgs = function(e) {
      var r = this.useColors;
      if (e[0] = (r ? "%c" : "") + this.namespace + (r ? " %c" : " ") + e[0] + (r ? "%c " : " ") + "+" + t.humanize(this.diff), !r) return;
      var n = "color: " + this.color;
      e.splice(1, 0, n, "color: inherit");
      var i = 0,
        a = 0;
      e[0].replace(/%[a-zA-Z%]/g, (function(e) {
        "%%" !== e && (i++, "%c" === e && (a = i))
      })), e.splice(a, 0, n)
    }, t.save = function(e) {
      try {
        null == e ? t.storage.removeItem("debug") : t.storage.debug = e
      } catch (e) {}
    }, t.load = i, t.useColors = function() {
      if ("undefined" != typeof window && window.process && "renderer" === window.process.type) return !0;
      return "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
    }, t.storage = "undefined" != typeof chrome && void 0 !== chrome.storage ? chrome.storage.local : function() {
      try {
        return window.localStorage
      } catch (e) {}
    }(), t.colors = ["lightseagreen", "forestgreen", "goldenrod", "dodgerblue", "darkorchid", "crimson"], t.formatters.j = function(e) {
      try {
        return JSON.stringify(e)
      } catch (e) {
        return "[UnexpectedJSONParseError]: " + e.message
      }
    }, t.enable(i())
  }).call(this, r(8))
}, function(e, t, r) {
  var n;

  function i(e) {
    function r() {
      if (r.enabled) {
        var e = r,
          i = +new Date,
          a = i - (n || i);
        e.diff = a, e.prev = n, e.curr = i, n = i;
        for (var s = new Array(arguments.length), o = 0; o < s.length; o++) s[o] = arguments[o];
        s[0] = t.coerce(s[0]), "string" != typeof s[0] && s.unshift("%O");
        var u = 0;
        s[0] = s[0].replace(/%([a-zA-Z%])/g, (function(r, n) {
          if ("%%" === r) return r;
          u++;
          var i = t.formatters[n];
          if ("function" == typeof i) {
            var a = s[u];
            r = i.call(e, a), s.splice(u, 1), u--
          }
          return r
        })), t.formatArgs.call(e, s);
        var c = r.log || t.log || console.log.bind(console);
        c.apply(e, s)
      }
    }
    return r.namespace = e, r.enabled = t.enabled(e), r.useColors = t.useColors(), r.color = function(e) {
      var r, n = 0;
      for (r in e) n = (n << 5) - n + e.charCodeAt(r), n |= 0;
      return t.colors[Math.abs(n) % t.colors.length]
    }(e), "function" == typeof t.init && t.init(r), r
  }(t = e.exports = i.debug = i.default = i).coerce = function(e) {
    return e instanceof Error ? e.stack || e.message : e
  }, t.disable = function() {
    t.enable("")
  }, t.enable = function(e) {
    t.save(e), t.names = [], t.skips = [];
    for (var r = ("string" == typeof e ? e : "").split(/[\s,]+/), n = r.length, i = 0; i < n; i++) r[i] && ("-" === (e = r[i].replace(/\*/g, ".*?"))[0] ? t.skips.push(new RegExp("^" + e.substr(1) + "$")) : t.names.push(new RegExp("^" + e + "$")))
  }, t.enabled = function(e) {
    var r, n;
    for (r = 0, n = t.skips.length; r < n; r++)
      if (t.skips[r].test(e)) return !1;
    for (r = 0, n = t.names.length; r < n; r++)
      if (t.names[r].test(e)) return !0;
    return !1
  }, t.humanize = r(464), t.names = [], t.skips = [], t.formatters = {}
}, function(e, t) {
  var r = 1e3,
    n = 6e4,
    i = 60 * n,
    a = 24 * i;

  function s(e, t, r) {
    if (!(e < t)) return e < 1.5 * t ? Math.floor(e / t) + " " + r : Math.ceil(e / t) + " " + r + "s"
  }
  e.exports = function(e, t) {
    t = t || {};
    var o, u = typeof e;
    if ("string" === u && e.length > 0) return function(e) {
      if ((e = String(e)).length > 100) return;
      var t = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(e);
      if (!t) return;
      var s = parseFloat(t[1]);
      switch ((t[2] || "ms").toLowerCase()) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return 315576e5 * s;
        case "days":
        case "day":
        case "d":
          return s * a;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return s * i;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return s * n;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return s * r;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return s;
        default:
          return
      }
    }(e);
    if ("number" === u && !1 === isNaN(e)) return t.long ? s(o = e, a, "day") || s(o, i, "hour") || s(o, n, "minute") || s(o, r, "second") || o + " ms" : function(e) {
      if (e >= a) return Math.round(e / a) + "d";
      if (e >= i) return Math.round(e / i) + "h";
      if (e >= n) return Math.round(e / n) + "m";
      if (e >= r) return Math.round(e / r) + "s";
      return e + "ms"
    }(e);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e))
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(466), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfJoinMultiSmallest = void 0;
  const n = r(1),
    i = r(55);
  class a extends i.ActorRdfJoin {
    constructor(e) {
      super(e, 3, !0)
    }
    static getSmallestPatternId(e) {
      let t = -1,
        r = 1 / 0;
      for (const [n, i] of e.entries()) i <= r && (r = i, t = n);
      return t
    }
    async getOutput(e) {
      const t = e.entries.slice(),
        r = (await Promise.all(e.entries.map(e => n.getMetadata(e)))).map(e => "totalItems" in e ? e.totalItems : 1 / 0),
        i = a.getSmallestPatternId(r),
        s = t.splice(i, 1)[0],
        o = (r.splice(i, 1), a.getSmallestPatternId(r)),
        u = t.splice(o, 1)[0],
        c = (r.splice(o, 1), await this.mediatorJoin.mediate({
          entries: [s, u]
        }));
      return t.push(c), await this.mediatorJoin.mediate({
        entries: t
      })
    }
    async getIterations(e) {
      return (await Promise.all(e.entries.map(e => n.getMetadata(e)))).reduce((e, t) => e * t.totalItems, 1)
    }
  }
  t.ActorRdfJoinMultiSmallest = a
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(174), t), i(r(471), t)
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(175), t), i(r(469), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfDereferenceMediaMappings = void 0;
  const n = r(175);
  class i extends n.ActorRdfDereference {
    constructor(e) {
      super(e)
    }
    getMediaTypeFromExtension(e) {
      const t = e.lastIndexOf(".");
      if (t >= 0) {
        const r = e.slice(t);
        return this.mediaMappings[r.slice(1)] || ""
      }
      return ""
    }
  }
  t.ActorRdfDereferenceMediaMappings = i
}, function(e, t) {
  var r = function(e) {
    function t() {
      this.fetch = !1, this.DOMException = e.DOMException
    }
    return t.prototype = e, new t
  }("undefined" != typeof self ? self : this);
  ! function(e) {
    ! function(t) {
      var r = "URLSearchParams" in e,
        n = "Symbol" in e && "iterator" in Symbol,
        i = "FileReader" in e && "Blob" in e && function() {
          try {
            return new Blob, !0
          } catch (e) {
            return !1
          }
        }(),
        a = "FormData" in e,
        s = "ArrayBuffer" in e;
      if (s) var o = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
        u = ArrayBuffer.isView || function(e) {
          return e && o.indexOf(Object.prototype.toString.call(e)) > -1
        };

      function c(e) {
        if ("string" != typeof e && (e = String(e)), /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(e)) throw new TypeError("Invalid character in header field name");
        return e.toLowerCase()
      }

      function l(e) {
        return "string" != typeof e && (e = String(e)), e
      }

      function h(e) {
        var t = {
          next: function() {
            var t = e.shift();
            return {
              done: void 0 === t,
              value: t
            }
          }
        };
        return n && (t[Symbol.iterator] = function() {
          return t
        }), t
      }

      function d(e) {
        this.map = {}, e instanceof d ? e.forEach((function(e, t) {
          this.append(t, e)
        }), this) : Array.isArray(e) ? e.forEach((function(e) {
          this.append(e[0], e[1])
        }), this) : e && Object.getOwnPropertyNames(e).forEach((function(t) {
          this.append(t, e[t])
        }), this)
      }

      function p(e) {
        if (e.bodyUsed) return Promise.reject(new TypeError("Already read"));
        e.bodyUsed = !0
      }

      function f(e) {
        return new Promise((function(t, r) {
          e.onload = function() {
            t(e.result)
          }, e.onerror = function() {
            r(e.error)
          }
        }))
      }

      function g(e) {
        var t = new FileReader,
          r = f(t);
        return t.readAsArrayBuffer(e), r
      }

      function m(e) {
        if (e.slice) return e.slice(0);
        var t = new Uint8Array(e.byteLength);
        return t.set(new Uint8Array(e)), t.buffer
      }

      function y() {
        return this.bodyUsed = !1, this._initBody = function(e) {
          var t;
          this._bodyInit = e, e ? "string" == typeof e ? this._bodyText = e : i && Blob.prototype.isPrototypeOf(e) ? this._bodyBlob = e : a && FormData.prototype.isPrototypeOf(e) ? this._bodyFormData = e : r && URLSearchParams.prototype.isPrototypeOf(e) ? this._bodyText = e.toString() : s && i && ((t = e) && DataView.prototype.isPrototypeOf(t)) ? (this._bodyArrayBuffer = m(e.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : s && (ArrayBuffer.prototype.isPrototypeOf(e) || u(e)) ? this._bodyArrayBuffer = m(e) : this._bodyText = e = Object.prototype.toString.call(e) : this._bodyText = "", this.headers.get("content-type") || ("string" == typeof e ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : r && URLSearchParams.prototype.isPrototypeOf(e) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
        }, i && (this.blob = function() {
          var e = p(this);
          if (e) return e;
          if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer) return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData) throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]))
        }, this.arrayBuffer = function() {
          return this._bodyArrayBuffer ? p(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(g)
        }), this.text = function() {
          var e, t, r, n = p(this);
          if (n) return n;
          if (this._bodyBlob) return e = this._bodyBlob, t = new FileReader, r = f(t), t.readAsText(e), r;
          if (this._bodyArrayBuffer) return Promise.resolve(function(e) {
            for (var t = new Uint8Array(e), r = new Array(t.length), n = 0; n < t.length; n++) r[n] = String.fromCharCode(t[n]);
            return r.join("")
          }(this._bodyArrayBuffer));
          if (this._bodyFormData) throw new Error("could not read FormData body as text");
          return Promise.resolve(this._bodyText)
        }, a && (this.formData = function() {
          return this.text().then(v)
        }), this.json = function() {
          return this.text().then(JSON.parse)
        }, this
      }
      d.prototype.append = function(e, t) {
        e = c(e), t = l(t);
        var r = this.map[e];
        this.map[e] = r ? r + ", " + t : t
      }, d.prototype.delete = function(e) {
        delete this.map[c(e)]
      }, d.prototype.get = function(e) {
        return e = c(e), this.has(e) ? this.map[e] : null
      }, d.prototype.has = function(e) {
        return this.map.hasOwnProperty(c(e))
      }, d.prototype.set = function(e, t) {
        this.map[c(e)] = l(t)
      }, d.prototype.forEach = function(e, t) {
        for (var r in this.map) this.map.hasOwnProperty(r) && e.call(t, this.map[r], r, this)
      }, d.prototype.keys = function() {
        var e = [];
        return this.forEach((function(t, r) {
          e.push(r)
        })), h(e)
      }, d.prototype.values = function() {
        var e = [];
        return this.forEach((function(t) {
          e.push(t)
        })), h(e)
      }, d.prototype.entries = function() {
        var e = [];
        return this.forEach((function(t, r) {
          e.push([r, t])
        })), h(e)
      }, n && (d.prototype[Symbol.iterator] = d.prototype.entries);
      var b = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

      function _(e, t) {
        var r, n, i = (t = t || {}).body;
        if (e instanceof _) {
          if (e.bodyUsed) throw new TypeError("Already read");
          this.url = e.url, this.credentials = e.credentials, t.headers || (this.headers = new d(e.headers)), this.method = e.method, this.mode = e.mode, this.signal = e.signal, i || null == e._bodyInit || (i = e._bodyInit, e.bodyUsed = !0)
        } else this.url = String(e);
        if (this.credentials = t.credentials || this.credentials || "same-origin", !t.headers && this.headers || (this.headers = new d(t.headers)), this.method = (r = t.method || this.method || "GET", n = r.toUpperCase(), b.indexOf(n) > -1 ? n : r), this.mode = t.mode || this.mode || null, this.signal = t.signal || this.signal, this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && i) throw new TypeError("Body not allowed for GET or HEAD requests");
        this._initBody(i)
      }

      function v(e) {
        var t = new FormData;
        return e.trim().split("&").forEach((function(e) {
          if (e) {
            var r = e.split("="),
              n = r.shift().replace(/\+/g, " "),
              i = r.join("=").replace(/\+/g, " ");
            t.append(decodeURIComponent(n), decodeURIComponent(i))
          }
        })), t
      }

      function w(e, t) {
        t || (t = {}), this.type = "default", this.status = void 0 === t.status ? 200 : t.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = "statusText" in t ? t.statusText : "OK", this.headers = new d(t.headers), this.url = t.url || "", this._initBody(e)
      }
      _.prototype.clone = function() {
        return new _(this, {
          body: this._bodyInit
        })
      }, y.call(_.prototype), y.call(w.prototype), w.prototype.clone = function() {
        return new w(this._bodyInit, {
          status: this.status,
          statusText: this.statusText,
          headers: new d(this.headers),
          url: this.url
        })
      }, w.error = function() {
        var e = new w(null, {
          status: 0,
          statusText: ""
        });
        return e.type = "error", e
      };
      var S = [301, 302, 303, 307, 308];
      w.redirect = function(e, t) {
        if (-1 === S.indexOf(t)) throw new RangeError("Invalid status code");
        return new w(null, {
          status: t,
          headers: {
            location: e
          }
        })
      }, t.DOMException = e.DOMException;
      try {
        new t.DOMException
      } catch (e) {
        t.DOMException = function(e, t) {
          this.message = e, this.name = t;
          var r = Error(e);
          this.stack = r.stack
        }, t.DOMException.prototype = Object.create(Error.prototype), t.DOMException.prototype.constructor = t.DOMException
      }

      function T(e, r) {
        return new Promise((function(n, a) {
          var s = new _(e, r);
          if (s.signal && s.signal.aborted) return a(new t.DOMException("Aborted", "AbortError"));
          var o = new XMLHttpRequest;

          function u() {
            o.abort()
          }
          o.onload = function() {
            var e, t, r = {
              status: o.status,
              statusText: o.statusText,
              headers: (e = o.getAllResponseHeaders() || "", t = new d, e.replace(/\r?\n[\t ]+/g, " ").split(/\r?\n/).forEach((function(e) {
                var r = e.split(":"),
                  n = r.shift().trim();
                if (n) {
                  var i = r.join(":").trim();
                  t.append(n, i)
                }
              })), t)
            };
            r.url = "responseURL" in o ? o.responseURL : r.headers.get("X-Request-URL");
            var i = "response" in o ? o.response : o.responseText;
            n(new w(i, r))
          }, o.onerror = function() {
            a(new TypeError("Network request failed"))
          }, o.ontimeout = function() {
            a(new TypeError("Network request failed"))
          }, o.onabort = function() {
            a(new t.DOMException("Aborted", "AbortError"))
          }, o.open(s.method, s.url, !0), "include" === s.credentials ? o.withCredentials = !0 : "omit" === s.credentials && (o.withCredentials = !1), "responseType" in o && i && (o.responseType = "blob"), s.headers.forEach((function(e, t) {
            o.setRequestHeader(t, e)
          })), s.signal && (s.signal.addEventListener("abort", u), o.onreadystatechange = function() {
            4 === o.readyState && s.signal.removeEventListener("abort", u)
          }), o.send(void 0 === s._bodyInit ? null : s._bodyInit)
        }))
      }
      T.polyfill = !0, e.fetch || (e.fetch = T, e.Headers = d, e.Request = _, e.Response = w), t.Headers = d, t.Request = _, t.Response = w, t.fetch = T
    }({})
  }(r), delete r.fetch.polyfill, (t = r.fetch).default = r.fetch, t.fetch = r.fetch, t.Headers = r.Headers, t.Request = r.Request, t.Response = r.Response, e.exports = t
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfDereferenceHttpParse = void 0;
  const n = r(174);
  class i extends n.ActorRdfDereferenceHttpParseBase {
    constructor(e) {
      super(e)
    }
    getMaxAcceptHeaderLength() {
      return this.maxAcceptHeaderLengthBrowser
    }
  }
  t.ActorRdfDereferenceHttpParse = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(473), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfParseHtmlScript = void 0;
  const n = r(81),
    i = r(474);
  class a extends n.ActorRdfParseHtml {
    constructor(e) {
      super(e)
    }
    async test(e) {
      return !0
    }
    async run(e) {
      const t = (await this.mediatorRdfParseMediatypes.mediate({
        context: e.context,
        mediaTypes: !0
      })).mediaTypes;
      return {
        htmlParseListener: new i.HtmlScriptListener(this.mediatorRdfParseHandle, e.emit, e.error, e.end, t, e.context, e.baseIRI, e.headers)
      }
    }
  }
  t.ActorRdfParseHtmlScript = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.HtmlScriptListener = void 0;
  const n = r(2),
    i = r(0),
    a = r(13);
  class s {
    constructor(e, t, r, n, a, s, o, u) {
      var c;
      this.textChunksJsonLd = [], this.endBarrier = 1, this.passedScripts = 0, this.isFinalJsonLdProcessing = !1, this.mediatorRdfParseHandle = e, this.cbQuad = t, this.cbError = r, this.cbEnd = n, this.supportedTypes = a, this.context = (s || i.ActionContext({})).set("@comunica/actor-rdf-parse-html-script:processing-html-script", !0), this.baseIRI = o, this.headers = u, this.onlyFirstScript = null !== (c = s && !1 === s.get("extractAllScripts")) && void 0 !== c && c;
      const l = this.baseIRI.indexOf("#");
      this.targetScriptId = l > 0 ? this.baseIRI.slice(l + 1, this.baseIRI.length) : null
    }
    static newErrorCoded(e, t) {
      const r = new Error(e);
      return r.code = t, r
    }
    onEnd() {
      0 == --this.endBarrier && (this.textChunksJsonLd.length > 0 ? (this.handleMediaType = "application/ld+json", this.textChunks = this.textChunksJsonLd, this.textChunks.push("]"), this.textChunksJsonLd = [], this.isFinalJsonLdProcessing = !0, this.endBarrier++, this.onTagClose()) : (0 === this.passedScripts && this.targetScriptId && this.cbError(s.newErrorCoded(`Failed to find targeted script id "${this.targetScriptId}"`, "loading document failed")), this.cbEnd()), this.isFinalJsonLdProcessing = !1)
    }
    onTagClose() {
      if (this.handleMediaType)
        if (this.requiresCustomJsonLdHandling(this.handleMediaType) && !this.isFinalJsonLdProcessing) this.handleMediaType = void 0, this.textChunks = void 0, this.onEnd();
        else {
          const e = new n.Readable({
            objectMode: !0
          });
          e._read = () => {};
          const t = this.textChunks,
            r = {
              context: this.context,
              handle: {
                baseIRI: this.baseIRI,
                input: e,
                headers: this.headers
              },
              handleMediaType: this.handleMediaType
            };
          this.mediatorRdfParseHandle.mediate(r).then(({
                                                         handle: r
                                                       }) => {
            r.quads.on("error", e => this.cbError(s.newErrorCoded(e.message, "invalid script element"))).on("data", this.cbQuad).on("end", () => this.onEnd());
            for (const r of t) e.push(r);
            e.push(null)
          }).catch(e => {
            this.targetScriptId ? this.cbError(s.newErrorCoded(e.message, "loading document failed")) : this.onEnd()
          }), this.handleMediaType = void 0, this.textChunks = void 0
        }
    }
    onTagOpen(e, t) {
      "base" === e && t.href && (this.baseIRI = a.resolve(t.href, this.baseIRI)), "script" !== e || this.targetScriptId && t.id !== this.targetScriptId ? this.handleMediaType = void 0 : this.supportedTypes[t.type] ? this.onlyFirstScript && this.passedScripts > 0 ? this.handleMediaType = void 0 : (this.passedScripts++, this.handleMediaType = t.type, this.endBarrier++, this.requiresCustomJsonLdHandling(this.handleMediaType) ? (this.textChunks = this.textChunksJsonLd, this.textChunks.push(0 === this.textChunks.length ? "[" : ",")) : this.textChunks = []) : this.targetScriptId && this.cbError(s.newErrorCoded(`Targeted script "${this.targetScriptId}" does not have a supported type`, "loading document failed"))
    }
    onText(e) {
      this.handleMediaType && this.textChunks.push(e)
    }
    requiresCustomJsonLdHandling(e) {
      return !this.onlyFirstScript && !this.targetScriptId && "application/ld+json" === e
    }
  }
  t.HtmlScriptListener = s
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(476), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorSparqlSerializeRdf = void 0;
  const n = r(15);
  class i extends n.ActorSparqlSerialize {
    constructor(e) {
      super(e)
    }
    async testHandle(e, t, r) {
      if ("quads" !== e.type) throw new Error(`Actor ${this.name} can only handle quad streams`);
      const {
        mediaTypes: n
      } = await this.mediatorMediaTypeCombiner.mediate({
        context: r,
        mediaTypes: !0
      });
      if (!(t in n)) throw new Error(`Actor ${this.name} can not handle media type ${t}. All available types: ${Object.keys(n)}`);
      return !0
    }
    async runHandle(e, t, r) {
      return (await this.mediatorRdfSerialize.mediate({
        context: r,
        handle: e,
        handleMediaType: t
      })).handle
    }
    async testMediaType(e) {
      return !0
    }
    async getMediaTypes(e) {
      return (await this.mediatorMediaTypeCombiner.mediate({
        context: e,
        mediaTypes: !0
      })).mediaTypes
    }
    async testMediaTypeFormats(e) {
      return !0
    }
    async getMediaTypeFormats(e) {
      return (await this.mediatorMediaTypeFormatCombiner.mediate({
        context: e,
        mediaTypeFormats: !0
      })).mediaTypeFormats
    }
  }
  t.ActorSparqlSerializeRdf = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(478), t), i(r(176), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfResolveQuadPatternFederated = void 0;
  const n = r(21),
    i = r(176);
  class a extends n.ActorRdfResolveQuadPatternSource {
    constructor(e) {
      super(e), this.emptyPatterns = new Map
    }
    async test(e) {
      if (!this.getContextSources(e.context)) throw new Error(`Actor ${this.name} can only resolve quad pattern queries against a sources array.`);
      return !0
    }
    async getSource(e) {
      return new i.FederatedQuadSource(this.mediatorResolveQuadPattern, e, this.emptyPatterns, this.skipEmptyPatterns)
    }
  }
  t.ActorRdfResolveQuadPatternFederated = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.BlankNodeScoped = void 0;
  t.BlankNodeScoped = class {
    constructor(e, t) {
      this.termType = "BlankNode", this.value = e, this.skolemized = t
    }
    equals(e) {
      return !!e && "BlankNode" === e.termType && e.value === this.value
    }
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(481), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationQuadpattern = void 0;
  const n = r(1),
    i = r(3),
    a = r(4),
    s = r(18);
  class o extends n.ActorQueryOperationTyped {
    constructor(e) {
      super(e, "pattern")
    }
    static isTermVariable(e) {
      return "Variable" === e.termType
    }
    static getVariables(e) {
      return s.uniqTerms(s.getTerms(e).filter(o.isTermVariable)).map(e => a.termToString(e))
    }
    static getDuplicateElementLinks(e) {
      const t = {};
      let r = !1;
      for (const n of s.QUAD_TERM_NAMES)
        if ("Variable" === e[n].termType) {
          const i = a.termToString(e[n]),
            s = (t[i] || (t[i] = [])).push(n);
          r = r || s > 1
        } if (!r) return;
      const n = {};
      for (const e in t) {
        const r = t[e],
          i = r.slice(1);
        i.length > 0 && (n[r[0]] = i)
      }
      return n
    }
    static getMetadata(e) {
      return () => new Promise((t, r) => {
        e.getProperty("metadata", e => t(e)), e.on("error", r)
      })
    }
    async testOperation(e, t) {
      return !0
    }
    async runOperation(e, t) {
      e.context && (t = t ? t.merge(e.context) : e.context);
      const r = await this.mediatorResolveQuadPattern.mediate({
          pattern: e,
          context: t
        }),
        u = o.getVariables(e),
        c = o.getMetadata(r.data),
        l = s.reduceTerms(e, (e, t, r) => (o.isTermVariable(t) && (e[r] = a.termToString(t)), e), {}),
        h = (e, t, r) => {
          const n = l[r];
          return n && (e[n] = t), e
        };
      return {
        type: "bindings",
        bindingsStream: new i.TransformIterator(async () => {
          let t = r.data;
          const i = o.getDuplicateElementLinks(e);
          return i && (t = t.filter(e => {
            for (const t of s.TRIPLE_TERM_NAMES)
              for (const r of i[t] || [])
                if (!e[t].equals(e[r])) return !1;
            return !0
          })), t.map(e => n.Bindings(s.reduceTerms(e, h, {})), {
            autoStart: !0,
            maxBufferSize: 128
          })
        }, {
          autoStart: !1
        }),
        variables: u,
        metadata: c,
        canContainUndefs: !1
      }
    }
  }
  t.ActorQueryOperationQuadpattern = o
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(483), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfResolveHypermediaQpf = void 0;
  const n = r(87),
    i = r(484);
  class a extends n.ActorRdfResolveHypermedia {
    constructor(e) {
      super(e, "qpf")
    }
    async testMetadata(e) {
      const {
        searchForm: t
      } = this.createSource(e.metadata, e.context);
      if (e.handledDatasets && e.handledDatasets[t.dataset]) throw new Error(`Actor ${this.name} can only be applied for the first page of a QPF dataset.`);
      return {
        filterFactor: 1
      }
    }
    async run(e) {
      this.logInfo(e.context, "Identified as qpf source: " + e.url);
      const t = this.createSource(e.metadata, e.context, e.quads);
      return {
        source: t,
        dataset: t.searchForm.dataset
      }
    }
    createSource(e, t, r) {
      return new i.RdfSourceQpf(this.mediatorMetadata, this.mediatorMetadataExtract, this.mediatorRdfDereference, this.subjectUri, this.predicateUri, this.objectUri, this.graphUri, e, t, r)
    }
  }
  t.ActorRdfResolveHypermediaQpf = a
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.RdfSourceQpf = void 0;
  const n = r(3),
    i = r(5),
    a = r(4),
    s = r(18),
    o = new i.DataFactory;
  t.RdfSourceQpf = class {
    constructor(e, t, r, i, a, s, u, c, l, h) {
      this.mediatorMetadata = e, this.mediatorMetadataExtract = t, this.mediatorRdfDereference = r, this.subjectUri = i, this.predicateUri = a, this.objectUri = s, this.graphUri = u, this.context = l, this.cachedQuads = {};
      const d = this.getSearchForm(c);
      if (!d) throw new Error("Illegal state: found no TPF/QPF search form anymore in metadata.");
      if (this.searchForm = d, this.defaultGraph = c.defaultGraph ? o.namedNode(c.defaultGraph) : void 0, h) {
        let e = n.wrap(h);
        this.defaultGraph && (e = this.reverseMapQuadsToDefaultGraph(e)), e.setProperty("metadata", c), this.cacheQuads(e, o.variable(""), o.variable(""), o.variable(""), o.variable(""))
      }
    }
    getSearchForm(e) {
      if (!e.searchForms || !e.searchForms.values) return;
      const {
        searchForms: t
      } = e;
      for (const e of t.values) {
        if (this.graphUri && this.subjectUri in e.mappings && this.predicateUri in e.mappings && this.objectUri in e.mappings && this.graphUri in e.mappings && 4 === Object.keys(e.mappings).length) return e;
        if (this.subjectUri in e.mappings && this.predicateUri in e.mappings && this.objectUri in e.mappings && 3 === Object.keys(e.mappings).length) return e
      }
    }
    createFragmentUri(e, t, r, n, i) {
      const s = {},
        o = [{
          uri: this.subjectUri,
          term: t
        }, {
          uri: this.predicateUri,
          term: r
        }, {
          uri: this.objectUri,
          term: n
        }, {
          uri: this.graphUri,
          term: i
        }];
      for (const e of o) e.uri && "Variable" !== e.term.termType && (s[e.uri] = a.termToString(e.term));
      return e.getUri(s)
    }
    match(e, t, r, i) {
      let a = !1;
      this.defaultGraph && "DefaultGraph" === i.termType && (a = !0, i = this.defaultGraph);
      const u = this.getCachedQuads(e, t, r, i);
      if (u) return u;
      const c = new n.TransformIterator(async () => {
        let u = this.createFragmentUri(this.searchForm, e, t, r, i);
        const l = await this.mediatorRdfDereference.mediate({
          context: this.context,
          url: u
        });
        u = l.url;
        const h = await this.mediatorMetadata.mediate({
            context: this.context,
            url: u,
            quads: l.quads,
            triples: l.triples
          }),
          d = this.mediatorMetadataExtract.mediate({
            context: this.context,
            url: u,
            metadata: h.metadata
          }).then(({
                     metadata: e
                   }) => c.setProperty("metadata", e)),
          p = o.defaultGraph();
        let f = n.wrap(h.data).transform({
          filter: n => !!s.matchPattern(n, e, t, r, i) || a && s.matchPattern(n, e, t, r, p)
        });
        return (a || "Variable" === i.termType) && (f = this.reverseMapQuadsToDefaultGraph(f)), f.on("error", () => {}), await d, f
      }, {
        autoStart: !1
      });
      return this.cacheQuads(c, e, t, r, i), this.getCachedQuads(e, t, r, i)
    }
    reverseMapQuadsToDefaultGraph(e) {
      const t = o.defaultGraph();
      return e.map(e => s.mapTerms(e, (e, r) => "graph" === r && e.equals(this.defaultGraph) ? t : e))
    }
    getPatternId(e, t, r, n) {
      return JSON.stringify({
        s: "Variable" === e.termType ? "" : a.termToString(e),
        p: "Variable" === t.termType ? "" : a.termToString(t),
        o: "Variable" === r.termType ? "" : a.termToString(r),
        g: "Variable" === n.termType ? "" : a.termToString(n)
      })
    }
    cacheQuads(e, t, r, n, i) {
      const a = this.getPatternId(t, r, n, i);
      this.cachedQuads[a] = e.clone()
    }
    getCachedQuads(e, t, r, n) {
      const i = this.getPatternId(e, t, r, n),
        a = this.cachedQuads[i];
      if (a) return a.clone()
    }
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(486), t), i(r(179), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorRdfResolveQuadPatternHypermedia = void 0;
  const n = r(21),
    i = r(178),
    a = r(179);
  class s extends n.ActorRdfResolveQuadPatternSource {
    constructor(e) {
      super(e), this.cache = this.cacheSize ? new i({
        max: this.cacheSize
      }) : void 0;
      const t = this.cache;
      t && this.httpInvalidator.addInvalidateListener(({
                                                         url: e
                                                       }) => e ? t.del(e) : t.reset())
    }
    async test(e) {
      if (!this.hasContextSingleSource(e.context)) throw new Error(`Actor ${this.name} can only resolve quad pattern queries against a single source.`);
      return !0
    }
    getSource(e, t) {
      const r = this.getContextSource(e),
        i = this.getContextSourceUrl(r);
      let s;
      return this.cache && this.cache.has(i) ? s = this.cache.get(i) : (s = new a.MediatedQuadSource(this.cacheSize, e, i, n.getDataSourceType(r), {
        mediatorMetadata: this.mediatorMetadata,
        mediatorMetadataExtract: this.mediatorMetadataExtract,
        mediatorRdfDereference: this.mediatorRdfDereference,
        mediatorRdfResolveHypermedia: this.mediatorRdfResolveHypermedia,
        mediatorRdfResolveHypermediaLinks: this.mediatorRdfResolveHypermediaLinks
      }), this.cache && this.cache.set(i, s)), Promise.resolve(s)
    }
  }
  t.ActorRdfResolveQuadPatternHypermedia = s
}, function(e, t, r) {
  "use strict";

  function n(e) {
    var t = this;
    if (t instanceof n || (t = new n), t.tail = null, t.head = null, t.length = 0, e && "function" == typeof e.forEach) e.forEach((function(e) {
      t.push(e)
    }));
    else if (arguments.length > 0)
      for (var r = 0, i = arguments.length; r < i; r++) t.push(arguments[r]);
    return t
  }

  function i(e, t, r) {
    var n = t === e.head ? new o(r, null, t, e) : new o(r, t, t.next, e);
    return null === n.next && (e.tail = n), null === n.prev && (e.head = n), e.length++, n
  }

  function a(e, t) {
    e.tail = new o(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++
  }

  function s(e, t) {
    e.head = new o(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++
  }

  function o(e, t, r, n) {
    if (!(this instanceof o)) return new o(e, t, r, n);
    this.list = n, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null
  }
  e.exports = n, n.Node = o, n.create = n, n.prototype.removeNode = function(e) {
    if (e.list !== this) throw new Error("removing node which does not belong to this list");
    var t = e.next,
      r = e.prev;
    return t && (t.prev = r), r && (r.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = r), e.list.length--, e.next = null, e.prev = null, e.list = null, t
  }, n.prototype.unshiftNode = function(e) {
    if (e !== this.head) {
      e.list && e.list.removeNode(e);
      var t = this.head;
      e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++
    }
  }, n.prototype.pushNode = function(e) {
    if (e !== this.tail) {
      e.list && e.list.removeNode(e);
      var t = this.tail;
      e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++
    }
  }, n.prototype.push = function() {
    for (var e = 0, t = arguments.length; e < t; e++) a(this, arguments[e]);
    return this.length
  }, n.prototype.unshift = function() {
    for (var e = 0, t = arguments.length; e < t; e++) s(this, arguments[e]);
    return this.length
  }, n.prototype.pop = function() {
    if (this.tail) {
      var e = this.tail.value;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e
    }
  }, n.prototype.shift = function() {
    if (this.head) {
      var e = this.head.value;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e
    }
  }, n.prototype.forEach = function(e, t) {
    t = t || this;
    for (var r = this.head, n = 0; null !== r; n++) e.call(t, r.value, n, this), r = r.next
  }, n.prototype.forEachReverse = function(e, t) {
    t = t || this;
    for (var r = this.tail, n = this.length - 1; null !== r; n--) e.call(t, r.value, n, this), r = r.prev
  }, n.prototype.get = function(e) {
    for (var t = 0, r = this.head; null !== r && t < e; t++) r = r.next;
    if (t === e && null !== r) return r.value
  }, n.prototype.getReverse = function(e) {
    for (var t = 0, r = this.tail; null !== r && t < e; t++) r = r.prev;
    if (t === e && null !== r) return r.value
  }, n.prototype.map = function(e, t) {
    t = t || this;
    for (var r = new n, i = this.head; null !== i;) r.push(e.call(t, i.value, this)), i = i.next;
    return r
  }, n.prototype.mapReverse = function(e, t) {
    t = t || this;
    for (var r = new n, i = this.tail; null !== i;) r.push(e.call(t, i.value, this)), i = i.prev;
    return r
  }, n.prototype.reduce = function(e, t) {
    var r, n = this.head;
    if (arguments.length > 1) r = t;
    else {
      if (!this.head) throw new TypeError("Reduce of empty list with no initial value");
      n = this.head.next, r = this.head.value
    }
    for (var i = 0; null !== n; i++) r = e(r, n.value, i), n = n.next;
    return r
  }, n.prototype.reduceReverse = function(e, t) {
    var r, n = this.tail;
    if (arguments.length > 1) r = t;
    else {
      if (!this.tail) throw new TypeError("Reduce of empty list with no initial value");
      n = this.tail.prev, r = this.tail.value
    }
    for (var i = this.length - 1; null !== n; i--) r = e(r, n.value, i), n = n.prev;
    return r
  }, n.prototype.toArray = function() {
    for (var e = new Array(this.length), t = 0, r = this.head; null !== r; t++) e[t] = r.value, r = r.next;
    return e
  }, n.prototype.toArrayReverse = function() {
    for (var e = new Array(this.length), t = 0, r = this.tail; null !== r; t++) e[t] = r.value, r = r.prev;
    return e
  }, n.prototype.slice = function(e, t) {
    (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);
    var r = new n;
    if (t < e || t < 0) return r;
    e < 0 && (e = 0), t > this.length && (t = this.length);
    for (var i = 0, a = this.head; null !== a && i < e; i++) a = a.next;
    for (; null !== a && i < t; i++, a = a.next) r.push(a.value);
    return r
  }, n.prototype.sliceReverse = function(e, t) {
    (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);
    var r = new n;
    if (t < e || t < 0) return r;
    e < 0 && (e = 0), t > this.length && (t = this.length);
    for (var i = this.length, a = this.tail; null !== a && i > t; i--) a = a.prev;
    for (; null !== a && i > e; i--, a = a.prev) r.push(a.value);
    return r
  }, n.prototype.splice = function(e, t, ...r) {
    e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
    for (var n = 0, a = this.head; null !== a && n < e; n++) a = a.next;
    var s = [];
    for (n = 0; a && n < t; n++) s.push(a.value), a = this.removeNode(a);
    null === a && (a = this.tail), a !== this.head && a !== this.tail && (a = a.prev);
    for (n = 0; n < r.length; n++) a = i(this, a, r[n]);
    return s
  }, n.prototype.reverse = function() {
    for (var e = this.head, t = this.tail, r = e; null !== r; r = r.prev) {
      var n = r.prev;
      r.prev = r.next, r.next = n
    }
    return this.head = t, this.tail = e, this
  };
  try {
    r(488)(n)
  } catch (e) {}
}, function(e, t, r) {
  "use strict";
  e.exports = function(e) {
    e.prototype[Symbol.iterator] = function*() {
      for (let e = this.head; e; e = e.next) yield e.value
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.MediatedLinkedRdfSourcesAsyncRdfIterator = void 0;
  const n = r(490);
  class i extends n.LinkedRdfSourcesAsyncRdfIterator {
    constructor(e, t, r, n, i, a, s, o, u) {
      super(e, n, i, a, s, o), this.context = t, this.forceSourceType = r, this.mediatorRdfDereference = u.mediatorRdfDereference, this.mediatorMetadata = u.mediatorMetadata, this.mediatorMetadataExtract = u.mediatorMetadataExtract, this.mediatorRdfResolveHypermedia = u.mediatorRdfResolveHypermedia, this.mediatorRdfResolveHypermediaLinks = u.mediatorRdfResolveHypermediaLinks, this.handledUrls = {}
    }
    async getSourceLinks(e) {
      try {
        const {
          urls: t
        } = await this.mediatorRdfResolveHypermediaLinks.mediate({
          context: this.context,
          metadata: e
        });
        return t.map(e => "string" == typeof e ? {
          url: e
        } : e).filter(e => !this.handledUrls[e.url] && (this.handledUrls[e.url] = !0, !0))
      } catch (e) {
        return []
      }
    }
    async getSource(e, t) {
      let r = this.context;
      e.context && (r = r.merge(e.context));
      let n = e.url;
      const i = await this.mediatorRdfDereference.mediate({
        context: r,
        url: n
      });
      n = i.url;
      const a = await this.mediatorMetadata.mediate({
          context: r,
          url: n,
          quads: i.quads,
          triples: i.triples
        }),
        {
          metadata: s
        } = await this.mediatorMetadataExtract.mediate({
          context: r,
          url: n,
          metadata: a.metadata
        });
      e.transform && (a.data = await e.transform(a.data));
      const {
        source: o,
        dataset: u
      } = await this.mediatorRdfResolveHypermedia.mediate({
        context: r,
        forceSourceType: this.forceSourceType,
        handledDatasets: t,
        metadata: s,
        quads: a.data,
        url: n
      });
      return u && (t[u] = !0), {
        source: o,
        metadata: s,
        handledDatasets: t
      }
    }
  }
  t.MediatedLinkedRdfSourcesAsyncRdfIterator = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.LinkedRdfSourcesAsyncRdfIterator = void 0;
  const n = r(3),
    i = r(178);
  class a extends n.BufferedIterator {
    constructor(e, t, r, n, i, a) {
      super({
        autoStart: !0
      }), this.started = !1, this.cacheSize = e, this.subject = t, this.predicate = r, this.object = n, this.graph = i, this.linkQueue = [], this.firstUrl = a
    }
    setSourcesState(e) {
      e ? this.sourcesState = e : (this.sourcesState = {
        sources: new i({
          max: this.cacheSize
        })
      }, this.getSourceCached({
        url: this.firstUrl
      }, {}).catch(e => this.destroy(e)))
    }
    getSourceCached(e, t) {
      let r = this.sourcesState.sources.get(e.url);
      return r || (r = this.getSource(e, t), this.sourcesState.sources.set(e.url, r), r)
    }
    _read(e, t) {
      if (this.started)
        if (this.currentIterator) {
          for (; e > 0;) {
            const t = this.currentIterator.read();
            if (null === t) break;
            e--, this._push(t)
          }
          t()
        } else t();
      else this.started = !0, this.sourcesState || this.setSourcesState(), this.getSourceCached({
        url: this.firstUrl
      }, {}).then(e => {
        this.setCurrentIterator(e, !0), t()
      }).catch(e => {
        t()
      })
    }
    setCurrentIterator(e, t) {
      this.currentIterator = e.source.match(this.subject, this.predicate, this.object, this.graph);
      let r = !1;
      this.currentIterator._destination = this, this.currentIterator.on("error", e => this.destroy(e)), this.currentIterator.on("readable", () => this._fillBuffer()), this.currentIterator.on("end", () => {
        this.currentIterator = void 0, r && this.handleNextUrl(e)
      }), this.currentIterator.getProperty("metadata", n => {
        e.metadata = Object.assign(Object.assign({}, e.metadata), n), t && this.setProperty("metadata", e.metadata), this.getSourceLinks(e.metadata).then(e => Promise.all(e)).then(async t => {
          for (const e of t) this.linkQueue.push(e);
          r = !0, this.currentIterator || this.handleNextUrl(e)
        }).catch(e => this.destroy(e))
      })
    }
    handleNextUrl(e) {
      0 === this.linkQueue.length ? this.close() : (this.getSourceCached(this.linkQueue[0], e.handledDatasets).then(e => this.setCurrentIterator(e, !1)).catch(e => this.destroy(e)), this.linkQueue.shift())
    }
  }
  t.LinkedRdfSourcesAsyncRdfIterator = a
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(492), t), i(r(493), t), i(r(494), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.KEY_CONTEXT_HTTPPROXYHANDLER = t.ActorHttpProxy = void 0;
  const n = r(36);
  class i extends n.ActorHttp {
    constructor(e) {
      super(e)
    }
    async test(e) {
      if (!e.context) throw new Error(`Actor ${this.name} could not find a context.`);
      const r = e.context.get(t.KEY_CONTEXT_HTTPPROXYHANDLER);
      if (!r) throw new Error(`Actor ${this.name} could not find a proxy handler in the context.`);
      if (!await r.getProxy(e)) throw new Error(`Actor ${this.name} could not determine a proxy for the given request.`);
      return {
        time: 1 / 0
      }
    }
    async run(e) {
      var r;
      const n = "string" == typeof e.input ? e.input : e.input.url;
      if (!e.context) throw new Error("Illegal state: missing context");
      const i = e.context.get(t.KEY_CONTEXT_HTTPPROXYHANDLER),
        a = await this.mediatorHttp.mediate(Object.assign(Object.assign({}, await i.getProxy(e)), {
          context: e.context.delete(t.KEY_CONTEXT_HTTPPROXYHANDLER)
        }));
      return a.url = null !== (r = a.headers.get("x-final-url")) && void 0 !== r ? r : n, a
    }
  }
  t.ActorHttpProxy = i, t.KEY_CONTEXT_HTTPPROXYHANDLER = "@comunica/actor-http-proxy:httpProxyHandler"
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  })
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ProxyHandlerStatic = void 0;
  t.ProxyHandlerStatic = class {
    constructor(e) {
      this.prefixUrl = e
    }
    async getProxy(e) {
      return {
        init: e.init,
        input: this.modifyInput(e.input)
      }
    }
    modifyInput(e) {
      return "string" == typeof e ? this.prefixUrl + e : new Request(this.prefixUrl + e.url, e)
    }
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(496), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.KEY_CONTEXT_DATETIME = t.ActorHttpMemento = void 0;
  const n = r(36);
  r(45);
  const i = r(127);
  class a extends n.ActorHttp {
    constructor(e) {
      super(e)
    }
    async test(e) {
      var r;
      if (!(e.context && e.context.has(t.KEY_CONTEXT_DATETIME) && e.context.get(t.KEY_CONTEXT_DATETIME) instanceof Date)) throw new Error("This actor only handles request with a set valid datetime.");
      if (e.init && new Headers(null !== (r = e.init.headers) && void 0 !== r ? r : {}).has("accept-datetime")) throw new Error("The request already has a set datetime.");
      return !0
    }
    async run(e) {
      var r;
      const n = e.init ? Object.assign({}, e.init) : {},
        a = n.headers = new Headers(null !== (r = n.headers) && void 0 !== r ? r : {});
      e.context && e.context.has(t.KEY_CONTEXT_DATETIME) && a.append("accept-datetime", e.context.get(t.KEY_CONTEXT_DATETIME).toUTCString());
      const s = {
          context: e.context,
          input: e.input,
          init: n
        },
        o = await this.mediatorHttp.mediate(s);
      if (a.has("accept-datetime") && o.headers && !o.headers.has("memento-datetime")) {
        const t = o.headers.has("link") && i(o.headers.get("link"));
        if (t && t.timegate) {
          o.body && await o.body.cancel();
          const r = {
            context: e.context,
            input: t.timegate.url,
            init: n
          };
          return this.mediatorHttp.mediate(r)
        }
      }
      return o
    }
  }
  t.ActorHttpMemento = a, t.KEY_CONTEXT_DATETIME = "@comunica/actor-http-memento:datetime"
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(498), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationAsk = void 0;
  const n = r(1);
  class i extends n.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "ask")
    }
    async testOperation(e, t) {
      return !0
    }
    async runOperation(e, t) {
      const r = await this.mediatorQueryOperation.mediate({
          operation: e.input,
          context: t
        }),
        i = n.ActorQueryOperation.getSafeBindings(r);
      return {
        type: "boolean",
        booleanResult: new Promise((e, t) => {
          i.bindingsStream.once("data", () => {
            e(!0), i.bindingsStream.close()
          }), i.bindingsStream.on("end", () => e(!1)), i.bindingsStream.on("error", t)
        })
      }
    }
  }
  t.ActorQueryOperationAsk = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(500), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationService = void 0;
  const n = r(1),
    i = r(21),
    a = r(0),
    s = r(3);
  class o extends n.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "service")
    }
    async testOperation(e, t) {
      if ("NamedNode" !== e.name.termType) throw new Error(`${this.name} can only query services by IRI, while a ${e.name.termType} was given.`);
      return !0
    }
    async runOperation(e, t) {
      const r = e.name.value;
      let o = (t = t || a.ActionContext({})).delete(i.KEY_CONTEXT_SOURCE).delete(i.KEY_CONTEXT_SOURCES);
      const u = this.forceSparqlEndpoint ? "sparql" : "auto";
      let c;
      o = o.set(i.KEY_CONTEXT_SOURCES, [{
        type: u,
        value: r
      }]);
      try {
        c = n.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
          operation: e.input,
          context: o
        }))
      } catch (t) {
        if (!e.silent) throw t;
        c = {
          bindingsStream: new s.SingletonIterator(n.Bindings({})),
          type: "bindings",
          variables: [],
          canContainUndefs: !1
        }
      }
      return c
    }
  }
  t.ActorQueryOperationService = o
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(502), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationSlice = void 0;
  const n = r(1);
  class i extends n.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "slice")
    }
    async testOperation(e, t) {
      return !0
    }
    async runOperation(e, t) {
      const r = await this.mediatorQueryOperation.mediate({
          operation: e.input,
          context: t
        }),
        n = this.sliceMetadata(r, e);
      if ("bindings" === r.type) {
        const t = r;
        return {
          type: "bindings",
          bindingsStream: this.sliceStream(t.bindingsStream, e),
          metadata: n,
          variables: t.variables,
          canContainUndefs: t.canContainUndefs
        }
      }
      if ("quads" === r.type) {
        const t = r;
        return {
          type: "quads",
          quadStream: this.sliceStream(t.quadStream, e),
          metadata: n
        }
      }
      throw new Error(`Invalid query output type: Expected 'bindings' or 'quads' but got '${r.type}'`)
    }
    sliceStream(e, t) {
      const r = Boolean(t.length) || 0 === t.length,
        {
          start: n
        } = t,
        i = r ? t.start + t.length - 1 : 1 / 0;
      return e.transform({
        offset: n,
        limit: Math.max(i - n + 1, 0),
        autoStart: !1
      })
    }
    sliceMetadata(e, t) {
      const r = Boolean(t.length) || 0 === t.length;
      return e.metadata ? () => e.metadata().then(e => {
        let {
          totalItems: n
        } = e;
        return Number.isFinite(n) && (n = Math.max(0, n - t.start), r && (n = Math.min(n, t.length))), Object.assign(Object.assign({}, e), {
          totalItems: n
        })
      }) : void 0
    }
  }
  t.ActorQueryOperationSlice = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(504), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationBgpSingle = void 0;
  const n = r(1);
  class i extends n.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "bgp")
    }
    async testOperation(e, t) {
      if (1 !== e.patterns.length) throw new Error(`Actor ${this.name} can only operate on BGPs with a single pattern.`);
      return !0
    }
    runOperation(e, t) {
      if (t && t.has(n.KEY_CONTEXT_BGP_PARENTMETADATA)) {
        const e = t.get(n.KEY_CONTEXT_BGP_PARENTMETADATA);
        t = (t = t.delete(n.KEY_CONTEXT_BGP_PARENTMETADATA)).set(n.KEY_CONTEXT_PATTERN_PARENTMETADATA, e[0])
      }
      return this.mediatorQueryOperation.mediate({
        operation: e.patterns[0],
        context: t
      })
    }
  }
  t.ActorQueryOperationBgpSingle = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(506), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationBgpLeftDeepSmallest = void 0;
  const n = r(1),
    i = r(3),
    a = r(4),
    s = r(18);
  class o extends n.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "bgp")
    }
    static createLeftDeepStream(e, t, r) {
      return new i.MultiTransformIterator(e, {
        autoStart: !1,
        multiTransform(e) {
          const n = t => t.merge(e);
          return new i.TransformIterator(async () => (await r(o.materializePatterns(t, e))).transform({
            map: n
          }), {
            maxBufferSize: 128
          })
        }
      })
    }
    static getCombinedVariables(e) {
      const t = [].concat.apply([], e.map(e => e.variables));
      return [...new Set(t)]
    }
    static getSmallestPatternId(e) {
      let t = -1,
        r = 1 / 0;
      for (const [n, i] of e.entries()) {
        const e = o.getTotalItems(i);
        e <= r && (r = e, t = n)
      }
      return t
    }
    static estimateCombinedTotalItems(e, t) {
      const r = o.getTotalItems(e);
      return t.map(e => r * o.getTotalItems(e)).reduce((e, t) => e + t, 0)
    }
    static getTotalItems(e) {
      const {
        totalItems: t
      } = null != e ? e : {};
      return t || 0 === t ? t : 1 / 0
    }
    static materializePatterns(e, t) {
      return e.map(e => o.materializePattern(e, t))
    }
    static materializePattern(e, t) {
      const r = {};
      return {
        pattern: Object.assign(s.mapTerms(e, (e, n) => {
          const i = o.materializeTerm(e, t);
          return e !== i && (r[n] = e), i
        }), {
          type: "pattern",
          context: e.context
        }),
        bindings: r
      }
    }
    static materializeTerm(e, t) {
      if ("Variable" === e.termType) {
        const r = t.get(a.termToString(e));
        if (r) return r
      }
      return e
    }
    static async hasOneEmptyPatternOutput(e) {
      for (const t of e)
        if (t.metadata) {
          const e = await t.metadata();
          if (!o.getTotalItems(e)) return !0
        } return !1
    }
    async testOperation(e, t) {
      if (e.patterns.length < 2) throw new Error(`Actor ${this.name} can only operate on BGPs with at least two patterns.`);
      return !0
    }
    async runOperation(e, t) {
      const r = (await Promise.all(e.patterns.map(e => this.mediatorQueryOperation.mediate({
        operation: e,
        context: t
      })))).map(n.ActorQueryOperation.getSafeBindings);
      if (await o.hasOneEmptyPatternOutput(r)) return {
        bindingsStream: new i.ArrayIterator([], {
          autoStart: !1
        }),
        metadata: () => Promise.resolve({
          totalItems: 0
        }),
        type: "bindings",
        variables: o.getCombinedVariables(r),
        canContainUndefs: !1
      };
      const a = await Promise.all(r.map(async e => e.metadata ? await e.metadata() : {})),
        s = o.getSmallestPatternId(a);
      this.logDebug(t, "Smallest pattern: ", () => ({
        pattern: e.patterns[s],
        metadata: a[s]
      }));
      for (const [e, t] of r.entries()) e !== s && t.bindingsStream.close();
      const u = r.slice(s)[0],
        c = e.patterns.concat([]);
      c.splice(s, 1);
      const l = a.concat([]);
      l.splice(s, 1), n.ActorQueryOperation.validateQueryOutput(u, "bindings");
      const h = t && t.set(n.KEY_CONTEXT_BGP_CURRENTMETADATA, a[s]).set(n.KEY_CONTEXT_BGP_PARENTMETADATA, l);
      return {
        type: "bindings",
        bindingsStream: o.createLeftDeepStream(u.bindingsStream, c, async e => {
          const t = {
              type: "bgp",
              patterns: e.map(e => e.pattern)
            },
            r = e.map(e => e.bindings);
          return n.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
            operation: t,
            context: h.set(n.KEY_CONTEXT_BGP_PATTERNBINDINGS, r)
          })).bindingsStream
        }),
        variables: o.getCombinedVariables(r),
        metadata: () => Promise.resolve({
          totalItems: o.estimateCombinedTotalItems(a[s], a.slice(s))
        }),
        canContainUndefs: !1
      }
    }
  }
  t.ActorQueryOperationBgpLeftDeepSmallest = o
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(508), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationConstruct = void 0;
  const n = r(1),
    i = r(18),
    a = r(509);
  class s extends n.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "construct")
    }
    static getVariables(e) {
      return i.uniqTerms([].concat.apply([], e.map(e => i.getVariables(i.getTerms(e)))))
    }
    async testOperation(e, t) {
      return !0
    }
    async runOperation(e, t) {
      const r = s.getVariables(e.template),
        i = {
          type: "project",
          input: e.input,
          variables: r
        },
        o = n.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
          operation: i,
          context: t
        })),
        u = new a.BindingsToQuadsIterator(e.template, o.bindingsStream);
      let c;
      return o.metadata && (c = () => o.metadata().then(t => t.totalItems ? Object.assign(Object.assign({}, t), {
        totalItems: t.totalItems * e.template.length
      }) : t)), {
        metadata: c,
        quadStream: u,
        type: "quads"
      }
    }
  }
  t.ActorQueryOperationConstruct = s
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.BindingsToQuadsIterator = void 0;
  const n = r(3),
    i = r(5),
    a = r(18),
    s = new i.DataFactory;
  class o extends n.MultiTransformIterator {
    constructor(e, t) {
      super(t, {
        autoStart: !1
      }), this.template = e, this.blankNodeCounter = 0
    }
    static bindTerm(e, t) {
      return "Variable" === t.termType ? e.get("?" + t.value) : t
    }
    static bindQuad(e, t) {
      try {
        return a.mapTerms(t, t => {
          const r = o.bindTerm(e, t);
          if (!r) throw new Error("Unbound term");
          return r
        })
      } catch (e) {}
    }
    static localizeBlankNode(e, t) {
      return "BlankNode" === t.termType ? s.blankNode(`${t.value}${e}`) : t
    }
    static localizeQuad(e, t) {
      return a.mapTerms(t, t => o.localizeBlankNode(e, t))
    }
    static bindTemplate(e, t, r) {
      return t.map(t => o.bindQuad.bind(null, e)(t)).filter(Boolean).map(o.localizeQuad.bind(null, r))
    }
    _createTransformer(e) {
      return new n.ArrayIterator(o.bindTemplate(e, this.template, this.blankNodeCounter++))
    }
  }
  t.BindingsToQuadsIterator = o
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(511), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationDescribeSubject = void 0;
  const n = r(180),
    i = r(1),
    a = r(3),
    s = new(r(5).DataFactory);
  class o extends i.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "describe")
    }
    async testOperation(e, t) {
      return !0
    }
    async runOperation(e, t) {
      const r = e.terms.filter(e => "Variable" !== e.termType).map(e => {
        const t = [s.quad(e, s.variable("__predicate"), s.variable("__object"))];
        t.forEach(e => e.type = "pattern");
        return {
          input: {
            type: "bgp",
            patterns: t
          },
          template: t,
          type: "construct"
        }
      });
      if (r.length !== e.terms.length) {
        let t = [];
        e.terms.filter(e => "Variable" === e.termType).forEach((e, r) => {
          const n = [s.quad(e, s.variable("__predicate" + r), s.variable("__object" + r))];
          n.forEach(e => e.type = "pattern"), t = t.concat(n)
        }), r.push({
          input: {
            type: "join",
            left: e.input,
            right: {
              type: "bgp",
              patterns: t
            }
          },
          template: t,
          type: "construct"
        })
      }
      const o = (await Promise.all(r.map(e => this.mediatorQueryOperation.mediate({
        operation: e,
        context: t
      })))).map(i.ActorQueryOperation.getSafeQuads);
      return {
        type: "quads",
        quadStream: new a.UnionIterator(o.map(e => e.quadStream), {
          autoStart: !1
        }),
        metadata: () => Promise.all(o.map(e => i.getMetadata(e))).then(n.ActorQueryOperationUnion.unionMetadata)
      }
    }
  }
  t.ActorQueryOperationDescribeSubject = o
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationUnion = void 0;
  const n = r(1),
    i = r(3);
  class a extends n.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "union")
    }
    static unionVariables(e) {
      const t = e.reduce((e, t) => [...e, ...t], []);
      return [...new Set(t)]
    }
    static unionMetadata(e) {
      let t = 0;
      for (const r of e) {
        if (!r.totalItems || !Number.isFinite(r.totalItems)) {
          t = 1 / 0;
          break
        }
        t += r.totalItems
      }
      return {
        totalItems: t
      }
    }
    async testOperation(e, t) {
      return !0
    }
    async runOperation(e, t) {
      const r = (await Promise.all([this.mediatorQueryOperation.mediate({
        operation: e.left,
        context: t
      }), this.mediatorQueryOperation.mediate({
        operation: e.right,
        context: t
      })])).map(n.ActorQueryOperation.getSafeBindings);
      return {
        type: "bindings",
        bindingsStream: new i.UnionIterator(r.map(e => e.bindingsStream), {
          autoStart: !1
        }),
        metadata: r[0].metadata && r[1].metadata ? () => Promise.all([r[0].metadata(), r[1].metadata()]).then(a.unionMetadata) : void 0,
        variables: a.unionVariables(r.map(e => e.variables)),
        canContainUndefs: r.reduce((e, t) => e || t.canContainUndefs, !1)
      }
    }
  }
  t.ActorQueryOperationUnion = a
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(514), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationDistinctHash = void 0;
  const n = r(88);
  class i extends n.AbstractBindingsHash {
    constructor(e) {
      super(e, "distinct")
    }
    newHashFilter() {
      const e = {};
      return t => {
        const r = n.AbstractFilterHash.hash(t);
        return !(r in e) && (e[r] = !0)
      }
    }
  }
  t.ActorQueryOperationDistinctHash = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.AbstractBindingsHash = void 0;
  const n = r(1);
  class i extends n.ActorQueryOperationTypedMediated {
    constructor(e, t) {
      super(e, t)
    }
    async testOperation(e, t) {
      return !0
    }
    async runOperation(e, t) {
      const r = n.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
        operation: e.input,
        context: t
      }));
      return {
        type: "bindings",
        bindingsStream: r.bindingsStream.filter(this.newHashFilter()),
        metadata: r.metadata,
        variables: r.variables,
        canContainUndefs: r.canContainUndefs
      }
    }
  }
  t.AbstractBindingsHash = i
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.AbstractFilterHash = void 0;
  const n = r(1),
    i = r(181),
    a = r(4);
  class s extends n.ActorQueryOperationTypedMediated {
    constructor(e, t) {
      super(e, t)
    }
    static hash(e) {
      return i.sha1().update(r(84)(e.map(e => a.termToString(e)))).digest("hex")
    }
  }
  t.AbstractFilterHash = s
}, function(e, t, r) {
  "use strict";
  t.sha1 = r(518), t.sha224 = r(519), t.sha256 = r(183), t.sha384 = r(520), t.sha512 = r(184)
}, function(e, t, r) {
  "use strict";
  var n = r(19),
    i = r(50),
    a = r(182),
    s = n.rotl32,
    o = n.sum32,
    u = n.sum32_5,
    c = a.ft_1,
    l = i.BlockHash,
    h = [1518500249, 1859775393, 2400959708, 3395469782];

  function d() {
    if (!(this instanceof d)) return new d;
    l.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80)
  }
  n.inherits(d, l), e.exports = d, d.blockSize = 512, d.outSize = 160, d.hmacStrength = 80, d.padLength = 64, d.prototype._update = function(e, t) {
    for (var r = this.W, n = 0; n < 16; n++) r[n] = e[t + n];
    for (; n < r.length; n++) r[n] = s(r[n - 3] ^ r[n - 8] ^ r[n - 14] ^ r[n - 16], 1);
    var i = this.h[0],
      a = this.h[1],
      l = this.h[2],
      d = this.h[3],
      p = this.h[4];
    for (n = 0; n < r.length; n++) {
      var f = ~~(n / 20),
        g = u(s(i, 5), c(f, a, l, d), p, r[n], h[f]);
      p = d, d = l, l = s(a, 30), a = i, i = g
    }
    this.h[0] = o(this.h[0], i), this.h[1] = o(this.h[1], a), this.h[2] = o(this.h[2], l), this.h[3] = o(this.h[3], d), this.h[4] = o(this.h[4], p)
  }, d.prototype._digest = function(e) {
    return "hex" === e ? n.toHex32(this.h, "big") : n.split32(this.h, "big")
  }
}, function(e, t, r) {
  "use strict";
  var n = r(19),
    i = r(183);

  function a() {
    if (!(this instanceof a)) return new a;
    i.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]
  }
  n.inherits(a, i), e.exports = a, a.blockSize = 512, a.outSize = 224, a.hmacStrength = 192, a.padLength = 64, a.prototype._digest = function(e) {
    return "hex" === e ? n.toHex32(this.h.slice(0, 7), "big") : n.split32(this.h.slice(0, 7), "big")
  }
}, function(e, t, r) {
  "use strict";
  var n = r(19),
    i = r(184);

  function a() {
    if (!(this instanceof a)) return new a;
    i.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]
  }
  n.inherits(a, i), e.exports = a, a.blockSize = 1024, a.outSize = 384, a.hmacStrength = 192, a.padLength = 128, a.prototype._digest = function(e) {
    return "hex" === e ? n.toHex32(this.h.slice(0, 12), "big") : n.split32(this.h.slice(0, 12), "big")
  }
}, function(e, t, r) {
  "use strict";
  var n = r(19),
    i = r(50),
    a = n.rotl32,
    s = n.sum32,
    o = n.sum32_3,
    u = n.sum32_4,
    c = i.BlockHash;

  function l() {
    if (!(this instanceof l)) return new l;
    c.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little"
  }

  function h(e, t, r, n) {
    return e <= 15 ? t ^ r ^ n : e <= 31 ? t & r | ~t & n : e <= 47 ? (t | ~r) ^ n : e <= 63 ? t & n | r & ~n : t ^ (r | ~n)
  }

  function d(e) {
    return e <= 15 ? 0 : e <= 31 ? 1518500249 : e <= 47 ? 1859775393 : e <= 63 ? 2400959708 : 2840853838
  }

  function p(e) {
    return e <= 15 ? 1352829926 : e <= 31 ? 1548603684 : e <= 47 ? 1836072691 : e <= 63 ? 2053994217 : 0
  }
  n.inherits(l, c), t.ripemd160 = l, l.blockSize = 512, l.outSize = 160, l.hmacStrength = 192, l.padLength = 64, l.prototype._update = function(e, t) {
    for (var r = this.h[0], n = this.h[1], i = this.h[2], c = this.h[3], l = this.h[4], b = r, _ = n, v = i, w = c, S = l, T = 0; T < 80; T++) {
      var E = s(a(u(r, h(T, n, i, c), e[f[T] + t], d(T)), m[T]), l);
      r = l, l = c, c = a(i, 10), i = n, n = E, E = s(a(u(b, h(79 - T, _, v, w), e[g[T] + t], p(T)), y[T]), S), b = S, S = w, w = a(v, 10), v = _, _ = E
    }
    E = o(this.h[1], i, w), this.h[1] = o(this.h[2], c, S), this.h[2] = o(this.h[3], l, b), this.h[3] = o(this.h[4], r, _), this.h[4] = o(this.h[0], n, v), this.h[0] = E
  }, l.prototype._digest = function(e) {
    return "hex" === e ? n.toHex32(this.h, "little") : n.split32(this.h, "little")
  };
  var f = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
    g = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
    m = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
    y = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]
}, function(e, t, r) {
  "use strict";
  var n = r(19),
    i = r(49);

  function a(e, t, r) {
    if (!(this instanceof a)) return new a(e, t, r);
    this.Hash = e, this.blockSize = e.blockSize / 8, this.outSize = e.outSize / 8, this.inner = null, this.outer = null, this._init(n.toArray(t, r))
  }
  e.exports = a, a.prototype._init = function(e) {
    e.length > this.blockSize && (e = (new this.Hash).update(e).digest()), i(e.length <= this.blockSize);
    for (var t = e.length; t < this.blockSize; t++) e.push(0);
    for (t = 0; t < e.length; t++) e[t] ^= 54;
    for (this.inner = (new this.Hash).update(e), t = 0; t < e.length; t++) e[t] ^= 106;
    this.outer = (new this.Hash).update(e)
  }, a.prototype.update = function(e, t) {
    return this.inner.update(e, t), this
  }, a.prototype.digest = function(e) {
    return this.outer.update(this.inner.digest()), this.outer.digest(e)
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(524), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationExtend = void 0;
  const n = r(1),
    i = r(4),
    a = r(51);
  class s extends n.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "extend")
    }
    async testOperation(e, t) {
      Boolean(new a.AsyncEvaluator(e.expression));
      return !0
    }
    async runOperation(e, t) {
      const {
        expression: r,
        input: s,
        variable: o
      } = e, u = n.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
        operation: s,
        context: t
      })), c = i.termToString(o), l = Object.assign({}, n.ActorQueryOperation.getExpressionContext(t, this.mediatorQueryOperation)), h = new a.AsyncEvaluator(r, l), d = u.variables.concat([c]), p = u.bindingsStream.transform({
        transform: async (e, r, n) => {
          try {
            const t = await h.evaluate(e);
            n(e.set(c, t))
          } catch (r) {
            a.isExpressionError(r) ? (n(e), this.logWarn(t, `Expression error for extend operation with bindings '${JSON.stringify(e)}'`)) : p.emit("error", r)
          }
          r()
        }
      }), {
        metadata: f
      } = u;
      return {
        type: "bindings",
        bindingsStream: p,
        metadata: f,
        variables: d,
        canContainUndefs: u.canContainUndefs
      }
    }
  }
  t.ActorQueryOperationExtend = s
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.AsyncEvaluator = void 0;
  const n = r(39),
    i = r(185);
  t.AsyncEvaluator = class {
    constructor(e, t = {}) {
      this.algExpr = e, this.config = t, this.expr = n.transformAlgebra(e);
      const r = {
        now: t.now || new Date(Date.now()),
        baseIRI: t.baseIRI || void 0,
        exists: t.exists,
        aggregate: t.aggregate
      };
      this.evaluator = new i.AsyncRecursiveEvaluator(r)
    }
    async evaluate(e) {
      return (await this.evaluator.evaluate(this.expr, e)).toRDF()
    }
    async evaluateAsEBV(e) {
      return (await this.evaluator.evaluate(this.expr, e)).coerceEBV()
    }
    async evaluateAsInternal(e) {
      return await this.evaluator.evaluate(this.expr, e)
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Variable = void 0;
  const n = r(24);
  t.Variable = class {
    constructor(e) {
      this.expressionType = n.ExpressionType.Variable, this.name = e
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.NonLexicalLiteral = t.StringLiteral = t.LangStringLiteral = t.DateTimeLiteral = t.BooleanLiteral = t.NumericLiteral = t.Literal = t.BlankNode = t.NamedNode = t.Term = void 0;
  const n = r(5),
    i = r(24),
    a = r(14),
    s = r(20),
    o = new n.DataFactory;
  class u {
    constructor() {
      this.expressionType = i.ExpressionType.Term
    }
    str() {
      throw new s.InvalidArgumentTypes([this], a.RegularOperator.STR)
    }
    coerceEBV() {
      throw new s.EBVCoercionError(this)
    }
  }
  t.Term = u;
  t.NamedNode = class extends u {
    constructor(e) {
      super(), this.value = e, this.termType = "namedNode"
    }
    toRDF() {
      return o.namedNode(this.value)
    }
    str() {
      return this.value
    }
  };
  class c extends u {
    constructor(e) {
      super(), this.value = e, this.termType = "blankNode", this.value = e
    }
    static nextID() {
      return c._nextID += 1, c.nextID.toString()
    }
    toRDF() {
      return o.blankNode(this.value)
    }
  }
  t.BlankNode = c, c._nextID = 0;
  class l extends u {
    constructor(e, t, r, n) {
      super(), this.typedValue = e, this.typeURL = t, this.strValue = r, this.language = n, this.termType = "literal", this.type = a.type(t.value)
    }
    toRDF() {
      return o.literal(this.strValue || this.str(), this.language || this.typeURL)
    }
    str() {
      return this.strValue || this.typedValue.toString()
    }
  }
  t.Literal = l;
  class h extends l {
    coerceEBV() {
      return !!this.typedValue
    }
    toRDF() {
      const e = super.toRDF();
      return isFinite(this.typedValue) || (e.value = e.value.replace("Infinity", "INF")), e
    }
    str() {
      return this.strValue || h.specificFormatters[this.type](this.typedValue)
    }
  }
  t.NumericLiteral = h, h.specificFormatters = {
    integer: e => e.toFixed(),
    float: e => e.toString(),
    decimal: e => e.toString(),
    double: e => {
      const t = e.toExponential(),
        [r, n] = t.split("e"),
        i = n.replace(/\+/, "");
      return `${r.match(/\./)?r:r+".0"}E${i}`
    }
  };
  t.BooleanLiteral = class extends l {
    constructor(e, t) {
      super(e, a.make(a.TypeURL.XSD_BOOLEAN), t), this.typedValue = e, this.strValue = t
    }
    coerceEBV() {
      return !!this.typedValue
    }
  };
  t.DateTimeLiteral = class extends l {
    constructor(e, t) {
      super(e, a.make(a.TypeURL.XSD_DATE_TIME), t), this.typedValue = e, this.strValue = t
    }
  };
  t.LangStringLiteral = class extends l {
    constructor(e, t) {
      super(e, a.make(a.TypeURL.RDF_LANG_STRING), e, t), this.typedValue = e, this.language = t
    }
    coerceEBV() {
      return 0 !== this.strValue.length
    }
  };
  t.StringLiteral = class extends l {
    constructor(e) {
      super(e, a.make(a.TypeURL.XSD_STRING), e), this.typedValue = e
    }
    coerceEBV() {
      return 0 !== this.strValue.length
    }
  };
  t.NonLexicalLiteral = class extends l {
    constructor(e, t, r, n) {
      super(e, t, r, n), this.typedValue = void 0, this.type = "nonlexical", this.shouldBeCategory = a.type(t.value)
    }
    coerceEBV() {
      if (a.PrimitiveNumericTypes.contains(this.shouldBeCategory) || "boolean" === this.shouldBeCategory) return !1;
      throw new s.EBVCoercionError(this)
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Operator = void 0;
  const n = r(24);
  t.Operator = class {
    constructor(e, t) {
      this.args = e, this.apply = t, this.expressionType = n.ExpressionType.Operator
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.SpecialOperator = void 0;
  const n = r(24);
  t.SpecialOperator = class {
    constructor(e, t, r) {
      this.args = e, this.applyAsync = t, this.applySync = r, this.expressionType = n.ExpressionType.SpecialOperator
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Named = void 0;
  const n = r(24);
  t.Named = class {
    constructor(e, t, r) {
      this.name = e, this.args = t, this.apply = r, this.expressionType = n.ExpressionType.Named
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Aggregate = void 0;
  const n = r(24);
  t.Aggregate = class {
    constructor(e, t) {
      this.name = e, this.expression = t, this.expressionType = n.ExpressionType.Aggregate
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.Existence = void 0;
  const n = r(24);
  t.Existence = class {
    constructor(e) {
      this.expression = e, this.expressionType = n.ExpressionType.Existence
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.namedDefinitions = void 0;
  const n = r(23),
    i = r(20),
    a = r(14),
    s = r(65),
    o = r(66),
    u = {
      arity: 1,
      overloads: o.declare().onNumeric1(e => o.string(o.number(e.typedValue).str())).onBoolean1Typed(e => o.string(o.bool(e).str())).onTerm1(e => o.string(e.str())).collect()
    },
    c = {
      arity: 1,
      overloads: o.declare().onNumeric1(e => o.number(e.typedValue)).onBoolean1Typed(e => o.number(e ? 1 : 0)).onUnary("string", e => {
        const t = s.parseXSDFloat(e.str());
        if (void 0 === t) throw new i.CastError(e, a.TypeURL.XSD_FLOAT);
        return o.number(t)
      }).copy({
        from: ["string"],
        to: ["nonlexical"]
      }).collect()
    },
    l = {
      arity: 1,
      overloads: o.declare().onNumeric1(e => o.number(e.typedValue, a.TypeURL.XSD_DOUBLE)).onBoolean1Typed(e => o.number(e ? 1 : 0, a.TypeURL.XSD_DOUBLE)).onUnary("string", e => {
        const t = s.parseXSDFloat(e.str());
        if (void 0 === t) throw new i.CastError(e, a.TypeURL.XSD_DOUBLE);
        return o.number(t, a.TypeURL.XSD_DOUBLE)
      }).copy({
        from: ["string"],
        to: ["nonlexical"]
      }).collect()
    },
    h = {
      arity: 1,
      overloads: o.declare().onNumeric1(e => {
        const t = s.parseXSDDecimal(e.str());
        if (void 0 === t) throw new i.CastError(e, a.TypeURL.XSD_DECIMAL);
        return o.number(t, a.TypeURL.XSD_DECIMAL)
      }).onString1(e => {
        const t = e.str(),
          r = /^(\-|\+)?([0-9]+(\.[0-9]+)?)$/.test(t) ? s.parseXSDDecimal(t) : void 0;
        if (void 0 === r) throw new i.CastError(e, a.TypeURL.XSD_DECIMAL);
        return o.number(r, a.TypeURL.XSD_DECIMAL)
      }).copy({
        from: ["string"],
        to: ["nonlexical"]
      }).onBoolean1Typed(e => o.number(e ? 1 : 0, a.TypeURL.XSD_DECIMAL)).collect()
    },
    d = {
      arity: 1,
      overloads: o.declare().onBoolean1Typed(e => o.number(e ? 1 : 0, a.TypeURL.XSD_INTEGER)).onNumeric1(e => {
        const t = s.parseXSDInteger(e.str());
        if (void 0 === t) throw new i.CastError(e, a.TypeURL.XSD_INTEGER);
        return o.number(t, a.TypeURL.XSD_INTEGER)
      }).onString1(e => {
        const t = e.str(),
          r = /^[0-9]+$/.test(t) ? s.parseXSDInteger(t) : void 0;
        if (void 0 === r) throw new i.CastError(e, a.TypeURL.XSD_INTEGER);
        return o.number(r, a.TypeURL.XSD_INTEGER)
      }).copy({
        from: ["integer"],
        to: ["nonlexical"]
      }).collect()
    },
    p = {
      arity: 1,
      overloads: o.declare().onUnary("date", e => e).onUnary("string", e => {
        const t = new Date(e.str());
        if (isNaN(t.getTime())) throw new i.CastError(e, a.TypeURL.XSD_DATE_TIME);
        return o.dateTime(t, e.str())
      }).copy({
        from: ["string"],
        to: ["nonlexical"]
      }).collect()
    },
    f = {
      arity: 1,
      overloads: o.declare().onNumeric1(e => o.bool(e.coerceEBV())).onUnary("boolean", e => o.bool(e.coerceEBV())).onUnary("string", e => {
        switch (e.str()) {
          case "true":
            return o.bool(!0);
          case "false":
            return o.bool(!1);
          case "1":
            return o.bool(!0);
          case "0":
            return o.bool(!1);
          default:
            throw new i.CastError(e, a.TypeURL.XSD_BOOLEAN)
        }
      }).copy({
        from: ["string"],
        to: ["nonlexical"]
      }).collect()
    },
    g = {
      [a.TypeURL.XSD_STRING]: u,
      [a.TypeURL.XSD_FLOAT]: c,
      [a.TypeURL.XSD_DOUBLE]: l,
      [a.TypeURL.XSD_DECIMAL]: h,
      [a.TypeURL.XSD_INTEGER]: d,
      [a.TypeURL.XSD_DATE_TIME]: p,
      [a.TypeURL.XSD_DATE]: p,
      [a.TypeURL.XSD_BOOLEAN]: f
    };
  t.namedDefinitions = n.Map(g)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.definitions = void 0;
  const n = r(5),
    i = r(181),
    a = r(535),
    s = r(536),
    o = r(188),
    u = r(23),
    c = r(40),
    l = r(14),
    h = r(20),
    d = r(65),
    p = r(537),
    f = r(14),
    g = r(39),
    m = r(66),
    y = new n.DataFactory;

  function b(e, t) {
    const r = e.toRDF(),
      n = t.toRDF(),
      i = r.equals(n);
    if ("Literal" === r.termType && "Literal" === n.termType) throw new h.RDFEqualTypeError([e, t]);
    return i
  }
  const _ = (e, t) => m.bool(p.matches(e, t)),
    v = (e, t, r) => m.bool(p.matches(e, t, r));

  function w(e) {
    return d.parseXSDDateTime(e.str())
  }
  const S = {
    "!": {
      arity: 1,
      overloads: m.declare().onTerm1(e => m.bool(!e.coerceEBV())).collect()
    },
    UPLUS: {
      arity: 1,
      overloads: m.declare().onNumeric1(e => m.number(e.typedValue, e.typeURL.value)).collect()
    },
    UMINUS: {
      arity: 1,
      overloads: m.declare().onNumeric1(e => m.number(-e.typedValue, e.typeURL.value)).collect()
    },
    "*": {
      arity: 2,
      overloads: m.declare().arithmetic((e, t) => s.Decimal.mul(e, t).toNumber()).collect()
    },
    "/": {
      arity: 2,
      overloads: m.declare().arithmetic((e, t) => s.Decimal.div(e, t).toNumber()).onBinaryTyped(["integer", "integer"], (e, t) => {
        if (0 === t) throw new h.ExpressionError("Integer division by 0");
        return m.number(s.Decimal.div(e, t).toNumber(), f.TypeURL.XSD_DECIMAL)
      }).collect()
    },
    "+": {
      arity: 2,
      overloads: m.declare().arithmetic((e, t) => s.Decimal.add(e, t).toNumber()).collect()
    },
    "-": {
      arity: 2,
      overloads: m.declare().arithmetic((e, t) => s.Decimal.sub(e, t).toNumber()).collect()
    },
    "=": {
      arity: 2,
      overloads: m.declare().numberTest((e, t) => e === t).stringTest((e, t) => 0 === e.localeCompare(t)).booleanTest((e, t) => e === t).dateTimeTest((e, t) => e.getTime() === t.getTime()).set(["term", "term"], ([e, t]) => m.bool(b(e, t))).collect()
    },
    "!=": {
      arity: 2,
      overloads: m.declare().numberTest((e, t) => e !== t).stringTest((e, t) => 0 !== e.localeCompare(t)).booleanTest((e, t) => e !== t).dateTimeTest((e, t) => e.getTime() !== t.getTime()).set(["term", "term"], ([e, t]) => m.bool(!b(e, t))).collect()
    },
    "<": {
      arity: 2,
      overloads: m.declare().numberTest((e, t) => e < t).stringTest((e, t) => -1 === e.localeCompare(t)).booleanTest((e, t) => e < t).dateTimeTest((e, t) => e.getTime() < t.getTime()).collect()
    },
    ">": {
      arity: 2,
      overloads: m.declare().numberTest((e, t) => e > t).stringTest((e, t) => 1 === e.localeCompare(t)).booleanTest((e, t) => e > t).dateTimeTest((e, t) => e.getTime() > t.getTime()).collect()
    },
    "<=": {
      arity: 2,
      overloads: m.declare().numberTest((e, t) => e <= t).stringTest((e, t) => 1 !== e.localeCompare(t)).booleanTest((e, t) => e <= t).dateTimeTest((e, t) => e.getTime() <= t.getTime()).collect()
    },
    ">=": {
      arity: 2,
      overloads: m.declare().numberTest((e, t) => e >= t).stringTest((e, t) => -1 !== e.localeCompare(t)).booleanTest((e, t) => e >= t).dateTimeTest((e, t) => e.getTime() >= t.getTime()).collect()
    },
    isiri: {
      arity: 1,
      overloads: m.declare().onTerm1(e => m.bool("namedNode" === e.termType)).collect()
    },
    isblank: {
      arity: 1,
      overloads: m.declare().onTerm1(e => m.bool("blankNode" === e.termType)).collect()
    },
    isliteral: {
      arity: 1,
      overloads: m.declare().onTerm1(e => m.bool("literal" === e.termType)).collect()
    },
    isnumeric: {
      arity: 1,
      overloads: m.declare().onNumeric1(e => m.bool(!0)).onTerm1(e => m.bool(!1)).collect()
    },
    str: {
      arity: 1,
      overloads: m.declare().onTerm1(e => m.string(e.str())).collect()
    },
    lang: {
      arity: 1,
      overloads: m.declare().onLiteral1(e => m.string(e.language || "")).collect()
    },
    datatype: {
      arity: 1,
      overloads: m.declare().onLiteral1(e => new c.NamedNode(e.typeURL.value)).collect()
    },
    strdt: {
      arity: 2,
      overloads: m.declare().onBinary(["string", "namedNode"], (e, t) => {
        const r = y.literal(e.typedValue, y.namedNode(t.value));
        return g.transformLiteral(r)
      }).collect()
    },
    strlang: {
      arity: 2,
      overloads: m.declare().onBinaryTyped(["string", "string"], (e, t) => new c.LangStringLiteral(e, t.toLowerCase())).collect()
    },
    uuid: {
      arity: 0,
      overloads: m.declare().set([], () => new c.NamedNode("urn:uuid:" + o.v4())).collect()
    },
    struuid: {
      arity: 0,
      overloads: m.declare().set([], () => m.string(o.v4())).collect()
    },
    strlen: {
      arity: 1,
      overloads: m.declare().onStringly1(e => m.number([...e.typedValue].length, f.TypeURL.XSD_INTEGER)).collect()
    },
    substr: {
      arity: [2, 3],
      overloads: m.declare().onBinaryTyped(["string", "integer"], (e, t) => m.string([...e].slice(t - 1).join(""))).onBinary(["langString", "integer"], (e, t) => {
        const r = [...e.typedValue].slice(t.typedValue - 1).join("");
        return m.langString(r, e.language)
      }).onTernaryTyped(["string", "integer", "integer"], (e, t, r) => m.string([...e].slice(t - 1, r).join(""))).onTernary(["langString", "integer", "integer"], (e, t, r) => {
        const n = [...e.typedValue].slice(t.typedValue - 1, r.typedValue).join("");
        return m.langString(n, e.language)
      }).collect()
    },
    ucase: {
      arity: 1,
      overloads: m.declare().onString1Typed(e => m.string(e.toUpperCase())).onLangString1(e => m.langString(e.typedValue.toUpperCase(), e.language)).collect()
    },
    lcase: {
      arity: 1,
      overloads: m.declare().onString1Typed(e => m.string(e.toLowerCase())).onLangString1(e => m.langString(e.typedValue.toLowerCase(), e.language)).collect()
    },
    strstarts: {
      arity: 2,
      overloads: m.declare().onBinaryTyped(["string", "string"], (e, t) => m.bool(e.startsWith(t))).onBinaryTyped(["langString", "string"], (e, t) => m.bool(e.startsWith(t))).onBinary(["langString", "langString"], (e, t) => {
        if (e.language !== t.language) throw new h.IncompatibleLanguageOperation(e, t);
        return m.bool(e.typedValue.startsWith(t.typedValue))
      }).collect()
    },
    strends: {
      arity: 2,
      overloads: m.declare().onBinaryTyped(["string", "string"], (e, t) => m.bool(e.endsWith(t))).onBinaryTyped(["langString", "string"], (e, t) => m.bool(e.endsWith(t))).onBinary(["langString", "langString"], (e, t) => {
        if (e.language !== t.language) throw new h.IncompatibleLanguageOperation(e, t);
        return m.bool(e.typedValue.endsWith(t.typedValue))
      }).collect()
    },
    contains: {
      arity: 2,
      overloads: m.declare().onBinaryTyped(["string", "string"], (e, t) => m.bool(e.includes(t))).onBinaryTyped(["langString", "string"], (e, t) => m.bool(e.includes(t))).onBinary(["langString", "langString"], (e, t) => {
        if (e.language !== t.language) throw new h.IncompatibleLanguageOperation(e, t);
        return m.bool(e.typedValue.includes(t.typedValue))
      }).collect()
    },
    strbefore: {
      arity: 2,
      overloads: m.declare().onBinaryTyped(["string", "string"], (e, t) => m.string(e.substr(0, e.indexOf(t)))).onBinary(["langString", "string"], (e, t) => {
        const [r, n] = [e.typedValue, t.typedValue], i = e.typedValue.substr(0, r.indexOf(n));
        return i || !n ? m.langString(i, e.language) : m.string(i)
      }).onBinary(["langString", "langString"], (e, t) => {
        if (e.language !== t.language) throw new h.IncompatibleLanguageOperation(e, t);
        const [r, n] = [e.typedValue, t.typedValue], i = e.typedValue.substr(0, r.indexOf(n));
        return i || !n ? m.langString(i, e.language) : m.string(i)
      }).collect()
    },
    strafter: {
      arity: 2,
      overloads: m.declare().onBinaryTyped(["string", "string"], (e, t) => m.string(e.substr(e.indexOf(t)).substr(t.length))).onBinary(["langString", "string"], (e, t) => {
        const [r, n] = [e.typedValue, t.typedValue], i = r.substr(r.indexOf(n)).substr(n.length);
        return i || !n ? m.langString(i, e.language) : m.string(i)
      }).onBinary(["langString", "langString"], (e, t) => {
        if (e.language !== t.language) throw new h.IncompatibleLanguageOperation(e, t);
        const [r, n] = [e.typedValue, t.typedValue], i = r.substr(r.indexOf(n)).substr(n.length);
        return i || !n ? m.langString(i, e.language) : m.string(i)
      }).collect()
    },
    encode_for_uri: {
      arity: 1,
      overloads: m.declare().onStringly1Typed(e => m.string(encodeURI(e))).collect()
    },
    langmatches: {
      arity: 2,
      overloads: m.declare().onBinaryTyped(["string", "string"], (e, t) => m.bool(p.langMatches(e, t))).collect()
    },
    regex: {
      arity: [2, 3],
      overloads: m.declare().onBinaryTyped(["string", "string"], _).onBinaryTyped(["langString", "string"], _).onTernaryTyped(["string", "string", "string"], v).onTernaryTyped(["langString", "string", "string"], v).collect()
    },
    replace: {
      arity: [3, 4],
      overloads: m.declare().onTernaryTyped(["string", "string", "string"], (e, t, r) => m.string(p.replace(e, t, r))).set(["langString", "string", "string"], ([e, t, r]) => {
        const n = p.replace(e.typedValue, t.typedValue, r.typedValue);
        return m.langString(n, e.language)
      }).onQuaternaryTyped(["string", "string", "string", "string"], (e, t, r, n) => m.string(p.replace(e, t, r, n))).set(["langString", "string", "string", "string"], ([e, t, r, n]) => {
        const i = p.replace(e.typedValue, t.typedValue, r.typedValue, n.typedValue);
        return m.langString(i, e.language)
      }).collect()
    },
    abs: {
      arity: 1,
      overloads: m.declare().onNumeric1(e => m.number(Math.abs(e.typedValue), e.typeURL.value)).collect()
    },
    round: {
      arity: 1,
      overloads: m.declare().onNumeric1(e => m.number(Math.round(e.typedValue), e.typeURL.value)).collect()
    },
    ceil: {
      arity: 1,
      overloads: m.declare().onNumeric1(e => m.number(Math.ceil(e.typedValue), e.typeURL.value)).collect()
    },
    floor: {
      arity: 1,
      overloads: m.declare().onNumeric1(e => m.number(Math.floor(e.typedValue), e.typeURL.value)).collect()
    },
    rand: {
      arity: 0,
      overloads: m.declare().set([], () => m.number(Math.random(), f.TypeURL.XSD_DOUBLE)).collect()
    },
    year: {
      arity: 1,
      overloads: m.declare().onDateTime1(e => m.number(Number(w(e).year), f.TypeURL.XSD_INTEGER)).collect()
    },
    month: {
      arity: 1,
      overloads: m.declare().onDateTime1(e => m.number(Number(w(e).month), f.TypeURL.XSD_INTEGER)).collect()
    },
    day: {
      arity: 1,
      overloads: m.declare().onDateTime1(e => m.number(Number(w(e).day), f.TypeURL.XSD_INTEGER)).collect()
    },
    hours: {
      arity: 1,
      overloads: m.declare().onDateTime1(e => m.number(Number(w(e).hours), f.TypeURL.XSD_INTEGER)).collect()
    },
    minutes: {
      arity: 1,
      overloads: m.declare().onDateTime1(e => m.number(Number(w(e).minutes), f.TypeURL.XSD_INTEGER)).collect()
    },
    seconds: {
      arity: 1,
      overloads: m.declare().onDateTime1(e => m.number(Number(w(e).seconds), f.TypeURL.XSD_DECIMAL)).collect()
    },
    timezone: {
      arity: 1,
      overloads: m.declare().onDateTime1(e => {
        const t = p.formatDayTimeDuration(w(e).timezone);
        if (!t) throw new h.InvalidTimezoneCall(e.strValue);
        return new c.Literal(t, l.make(f.TypeURL.XSD_DAYTIME_DURATION), t)
      }).collect()
    },
    tz: {
      arity: 1,
      overloads: m.declare().onDateTime1(e => m.string(w(e).timezone)).collect()
    },
    md5: {
      arity: 1,
      overloads: m.declare().onString1Typed(e => m.string(a.hash(e))).collect()
    },
    sha1: {
      arity: 1,
      overloads: m.declare().onString1Typed(e => m.string(i.sha1().update(e).digest("hex"))).collect()
    },
    sha256: {
      arity: 1,
      overloads: m.declare().onString1Typed(e => m.string(i.sha256().update(e).digest("hex"))).collect()
    },
    sha384: {
      arity: 1,
      overloads: m.declare().onString1Typed(e => m.string(i.sha384().update(e).digest("hex"))).collect()
    },
    sha512: {
      arity: 1,
      overloads: m.declare().onString1Typed(e => m.string(i.sha512().update(e).digest("hex"))).collect()
    }
  };
  t.definitions = u.Map(S)
}, function(e, t, r) {
  e.exports = function(e) {
    "use strict";
    var t = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];

    function r(e, t) {
      var r = e[0],
        n = e[1],
        i = e[2],
        a = e[3];
      n = ((n += ((i = ((i += ((a = ((a += ((r = ((r += (n & i | ~n & a) + t[0] - 680876936 | 0) << 7 | r >>> 25) + n | 0) & n | ~r & i) + t[1] - 389564586 | 0) << 12 | a >>> 20) + r | 0) & r | ~a & n) + t[2] + 606105819 | 0) << 17 | i >>> 15) + a | 0) & a | ~i & r) + t[3] - 1044525330 | 0) << 22 | n >>> 10) + i | 0, n = ((n += ((i = ((i += ((a = ((a += ((r = ((r += (n & i | ~n & a) + t[4] - 176418897 | 0) << 7 | r >>> 25) + n | 0) & n | ~r & i) + t[5] + 1200080426 | 0) << 12 | a >>> 20) + r | 0) & r | ~a & n) + t[6] - 1473231341 | 0) << 17 | i >>> 15) + a | 0) & a | ~i & r) + t[7] - 45705983 | 0) << 22 | n >>> 10) + i | 0, n = ((n += ((i = ((i += ((a = ((a += ((r = ((r += (n & i | ~n & a) + t[8] + 1770035416 | 0) << 7 | r >>> 25) + n | 0) & n | ~r & i) + t[9] - 1958414417 | 0) << 12 | a >>> 20) + r | 0) & r | ~a & n) + t[10] - 42063 | 0) << 17 | i >>> 15) + a | 0) & a | ~i & r) + t[11] - 1990404162 | 0) << 22 | n >>> 10) + i | 0, n = ((n += ((i = ((i += ((a = ((a += ((r = ((r += (n & i | ~n & a) + t[12] + 1804603682 | 0) << 7 | r >>> 25) + n | 0) & n | ~r & i) + t[13] - 40341101 | 0) << 12 | a >>> 20) + r | 0) & r | ~a & n) + t[14] - 1502002290 | 0) << 17 | i >>> 15) + a | 0) & a | ~i & r) + t[15] + 1236535329 | 0) << 22 | n >>> 10) + i | 0, n = ((n += ((i = ((i += ((a = ((a += ((r = ((r += (n & a | i & ~a) + t[1] - 165796510 | 0) << 5 | r >>> 27) + n | 0) & i | n & ~i) + t[6] - 1069501632 | 0) << 9 | a >>> 23) + r | 0) & n | r & ~n) + t[11] + 643717713 | 0) << 14 | i >>> 18) + a | 0) & r | a & ~r) + t[0] - 373897302 | 0) << 20 | n >>> 12) + i | 0, n = ((n += ((i = ((i += ((a = ((a += ((r = ((r += (n & a | i & ~a) + t[5] - 701558691 | 0) << 5 | r >>> 27) + n | 0) & i | n & ~i) + t[10] + 38016083 | 0) << 9 | a >>> 23) + r | 0) & n | r & ~n) + t[15] - 660478335 | 0) << 14 | i >>> 18) + a | 0) & r | a & ~r) + t[4] - 405537848 | 0) << 20 | n >>> 12) + i | 0, n = ((n += ((i = ((i += ((a = ((a += ((r = ((r += (n & a | i & ~a) + t[9] + 568446438 | 0) << 5 | r >>> 27) + n | 0) & i | n & ~i) + t[14] - 1019803690 | 0) << 9 | a >>> 23) + r | 0) & n | r & ~n) + t[3] - 187363961 | 0) << 14 | i >>> 18) + a | 0) & r | a & ~r) + t[8] + 1163531501 | 0) << 20 | n >>> 12) + i | 0, n = ((n += ((i = ((i += ((a = ((a += ((r = ((r += (n & a | i & ~a) + t[13] - 1444681467 | 0) << 5 | r >>> 27) + n | 0) & i | n & ~i) + t[2] - 51403784 | 0) << 9 | a >>> 23) + r | 0) & n | r & ~n) + t[7] + 1735328473 | 0) << 14 | i >>> 18) + a | 0) & r | a & ~r) + t[12] - 1926607734 | 0) << 20 | n >>> 12) + i | 0, n = ((n += ((i = ((i += ((a = ((a += ((r = ((r += (n ^ i ^ a) + t[5] - 378558 | 0) << 4 | r >>> 28) + n | 0) ^ n ^ i) + t[8] - 2022574463 | 0) << 11 | a >>> 21) + r | 0) ^ r ^ n) + t[11] + 1839030562 | 0) << 16 | i >>> 16) + a | 0) ^ a ^ r) + t[14] - 35309556 | 0) << 23 | n >>> 9) + i | 0, n = ((n += ((i = ((i += ((a = ((a += ((r = ((r += (n ^ i ^ a) + t[1] - 1530992060 | 0) << 4 | r >>> 28) + n | 0) ^ n ^ i) + t[4] + 1272893353 | 0) << 11 | a >>> 21) + r | 0) ^ r ^ n) + t[7] - 155497632 | 0) << 16 | i >>> 16) + a | 0) ^ a ^ r) + t[10] - 1094730640 | 0) << 23 | n >>> 9) + i | 0, n = ((n += ((i = ((i += ((a = ((a += ((r = ((r += (n ^ i ^ a) + t[13] + 681279174 | 0) << 4 | r >>> 28) + n | 0) ^ n ^ i) + t[0] - 358537222 | 0) << 11 | a >>> 21) + r | 0) ^ r ^ n) + t[3] - 722521979 | 0) << 16 | i >>> 16) + a | 0) ^ a ^ r) + t[6] + 76029189 | 0) << 23 | n >>> 9) + i | 0, n = ((n += ((i = ((i += ((a = ((a += ((r = ((r += (n ^ i ^ a) + t[9] - 640364487 | 0) << 4 | r >>> 28) + n | 0) ^ n ^ i) + t[12] - 421815835 | 0) << 11 | a >>> 21) + r | 0) ^ r ^ n) + t[15] + 530742520 | 0) << 16 | i >>> 16) + a | 0) ^ a ^ r) + t[2] - 995338651 | 0) << 23 | n >>> 9) + i | 0, n = ((n += ((a = ((a += (n ^ ((r = ((r += (i ^ (n | ~a)) + t[0] - 198630844 | 0) << 6 | r >>> 26) + n | 0) | ~i)) + t[7] + 1126891415 | 0) << 10 | a >>> 22) + r | 0) ^ ((i = ((i += (r ^ (a | ~n)) + t[14] - 1416354905 | 0) << 15 | i >>> 17) + a | 0) | ~r)) + t[5] - 57434055 | 0) << 21 | n >>> 11) + i | 0, n = ((n += ((a = ((a += (n ^ ((r = ((r += (i ^ (n | ~a)) + t[12] + 1700485571 | 0) << 6 | r >>> 26) + n | 0) | ~i)) + t[3] - 1894986606 | 0) << 10 | a >>> 22) + r | 0) ^ ((i = ((i += (r ^ (a | ~n)) + t[10] - 1051523 | 0) << 15 | i >>> 17) + a | 0) | ~r)) + t[1] - 2054922799 | 0) << 21 | n >>> 11) + i | 0, n = ((n += ((a = ((a += (n ^ ((r = ((r += (i ^ (n | ~a)) + t[8] + 1873313359 | 0) << 6 | r >>> 26) + n | 0) | ~i)) + t[15] - 30611744 | 0) << 10 | a >>> 22) + r | 0) ^ ((i = ((i += (r ^ (a | ~n)) + t[6] - 1560198380 | 0) << 15 | i >>> 17) + a | 0) | ~r)) + t[13] + 1309151649 | 0) << 21 | n >>> 11) + i | 0, n = ((n += ((a = ((a += (n ^ ((r = ((r += (i ^ (n | ~a)) + t[4] - 145523070 | 0) << 6 | r >>> 26) + n | 0) | ~i)) + t[11] - 1120210379 | 0) << 10 | a >>> 22) + r | 0) ^ ((i = ((i += (r ^ (a | ~n)) + t[2] + 718787259 | 0) << 15 | i >>> 17) + a | 0) | ~r)) + t[9] - 343485551 | 0) << 21 | n >>> 11) + i | 0, e[0] = r + e[0] | 0, e[1] = n + e[1] | 0, e[2] = i + e[2] | 0, e[3] = a + e[3] | 0
    }

    function n(e) {
      var t, r = [];
      for (t = 0; t < 64; t += 4) r[t >> 2] = e.charCodeAt(t) + (e.charCodeAt(t + 1) << 8) + (e.charCodeAt(t + 2) << 16) + (e.charCodeAt(t + 3) << 24);
      return r
    }

    function i(e) {
      var t, r = [];
      for (t = 0; t < 64; t += 4) r[t >> 2] = e[t] + (e[t + 1] << 8) + (e[t + 2] << 16) + (e[t + 3] << 24);
      return r
    }

    function a(e) {
      var t, i, a, s, o, u, c = e.length,
        l = [1732584193, -271733879, -1732584194, 271733878];
      for (t = 64; t <= c; t += 64) r(l, n(e.substring(t - 64, t)));
      for (i = (e = e.substring(t - 64)).length, a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], t = 0; t < i; t += 1) a[t >> 2] |= e.charCodeAt(t) << (t % 4 << 3);
      if (a[t >> 2] |= 128 << (t % 4 << 3), t > 55)
        for (r(l, a), t = 0; t < 16; t += 1) a[t] = 0;
      return s = (s = 8 * c).toString(16).match(/(.*?)(.{0,8})$/), o = parseInt(s[2], 16), u = parseInt(s[1], 16) || 0, a[14] = o, a[15] = u, r(l, a), l
    }

    function s(e) {
      var r, n = "";
      for (r = 0; r < 4; r += 1) n += t[e >> 8 * r + 4 & 15] + t[e >> 8 * r & 15];
      return n
    }

    function o(e) {
      var t;
      for (t = 0; t < e.length; t += 1) e[t] = s(e[t]);
      return e.join("")
    }

    function u(e) {
      return /[\u0080-\uFFFF]/.test(e) && (e = unescape(encodeURIComponent(e))), e
    }

    function c(e) {
      var t, r = [],
        n = e.length;
      for (t = 0; t < n - 1; t += 2) r.push(parseInt(e.substr(t, 2), 16));
      return String.fromCharCode.apply(String, r)
    }

    function l() {
      this.reset()
    }
    return o(a("hello")), "undefined" == typeof ArrayBuffer || ArrayBuffer.prototype.slice || function() {
      function t(e, t) {
        return (e = 0 | e || 0) < 0 ? Math.max(e + t, 0) : Math.min(e, t)
      }
      ArrayBuffer.prototype.slice = function(r, n) {
        var i, a, s, o, u = this.byteLength,
          c = t(r, u),
          l = u;
        return n !== e && (l = t(n, u)), c > l ? new ArrayBuffer(0) : (i = l - c, a = new ArrayBuffer(i), s = new Uint8Array(a), o = new Uint8Array(this, c, i), s.set(o), a)
      }
    }(), l.prototype.append = function(e) {
      return this.appendBinary(u(e)), this
    }, l.prototype.appendBinary = function(e) {
      this._buff += e, this._length += e.length;
      var t, i = this._buff.length;
      for (t = 64; t <= i; t += 64) r(this._hash, n(this._buff.substring(t - 64, t)));
      return this._buff = this._buff.substring(t - 64), this
    }, l.prototype.end = function(e) {
      var t, r, n = this._buff,
        i = n.length,
        a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (t = 0; t < i; t += 1) a[t >> 2] |= n.charCodeAt(t) << (t % 4 << 3);
      return this._finish(a, i), r = o(this._hash), e && (r = c(r)), this.reset(), r
    }, l.prototype.reset = function() {
      return this._buff = "", this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this
    }, l.prototype.getState = function() {
      return {
        buff: this._buff,
        length: this._length,
        hash: this._hash.slice()
      }
    }, l.prototype.setState = function(e) {
      return this._buff = e.buff, this._length = e.length, this._hash = e.hash, this
    }, l.prototype.destroy = function() {
      delete this._hash, delete this._buff, delete this._length
    }, l.prototype._finish = function(e, t) {
      var n, i, a, s = t;
      if (e[s >> 2] |= 128 << (s % 4 << 3), s > 55)
        for (r(this._hash, e), s = 0; s < 16; s += 1) e[s] = 0;
      n = (n = 8 * this._length).toString(16).match(/(.*?)(.{0,8})$/), i = parseInt(n[2], 16), a = parseInt(n[1], 16) || 0, e[14] = i, e[15] = a, r(this._hash, e)
    }, l.hash = function(e, t) {
      return l.hashBinary(u(e), t)
    }, l.hashBinary = function(e, t) {
      var r = o(a(e));
      return t ? c(r) : r
    }, l.ArrayBuffer = function() {
      this.reset()
    }, l.ArrayBuffer.prototype.append = function(e) {
      var t, n, a, s, o, u = (n = this._buff.buffer, a = e, s = !0, (o = new Uint8Array(n.byteLength + a.byteLength)).set(new Uint8Array(n)), o.set(new Uint8Array(a), n.byteLength), s ? o : o.buffer),
        c = u.length;
      for (this._length += e.byteLength, t = 64; t <= c; t += 64) r(this._hash, i(u.subarray(t - 64, t)));
      return this._buff = t - 64 < c ? new Uint8Array(u.buffer.slice(t - 64)) : new Uint8Array(0), this
    }, l.ArrayBuffer.prototype.end = function(e) {
      var t, r, n = this._buff,
        i = n.length,
        a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
      for (t = 0; t < i; t += 1) a[t >> 2] |= n[t] << (t % 4 << 3);
      return this._finish(a, i), r = o(this._hash), e && (r = c(r)), this.reset(), r
    }, l.ArrayBuffer.prototype.reset = function() {
      return this._buff = new Uint8Array(0), this._length = 0, this._hash = [1732584193, -271733879, -1732584194, 271733878], this
    }, l.ArrayBuffer.prototype.getState = function() {
      var e, t = l.prototype.getState.call(this);
      return t.buff = (e = t.buff, String.fromCharCode.apply(null, new Uint8Array(e))), t
    }, l.ArrayBuffer.prototype.setState = function(e) {
      return e.buff = function(e, t) {
        var r, n = e.length,
          i = new ArrayBuffer(n),
          a = new Uint8Array(i);
        for (r = 0; r < n; r += 1) a[r] = e.charCodeAt(r);
        return t ? a : i
      }(e.buff, !0), l.prototype.setState.call(this, e)
    }, l.ArrayBuffer.prototype.destroy = l.prototype.destroy, l.ArrayBuffer.prototype._finish = l.prototype._finish, l.ArrayBuffer.hash = function(e, t) {
      var n = o(function(e) {
        var t, n, a, s, o, u, c = e.length,
          l = [1732584193, -271733879, -1732584194, 271733878];
        for (t = 64; t <= c; t += 64) r(l, i(e.subarray(t - 64, t)));
        for (e = t - 64 < c ? e.subarray(t - 64) : new Uint8Array(0), n = e.length, a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], t = 0; t < n; t += 1) a[t >> 2] |= e[t] << (t % 4 << 3);
        if (a[t >> 2] |= 128 << (t % 4 << 3), t > 55)
          for (r(l, a), t = 0; t < 16; t += 1) a[t] = 0;
        return s = (s = 8 * c).toString(16).match(/(.*?)(.{0,8})$/), o = parseInt(s[2], 16), u = parseInt(s[1], 16) || 0, a[14] = o, a[15] = u, r(l, a), l
      }(new Uint8Array(e)));
      return t ? c(n) : n
    }, l
  }()
}, function(e, t, r) {
  var n;
  ! function(i) {
    "use strict";
    var a, s, o, u = 9e15,
      c = "0123456789abcdef",
      l = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058",
      h = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789",
      d = {
        precision: 20,
        rounding: 4,
        modulo: 1,
        toExpNeg: -7,
        toExpPos: 21,
        minE: -u,
        maxE: u,
        crypto: !1
      },
      p = !0,
      f = "[DecimalError] Invalid argument: ",
      g = Math.floor,
      m = Math.pow,
      y = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
      b = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
      _ = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
      v = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
      w = 1e7,
      S = l.length - 1,
      T = h.length - 1,
      E = {
        name: "[object Decimal]"
      };

    function x(e) {
      var t, r, n, i = e.length - 1,
        a = "",
        s = e[0];
      if (i > 0) {
        for (a += s, t = 1; t < i; t++)(r = 7 - (n = e[t] + "").length) && (a += L(r)), a += n;
        (r = 7 - (n = (s = e[t]) + "").length) && (a += L(r))
      } else if (0 === s) return "0";
      for (; s % 10 == 0;) s /= 10;
      return a + s
    }

    function O(e, t, r) {
      if (e !== ~~e || e < t || e > r) throw Error(f + e)
    }

    function A(e, t, r, n) {
      var i, a, s, o;
      for (a = e[0]; a >= 10; a /= 10) --t;
      return --t < 0 ? (t += 7, i = 0) : (i = Math.ceil((t + 1) / 7), t %= 7), a = m(10, 7 - t), o = e[i] % a | 0, null == n ? t < 3 ? (0 == t ? o = o / 100 | 0 : 1 == t && (o = o / 10 | 0), s = r < 4 && 99999 == o || r > 3 && 49999 == o || 5e4 == o || 0 == o) : s = (r < 4 && o + 1 == a || r > 3 && o + 1 == a / 2) && (e[i + 1] / a / 100 | 0) == m(10, t - 2) - 1 || (o == a / 2 || 0 == o) && 0 == (e[i + 1] / a / 100 | 0) : t < 4 ? (0 == t ? o = o / 1e3 | 0 : 1 == t ? o = o / 100 | 0 : 2 == t && (o = o / 10 | 0), s = (n || r < 4) && 9999 == o || !n && r > 3 && 4999 == o) : s = ((n || r < 4) && o + 1 == a || !n && r > 3 && o + 1 == a / 2) && (e[i + 1] / a / 1e3 | 0) == m(10, t - 3) - 1, s
    }

    function R(e, t, r) {
      for (var n, i, a = [0], s = 0, o = e.length; s < o;) {
        for (i = a.length; i--;) a[i] *= t;
        for (a[0] += c.indexOf(e.charAt(s++)), n = 0; n < a.length; n++) a[n] > r - 1 && (void 0 === a[n + 1] && (a[n + 1] = 0), a[n + 1] += a[n] / r | 0, a[n] %= r)
      }
      return a.reverse()
    }
    E.absoluteValue = E.abs = function() {
      var e = new this.constructor(this);
      return e.s < 0 && (e.s = 1), N(e)
    }, E.ceil = function() {
      return N(new this.constructor(this), this.e + 1, 2)
    }, E.comparedTo = E.cmp = function(e) {
      var t, r, n, i, a = this,
        s = a.d,
        o = (e = new a.constructor(e)).d,
        u = a.s,
        c = e.s;
      if (!s || !o) return u && c ? u !== c ? u : s === o ? 0 : !s ^ u < 0 ? 1 : -1 : NaN;
      if (!s[0] || !o[0]) return s[0] ? u : o[0] ? -c : 0;
      if (u !== c) return u;
      if (a.e !== e.e) return a.e > e.e ^ u < 0 ? 1 : -1;
      for (t = 0, r = (n = s.length) < (i = o.length) ? n : i; t < r; ++t)
        if (s[t] !== o[t]) return s[t] > o[t] ^ u < 0 ? 1 : -1;
      return n === i ? 0 : n > i ^ u < 0 ? 1 : -1
    }, E.cosine = E.cos = function() {
      var e, t, r = this,
        n = r.constructor;
      return r.d ? r.d[0] ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + 7, n.rounding = 1, r = function(e, t) {
        var r, n, i = t.d.length;
        i < 32 ? (r = Math.ceil(i / 3), n = (1 / Q(4, r)).toString()) : (r = 16, n = "2.3283064365386962890625e-10");
        e.precision += r, t = z(e, 1, t.times(n), new e(1));
        for (var a = r; a--;) {
          var s = t.times(t);
          t = s.times(s).minus(s).times(8).plus(1)
        }
        return e.precision -= r, t
      }(n, X(n, r)), n.precision = e, n.rounding = t, N(2 == o || 3 == o ? r.neg() : r, e, t, !0)) : new n(1) : new n(NaN)
    }, E.cubeRoot = E.cbrt = function() {
      var e, t, r, n, i, a, s, o, u, c, l = this,
        h = l.constructor;
      if (!l.isFinite() || l.isZero()) return new h(l);
      for (p = !1, (a = l.s * m(l.s * l, 1 / 3)) && Math.abs(a) != 1 / 0 ? n = new h(a.toString()) : (r = x(l.d), (a = ((e = l.e) - r.length + 1) % 3) && (r += 1 == a || -2 == a ? "0" : "00"), a = m(r, 1 / 3), e = g((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2)), (n = new h(r = a == 1 / 0 ? "5e" + e : (r = a.toExponential()).slice(0, r.indexOf("e") + 1) + e)).s = l.s), s = (e = h.precision) + 3;;)
        if (c = (u = (o = n).times(o).times(o)).plus(l), n = I(c.plus(l).times(o), c.plus(u), s + 2, 1), x(o.d).slice(0, s) === (r = x(n.d)).slice(0, s)) {
          if ("9999" != (r = r.slice(s - 3, s + 1)) && (i || "4999" != r)) {
            +r && (+r.slice(1) || "5" != r.charAt(0)) || (N(n, e + 1, 1), t = !n.times(n).times(n).eq(l));
            break
          }
          if (!i && (N(o, e + 1, 0), o.times(o).times(o).eq(l))) {
            n = o;
            break
          }
          s += 4, i = 1
        } return p = !0, N(n, e, h.rounding, t)
    }, E.decimalPlaces = E.dp = function() {
      var e, t = this.d,
        r = NaN;
      if (t) {
        if (r = 7 * ((e = t.length - 1) - g(this.e / 7)), e = t[e])
          for (; e % 10 == 0; e /= 10) r--;
        r < 0 && (r = 0)
      }
      return r
    }, E.dividedBy = E.div = function(e) {
      return I(this, new this.constructor(e))
    }, E.dividedToIntegerBy = E.divToInt = function(e) {
      var t = this.constructor;
      return N(I(this, new t(e), 0, 1, 1), t.precision, t.rounding)
    }, E.equals = E.eq = function(e) {
      return 0 === this.cmp(e)
    }, E.floor = function() {
      return N(new this.constructor(this), this.e + 1, 3)
    }, E.greaterThan = E.gt = function(e) {
      return this.cmp(e) > 0
    }, E.greaterThanOrEqualTo = E.gte = function(e) {
      var t = this.cmp(e);
      return 1 == t || 0 === t
    }, E.hyperbolicCosine = E.cosh = function() {
      var e, t, r, n, i, a = this,
        s = a.constructor,
        o = new s(1);
      if (!a.isFinite()) return new s(a.s ? 1 / 0 : NaN);
      if (a.isZero()) return o;
      r = s.precision, n = s.rounding, s.precision = r + Math.max(a.e, a.sd()) + 4, s.rounding = 1, (i = a.d.length) < 32 ? t = (1 / Q(4, e = Math.ceil(i / 3))).toString() : (e = 16, t = "2.3283064365386962890625e-10"), a = z(s, 1, a.times(t), new s(1), !0);
      for (var u, c = e, l = new s(8); c--;) u = a.times(a), a = o.minus(u.times(l.minus(u.times(l))));
      return N(a, s.precision = r, s.rounding = n, !0)
    }, E.hyperbolicSine = E.sinh = function() {
      var e, t, r, n, i = this,
        a = i.constructor;
      if (!i.isFinite() || i.isZero()) return new a(i);
      if (t = a.precision, r = a.rounding, a.precision = t + Math.max(i.e, i.sd()) + 4, a.rounding = 1, (n = i.d.length) < 3) i = z(a, 2, i, i, !0);
      else {
        e = (e = 1.4 * Math.sqrt(n)) > 16 ? 16 : 0 | e, i = z(a, 2, i = i.times(1 / Q(5, e)), i, !0);
        for (var s, o = new a(5), u = new a(16), c = new a(20); e--;) s = i.times(i), i = i.times(o.plus(s.times(u.times(s).plus(c))))
      }
      return a.precision = t, a.rounding = r, N(i, t, r, !0)
    }, E.hyperbolicTangent = E.tanh = function() {
      var e, t, r = this,
        n = r.constructor;
      return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 7, n.rounding = 1, I(r.sinh(), r.cosh(), n.precision = e, n.rounding = t)) : new n(r.s)
    }, E.inverseCosine = E.acos = function() {
      var e, t = this,
        r = t.constructor,
        n = t.abs().cmp(1),
        i = r.precision,
        a = r.rounding;
      return -1 !== n ? 0 === n ? t.isNeg() ? j(r, i, a) : new r(0) : new r(NaN) : t.isZero() ? j(r, i + 4, a).times(.5) : (r.precision = i + 6, r.rounding = 1, t = t.asin(), e = j(r, i + 4, a).times(.5), r.precision = i, r.rounding = a, e.minus(t))
    }, E.inverseHyperbolicCosine = E.acosh = function() {
      var e, t, r = this,
        n = r.constructor;
      return r.lte(1) ? new n(r.eq(1) ? 0 : NaN) : r.isFinite() ? (e = n.precision, t = n.rounding, n.precision = e + Math.max(Math.abs(r.e), r.sd()) + 4, n.rounding = 1, p = !1, r = r.times(r).minus(1).sqrt().plus(r), p = !0, n.precision = e, n.rounding = t, r.ln()) : new n(r)
    }, E.inverseHyperbolicSine = E.asinh = function() {
      var e, t, r = this,
        n = r.constructor;
      return !r.isFinite() || r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 2 * Math.max(Math.abs(r.e), r.sd()) + 6, n.rounding = 1, p = !1, r = r.times(r).plus(1).sqrt().plus(r), p = !0, n.precision = e, n.rounding = t, r.ln())
    }, E.inverseHyperbolicTangent = E.atanh = function() {
      var e, t, r, n, i = this,
        a = i.constructor;
      return i.isFinite() ? i.e >= 0 ? new a(i.abs().eq(1) ? i.s / 0 : i.isZero() ? i : NaN) : (e = a.precision, t = a.rounding, n = i.sd(), Math.max(n, e) < 2 * -i.e - 1 ? N(new a(i), e, t, !0) : (a.precision = r = n - i.e, i = I(i.plus(1), new a(1).minus(i), r + e, 1), a.precision = e + 4, a.rounding = 1, i = i.ln(), a.precision = e, a.rounding = t, i.times(.5))) : new a(NaN)
    }, E.inverseSine = E.asin = function() {
      var e, t, r, n, i = this,
        a = i.constructor;
      return i.isZero() ? new a(i) : (t = i.abs().cmp(1), r = a.precision, n = a.rounding, -1 !== t ? 0 === t ? ((e = j(a, r + 4, n).times(.5)).s = i.s, e) : new a(NaN) : (a.precision = r + 6, a.rounding = 1, i = i.div(new a(1).minus(i.times(i)).sqrt().plus(1)).atan(), a.precision = r, a.rounding = n, i.times(2)))
    }, E.inverseTangent = E.atan = function() {
      var e, t, r, n, i, a, s, o, u, c = this,
        l = c.constructor,
        h = l.precision,
        d = l.rounding;
      if (c.isFinite()) {
        if (c.isZero()) return new l(c);
        if (c.abs().eq(1) && h + 4 <= T) return (s = j(l, h + 4, d).times(.25)).s = c.s, s
      } else {
        if (!c.s) return new l(NaN);
        if (h + 4 <= T) return (s = j(l, h + 4, d).times(.5)).s = c.s, s
      }
      for (l.precision = o = h + 10, l.rounding = 1, e = r = Math.min(28, o / 7 + 2 | 0); e; --e) c = c.div(c.times(c).plus(1).sqrt().plus(1));
      for (p = !1, t = Math.ceil(o / 7), n = 1, u = c.times(c), s = new l(c), i = c; - 1 !== e;)
        if (i = i.times(u), a = s.minus(i.div(n += 2)), i = i.times(u), void 0 !== (s = a.plus(i.div(n += 2))).d[t])
          for (e = t; s.d[e] === a.d[e] && e--;);
      return r && (s = s.times(2 << r - 1)), p = !0, N(s, l.precision = h, l.rounding = d, !0)
    }, E.isFinite = function() {
      return !!this.d
    }, E.isInteger = E.isInt = function() {
      return !!this.d && g(this.e / 7) > this.d.length - 2
    }, E.isNaN = function() {
      return !this.s
    }, E.isNegative = E.isNeg = function() {
      return this.s < 0
    }, E.isPositive = E.isPos = function() {
      return this.s > 0
    }, E.isZero = function() {
      return !!this.d && 0 === this.d[0]
    }, E.lessThan = E.lt = function(e) {
      return this.cmp(e) < 0
    }, E.lessThanOrEqualTo = E.lte = function(e) {
      return this.cmp(e) < 1
    }, E.logarithm = E.log = function(e) {
      var t, r, n, i, a, s, o, u, c = this.constructor,
        l = c.precision,
        h = c.rounding;
      if (null == e) e = new c(10), t = !0;
      else {
        if (r = (e = new c(e)).d, e.s < 0 || !r || !r[0] || e.eq(1)) return new c(NaN);
        t = e.eq(10)
      }
      if (r = this.d, this.s < 0 || !r || !r[0] || this.eq(1)) return new c(r && !r[0] ? -1 / 0 : 1 != this.s ? NaN : r ? 0 : 1 / 0);
      if (t)
        if (r.length > 1) a = !0;
        else {
          for (i = r[0]; i % 10 == 0;) i /= 10;
          a = 1 !== i
        } if (p = !1, s = U(this, o = l + 5), n = t ? D(c, o + 10) : U(e, o), A((u = I(s, n, o, 1)).d, i = l, h))
        do {
          if (s = U(this, o += 10), n = t ? D(c, o + 10) : U(e, o), u = I(s, n, o, 1), !a) {
            +x(u.d).slice(i + 1, i + 15) + 1 == 1e14 && (u = N(u, l + 1, 0));
            break
          }
        } while (A(u.d, i += 10, h));
      return p = !0, N(u, l, h)
    }, E.minus = E.sub = function(e) {
      var t, r, n, i, a, s, o, u, c, l, h, d, f = this,
        m = f.constructor;
      if (e = new m(e), !f.d || !e.d) return f.s && e.s ? f.d ? e.s = -e.s : e = new m(e.d || f.s !== e.s ? f : NaN) : e = new m(NaN), e;
      if (f.s != e.s) return e.s = -e.s, f.plus(e);
      if (c = f.d, d = e.d, o = m.precision, u = m.rounding, !c[0] || !d[0]) {
        if (d[0]) e.s = -e.s;
        else {
          if (!c[0]) return new m(3 === u ? -0 : 0);
          e = new m(f)
        }
        return p ? N(e, o, u) : e
      }
      if (r = g(e.e / 7), l = g(f.e / 7), c = c.slice(), a = l - r) {
        for ((h = a < 0) ? (t = c, a = -a, s = d.length) : (t = d, r = l, s = c.length), a > (n = Math.max(Math.ceil(o / 7), s) + 2) && (a = n, t.length = 1), t.reverse(), n = a; n--;) t.push(0);
        t.reverse()
      } else {
        for ((h = (n = c.length) < (s = d.length)) && (s = n), n = 0; n < s; n++)
          if (c[n] != d[n]) {
            h = c[n] < d[n];
            break
          } a = 0
      }
      for (h && (t = c, c = d, d = t, e.s = -e.s), s = c.length, n = d.length - s; n > 0; --n) c[s++] = 0;
      for (n = d.length; n > a;) {
        if (c[--n] < d[n]) {
          for (i = n; i && 0 === c[--i];) c[i] = w - 1;
          --c[i], c[n] += w
        }
        c[n] -= d[n]
      }
      for (; 0 === c[--s];) c.pop();
      for (; 0 === c[0]; c.shift()) --r;
      return c[0] ? (e.d = c, e.e = C(c, r), p ? N(e, o, u) : e) : new m(3 === u ? -0 : 0)
    }, E.modulo = E.mod = function(e) {
      var t, r = this,
        n = r.constructor;
      return e = new n(e), !r.d || !e.s || e.d && !e.d[0] ? new n(NaN) : !e.d || r.d && !r.d[0] ? N(new n(r), n.precision, n.rounding) : (p = !1, 9 == n.modulo ? (t = I(r, e.abs(), 0, 3, 1)).s *= e.s : t = I(r, e, 0, n.modulo, 1), t = t.times(e), p = !0, r.minus(t))
    }, E.naturalExponential = E.exp = function() {
      return q(this)
    }, E.naturalLogarithm = E.ln = function() {
      return U(this)
    }, E.negated = E.neg = function() {
      var e = new this.constructor(this);
      return e.s = -e.s, N(e)
    }, E.plus = E.add = function(e) {
      var t, r, n, i, a, s, o, u, c, l, h = this,
        d = h.constructor;
      if (e = new d(e), !h.d || !e.d) return h.s && e.s ? h.d || (e = new d(e.d || h.s === e.s ? h : NaN)) : e = new d(NaN), e;
      if (h.s != e.s) return e.s = -e.s, h.minus(e);
      if (c = h.d, l = e.d, o = d.precision, u = d.rounding, !c[0] || !l[0]) return l[0] || (e = new d(h)), p ? N(e, o, u) : e;
      if (a = g(h.e / 7), n = g(e.e / 7), c = c.slice(), i = a - n) {
        for (i < 0 ? (r = c, i = -i, s = l.length) : (r = l, n = a, s = c.length), i > (s = (a = Math.ceil(o / 7)) > s ? a + 1 : s + 1) && (i = s, r.length = 1), r.reverse(); i--;) r.push(0);
        r.reverse()
      }
      for ((s = c.length) - (i = l.length) < 0 && (i = s, r = l, l = c, c = r), t = 0; i;) t = (c[--i] = c[i] + l[i] + t) / w | 0, c[i] %= w;
      for (t && (c.unshift(t), ++n), s = c.length; 0 == c[--s];) c.pop();
      return e.d = c, e.e = C(c, n), p ? N(e, o, u) : e
    }, E.precision = E.sd = function(e) {
      var t, r = this;
      if (void 0 !== e && e !== !!e && 1 !== e && 0 !== e) throw Error(f + e);
      return r.d ? (t = k(r.d), e && r.e + 1 > t && (t = r.e + 1)) : t = NaN, t
    }, E.round = function() {
      var e = this,
        t = e.constructor;
      return N(new t(e), e.e + 1, t.rounding)
    }, E.sine = E.sin = function() {
      var e, t, r = this,
        n = r.constructor;
      return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + Math.max(r.e, r.sd()) + 7, n.rounding = 1, r = function(e, t) {
        var r, n = t.d.length;
        if (n < 3) return z(e, 2, t, t);
        r = (r = 1.4 * Math.sqrt(n)) > 16 ? 16 : 0 | r, t = t.times(1 / Q(5, r)), t = z(e, 2, t, t);
        for (var i, a = new e(5), s = new e(16), o = new e(20); r--;) i = t.times(t), t = t.times(a.plus(i.times(s.times(i).minus(o))));
        return t
      }(n, X(n, r)), n.precision = e, n.rounding = t, N(o > 2 ? r.neg() : r, e, t, !0)) : new n(NaN)
    }, E.squareRoot = E.sqrt = function() {
      var e, t, r, n, i, a, s = this,
        o = s.d,
        u = s.e,
        c = s.s,
        l = s.constructor;
      if (1 !== c || !o || !o[0]) return new l(!c || c < 0 && (!o || o[0]) ? NaN : o ? s : 1 / 0);
      for (p = !1, 0 == (c = Math.sqrt(+s)) || c == 1 / 0 ? (((t = x(o)).length + u) % 2 == 0 && (t += "0"), c = Math.sqrt(t), u = g((u + 1) / 2) - (u < 0 || u % 2), n = new l(t = c == 1 / 0 ? "5e" + u : (t = c.toExponential()).slice(0, t.indexOf("e") + 1) + u)) : n = new l(c.toString()), r = (u = l.precision) + 3;;)
        if (n = (a = n).plus(I(s, a, r + 2, 1)).times(.5), x(a.d).slice(0, r) === (t = x(n.d)).slice(0, r)) {
          if ("9999" != (t = t.slice(r - 3, r + 1)) && (i || "4999" != t)) {
            +t && (+t.slice(1) || "5" != t.charAt(0)) || (N(n, u + 1, 1), e = !n.times(n).eq(s));
            break
          }
          if (!i && (N(a, u + 1, 0), a.times(a).eq(s))) {
            n = a;
            break
          }
          r += 4, i = 1
        } return p = !0, N(n, u, l.rounding, e)
    }, E.tangent = E.tan = function() {
      var e, t, r = this,
        n = r.constructor;
      return r.isFinite() ? r.isZero() ? new n(r) : (e = n.precision, t = n.rounding, n.precision = e + 10, n.rounding = 1, (r = r.sin()).s = 1, r = I(r, new n(1).minus(r.times(r)).sqrt(), e + 10, 0), n.precision = e, n.rounding = t, N(2 == o || 4 == o ? r.neg() : r, e, t, !0)) : new n(NaN)
    }, E.times = E.mul = function(e) {
      var t, r, n, i, a, s, o, u, c, l = this,
        h = l.constructor,
        d = l.d,
        f = (e = new h(e)).d;
      if (e.s *= l.s, !(d && d[0] && f && f[0])) return new h(!e.s || d && !d[0] && !f || f && !f[0] && !d ? NaN : d && f ? 0 * e.s : e.s / 0);
      for (r = g(l.e / 7) + g(e.e / 7), (u = d.length) < (c = f.length) && (a = d, d = f, f = a, s = u, u = c, c = s), a = [], n = s = u + c; n--;) a.push(0);
      for (n = c; --n >= 0;) {
        for (t = 0, i = u + n; i > n;) o = a[i] + f[n] * d[i - n - 1] + t, a[i--] = o % w | 0, t = o / w | 0;
        a[i] = (a[i] + t) % w | 0
      }
      for (; !a[--s];) a.pop();
      return t ? ++r : a.shift(), e.d = a, e.e = C(a, r), p ? N(e, h.precision, h.rounding) : e
    }, E.toBinary = function(e, t) {
      return $(this, 2, e, t)
    }, E.toDecimalPlaces = E.toDP = function(e, t) {
      var r = this,
        n = r.constructor;
      return r = new n(r), void 0 === e ? r : (O(e, 0, 1e9), void 0 === t ? t = n.rounding : O(t, 0, 8), N(r, e + r.e + 1, t))
    }, E.toExponential = function(e, t) {
      var r, n = this,
        i = n.constructor;
      return void 0 === e ? r = P(n, !0) : (O(e, 0, 1e9), void 0 === t ? t = i.rounding : O(t, 0, 8), r = P(n = N(new i(n), e + 1, t), !0, e + 1)), n.isNeg() && !n.isZero() ? "-" + r : r
    }, E.toFixed = function(e, t) {
      var r, n, i = this,
        a = i.constructor;
      return void 0 === e ? r = P(i) : (O(e, 0, 1e9), void 0 === t ? t = a.rounding : O(t, 0, 8), r = P(n = N(new a(i), e + i.e + 1, t), !1, e + n.e + 1)), i.isNeg() && !i.isZero() ? "-" + r : r
    }, E.toFraction = function(e) {
      var t, r, n, i, a, s, o, u, c, l, h, d, g = this,
        y = g.d,
        b = g.constructor;
      if (!y) return new b(g);
      if (c = r = new b(1), n = u = new b(0), s = (a = (t = new b(n)).e = k(y) - g.e - 1) % 7, t.d[0] = m(10, s < 0 ? 7 + s : s), null == e) e = a > 0 ? t : c;
      else {
        if (!(o = new b(e)).isInt() || o.lt(c)) throw Error(f + o);
        e = o.gt(t) ? a > 0 ? t : c : o
      }
      for (p = !1, o = new b(x(y)), l = b.precision, b.precision = a = 7 * y.length * 2; h = I(o, t, 0, 1, 1), 1 != (i = r.plus(h.times(n))).cmp(e);) r = n, n = i, i = c, c = u.plus(h.times(i)), u = i, i = t, t = o.minus(h.times(i)), o = i;
      return i = I(e.minus(r), n, 0, 1, 1), u = u.plus(i.times(c)), r = r.plus(i.times(n)), u.s = c.s = g.s, d = I(c, n, a, 1).minus(g).abs().cmp(I(u, r, a, 1).minus(g).abs()) < 1 ? [c, n] : [u, r], b.precision = l, p = !0, d
    }, E.toHexadecimal = E.toHex = function(e, t) {
      return $(this, 16, e, t)
    }, E.toNearest = function(e, t) {
      var r = this,
        n = r.constructor;
      if (r = new n(r), null == e) {
        if (!r.d) return r;
        e = new n(1), t = n.rounding
      } else {
        if (e = new n(e), void 0 === t ? t = n.rounding : O(t, 0, 8), !r.d) return e.s ? r : e;
        if (!e.d) return e.s && (e.s = r.s), e
      }
      return e.d[0] ? (p = !1, r = I(r, e, 0, t, 1).times(e), p = !0, N(r)) : (e.s = r.s, r = e), r
    }, E.toNumber = function() {
      return +this
    }, E.toOctal = function(e, t) {
      return $(this, 8, e, t)
    }, E.toPower = E.pow = function(e) {
      var t, r, n, i, a, s, o = this,
        u = o.constructor,
        c = +(e = new u(e));
      if (!(o.d && e.d && o.d[0] && e.d[0])) return new u(m(+o, c));
      if ((o = new u(o)).eq(1)) return o;
      if (n = u.precision, a = u.rounding, e.eq(1)) return N(o, n, a);
      if ((t = g(e.e / 7)) >= e.d.length - 1 && (r = c < 0 ? -c : c) <= 9007199254740991) return i = M(u, o, r, n), e.s < 0 ? new u(1).div(i) : N(i, n, a);
      if ((s = o.s) < 0) {
        if (t < e.d.length - 1) return new u(NaN);
        if (0 == (1 & e.d[t]) && (s = 1), 0 == o.e && 1 == o.d[0] && 1 == o.d.length) return o.s = s, o
      }
      return (t = 0 != (r = m(+o, c)) && isFinite(r) ? new u(r + "").e : g(c * (Math.log("0." + x(o.d)) / Math.LN10 + o.e + 1))) > u.maxE + 1 || t < u.minE - 1 ? new u(t > 0 ? s / 0 : 0) : (p = !1, u.rounding = o.s = 1, r = Math.min(12, (t + "").length), (i = q(e.times(U(o, n + r)), n)).d && A((i = N(i, n + 5, 1)).d, n, a) && (t = n + 10, +x((i = N(q(e.times(U(o, t + r)), t), t + 5, 1)).d).slice(n + 1, n + 15) + 1 == 1e14 && (i = N(i, n + 1, 0))), i.s = s, p = !0, u.rounding = a, N(i, n, a))
    }, E.toPrecision = function(e, t) {
      var r, n = this,
        i = n.constructor;
      return void 0 === e ? r = P(n, n.e <= i.toExpNeg || n.e >= i.toExpPos) : (O(e, 1, 1e9), void 0 === t ? t = i.rounding : O(t, 0, 8), r = P(n = N(new i(n), e, t), e <= n.e || n.e <= i.toExpNeg, e)), n.isNeg() && !n.isZero() ? "-" + r : r
    }, E.toSignificantDigits = E.toSD = function(e, t) {
      var r = this.constructor;
      return void 0 === e ? (e = r.precision, t = r.rounding) : (O(e, 1, 1e9), void 0 === t ? t = r.rounding : O(t, 0, 8)), N(new r(this), e, t)
    }, E.toString = function() {
      var e = this,
        t = e.constructor,
        r = P(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
      return e.isNeg() && !e.isZero() ? "-" + r : r
    }, E.truncated = E.trunc = function() {
      return N(new this.constructor(this), this.e + 1, 1)
    }, E.valueOf = E.toJSON = function() {
      var e = this,
        t = e.constructor,
        r = P(e, e.e <= t.toExpNeg || e.e >= t.toExpPos);
      return e.isNeg() ? "-" + r : r
    };
    var I = function() {
      function e(e, t, r) {
        var n, i = 0,
          a = e.length;
        for (e = e.slice(); a--;) n = e[a] * t + i, e[a] = n % r | 0, i = n / r | 0;
        return i && e.unshift(i), e
      }

      function t(e, t, r, n) {
        var i, a;
        if (r != n) a = r > n ? 1 : -1;
        else
          for (i = a = 0; i < r; i++)
            if (e[i] != t[i]) {
              a = e[i] > t[i] ? 1 : -1;
              break
            } return a
      }

      function r(e, t, r, n) {
        for (var i = 0; r--;) e[r] -= i, i = e[r] < t[r] ? 1 : 0, e[r] = i * n + e[r] - t[r];
        for (; !e[0] && e.length > 1;) e.shift()
      }
      return function(n, i, a, o, u, c) {
        var l, h, d, p, f, m, y, b, _, v, S, T, E, x, O, A, R, I, P, C, D = n.constructor,
          j = n.s == i.s ? 1 : -1,
          k = n.d,
          L = i.d;
        if (!(k && k[0] && L && L[0])) return new D(n.s && i.s && (k ? !L || k[0] != L[0] : L) ? k && 0 == k[0] || !L ? 0 * j : j / 0 : NaN);
        for (c ? (f = 1, h = n.e - i.e) : (c = w, f = 7, h = g(n.e / f) - g(i.e / f)), P = L.length, R = k.length, v = (_ = new D(j)).d = [], d = 0; L[d] == (k[d] || 0); d++);
        if (L[d] > (k[d] || 0) && h--, null == a ? (x = a = D.precision, o = D.rounding) : x = u ? a + (n.e - i.e) + 1 : a, x < 0) v.push(1), m = !0;
        else {
          if (x = x / f + 2 | 0, d = 0, 1 == P) {
            for (p = 0, L = L[0], x++;
                 (d < R || p) && x--; d++) O = p * c + (k[d] || 0), v[d] = O / L | 0, p = O % L | 0;
            m = p || d < R
          } else {
            for ((p = c / (L[0] + 1) | 0) > 1 && (L = e(L, p, c), k = e(k, p, c), P = L.length, R = k.length), A = P, T = (S = k.slice(0, P)).length; T < P;) S[T++] = 0;
            (C = L.slice()).unshift(0), I = L[0], L[1] >= c / 2 && ++I;
            do {
              p = 0, (l = t(L, S, P, T)) < 0 ? (E = S[0], P != T && (E = E * c + (S[1] || 0)), (p = E / I | 0) > 1 ? (p >= c && (p = c - 1), 1 == (l = t(y = e(L, p, c), S, b = y.length, T = S.length)) && (p--, r(y, P < b ? C : L, b, c))) : (0 == p && (l = p = 1), y = L.slice()), (b = y.length) < T && y.unshift(0), r(S, y, T, c), -1 == l && (l = t(L, S, P, T = S.length)) < 1 && (p++, r(S, P < T ? C : L, T, c)), T = S.length) : 0 === l && (p++, S = [0]), v[d++] = p, l && S[0] ? S[T++] = k[A] || 0 : (S = [k[A]], T = 1)
            } while ((A++ < R || void 0 !== S[0]) && x--);
            m = void 0 !== S[0]
          }
          v[0] || v.shift()
        }
        if (1 == f) _.e = h, s = m;
        else {
          for (d = 1, p = v[0]; p >= 10; p /= 10) d++;
          _.e = d + h * f - 1, N(_, u ? a + _.e + 1 : a, o, m)
        }
        return _
      }
    }();

    function N(e, t, r, n) {
      var i, a, s, o, u, c, l, h, d, f = e.constructor;
      e: if (null != t) {
        if (!(h = e.d)) return e;
        for (i = 1, o = h[0]; o >= 10; o /= 10) i++;
        if ((a = t - i) < 0) a += 7, s = t, u = (l = h[d = 0]) / m(10, i - s - 1) % 10 | 0;
        else if ((d = Math.ceil((a + 1) / 7)) >= (o = h.length)) {
          if (!n) break e;
          for (; o++ <= d;) h.push(0);
          l = u = 0, i = 1, s = (a %= 7) - 7 + 1
        } else {
          for (l = o = h[d], i = 1; o >= 10; o /= 10) i++;
          u = (s = (a %= 7) - 7 + i) < 0 ? 0 : l / m(10, i - s - 1) % 10 | 0
        }
        if (n = n || t < 0 || void 0 !== h[d + 1] || (s < 0 ? l : l % m(10, i - s - 1)), c = r < 4 ? (u || n) && (0 == r || r == (e.s < 0 ? 3 : 2)) : u > 5 || 5 == u && (4 == r || n || 6 == r && (a > 0 ? s > 0 ? l / m(10, i - s) : 0 : h[d - 1]) % 10 & 1 || r == (e.s < 0 ? 8 : 7)), t < 1 || !h[0]) return h.length = 0, c ? (t -= e.e + 1, h[0] = m(10, (7 - t % 7) % 7), e.e = -t || 0) : h[0] = e.e = 0, e;
        if (0 == a ? (h.length = d, o = 1, d--) : (h.length = d + 1, o = m(10, 7 - a), h[d] = s > 0 ? (l / m(10, i - s) % m(10, s) | 0) * o : 0), c)
          for (;;) {
            if (0 == d) {
              for (a = 1, s = h[0]; s >= 10; s /= 10) a++;
              for (s = h[0] += o, o = 1; s >= 10; s /= 10) o++;
              a != o && (e.e++, h[0] == w && (h[0] = 1));
              break
            }
            if (h[d] += o, h[d] != w) break;
            h[d--] = 0, o = 1
          }
        for (a = h.length; 0 === h[--a];) h.pop()
      }
      return p && (e.e > f.maxE ? (e.d = null, e.e = NaN) : e.e < f.minE && (e.e = 0, e.d = [0])), e
    }

    function P(e, t, r) {
      if (!e.isFinite()) return V(e);
      var n, i = e.e,
        a = x(e.d),
        s = a.length;
      return t ? (r && (n = r - s) > 0 ? a = a.charAt(0) + "." + a.slice(1) + L(n) : s > 1 && (a = a.charAt(0) + "." + a.slice(1)), a = a + (e.e < 0 ? "e" : "e+") + e.e) : i < 0 ? (a = "0." + L(-i - 1) + a, r && (n = r - s) > 0 && (a += L(n))) : i >= s ? (a += L(i + 1 - s), r && (n = r - i - 1) > 0 && (a = a + "." + L(n))) : ((n = i + 1) < s && (a = a.slice(0, n) + "." + a.slice(n)), r && (n = r - s) > 0 && (i + 1 === s && (a += "."), a += L(n))), a
    }

    function C(e, t) {
      var r = e[0];
      for (t *= 7; r >= 10; r /= 10) t++;
      return t
    }

    function D(e, t, r) {
      if (t > S) throw p = !0, r && (e.precision = r), Error("[DecimalError] Precision limit exceeded");
      return N(new e(l), t, 1, !0)
    }

    function j(e, t, r) {
      if (t > T) throw Error("[DecimalError] Precision limit exceeded");
      return N(new e(h), t, r, !0)
    }

    function k(e) {
      var t = e.length - 1,
        r = 7 * t + 1;
      if (t = e[t]) {
        for (; t % 10 == 0; t /= 10) r--;
        for (t = e[0]; t >= 10; t /= 10) r++
      }
      return r
    }

    function L(e) {
      for (var t = ""; e--;) t += "0";
      return t
    }

    function M(e, t, r, n) {
      var i, a = new e(1),
        s = Math.ceil(n / 7 + 4);
      for (p = !1;;) {
        if (r % 2 && Y((a = a.times(t)).d, s) && (i = !0), 0 === (r = g(r / 2))) {
          r = a.d.length - 1, i && 0 === a.d[r] && ++a.d[r];
          break
        }
        Y((t = t.times(t)).d, s)
      }
      return p = !0, a
    }

    function F(e) {
      return 1 & e.d[e.d.length - 1]
    }

    function B(e, t, r) {
      for (var n, i = new e(t[0]), a = 0; ++a < t.length;) {
        if (!(n = new e(t[a])).s) {
          i = n;
          break
        }
        i[r](n) && (i = n)
      }
      return i
    }

    function q(e, t) {
      var r, n, i, a, s, o, u, c = 0,
        l = 0,
        h = 0,
        d = e.constructor,
        f = d.rounding,
        g = d.precision;
      if (!e.d || !e.d[0] || e.e > 17) return new d(e.d ? e.d[0] ? e.s < 0 ? 0 : 1 / 0 : 1 : e.s ? e.s < 0 ? 0 : e : NaN);
      for (null == t ? (p = !1, u = g) : u = t, o = new d(.03125); e.e > -2;) e = e.times(o), h += 5;
      for (u += n = Math.log(m(2, h)) / Math.LN10 * 2 + 5 | 0, r = a = s = new d(1), d.precision = u;;) {
        if (a = N(a.times(e), u, 1), r = r.times(++l), x((o = s.plus(I(a, r, u, 1))).d).slice(0, u) === x(s.d).slice(0, u)) {
          for (i = h; i--;) s = N(s.times(s), u, 1);
          if (null != t) return d.precision = g, s;
          if (!(c < 3 && A(s.d, u - n, f, c))) return N(s, d.precision = g, f, p = !0);
          d.precision = u += 10, r = a = o = new d(1), l = 0, c++
        }
        s = o
      }
    }

    function U(e, t) {
      var r, n, i, a, s, o, u, c, l, h, d, f = 1,
        g = e,
        m = g.d,
        y = g.constructor,
        b = y.rounding,
        _ = y.precision;
      if (g.s < 0 || !m || !m[0] || !g.e && 1 == m[0] && 1 == m.length) return new y(m && !m[0] ? -1 / 0 : 1 != g.s ? NaN : m ? 0 : g);
      if (null == t ? (p = !1, l = _) : l = t, y.precision = l += 10, n = (r = x(m)).charAt(0), !(Math.abs(a = g.e) < 15e14)) return c = D(y, l + 2, _).times(a + ""), g = U(new y(n + "." + r.slice(1)), l - 10).plus(c), y.precision = _, null == t ? N(g, _, b, p = !0) : g;
      for (; n < 7 && 1 != n || 1 == n && r.charAt(1) > 3;) n = (r = x((g = g.times(e)).d)).charAt(0), f++;
      for (a = g.e, n > 1 ? (g = new y("0." + r), a++) : g = new y(n + "." + r.slice(1)), h = g, u = s = g = I(g.minus(1), g.plus(1), l, 1), d = N(g.times(g), l, 1), i = 3;;) {
        if (s = N(s.times(d), l, 1), x((c = u.plus(I(s, new y(i), l, 1))).d).slice(0, l) === x(u.d).slice(0, l)) {
          if (u = u.times(2), 0 !== a && (u = u.plus(D(y, l + 2, _).times(a + ""))), u = I(u, new y(f), l, 1), null != t) return y.precision = _, u;
          if (!A(u.d, l - 10, b, o)) return N(u, y.precision = _, b, p = !0);
          y.precision = l += 10, c = s = g = I(h.minus(1), h.plus(1), l, 1), d = N(g.times(g), l, 1), i = o = 1
        }
        u = c, i += 2
      }
    }

    function V(e) {
      return String(e.s * e.s / 0)
    }

    function H(e, t) {
      var r, n, i;
      for ((r = t.indexOf(".")) > -1 && (t = t.replace(".", "")), (n = t.search(/e/i)) > 0 ? (r < 0 && (r = n), r += +t.slice(n + 1), t = t.substring(0, n)) : r < 0 && (r = t.length), n = 0; 48 === t.charCodeAt(n); n++);
      for (i = t.length; 48 === t.charCodeAt(i - 1); --i);
      if (t = t.slice(n, i)) {
        if (i -= n, e.e = r = r - n - 1, e.d = [], n = (r + 1) % 7, r < 0 && (n += 7), n < i) {
          for (n && e.d.push(+t.slice(0, n)), i -= 7; n < i;) e.d.push(+t.slice(n, n += 7));
          n = 7 - (t = t.slice(n)).length
        } else n -= i;
        for (; n--;) t += "0";
        e.d.push(+t), p && (e.e > e.constructor.maxE ? (e.d = null, e.e = NaN) : e.e < e.constructor.minE && (e.e = 0, e.d = [0]))
      } else e.e = 0, e.d = [0];
      return e
    }

    function G(e, t) {
      var r, n, i, s, o, u, c, l, h;
      if ("Infinity" === t || "NaN" === t) return +t || (e.s = NaN), e.e = NaN, e.d = null, e;
      if (b.test(t)) r = 16, t = t.toLowerCase();
      else if (y.test(t)) r = 2;
      else {
        if (!_.test(t)) throw Error(f + t);
        r = 8
      }
      for ((s = t.search(/p/i)) > 0 ? (c = +t.slice(s + 1), t = t.substring(2, s)) : t = t.slice(2), o = (s = t.indexOf(".")) >= 0, n = e.constructor, o && (s = (u = (t = t.replace(".", "")).length) - s, i = M(n, new n(r), s, 2 * s)), s = h = (l = R(t, r, w)).length - 1; 0 === l[s]; --s) l.pop();
      return s < 0 ? new n(0 * e.s) : (e.e = C(l, h), e.d = l, p = !1, o && (e = I(e, i, 4 * u)), c && (e = e.times(Math.abs(c) < 54 ? m(2, c) : a.pow(2, c))), p = !0, e)
    }

    function z(e, t, r, n, i) {
      var a, s, o, u, c = e.precision,
        l = Math.ceil(c / 7);
      for (p = !1, u = r.times(r), o = new e(n);;) {
        if (s = I(o.times(u), new e(t++ * t++), c, 1), o = i ? n.plus(s) : n.minus(s), n = I(s.times(u), new e(t++ * t++), c, 1), void 0 !== (s = o.plus(n)).d[l]) {
          for (a = l; s.d[a] === o.d[a] && a--;);
          if (-1 == a) break
        }
        a = o, o = n, n = s, s = a
      }
      return p = !0, s.d.length = l + 1, s
    }

    function Q(e, t) {
      for (var r = e; --t;) r *= e;
      return r
    }

    function X(e, t) {
      var r, n = t.s < 0,
        i = j(e, e.precision, 1),
        a = i.times(.5);
      if ((t = t.abs()).lte(a)) return o = n ? 4 : 1, t;
      if ((r = t.divToInt(i)).isZero()) o = n ? 3 : 2;
      else {
        if ((t = t.minus(r.times(i))).lte(a)) return o = F(r) ? n ? 2 : 3 : n ? 4 : 1, t;
        o = F(r) ? n ? 1 : 4 : n ? 3 : 2
      }
      return t.minus(i).abs()
    }

    function $(e, t, r, n) {
      var i, a, o, u, l, h, d, p, f, g = e.constructor,
        m = void 0 !== r;
      if (m ? (O(r, 1, 1e9), void 0 === n ? n = g.rounding : O(n, 0, 8)) : (r = g.precision, n = g.rounding), e.isFinite()) {
        for (m ? (i = 2, 16 == t ? r = 4 * r - 3 : 8 == t && (r = 3 * r - 2)) : i = t, (o = (d = P(e)).indexOf(".")) >= 0 && (d = d.replace(".", ""), (f = new g(1)).e = d.length - o, f.d = R(P(f), 10, i), f.e = f.d.length), a = l = (p = R(d, 10, i)).length; 0 == p[--l];) p.pop();
        if (p[0]) {
          if (o < 0 ? a-- : ((e = new g(e)).d = p, e.e = a, p = (e = I(e, f, r, n, 0, i)).d, a = e.e, h = s), o = p[r], u = i / 2, h = h || void 0 !== p[r + 1], h = n < 4 ? (void 0 !== o || h) && (0 === n || n === (e.s < 0 ? 3 : 2)) : o > u || o === u && (4 === n || h || 6 === n && 1 & p[r - 1] || n === (e.s < 0 ? 8 : 7)), p.length = r, h)
            for (; ++p[--r] > i - 1;) p[r] = 0, r || (++a, p.unshift(1));
          for (l = p.length; !p[l - 1]; --l);
          for (o = 0, d = ""; o < l; o++) d += c.charAt(p[o]);
          if (m) {
            if (l > 1)
              if (16 == t || 8 == t) {
                for (o = 16 == t ? 4 : 3, --l; l % o; l++) d += "0";
                for (l = (p = R(d, i, t)).length; !p[l - 1]; --l);
                for (o = 1, d = "1."; o < l; o++) d += c.charAt(p[o])
              } else d = d.charAt(0) + "." + d.slice(1);
            d = d + (a < 0 ? "p" : "p+") + a
          } else if (a < 0) {
            for (; ++a;) d = "0" + d;
            d = "0." + d
          } else if (++a > l)
            for (a -= l; a--;) d += "0";
          else a < l && (d = d.slice(0, a) + "." + d.slice(a))
        } else d = m ? "0p+0" : "0";
        d = (16 == t ? "0x" : 2 == t ? "0b" : 8 == t ? "0o" : "") + d
      } else d = V(e);
      return e.s < 0 ? "-" + d : d
    }

    function Y(e, t) {
      if (e.length > t) return e.length = t, !0
    }

    function J(e) {
      return new this(e).abs()
    }

    function W(e) {
      return new this(e).acos()
    }

    function K(e) {
      return new this(e).acosh()
    }

    function Z(e, t) {
      return new this(e).plus(t)
    }

    function ee(e) {
      return new this(e).asin()
    }

    function te(e) {
      return new this(e).asinh()
    }

    function re(e) {
      return new this(e).atan()
    }

    function ne(e) {
      return new this(e).atanh()
    }

    function ie(e, t) {
      e = new this(e), t = new this(t);
      var r, n = this.precision,
        i = this.rounding,
        a = n + 4;
      return e.s && t.s ? e.d || t.d ? !t.d || e.isZero() ? (r = t.s < 0 ? j(this, n, i) : new this(0)).s = e.s : !e.d || t.isZero() ? (r = j(this, a, 1).times(.5)).s = e.s : t.s < 0 ? (this.precision = a, this.rounding = 1, r = this.atan(I(e, t, a, 1)), t = j(this, a, 1), this.precision = n, this.rounding = i, r = e.s < 0 ? r.minus(t) : r.plus(t)) : r = this.atan(I(e, t, a, 1)) : (r = j(this, a, 1).times(t.s > 0 ? .25 : .75)).s = e.s : r = new this(NaN), r
    }

    function ae(e) {
      return new this(e).cbrt()
    }

    function se(e) {
      return N(e = new this(e), e.e + 1, 2)
    }

    function oe(e) {
      if (!e || "object" != typeof e) throw Error("[DecimalError] Object expected");
      var t, r, n, i = !0 === e.defaults,
        a = ["precision", 1, 1e9, "rounding", 0, 8, "toExpNeg", -u, 0, "toExpPos", 0, u, "maxE", 0, u, "minE", -u, 0, "modulo", 0, 9];
      for (t = 0; t < a.length; t += 3)
        if (r = a[t], i && (this[r] = d[r]), void 0 !== (n = e[r])) {
          if (!(g(n) === n && n >= a[t + 1] && n <= a[t + 2])) throw Error(f + r + ": " + n);
          this[r] = n
        } if (r = "crypto", i && (this[r] = d[r]), void 0 !== (n = e[r])) {
        if (!0 !== n && !1 !== n && 0 !== n && 1 !== n) throw Error(f + r + ": " + n);
        if (n) {
          if ("undefined" == typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes) throw Error("[DecimalError] crypto unavailable");
          this[r] = !0
        } else this[r] = !1
      }
      return this
    }

    function ue(e) {
      return new this(e).cos()
    }

    function ce(e) {
      return new this(e).cosh()
    }

    function le(e, t) {
      return new this(e).div(t)
    }

    function he(e) {
      return new this(e).exp()
    }

    function de(e) {
      return N(e = new this(e), e.e + 1, 3)
    }

    function pe() {
      var e, t, r = new this(0);
      for (p = !1, e = 0; e < arguments.length;)
        if ((t = new this(arguments[e++])).d) r.d && (r = r.plus(t.times(t)));
        else {
          if (t.s) return p = !0, new this(1 / 0);
          r = t
        } return p = !0, r.sqrt()
    }

    function fe(e) {
      return e instanceof a || e && "[object Decimal]" === e.name || !1
    }

    function ge(e) {
      return new this(e).ln()
    }

    function me(e, t) {
      return new this(e).log(t)
    }

    function ye(e) {
      return new this(e).log(2)
    }

    function be(e) {
      return new this(e).log(10)
    }

    function _e() {
      return B(this, arguments, "lt")
    }

    function ve() {
      return B(this, arguments, "gt")
    }

    function we(e, t) {
      return new this(e).mod(t)
    }

    function Se(e, t) {
      return new this(e).mul(t)
    }

    function Te(e, t) {
      return new this(e).pow(t)
    }

    function Ee(e) {
      var t, r, n, i, a = 0,
        s = new this(1),
        o = [];
      if (void 0 === e ? e = this.precision : O(e, 1, 1e9), n = Math.ceil(e / 7), this.crypto)
        if (crypto.getRandomValues)
          for (t = crypto.getRandomValues(new Uint32Array(n)); a < n;)(i = t[a]) >= 429e7 ? t[a] = crypto.getRandomValues(new Uint32Array(1))[0] : o[a++] = i % 1e7;
        else {
          if (!crypto.randomBytes) throw Error("[DecimalError] crypto unavailable");
          for (t = crypto.randomBytes(n *= 4); a < n;)(i = t[a] + (t[a + 1] << 8) + (t[a + 2] << 16) + ((127 & t[a + 3]) << 24)) >= 214e7 ? crypto.randomBytes(4).copy(t, a) : (o.push(i % 1e7), a += 4);
          a = n / 4
        }
      else
        for (; a < n;) o[a++] = 1e7 * Math.random() | 0;
      for (e %= 7, (n = o[--a]) && e && (i = m(10, 7 - e), o[a] = (n / i | 0) * i); 0 === o[a]; a--) o.pop();
      if (a < 0) r = 0, o = [0];
      else {
        for (r = -1; 0 === o[0]; r -= 7) o.shift();
        for (n = 1, i = o[0]; i >= 10; i /= 10) n++;
        n < 7 && (r -= 7 - n)
      }
      return s.e = r, s.d = o, s
    }

    function xe(e) {
      return N(e = new this(e), e.e + 1, this.rounding)
    }

    function Oe(e) {
      return (e = new this(e)).d ? e.d[0] ? e.s : 0 * e.s : e.s || NaN
    }

    function Ae(e) {
      return new this(e).sin()
    }

    function Re(e) {
      return new this(e).sinh()
    }

    function Ie(e) {
      return new this(e).sqrt()
    }

    function Ne(e, t) {
      return new this(e).sub(t)
    }

    function Pe(e) {
      return new this(e).tan()
    }

    function Ce(e) {
      return new this(e).tanh()
    }

    function De(e) {
      return N(e = new this(e), e.e + 1, 1)
    }(a = function e(t) {
      var r, n, i;

      function a(e) {
        var t, r, n, i = this;
        if (!(i instanceof a)) return new a(e);
        if (i.constructor = a, e instanceof a) return i.s = e.s, void(p ? !e.d || e.e > a.maxE ? (i.e = NaN, i.d = null) : e.e < a.minE ? (i.e = 0, i.d = [0]) : (i.e = e.e, i.d = e.d.slice()) : (i.e = e.e, i.d = e.d ? e.d.slice() : e.d));
        if ("number" === (n = typeof e)) {
          if (0 === e) return i.s = 1 / e < 0 ? -1 : 1, i.e = 0, void(i.d = [0]);
          if (e < 0 ? (e = -e, i.s = -1) : i.s = 1, e === ~~e && e < 1e7) {
            for (t = 0, r = e; r >= 10; r /= 10) t++;
            return void(p ? t > a.maxE ? (i.e = NaN, i.d = null) : t < a.minE ? (i.e = 0, i.d = [0]) : (i.e = t, i.d = [e]) : (i.e = t, i.d = [e]))
          }
          return 0 * e != 0 ? (e || (i.s = NaN), i.e = NaN, void(i.d = null)) : H(i, e.toString())
        }
        if ("string" !== n) throw Error(f + e);
        return 45 === (r = e.charCodeAt(0)) ? (e = e.slice(1), i.s = -1) : (43 === r && (e = e.slice(1)), i.s = 1), v.test(e) ? H(i, e) : G(i, e)
      }
      if (a.prototype = E, a.ROUND_UP = 0, a.ROUND_DOWN = 1, a.ROUND_CEIL = 2, a.ROUND_FLOOR = 3, a.ROUND_HALF_UP = 4, a.ROUND_HALF_DOWN = 5, a.ROUND_HALF_EVEN = 6, a.ROUND_HALF_CEIL = 7, a.ROUND_HALF_FLOOR = 8, a.EUCLID = 9, a.config = a.set = oe, a.clone = e, a.isDecimal = fe, a.abs = J, a.acos = W, a.acosh = K, a.add = Z, a.asin = ee, a.asinh = te, a.atan = re, a.atanh = ne, a.atan2 = ie, a.cbrt = ae, a.ceil = se, a.cos = ue, a.cosh = ce, a.div = le, a.exp = he, a.floor = de, a.hypot = pe, a.ln = ge, a.log = me, a.log10 = be, a.log2 = ye, a.max = _e, a.min = ve, a.mod = we, a.mul = Se, a.pow = Te, a.random = Ee, a.round = xe, a.sign = Oe, a.sin = Ae, a.sinh = Re, a.sqrt = Ie, a.sub = Ne, a.tan = Pe, a.tanh = Ce, a.trunc = De, void 0 === t && (t = {}), t && !0 !== t.defaults)
        for (i = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], r = 0; r < i.length;) t.hasOwnProperty(n = i[r++]) || (t[n] = this[n]);
      return a.config(t), a
    }(d)).default = a.Decimal = a, l = new a(l), h = new a(h), void 0 === (n = function() {
      return a
    }.call(t, r, t, e)) || (e.exports = n)
  }()
}, function(e, t, r) {
  "use strict";

  function n(e) {
    return "*" === e
  }

  function i(e, t) {
    return new RegExp(`/${e}/`, "i").test(`/${t}/`)
  }
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.formatDayTimeDuration = t.langMatches = t.replace = t.matches = void 0, t.matches = function(e, t, r) {
    return new RegExp(t, r).test(e)
  }, t.replace = function(e, t, r, n) {
    let i = new RegExp(t, n);
    if (!i.global) {
      i = new RegExp(t, (n || "") + "g")
    }
    return e.replace(i, r)
  }, t.langMatches = function(e, t) {
    const r = e.split("-"),
      a = t.split("-");
    if (!i(a[0], r[0]) && !n(r[0])) return !1;
    let s = 1,
      o = 1;
    for (; o < a.length;)
      if (n(a[o])) o++;
      else {
        if (s === r.length) return !1;
        if (i(a[o], r[s])) s++, o++;
        else {
          if (1 === r[s].length) return !1;
          s++
        }
      } return !0
  }, t.formatDayTimeDuration = function(e) {
    if (e) {
      if ("Z" === e[0]) return "PT0S"; {
        const [t, r, n, i, a, s] = e, o = "0" !== r ? r : "", u = o || "0" !== n ? n : "", c = "0" !== a ? a : "", l = c || "0" !== s ? s : "";
        return `${"-"===t?"-":""}PT${`${o+u?o+u+"H":""}${c+l?c+l+"M":""}`}`
      }
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.specialDefinitions = void 0;
  const n = r(23),
    i = r(13),
    a = r(188),
    s = r(40),
    o = r(14),
    u = r(20),
    c = r(66),
    l = r(89);

  function h({
               args: e,
               mapping: t
             }) {
    const r = e[0];
    if (r.expressionType !== s.ExpressionType.Variable) throw new u.InvalidArgumentTypes(e, o.SpecialOperator.BOUND);
    const n = t.has(r.name) && !!t.get(r.name);
    return c.bool(n)
  }

  function d(e) {
    return e.length > 0 && e.every(t => t.language === e[0].language)
  }
  const p = {
    arity: 1,
    applyAsync: async ({
                         args: e,
                         evaluate: t,
                         mapping: r,
                         context: n
                       }) => f(await t(e[0], r), n.baseIRI, e),
    applySync: ({
                  args: e,
                  evaluate: t,
                  mapping: r,
                  context: n
                }) => f(t(e[0], r), n.baseIRI, e)
  };

  function f(e, t, r) {
    const n = "namedNode" !== e.termType ? c.typeCheckLit(e, ["string"], r, o.SpecialOperator.IRI) : e,
      a = i.resolve(n.str(), t || "");
    return new s.NamedNode(a)
  }

  function g(e) {
    return new s.BlankNode(e || a.v4())
  }
  const m = {
    bound: {
      arity: 1,
      applyAsync: async ({
                           args: e,
                           mapping: t
                         }) => h({
        args: e,
        mapping: t
      }),
      applySync: ({
                    args: e,
                    mapping: t
                  }) => h({
        args: e,
        mapping: t
      })
    },
    if: {
      arity: 3,
      async applyAsync({
                         args: e,
                         mapping: t,
                         evaluate: r
                       }) {
        const n = await r(e[0], t);
        return r(n.coerceEBV() ? e[1] : e[2], t)
      },
      applySync({
                  args: e,
                  mapping: t,
                  evaluate: r
                }) {
        const n = r(e[0], t);
        return r(n.coerceEBV() ? e[1] : e[2], t)
      }
    },
    coalesce: {
      arity: 1 / 0,
      async applyAsync({
                         args: e,
                         mapping: t,
                         evaluate: r
                       }) {
        const n = [];
        for (const i of e) try {
          return await r(i, t)
        } catch (e) {
          n.push(e)
        }
        throw new u.CoalesceError(n)
      },
      applySync({
                  args: e,
                  mapping: t,
                  evaluate: r
                }) {
        const n = [];
        for (const i of e) try {
          return r(i, t)
        } catch (e) {
          n.push(e)
        }
        throw new u.CoalesceError(n)
      }
    },
    "&&": {
      arity: 2,
      async applyAsync({
                         args: e,
                         mapping: t,
                         evaluate: r
                       }) {
        const [n, i] = e;
        try {
          const e = await r(n, t);
          if (!e.coerceEBV()) return c.bool(!1);
          const a = (await r(i, t)).coerceEBV();
          return c.bool(a)
        } catch (e) {
          if ((await r(i, t)).coerceEBV()) throw e;
          return c.bool(!1)
        }
      },
      applySync({
                  args: e,
                  mapping: t,
                  evaluate: r
                }) {
        const [n, i] = e;
        try {
          const e = r(n, t);
          if (!e.coerceEBV()) return c.bool(!1);
          const a = r(i, t).coerceEBV();
          return c.bool(a)
        } catch (e) {
          if (r(i, t).coerceEBV()) throw e;
          return c.bool(!1)
        }
      }
    },
    "||": {
      arity: 2,
      async applyAsync({
                         args: e,
                         mapping: t,
                         evaluate: r
                       }) {
        const [n, i] = e;
        try {
          const e = await r(n, t);
          if (e.coerceEBV()) return c.bool(!0);
          const a = (await r(i, t)).coerceEBV();
          return c.bool(a)
        } catch (e) {
          if (!(await r(i, t)).coerceEBV()) throw e;
          return c.bool(!0)
        }
      },
      applySync({
                  args: e,
                  mapping: t,
                  evaluate: r
                }) {
        const [n, i] = e;
        try {
          const e = r(n, t);
          if (e.coerceEBV()) return c.bool(!0);
          const a = r(i, t).coerceEBV();
          return c.bool(a)
        } catch (e) {
          if (!r(i, t).coerceEBV()) throw e;
          return c.bool(!0)
        }
      }
    },
    sameterm: {
      arity: 2,
      async applyAsync({
                         args: e,
                         mapping: t,
                         evaluate: r
                       }) {
        const [n, i] = e.map(e => r(e, t)), a = await n, s = await i;
        return c.bool(a.toRDF().equals(s.toRDF()))
      },
      applySync({
                  args: e,
                  mapping: t,
                  evaluate: r
                }) {
        const [n, i] = e.map(e => r(e, t));
        return c.bool(n.toRDF().equals(i.toRDF()))
      }
    },
    in: {
      arity: 1 / 0,
      checkArity: e => e.length >= 1,
      async applyAsync({
                         args: e,
                         mapping: t,
                         evaluate: r,
                         context: n
                       }) {
        const [i, ...a] = e;
        return async function e(t, {
          args: r,
          mapping: n,
          evaluate: i,
          context: a
        }, s) {
          if (0 === r.length) {
            return s.every(e => !e) ? c.bool(!1) : Promise.reject(new u.InError(s))
          }
          try {
            const u = await i(r.shift(), n);
            return !0 === l.regularFunctions.get(o.RegularOperator.EQUAL).apply([t, u]).typedValue ? c.bool(!0) : e(t, {
              args: r,
              mapping: n,
              evaluate: i,
              context: a
            }, [...s, !1])
          } catch (o) {
            return e(t, {
              args: r,
              mapping: n,
              evaluate: i,
              context: a
            }, [...s, o])
          }
        }(await r(i, t), {
          args: a,
          mapping: t,
          evaluate: r,
          context: n
        }, [])
      },
      applySync({
                  args: e,
                  mapping: t,
                  evaluate: r,
                  context: n
                }) {
        const [i, ...a] = e;
        return function e(t, {
          args: r,
          mapping: n,
          evaluate: i,
          context: a
        }, s) {
          if (0 === r.length) {
            if (!s.every(e => !e)) throw new u.InError(s);
            c.bool(!1)
          }
          try {
            const u = i(r.shift(), n);
            return !0 === l.regularFunctions.get(o.RegularOperator.EQUAL).apply([t, u]).typedValue ? c.bool(!0) : e(t, {
              args: r,
              mapping: n,
              evaluate: i,
              context: a
            }, [...s, !1])
          } catch (o) {
            return e(t, {
              args: r,
              mapping: n,
              evaluate: i,
              context: a
            }, [...s, o])
          }
        }(r(i, t), {
          args: a,
          mapping: t,
          evaluate: r,
          context: n
        }, [])
      }
    },
    notin: {
      arity: 1 / 0,
      checkArity: e => e.length >= 1,
      async applyAsync(e) {
        const t = l.specialFunctions.get(o.SpecialOperator.IN),
          r = await t.applyAsync(e);
        return c.bool(!r.typedValue)
      },
      applySync(e) {
        const t = l.specialFunctions.get(o.SpecialOperator.IN).applySync(e);
        return c.bool(!t.typedValue)
      }
    },
    concat: {
      arity: 1 / 0,
      async applyAsync({
                         args: e,
                         evaluate: t,
                         mapping: r
                       }) {
        const n = e.map(async e => t(e, r)).map(async t => c.typeCheckLit(await t, ["string", "langString"], e, o.SpecialOperator.CONCAT)),
          i = await Promise.all(n),
          a = i.map(e => e.typedValue).join(""),
          s = d(i) ? i[0].language : void 0;
        return s ? c.langString(a, s) : c.string(a)
      },
      applySync({
                  args: e,
                  evaluate: t,
                  mapping: r
                }) {
        const n = e.map(e => t(e, r)).map(t => c.typeCheckLit(t, ["string", "langString"], e, o.SpecialOperator.CONCAT)),
          i = n.map(e => e.typedValue).join(""),
          a = d(n) ? n[0].language : void 0;
        return a ? c.langString(i, a) : c.string(i)
      }
    },
    now: {
      arity: 0,
      applyAsync: async ({
                           context: e
                         }) => new s.DateTimeLiteral(e.now, e.now.toISOString()),
      applySync: ({
                    context: e
                  }) => new s.DateTimeLiteral(e.now, e.now.toISOString())
    },
    iri: p,
    uri: p,
    BNODE: {
      arity: 1 / 0,
      checkArity: e => 0 === e.length || 1 === e.length,
      async applyAsync({
                         args: e,
                         evaluate: t,
                         mapping: r,
                         context: n
                       }) {
        const i = 1 === e.length ? await t(e[0], r) : void 0,
          a = i ? c.typeCheckLit(i, ["string"], e, o.SpecialOperator.BNODE).str() : void 0;
        if (n.bnode) {
          const e = await n.bnode(a);
          return new s.BlankNode(e.value)
        }
        return g(a)
      },
      applySync({
                  args: e,
                  evaluate: t,
                  mapping: r,
                  context: n
                }) {
        const i = 1 === e.length ? t(e[0], r) : void 0,
          a = i ? c.typeCheckLit(i, ["string"], e, o.SpecialOperator.BNODE).str() : void 0;
        if (n.bnode) {
          const e = n.bnode(a);
          return new s.BlankNode(e.value)
        }
        return g(a)
      }
    }
  };
  t.specialDefinitions = n.Map(m)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.aggregators = t.AggregateEvaluator = void 0;
  const n = r(5),
    i = r(40),
    a = r(14),
    s = r(20),
    o = r(89),
    u = r(66),
    c = r(65),
    l = r(14),
    h = r(186),
    d = r(39),
    p = new n.DataFactory;
  t.AggregateEvaluator = class {
    constructor(e, r, n) {
      this.throwError = !1, this.expression = e, this.evaluator = new h.SyncEvaluator(e.expression, r), this.aggregator = new t.aggregators[e.aggregator](e), this.throwError = n
    }
    static emptyValue(e, r = !1) {
      const n = t.aggregators[e.aggregator].emptyValue();
      if (void 0 === n && r) throw new s.EmptyAggregateError;
      return n
    }
    put(e) {
      this.init(e), this.state && (this.put = this.__put, this.result = this.__result)
    }
    result() {
      return this.aggregator.constructor.emptyValue()
    }
    __put(e) {
      try {
        const t = this.evaluator.evaluate(e);
        this.state = this.aggregator.put(this.state, t)
      } catch (e) {
        this.safeThrow(e)
      }
    }
    __result() {
      return this.aggregator.result(this.state)
    }
    init(e) {
      try {
        const t = this.evaluator.evaluate(e);
        this.state = this.aggregator.init(t)
      } catch (e) {
        this.safeThrow(e)
      }
    }
    safeThrow(e) {
      if (this.throwError) throw e;
      this.put = () => {}, this.result = () => {}
    }
  };
  class f {
    constructor(e) {
      this.distinct = e.distinct, this.separator = e.separator || " "
    }
    static emptyValue() {}
  }

  function g(e) {
    if ("Literal" !== e.termType) throw new Error("Term with value " + e.value + " has type " + e.termType + " and is not a numeric literal");
    if (!a.NumericTypeURLs.contains(e.datatype.value)) throw new Error("Term datatype " + e.datatype.value + " with value " + e.value + " has type " + e.termType + " and is not a numeric literal");
    return {
      type: e.datatype.value,
      value: c.parseXSDFloat(e.value)
    }
  }

  function m(e, t) {
    if ("Literal" !== t.termType) throw new Error("Term with value " + t.value + " has type " + t.termType + " and is not a literal");
    const r = d.transformLiteral(t);
    return {
      type: r.typeURL.value,
      value: r.typedValue
    }
  }
  t.aggregators = {
    count: class extends f {
      static emptyValue() {
        return u.number(0, l.TypeURL.XSD_INTEGER).toRDF()
      }
      init(e) {
        return 1
      }
      put(e, t) {
        return e + 1
      }
      result(e) {
        return u.number(e, l.TypeURL.XSD_INTEGER).toRDF()
      }
    },
    sum: class extends f {
      constructor() {
        super(...arguments), this.summer = o.regularFunctions.get(a.RegularOperator.ADDITION)
      }
      static emptyValue() {
        return u.number(0, l.TypeURL.XSD_INTEGER).toRDF()
      }
      init(e) {
        const {
          value: t,
          type: r
        } = g(e);
        return new i.NumericLiteral(t, p.namedNode(r))
      }
      put(e, t) {
        const {
          value: r,
          type: n
        } = g(t), a = new i.NumericLiteral(r, p.namedNode(n));
        return this.summer.apply([e, a])
      }
      result(e) {
        return e.toRDF()
      }
    },
    min: class extends f {
      init(e) {
        const {
          value: t
        } = m(null, e);
        if ("Literal" === e.termType) return {
          extremeValue: t,
          term: e
        }
      }
      put(e, t) {
        const r = m(e.term, t);
        return r.value < e.extremeValue && "Literal" === t.termType ? {
          extremeValue: r.value,
          term: t
        } : e
      }
      result(e) {
        return e.term
      }
    },
    max: class extends f {
      init(e) {
        const {
          value: t
        } = m(null, e);
        if ("Literal" === e.termType) return {
          extremeValue: t,
          term: e
        }
      }
      put(e, t) {
        const r = m(e.term, t);
        return r.value > e.extremeValue && "Literal" === t.termType ? {
          extremeValue: r.value,
          term: t
        } : e
      }
      result(e) {
        return e.term
      }
    },
    avg: class extends f {
      constructor() {
        super(...arguments), this.summer = o.regularFunctions.get(a.RegularOperator.ADDITION), this.divider = o.regularFunctions.get(a.RegularOperator.DIVISION)
      }
      static emptyValue() {
        return u.number(0, l.TypeURL.XSD_INTEGER).toRDF()
      }
      init(e) {
        const {
          value: t,
          type: r
        } = g(e);
        return {
          sum: new i.NumericLiteral(t, p.namedNode(r)),
          count: 1
        }
      }
      put(e, t) {
        const {
          value: r,
          type: n
        } = g(t), a = new i.NumericLiteral(r, p.namedNode(n));
        return {
          sum: this.summer.apply([e.sum, a]),
          count: e.count + 1
        }
      }
      result(e) {
        const t = new i.NumericLiteral(e.count, p.namedNode(a.TypeURL.XSD_INTEGER));
        return this.divider.apply([e.sum, t]).toRDF()
      }
    },
    group_concat: class extends f {
      static emptyValue() {
        return u.string("").toRDF()
      }
      init(e) {
        return e.value
      }
      put(e, t) {
        return e + this.separator + t.value
      }
      result(e) {
        return u.string(e).toRDF()
      }
    },
    sample: class extends f {
      init(e) {
        return e
      }
      put(e, t) {
        return e
      }
      result(e) {
        return e
      }
    }
  }
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.order = t.orderTypes = void 0;
  const n = r(39);

  function i(e, t, r) {
    return e.typedValue === t.typedValue ? 0 : e.typedValue > t.typedValue === r ? 1 : -1
  }
  t.orderTypes = function(e, t, r) {
    if (e && "Literal" === e.termType && t && "Literal" === t.termType) {
      return i(n.transformLiteral(e), n.transformLiteral(t), r)
    }
    return 0
  }, t.order = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(542), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationReducedHash = void 0;
  const n = r(88),
    i = r(543);
  class a extends n.AbstractBindingsHash {
    constructor(e) {
      super(e, "reduced")
    }
    newHashFilter() {
      const e = new i({
        max: this.cacheSize
      });
      return t => {
        const r = n.AbstractFilterHash.hash(t);
        return !e.has(r) && e.set(r, !0)
      }
    }
  }
  t.ActorQueryOperationReducedHash = a
}, function(e, t, r) {
  "use strict";
  const n = r(544),
    i = Symbol("max"),
    a = Symbol("length"),
    s = Symbol("lengthCalculator"),
    o = Symbol("allowStale"),
    u = Symbol("maxAge"),
    c = Symbol("dispose"),
    l = Symbol("noDisposeOnSet"),
    h = Symbol("lruList"),
    d = Symbol("cache"),
    p = Symbol("updateAgeOnGet"),
    f = () => 1;
  const g = (e, t, r) => {
      const n = e[d].get(t);
      if (n) {
        const t = n.value;
        if (m(e, t)) {
          if (b(e, n), !e[o]) return
        } else r && (e[p] && (n.value.now = Date.now()), e[h].unshiftNode(n));
        return t.value
      }
    },
    m = (e, t) => {
      if (!t || !t.maxAge && !e[u]) return !1;
      const r = Date.now() - t.now;
      return t.maxAge ? r > t.maxAge : e[u] && r > e[u]
    },
    y = e => {
      if (e[a] > e[i])
        for (let t = e[h].tail; e[a] > e[i] && null !== t;) {
          const r = t.prev;
          b(e, t), t = r
        }
    },
    b = (e, t) => {
      if (t) {
        const r = t.value;
        e[c] && e[c](r.key, r.value), e[a] -= r.length, e[d].delete(r.key), e[h].removeNode(t)
      }
    };
  class _ {
    constructor(e, t, r, n, i) {
      this.key = e, this.value = t, this.length = r, this.now = n, this.maxAge = i || 0
    }
  }
  const v = (e, t, r, n) => {
    let i = r.value;
    m(e, i) && (b(e, r), e[o] || (i = void 0)), i && t.call(n, i.value, i.key, e)
  };
  e.exports = class {
    constructor(e) {
      if ("number" == typeof e && (e = {
        max: e
      }), e || (e = {}), e.max && ("number" != typeof e.max || e.max < 0)) throw new TypeError("max must be a non-negative number");
      this[i] = e.max || 1 / 0;
      const t = e.length || f;
      if (this[s] = "function" != typeof t ? f : t, this[o] = e.stale || !1, e.maxAge && "number" != typeof e.maxAge) throw new TypeError("maxAge must be a number");
      this[u] = e.maxAge || 0, this[c] = e.dispose, this[l] = e.noDisposeOnSet || !1, this[p] = e.updateAgeOnGet || !1, this.reset()
    }
    set max(e) {
      if ("number" != typeof e || e < 0) throw new TypeError("max must be a non-negative number");
      this[i] = e || 1 / 0, y(this)
    }
    get max() {
      return this[i]
    }
    set allowStale(e) {
      this[o] = !!e
    }
    get allowStale() {
      return this[o]
    }
    set maxAge(e) {
      if ("number" != typeof e) throw new TypeError("maxAge must be a non-negative number");
      this[u] = e, y(this)
    }
    get maxAge() {
      return this[u]
    }
    set lengthCalculator(e) {
      "function" != typeof e && (e = f), e !== this[s] && (this[s] = e, this[a] = 0, this[h].forEach(e => {
        e.length = this[s](e.value, e.key), this[a] += e.length
      })), y(this)
    }
    get lengthCalculator() {
      return this[s]
    }
    get length() {
      return this[a]
    }
    get itemCount() {
      return this[h].length
    }
    rforEach(e, t) {
      t = t || this;
      for (let r = this[h].tail; null !== r;) {
        const n = r.prev;
        v(this, e, r, t), r = n
      }
    }
    forEach(e, t) {
      t = t || this;
      for (let r = this[h].head; null !== r;) {
        const n = r.next;
        v(this, e, r, t), r = n
      }
    }
    keys() {
      return this[h].toArray().map(e => e.key)
    }
    values() {
      return this[h].toArray().map(e => e.value)
    }
    reset() {
      this[c] && this[h] && this[h].length && this[h].forEach(e => this[c](e.key, e.value)), this[d] = new Map, this[h] = new n, this[a] = 0
    }
    dump() {
      return this[h].map(e => !m(this, e) && {
        k: e.key,
        v: e.value,
        e: e.now + (e.maxAge || 0)
      }).toArray().filter(e => e)
    }
    dumpLru() {
      return this[h]
    }
    set(e, t, r) {
      if ((r = r || this[u]) && "number" != typeof r) throw new TypeError("maxAge must be a number");
      const n = r ? Date.now() : 0,
        o = this[s](t, e);
      if (this[d].has(e)) {
        if (o > this[i]) return b(this, this[d].get(e)), !1;
        const s = this[d].get(e).value;
        return this[c] && (this[l] || this[c](e, s.value)), s.now = n, s.maxAge = r, s.value = t, this[a] += o - s.length, s.length = o, this.get(e), y(this), !0
      }
      const p = new _(e, t, o, n, r);
      return p.length > this[i] ? (this[c] && this[c](e, t), !1) : (this[a] += p.length, this[h].unshift(p), this[d].set(e, this[h].head), y(this), !0)
    }
    has(e) {
      if (!this[d].has(e)) return !1;
      const t = this[d].get(e).value;
      return !m(this, t)
    }
    get(e) {
      return g(this, e, !0)
    }
    peek(e) {
      return g(this, e, !1)
    }
    pop() {
      const e = this[h].tail;
      return e ? (b(this, e), e.value) : null
    }
    del(e) {
      b(this, this[d].get(e))
    }
    load(e) {
      this.reset();
      const t = Date.now();
      for (let r = e.length - 1; r >= 0; r--) {
        const n = e[r],
          i = n.e || 0;
        if (0 === i) this.set(n.k, n.v);
        else {
          const e = i - t;
          e > 0 && this.set(n.k, n.v, e)
        }
      }
    }
    prune() {
      this[d].forEach((e, t) => g(this, t, !1))
    }
  }
}, function(e, t, r) {
  "use strict";

  function n(e) {
    var t = this;
    if (t instanceof n || (t = new n), t.tail = null, t.head = null, t.length = 0, e && "function" == typeof e.forEach) e.forEach((function(e) {
      t.push(e)
    }));
    else if (arguments.length > 0)
      for (var r = 0, i = arguments.length; r < i; r++) t.push(arguments[r]);
    return t
  }

  function i(e, t, r) {
    var n = t === e.head ? new o(r, null, t, e) : new o(r, t, t.next, e);
    return null === n.next && (e.tail = n), null === n.prev && (e.head = n), e.length++, n
  }

  function a(e, t) {
    e.tail = new o(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++
  }

  function s(e, t) {
    e.head = new o(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++
  }

  function o(e, t, r, n) {
    if (!(this instanceof o)) return new o(e, t, r, n);
    this.list = n, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, r ? (r.prev = this, this.next = r) : this.next = null
  }
  e.exports = n, n.Node = o, n.create = n, n.prototype.removeNode = function(e) {
    if (e.list !== this) throw new Error("removing node which does not belong to this list");
    var t = e.next,
      r = e.prev;
    return t && (t.prev = r), r && (r.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = r), e.list.length--, e.next = null, e.prev = null, e.list = null, t
  }, n.prototype.unshiftNode = function(e) {
    if (e !== this.head) {
      e.list && e.list.removeNode(e);
      var t = this.head;
      e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++
    }
  }, n.prototype.pushNode = function(e) {
    if (e !== this.tail) {
      e.list && e.list.removeNode(e);
      var t = this.tail;
      e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++
    }
  }, n.prototype.push = function() {
    for (var e = 0, t = arguments.length; e < t; e++) a(this, arguments[e]);
    return this.length
  }, n.prototype.unshift = function() {
    for (var e = 0, t = arguments.length; e < t; e++) s(this, arguments[e]);
    return this.length
  }, n.prototype.pop = function() {
    if (this.tail) {
      var e = this.tail.value;
      return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e
    }
  }, n.prototype.shift = function() {
    if (this.head) {
      var e = this.head.value;
      return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e
    }
  }, n.prototype.forEach = function(e, t) {
    t = t || this;
    for (var r = this.head, n = 0; null !== r; n++) e.call(t, r.value, n, this), r = r.next
  }, n.prototype.forEachReverse = function(e, t) {
    t = t || this;
    for (var r = this.tail, n = this.length - 1; null !== r; n--) e.call(t, r.value, n, this), r = r.prev
  }, n.prototype.get = function(e) {
    for (var t = 0, r = this.head; null !== r && t < e; t++) r = r.next;
    if (t === e && null !== r) return r.value
  }, n.prototype.getReverse = function(e) {
    for (var t = 0, r = this.tail; null !== r && t < e; t++) r = r.prev;
    if (t === e && null !== r) return r.value
  }, n.prototype.map = function(e, t) {
    t = t || this;
    for (var r = new n, i = this.head; null !== i;) r.push(e.call(t, i.value, this)), i = i.next;
    return r
  }, n.prototype.mapReverse = function(e, t) {
    t = t || this;
    for (var r = new n, i = this.tail; null !== i;) r.push(e.call(t, i.value, this)), i = i.prev;
    return r
  }, n.prototype.reduce = function(e, t) {
    var r, n = this.head;
    if (arguments.length > 1) r = t;
    else {
      if (!this.head) throw new TypeError("Reduce of empty list with no initial value");
      n = this.head.next, r = this.head.value
    }
    for (var i = 0; null !== n; i++) r = e(r, n.value, i), n = n.next;
    return r
  }, n.prototype.reduceReverse = function(e, t) {
    var r, n = this.tail;
    if (arguments.length > 1) r = t;
    else {
      if (!this.tail) throw new TypeError("Reduce of empty list with no initial value");
      n = this.tail.prev, r = this.tail.value
    }
    for (var i = this.length - 1; null !== n; i--) r = e(r, n.value, i), n = n.prev;
    return r
  }, n.prototype.toArray = function() {
    for (var e = new Array(this.length), t = 0, r = this.head; null !== r; t++) e[t] = r.value, r = r.next;
    return e
  }, n.prototype.toArrayReverse = function() {
    for (var e = new Array(this.length), t = 0, r = this.tail; null !== r; t++) e[t] = r.value, r = r.prev;
    return e
  }, n.prototype.slice = function(e, t) {
    (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);
    var r = new n;
    if (t < e || t < 0) return r;
    e < 0 && (e = 0), t > this.length && (t = this.length);
    for (var i = 0, a = this.head; null !== a && i < e; i++) a = a.next;
    for (; null !== a && i < t; i++, a = a.next) r.push(a.value);
    return r
  }, n.prototype.sliceReverse = function(e, t) {
    (t = t || this.length) < 0 && (t += this.length), (e = e || 0) < 0 && (e += this.length);
    var r = new n;
    if (t < e || t < 0) return r;
    e < 0 && (e = 0), t > this.length && (t = this.length);
    for (var i = this.length, a = this.tail; null !== a && i > t; i--) a = a.prev;
    for (; null !== a && i > e; i--, a = a.prev) r.push(a.value);
    return r
  }, n.prototype.splice = function(e, t, ...r) {
    e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
    for (var n = 0, a = this.head; null !== a && n < e; n++) a = a.next;
    var s = [];
    for (n = 0; a && n < t; n++) s.push(a.value), a = this.removeNode(a);
    null === a && (a = this.tail), a !== this.head && a !== this.tail && (a = a.prev);
    for (n = 0; n < r.length; n++) a = i(this, a, r[n]);
    return s
  }, n.prototype.reverse = function() {
    for (var e = this.head, t = this.tail, r = e; null !== r; r = r.prev) {
      var n = r.prev;
      r.prev = r.next, r.next = n
    }
    return this.head = t, this.tail = e, this
  };
  try {
    r(545)(n)
  } catch (e) {}
}, function(e, t, r) {
  "use strict";
  e.exports = function(e) {
    e.prototype[Symbol.iterator] = function*() {
      for (let e = this.head; e; e = e.next) yield e.value
    }
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(547), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationFilterSparqlee = void 0;
  const n = r(1),
    i = r(51);
  class a extends n.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "filter")
    }
    async testOperation(e, t) {
      new i.AsyncEvaluator(e.expression, n.ActorQueryOperation.getExpressionContext(t, this.mediatorQueryOperation));
      return !0
    }
    async runOperation(e, t) {
      const r = await this.mediatorQueryOperation.mediate({
          operation: e.input,
          context: t
        }),
        a = n.ActorQueryOperation.getSafeBindings(r);
      n.ActorQueryOperation.validateQueryOutput(a, "bindings");
      const {
        variables: s,
        metadata: o
      } = a, u = n.ActorQueryOperation.getExpressionContext(t, this.mediatorQueryOperation), c = new i.AsyncEvaluator(e.expression, u), l = a.bindingsStream.transform({
        transform: async (e, t, r) => {
          try {
            await c.evaluateAsEBV(e) && r(e)
          } catch (e) {
            i.isExpressionError(e) || l.emit("error", e)
          }
          t()
        }
      });
      return {
        type: "bindings",
        bindingsStream: l,
        metadata: o,
        variables: s,
        canContainUndefs: a.canContainUndefs
      }
    }
  }
  t.ActorQueryOperationFilterSparqlee = a
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(549), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationFromQuad = void 0;
  const n = r(1),
    i = r(6);
  class a extends n.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "from")
    }
    static copyOperation(e, t) {
      const r = {};
      for (const n of Object.keys(e)) Array.isArray(e[n]) ? r[n] = "variables" === n ? e[n] : e[n].map(t) : a.ALGEBRA_TYPES.includes(e[n].type) ? r[n] = t(e[n]) : r[n] = e[n];
      return r
    }
    static applyOperationDefaultGraph(e, t) {
      if ("bgp" === e.type && e.patterns.length > 0 || "path" === e.type) {
        if ("bgp" === e.type) return a.joinOperations(e.patterns.map(e => {
          if ("DefaultGraph" !== e.graph.termType) return a.FACTORY.createBgp([e]);
          const r = t.map(t => a.FACTORY.createBgp([a.FACTORY.createPattern(e.subject, e.predicate, e.object, t)]));
          return a.unionOperations(r)
        }));
        if ("DefaultGraph" !== e.graph.termType) return e;
        const r = t.map(t => a.FACTORY.createPath(e.subject, e.predicate, e.object, t));
        return a.joinOperations(r)
      }
      return a.copyOperation(e, e => this.applyOperationDefaultGraph(e, t))
    }
    static applyOperationNamedGraph(e, t, r) {
      if ("bgp" === e.type && e.patterns.length > 0 || "path" === e.type) {
        let n;
        if (n = "bgp" === e.type ? e.patterns[0].graph : e.graph, "DefaultGraph" === n.termType) return {
          type: "bgp",
          patterns: []
        };
        if ("Variable" === n.termType) {
          if (1 === t.length) {
            const r = t[0],
              i = {};
            i["?" + n.value] = r;
            const s = a.FACTORY.createValues([n], [i]);
            let o;
            return o = "bgp" === e.type ? a.FACTORY.createBgp(e.patterns.map(e => a.FACTORY.createPattern(e.subject, e.predicate, e.object, r))) : a.FACTORY.createPath(e.subject, e.predicate, e.object, r), a.FACTORY.createJoin(s, o)
          }
          return a.unionOperations(t.map(t => a.applyOperationNamedGraph(e, [t], r)))
        }
        return t.concat(r).some(e => e.equals(n)) ? e : {
          type: "bgp",
          patterns: []
        }
      }
      return a.copyOperation(e, e => this.applyOperationNamedGraph(e, t, r))
    }
    static joinOperations(e) {
      if (1 === e.length) return e[0];
      if (2 === e.length) return a.FACTORY.createJoin(e[0], e[1]);
      if (e.length > 2) return a.FACTORY.createJoin(e.shift(), this.joinOperations(e));
      throw new Error("A join can only be applied on at least one operation")
    }
    static unionOperations(e) {
      if (1 === e.length) return e[0];
      if (2 === e.length) return a.FACTORY.createUnion(e[0], e[1]);
      if (e.length > 2) return a.FACTORY.createUnion(e.shift(), this.unionOperations(e));
      throw new Error("A union can only be applied on at least one operation")
    }
    static createOperation(e) {
      let t = e.input;
      return e.default.length > 0 && (t = a.applyOperationDefaultGraph(t, e.default)), e.named.length > 0 && (t = a.applyOperationNamedGraph(t, e.named, e.default)), t
    }
    async testOperation(e, t) {
      return !0
    }
    async runOperation(e, t) {
      const r = a.createOperation(e);
      return this.mediatorQueryOperation.mediate({
        operation: r,
        context: t
      })
    }
  }
  t.ActorQueryOperationFromQuad = a, a.FACTORY = new i.Factory, a.ALGEBRA_TYPES = Object.keys(i.Algebra.types).map(e => i.Algebra.types[e])
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(551), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationGroup = void 0;
  const n = r(1),
    i = r(3),
    a = r(4),
    s = r(51),
    o = r(552);
  class u extends n.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "group")
    }
    async testOperation(e, t) {
      for (const t of e.aggregates) {
        new s.SyncEvaluator(t.expression)
      }
      return !0
    }
    async runOperation(e, t) {
      const {
        input: r,
        aggregates: s
      } = e, u = await this.mediatorQueryOperation.mediate({
        operation: r,
        context: t
      }), c = n.ActorQueryOperation.getSafeBindings(u), l = e.variables.map(e => a.termToString(e)).concat(s.map(e => a.termToString(e.variable))), h = Object.assign({}, n.ActorQueryOperation.getExpressionContext(t));
      return new Promise((t, r) => {
        const n = new o.GroupsState(e, h);
        c.bindingsStream.on("end", () => {
          try {
            const e = new i.ArrayIterator(n.collectResults(), {
                autoStart: !1
              }),
              {
                metadata: r
              } = c;
            t({
              type: "bindings",
              bindingsStream: e,
              metadata: r,
              variables: l,
              canContainUndefs: c.canContainUndefs
            })
          } catch (e) {
            r(e)
          }
        }), c.bindingsStream.on("error", r), c.bindingsStream.on("data", e => {
          try {
            n.consumeBindings(e)
          } catch (e) {
            r(e)
          }
        })
      })
    }
  }
  t.ActorQueryOperationGroup = u
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.GroupsState = void 0;
  const n = r(88),
    i = r(1),
    a = r(4),
    s = r(51);
  t.GroupsState = class {
    constructor(e, t) {
      this.pattern = e, this.sparqleeConfig = t, this.groups = new Map, this.groupVariables = new Set(this.pattern.variables.map(e => a.termToString(e))), this.distinctHashes = e.aggregates.some(({
                                                                                                                                                                                                      distinct: e
                                                                                                                                                                                                    }) => e) ? new Map : null
    }
    consumeBindings(e) {
      const t = e.filter((e, t) => this.groupVariables.has(t)).toMap(),
        r = this.hashBindings(t);
      let n = this.groups.get(r);
      if (n)
        for (const t of this.pattern.aggregates) {
          if (t.distinct) {
            const t = this.hashBindings(e);
            if (this.distinctHashes.get(r).has(t)) continue;
            this.distinctHashes.get(r).add(t)
          }
          const i = a.termToString(t.variable);
          n.aggregators[i].put(e)
        } else {
        const i = {};
        for (const t of this.pattern.aggregates) {
          const r = a.termToString(t.variable);
          i[r] = new s.AggregateEvaluator(t, this.sparqleeConfig), i[r].put(e)
        }
        if (n = {
          aggregators: i,
          bindings: t
        }, this.groups.set(r, n), this.distinctHashes) {
          const t = this.hashBindings(e);
          this.distinctHashes.set(r, new Set([t]))
        }
      }
    }
    collectResults() {
      let e = [...this.groups].map(([e, t]) => {
        const {
          bindings: r,
          aggregators: n
        } = t, i = {};
        for (const e in n) {
          const t = n[e].result();
          void 0 !== t && (i[e] = t)
        }
        return r.merge(i)
      });
      if (0 === e.length && 0 === this.groupVariables.size) {
        const t = {};
        for (const e of this.pattern.aggregates) {
          const r = a.termToString(e.variable),
            n = s.AggregateEvaluator.emptyValue(e);
          void 0 !== n && (t[r] = n)
        }
        e = [i.Bindings(t)]
      }
      return e
    }
    hashBindings(e) {
      return n.AbstractFilterHash.hash(e)
    }
  }
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(554), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationJoin = void 0;
  const n = r(1);
  class i extends n.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "join")
    }
    async testOperation(e, t) {
      return !0
    }
    async runOperation(e, t) {
      const r = this.mediatorQueryOperation.mediate({
          operation: e.left,
          context: t
        }),
        i = this.mediatorQueryOperation.mediate({
          operation: e.right,
          context: t
        });
      return this.mediatorJoin.mediate({
        entries: [n.ActorQueryOperation.getSafeBindings(await r), n.ActorQueryOperation.getSafeBindings(await i)]
      })
    }
  }
  t.ActorQueryOperationJoin = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(556), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationLeftJoinLeftDeep = void 0;
  const n = r(1),
    i = r(55),
    a = r(3),
    s = r(6);
  class o extends n.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "leftjoin")
    }
    static createLeftDeepStream(e, t, r) {
      return new a.MultiTransformIterator(e, {
        multiTransform(e) {
          const i = t => t.merge(e);
          return new a.TransformIterator(async () => (await r(n.materializeOperation(t, e))).map(i), {
            maxBufferSize: 128
          })
        },
        optional: !0
      })
    }
    async testOperation(e, t) {
      return !0
    }
    async runOperation(e, t) {
      const r = n.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
          operation: e.left,
          context: t
        })),
        a = n.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
          operation: e.right,
          context: t
        }));
      a.bindingsStream.close();
      const s = e.expression ? o.FACTORY.createFilter(e.right, e.expression) : e.right;
      return {
        type: "bindings",
        bindingsStream: o.createLeftDeepStream(r.bindingsStream, s, async e => n.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
          operation: e,
          context: t
        })).bindingsStream),
        metadata: () => Promise.all([r, a].map(e => n.getMetadata(e))).then(e => e.reduce((e, t) => e * t.totalItems, 1)).catch(() => 1 / 0).then(e => ({
          totalItems: e
        })),
        variables: i.ActorRdfJoin.joinVariables({
          entries: [r, a]
        }),
        canContainUndefs: !0
      }
    }
  }
  t.ActorQueryOperationLeftJoinLeftDeep = o, o.FACTORY = new s.Factory
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(558), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationOrderBySparqlee = void 0;
  const n = r(1),
    i = r(6),
    a = r(51),
    s = r(559);
  class o extends n.ActorQueryOperationTypedMediated {
    constructor(e) {
      var t;
      super(e, "orderby"), this.window = null !== (t = e.window) && void 0 !== t ? t : 1 / 0
    }
    async testOperation(e, t) {
      for (let t of e.expressions) {
        t = this.extractSortExpression(t);
        new a.AsyncEvaluator(t)
      }
      return !0
    }
    async runOperation(e, t) {
      const r = await this.mediatorQueryOperation.mediate({
          operation: e.input,
          context: t
        }),
        i = n.ActorQueryOperation.getSafeBindings(r),
        o = {
          window: this.window
        },
        u = Object.assign({}, n.ActorQueryOperation.getExpressionContext(t));
      let {
        bindingsStream: c
      } = i;
      for (let t = e.expressions.length - 1; t >= 0; t--) {
        let r = e.expressions[t];
        const n = this.isAscending(r);
        r = this.extractSortExpression(r);
        const i = new a.AsyncEvaluator(r, u),
          l = async (e, t, r) => {
            try {
              r({
                bindings: e,
                result: await i.evaluate(e)
              })
            } catch (t) {
              a.isExpressionError(t) || c.emit("error", t), r({
                bindings: e,
                result: void 0
              })
            }
            t()
          }, h = c.transform({
            transform: l
          }), d = new s.SortIterator(h, (e, t) => a.orderTypes(e.result, t.result, n), o);
        c = d.map(({
                     bindings: e,
                     result: t
                   }) => e)
      }
      return {
        type: "bindings",
        bindingsStream: c,
        metadata: i.metadata,
        variables: i.variables,
        canContainUndefs: i.canContainUndefs
      }
    }
    extractSortExpression(e) {
      const {
        expressionType: t,
        operator: r
      } = e;
      return t !== i.Algebra.expressionTypes.OPERATOR ? e : "desc" === r ? e.args[0] : e
    }
    isAscending(e) {
      const {
        expressionType: t,
        operator: r
      } = e;
      return t !== i.Algebra.expressionTypes.OPERATOR || "desc" !== r
    }
  }
  t.ActorQueryOperationOrderBySparqlee = o
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.SortIterator = void 0;
  const n = r(3);
  class i extends n.TransformIterator {
    constructor(e, t, r) {
      super(e, r);
      const n = r && r.window;
      this.windowLength = Number.isFinite(n) && n > 0 ? n : 1 / 0, this.sort = t, this.sorted = []
    }
    _read(e, t) {
      let r, {
        length: n
      } = this.sorted;
      for (; n !== this.windowLength && (r = this.source.read(), null !== r);) {
        let e, t, i = 0,
          a = n - 1;
        for (; i <= a;) e = Math.trunc((i + a) / 2), t = this.sort(r, this.sorted[e]), t < 0 ? i = e + 1 : t > 0 ? a = e - 1 : (i = e, a = -1);
        this.sorted.splice(i, 0, r), n++
      }
      n === this.windowLength && this._push(this.sorted.pop()), t()
    }
    _flush(e) {
      let {
        length: t
      } = this.sorted;
      for (; t--;) this._push(this.sorted.pop());
      e()
    }
  }
  t.SortIterator = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(561), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationProject = void 0;
  const n = r(1),
    i = r(177),
    a = r(5),
    s = r(4),
    o = new a.DataFactory;
  class u extends n.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "project")
    }
    async testOperation(e, t) {
      return !0
    }
    async runOperation(e, t) {
      const r = n.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
          operation: e.input,
          context: t
        })),
        a = e.variables.map(e => s.termToString(e)),
        u = r.variables.filter(e => !a.includes(e)),
        c = a.filter(e => !r.variables.includes(e));
      if (c.length > 0) throw new Error(`Variables '${c}' are used in the projection result, but are not assigned.`);
      let l = 0 === u.length ? r.bindingsStream : r.bindingsStream.transform({
          map(e) {
            for (const t of u) e = e.delete(t);
            return e
          },
          autoStart: !1
        }),
        h = 0;
      return l = l.transform({
        map: e => (h++, e.map(e => e && "BlankNode" === e.termType ? e instanceof i.BlankNodeScoped ? new i.BlankNodeScoped(`${e.value}${h}`, e.skolemized) : o.blankNode(`${e.value}${h}`) : e)),
        autoStart: !1
      }), {
        type: "bindings",
        bindingsStream: l,
        metadata: r.metadata,
        variables: a,
        canContainUndefs: r.canContainUndefs
      }
    }
  }
  t.ActorQueryOperationProject = u
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(563), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationMinus = void 0;
  const n = r(1),
    i = r(3),
    a = r(564);
  class s extends n.ActorQueryOperationTypedMediated {
    constructor(e) {
      super(e, "minus")
    }
    async testOperation(e, t) {
      return !0
    }
    async runOperation(e, t) {
      const r = n.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
          operation: e.right,
          context: t
        })),
        s = n.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
          operation: e.left,
          context: t
        })),
        o = this.getCommonVariables(r.variables, s.variables);
      if (o.length > 0) {
        const e = new a.BindingsIndex(o),
          t = new i.TransformIterator(async () => (await new Promise(t => {
            r.bindingsStream.on("data", t => e.add(t)), r.bindingsStream.on("end", t)
          }), s.bindingsStream.filter(t => !e.contains(t))), {
            autoStart: !1
          }),
          n = r.canContainUndefs || s.canContainUndefs;
        return {
          type: "bindings",
          bindingsStream: t,
          variables: s.variables,
          metadata: s.metadata,
          canContainUndefs: n
        }
      }
      return s
    }
    getCommonVariables(e, t) {
      return Object.keys(e.filter(e => t.includes(e)).reduce((e, t) => (e[t] = !0, e), {}))
    }
  }
  t.ActorQueryOperationMinus = s
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.BindingsIndex = void 0;
  const n = r(4);
  class i {
    constructor(e) {
      this.data = {}, this.keys = e
    }
    static hashTerm(e) {
      return e && "Variable" !== e.termType ? n.termToString(e) : ""
    }
    add(e) {
      if (this.isBindingsValid(e)) {
        let t = this.data;
        for (const r of this.keys) {
          const n = i.hashTerm(e.get(r));
          let a = t[n];
          a || (a = t[n] = {}), t = a
        }
      }
    }
    contains(e) {
      return !!this.isBindingsValid(e) && this.containsRecursive(e, this.keys, [this.data])
    }
    isBindingsValid(e) {
      let t = !1;
      for (const r of this.keys)
        if (e.get(r)) {
          t = !0;
          break
        } return t
    }
    containsRecursive(e, t, r) {
      if (0 === t.length) return !0;
      let n;
      [n, ...t] = t;
      for (const a of r) {
        const r = i.hashTerm(e.get(n));
        if (r) {
          const n = [a[r], a[""]].filter(Boolean);
          if (0 === n.length) continue;
          if (this.containsRecursive(e, t, n)) return !0
        } else {
          let r = Object.keys(a).map(e => a[e]);
          if (0 === r.length && (r = [{}]), this.containsRecursive(e, t, r)) return !0
        }
      }
      return !1
    }
  }
  t.BindingsIndex = i
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(566), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationPathAlt = void 0;
  const n = r(29),
    i = r(1),
    a = r(3),
    s = r(6);
  class o extends n.ActorAbstractPath {
    constructor(e) {
      super(e, s.Algebra.types.ALT)
    }
    async runOperation(e, t) {
      const r = e.predicate,
        s = (await Promise.all([this.mediatorQueryOperation.mediate({
          context: t,
          operation: n.ActorAbstractPath.FACTORY.createPath(e.subject, r.left, e.object, e.graph)
        }), this.mediatorQueryOperation.mediate({
          context: t,
          operation: n.ActorAbstractPath.FACTORY.createPath(e.subject, r.right, e.object, e.graph)
        })])).map(e => i.ActorQueryOperation.getSafeBindings(e)),
        o = new a.UnionIterator(s.map(e => e.bindingsStream), {
          autoStart: !1
        }),
        u = [].concat.apply([], s.map(e => e.variables));
      return {
        type: "bindings",
        bindingsStream: o,
        variables: [...new Set(u)],
        canContainUndefs: !1
      }
    }
  }
  t.ActorQueryOperationPathAlt = o
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(568), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationPathInv = void 0;
  const n = r(29),
    i = r(6);
  class a extends n.ActorAbstractPath {
    constructor(e) {
      super(e, i.Algebra.types.INV)
    }
    async runOperation(e, t) {
      const r = e.predicate,
        i = n.ActorAbstractPath.FACTORY.createPath(e.object, r.path, e.subject, e.graph);
      return this.mediatorQueryOperation.mediate({
        operation: i,
        context: t
      })
    }
  }
  t.ActorQueryOperationPathInv = a
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(570), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationPathLink = void 0;
  const n = r(29),
    i = r(6);
  class a extends n.ActorAbstractPath {
    constructor(e) {
      super(e, i.Algebra.types.LINK)
    }
    async runOperation(e, t) {
      const r = e.predicate,
        i = n.ActorAbstractPath.FACTORY.createPattern(e.subject, r.iri, e.object, e.graph);
      return this.mediatorQueryOperation.mediate({
        operation: i,
        context: t
      })
    }
  }
  t.ActorQueryOperationPathLink = a
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(572), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationPathNps = void 0;
  const n = r(29),
    i = r(1),
    a = r(4),
    s = r(6);
  class o extends n.ActorAbstractPath {
    constructor(e) {
      super(e, s.Algebra.types.NPS)
    }
    async runOperation(e, t) {
      const r = e.predicate,
        s = this.generateVariable(e),
        o = a.termToString(s),
        u = n.ActorAbstractPath.FACTORY.createPattern(e.subject, s, e.object, e.graph),
        c = i.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
          operation: u,
          context: t
        }));
      return {
        type: "bindings",
        bindingsStream: c.bindingsStream.transform({
          filter: e => !r.iris.some(t => t.equals(e.get(o))),
          transform(e, t, r) {
            r(e.delete(o)), t()
          }
        }),
        variables: c.variables,
        canContainUndefs: !1
      }
    }
  }
  t.ActorQueryOperationPathNps = o
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(574), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationPathOneOrMore = void 0;
  const n = r(29),
    i = r(1),
    a = r(3),
    s = r(4),
    o = r(6);
  class u extends n.ActorAbstractPath {
    constructor(e) {
      super(e, o.Algebra.types.ONE_OR_MORE_PATH)
    }
    async runOperation(e, t) {
      const r = await this.isPathArbitraryLengthDistinct(t, e);
      if (r.operation) return r.operation;
      t = r.context;
      const o = e.predicate,
        u = "Variable" === e.subject.termType,
        c = "Variable" === e.object.termType,
        l = "Variable" === e.graph.termType;
      if (!u && c) {
        const r = n.ActorAbstractPath.FACTORY.createDistinct(n.ActorAbstractPath.FACTORY.createPath(e.subject, o.path, e.object, e.graph)),
          u = i.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
            context: t,
            operation: r
          })),
          c = s.termToString(e.object),
          h = {};
        return {
          type: "bindings",
          bindingsStream: new a.MultiTransformIterator(u.bindingsStream, {
            multiTransform: r => {
              const n = r.get(c),
                u = l ? r.get(s.termToString(e.graph)) : e.graph;
              return new a.TransformIterator(async () => {
                const r = new a.BufferedIterator;
                return await this.getObjectsPredicateStar(n, o.path, e.graph, t, h, r, {
                  count: 0
                }), r.transform({
                  transform(t, r, n) {
                    let a = i.Bindings({
                      [c]: t
                    });
                    l && (a = a.set(s.termToString(e.graph), u)), n(a), r()
                  }
                })
              }, {
                maxBufferSize: 128
              })
            },
            autoStart: !1
          }),
          variables: l ? [c, s.termToString(e.graph)] : [c],
          canContainUndefs: !1
        }
      }
      if (u && c) {
        const r = n.ActorAbstractPath.FACTORY.createDistinct(n.ActorAbstractPath.FACTORY.createPath(e.subject, e.predicate.path, e.object, e.graph)),
          u = i.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
            context: t,
            operation: r
          })),
          c = s.termToString(e.subject),
          h = s.termToString(e.object),
          d = {};
        return {
          type: "bindings",
          bindingsStream: new a.MultiTransformIterator(u.bindingsStream, {
            multiTransform: r => {
              const n = r.get(c),
                i = r.get(h),
                u = l ? r.get(s.termToString(e.graph)) : e.graph;
              return new a.TransformIterator(async () => {
                const r = new a.BufferedIterator;
                return await this.getSubjectAndObjectBindingsPredicateStar(c, h, n, i, o.path, u, t, d, {}, r, {
                  count: 0
                }), r.transform({
                  transform(t, r, n) {
                    l && (t = t.set(s.termToString(e.graph), u)), n(t), r()
                  }
                })
              }, {
                maxBufferSize: 128
              })
            },
            autoStart: !1
          }),
          variables: l ? [c, h, s.termToString(e.graph)] : [c, h],
          canContainUndefs: !1
        }
      }
      if (u && !c) return this.mediatorQueryOperation.mediate({
        context: t,
        operation: n.ActorAbstractPath.FACTORY.createPath(e.object, n.ActorAbstractPath.FACTORY.createOneOrMorePath(n.ActorAbstractPath.FACTORY.createInv(o.path)), e.subject, e.graph)
      });
      const h = this.generateVariable(),
        d = s.termToString(h);
      return {
        type: "bindings",
        bindingsStream: i.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
          context: t,
          operation: n.ActorAbstractPath.FACTORY.createPath(e.subject, o, h, e.graph)
        })).bindingsStream.transform({
          filter: t => t.get(d).equals(e.object),
          transform(t, r, n) {
            n(l ? i.Bindings({
              [s.termToString(e.graph)]: t.get(s.termToString(e.graph))
            }) : i.Bindings({})), r()
          }
        }),
        variables: l ? [s.termToString(e.graph)] : [],
        canContainUndefs: !1
      }
    }
  }
  t.ActorQueryOperationPathOneOrMore = u
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(576), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationPathSeq = void 0;
  const n = r(29),
    i = r(1),
    a = r(4),
    s = r(6);
  class o extends n.ActorAbstractPath {
    constructor(e) {
      super(e, s.Algebra.types.SEQ)
    }
    async runOperation(e, t) {
      const r = e.predicate,
        s = this.generateVariable(e),
        o = a.termToString(s),
        u = (await Promise.all([this.mediatorQueryOperation.mediate({
          context: t,
          operation: n.ActorAbstractPath.FACTORY.createPath(e.subject, r.left, s, e.graph)
        }), this.mediatorQueryOperation.mediate({
          context: t,
          operation: n.ActorAbstractPath.FACTORY.createPath(s, r.right, e.object, e.graph)
        })])).map(e => i.ActorQueryOperation.getSafeBindings(e)),
        c = i.ActorQueryOperation.getSafeBindings(await this.mediatorJoin.mediate({
          entries: u
        })),
        l = c.bindingsStream.transform({
          transform(e, t, r) {
            r(e.delete(o)), t()
          }
        }),
        h = c.variables,
        d = h.indexOf(o);
      return h.splice(d, 1), {
        type: "bindings",
        bindingsStream: l,
        variables: h,
        canContainUndefs: !1
      }
    }
  }
  t.ActorQueryOperationPathSeq = o
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(578), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationPathZeroOrMore = void 0;
  const n = r(29),
    i = r(1),
    a = r(3),
    s = r(4),
    o = r(6);
  class u extends n.ActorAbstractPath {
    constructor(e) {
      super(e, o.Algebra.types.ZERO_OR_MORE_PATH)
    }
    async runOperation(e, t) {
      const r = await this.isPathArbitraryLengthDistinct(t, e);
      if (r.operation) return r.operation;
      t = r.context;
      const o = e.predicate,
        u = "Variable" === e.subject.termType,
        c = "Variable" === e.object.termType,
        l = "Variable" === e.graph.termType;
      if (u && c) {
        const r = this.generateVariable(e),
          u = n.ActorAbstractPath.FACTORY.createPattern(e.subject, r, e.object, e.graph),
          c = i.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
            context: t,
            operation: u
          })),
          h = s.termToString(e.subject),
          d = s.termToString(e.object),
          p = new Set,
          f = {};
        return {
          type: "bindings",
          bindingsStream: new a.MultiTransformIterator(c.bindingsStream, {
            multiTransform: r => {
              const n = r.get(h),
                i = r.get(d),
                u = l ? r.get(s.termToString(e.graph)) : e.graph,
                c = s.termToString(n) + s.termToString(u),
                g = s.termToString(i) + s.termToString(u);
              return new a.TransformIterator(async () => {
                if (p.has(c) && p.has(g)) return new a.EmptyIterator;
                const r = new a.BufferedIterator,
                  m = {
                    count: 0
                  };
                return p.has(c) || (p.add(c), await this.getSubjectAndObjectBindingsPredicateStar(h, d, n, n, o.path, u, t, f, {}, r, m)), p.has(g) || (p.add(g), await this.getSubjectAndObjectBindingsPredicateStar(h, d, i, i, o.path, u, t, f, {}, r, m)), r.transform({
                  transform(t, r, n) {
                    l && (t = t.set(s.termToString(e.graph), u)), n(t), r()
                  }
                })
              })
            }
          }),
          variables: l ? [h, d, s.termToString(e.graph)] : [h, d],
          canContainUndefs: !1
        }
      }
      if (!u && !c) {
        const r = this.generateVariable();
        return {
          type: "bindings",
          bindingsStream: (await this.getObjectsPredicateStarEval(e.subject, r, o.path, e.graph, t)).transform({
            filter: t => t.get(s.termToString(r)).equals(e.object),
            transform(t, r, n) {
              n(l ? i.Bindings({
                [s.termToString(e.graph)]: t.get(s.termToString(e.graph))
              }) : i.Bindings({})), r()
            }
          }),
          variables: l ? [s.termToString(e.graph)] : [],
          canContainUndefs: !1
        }
      }
      const h = u ? e.object : e.subject,
        d = u ? e.subject : e.object,
        p = u ? n.ActorAbstractPath.FACTORY.createInv(o.path) : o.path;
      return {
        type: "bindings",
        bindingsStream: (await this.getObjectsPredicateStarEval(h, d, p, e.graph, t)).transform({
          transform(e, t, r) {
            r(e), t()
          }
        }),
        variables: l ? [s.termToString(d), s.termToString(e.graph)] : [s.termToString(d)],
        canContainUndefs: !1
      }
    }
  }
  t.ActorQueryOperationPathZeroOrMore = u
}, function(e, t, r) {
  "use strict";
  var n = this && this.__createBinding || (Object.create ? function(e, t, r, n) {
      void 0 === n && (n = r), Object.defineProperty(e, n, {
        enumerable: !0,
        get: function() {
          return t[r]
        }
      })
    } : function(e, t, r, n) {
      void 0 === n && (n = r), e[n] = t[r]
    }),
    i = this && this.__exportStar || function(e, t) {
      for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || n(t, e, r)
    };
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), i(r(580), t)
}, function(e, t, r) {
  "use strict";
  Object.defineProperty(t, "__esModule", {
    value: !0
  }), t.ActorQueryOperationPathZeroOrOne = void 0;
  const n = r(187),
    i = r(1),
    a = r(3),
    s = r(4),
    o = r(6);
  class u extends n.ActorAbstractPath {
    constructor(e) {
      super(e, o.Algebra.types.ZERO_OR_ONE_PATH)
    }
    async runOperation(e, t) {
      const r = e.predicate,
        o = "Variable" === e.subject.termType,
        u = "Variable" === e.object.termType,
        c = [];
      if (!o && !u && e.subject.equals(e.object)) return {
        type: "bindings",
        bindingsStream: new a.SingletonIterator(i.Bindings({})),
        variables: [],
        canContainUndefs: !1
      };
      if (o && u) throw new Error("ZeroOrOne path expressions with 2 variables not supported yet");
      const l = await this.isPathArbitraryLengthDistinct(t, e);
      if (l.operation) return l.operation;
      t = l.context, o && c.push(i.Bindings({
        [s.termToString(e.subject)]: e.object
      })), u && c.push(i.Bindings({
        [s.termToString(e.object)]: e.subject
      }));
      const h = i.ActorQueryOperation.getSafeBindings(await this.mediatorQueryOperation.mediate({
        context: t,
        operation: n.ActorAbstractPath.FACTORY.createPath(e.subject, r.path, e.object, e.graph)
      }));
      return {
        type: "bindings",
        bindingsStream: h.bindingsStream.prepend(c),
        variables: h.variables,
        canContainUndefs: !1
      }
    }
  }
  t.ActorQueryOperationPathZeroOrOne = u
}, function(e, t, r) {
  "use strict";
  r.r(t), r.d(t, "Source", (function() {
    return s
  })), r.d(t, "getLocation", (function() {
    return o
  })), r.d(t, "printLocation", (function() {
    return u
  })), r.d(t, "printSourceLocation", (function() {
    return c
  })), r.d(t, "Kind", (function() {
    return d
  })), r.d(t, "TokenKind", (function() {
    return p
  })), r.d(t, "Lexer", (function() {
    return j
  })), r.d(t, "parse", (function() {
    return H
  })), r.d(t, "parseValue", (function() {
    return G
  })), r.d(t, "parseType", (function() {
    return z
  })), r.d(t, "print", (function() {
    return ee
  })), r.d(t, "visit", (function() {
    return W
  })), r.d(t, "visitInParallel", (function() {
    return K
  })), r.d(t, "getVisitFn", (function() {
    return Z
  })), r.d(t, "BREAK", (function() {
    return J
  })), r.d(t, "Location", (function() {
    return R
  })), r.d(t, "Token", (function() {
    return I
  })), r.d(t, "isDefinitionNode", (function() {
    return ce
  })), r.d(t, "isExecutableDefinitionNode", (function() {
    return le
  })), r.d(t, "isSelectionNode", (function() {
    return he
  })), r.d(t, "isValueNode", (function() {
    return de
  })), r.d(t, "isTypeNode", (function() {
    return pe
  })), r.d(t, "isTypeSystemDefinitionNode", (function() {
    return fe
  })), r.d(t, "isTypeDefinitionNode", (function() {
    return ge
  })), r.d(t, "isTypeSystemExtensionNode", (function() {
    return me
  })), r.d(t, "isTypeExtensionNode", (function() {
    return ye
  })), r.d(t, "DirectiveLocation", (function() {
    return V
  }));
  "function" == typeof Symbol && Symbol.iterator, "function" == typeof Symbol && Symbol.asyncIterator;
  var n = "function" == typeof Symbol ? Symbol.toStringTag : "@@toStringTag";

  function i(e, t) {
    if (!Boolean(e)) throw new Error(t)
  }

  function a(e, t) {
    for (var r = 0; r < t.length; r++) {
      var n = t[r];
      n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
    }
  }
  var s = function() {
    function e(e) {
      var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "GraphQL request",
        r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {
          line: 1,
          column: 1
        };
      this.body = e, this.name = t, this.locationOffset = r, this.locationOffset.line > 0 || i(0, "line in locationOffset is 1-indexed and must be positive."), this.locationOffset.column > 0 || i(0, "column in locationOffset is 1-indexed and must be positive.")
    }
    var t, r, s;
    return t = e, (r = [{
      key: n,
      get: function() {
        return "Source"
      }
    }]) && a(t.prototype, r), s && a(t, s), e
  }();

  function o(e, t) {
    for (var r, n = /\r\n|[\n\r]/g, i = 1, a = t + 1;
         (r = n.exec(e.body)) && r.index < t;) i += 1, a = t + 1 - (r.index + r[0].length);
    return {
      line: i,
      column: a
    }
  }

  function u(e) {
    return c(e.source, o(e.source, e.start))
  }

  function c(e, t) {
    var r = e.locationOffset.column - 1,
      n = h(r) + e.body,
      i = t.line - 1,
      a = e.locationOffset.line - 1,
      s = t.line + a,
      o = 1 === t.line ? r : 0,
      u = t.column + o,
      c = "".concat(e.name, ":").concat(s, ":").concat(u, "\n"),
      d = n.split(/\r\n|[\n\r]/g),
      p = d[i];
    if (p.length > 120) {
      for (var f = Math.floor(u / 80), g = u % 80, m = [], y = 0; y < p.length; y += 80) m.push(p.slice(y, y + 80));
      return c + l([
        ["".concat(s), m[0]]
      ].concat(m.slice(1, f + 1).map((function(e) {
        return ["", e]
      })), [
        [" ", h(g - 1) + "^"],
        ["", m[f + 1]]
      ]))
    }
    return c + l([
      ["".concat(s - 1), d[i - 1]],
      ["".concat(s), p],
      ["", h(u - 1) + "^"],
      ["".concat(s + 1), d[i + 1]]
    ])
  }

  function l(e) {
    var t = e.filter((function(e) {
        e[0];
        return void 0 !== e[1]
      })),
      r = Math.max.apply(Math, t.map((function(e) {
        return e[0].length
      })));
    return t.map((function(e) {
      var t, n = e[0],
        i = e[1];
      return h(r - (t = n).length) + t + (i ? " | " + i : " |")
    })).join("\n")
  }

  function h(e) {
    return Array(e + 1).join(" ")
  }
  var d = Object.freeze({
      NAME: "Name",
      DOCUMENT: "Document",
      OPERATION_DEFINITION: "OperationDefinition",
      VARIABLE_DEFINITION: "VariableDefinition",
      SELECTION_SET: "SelectionSet",
      FIELD: "Field",
      ARGUMENT: "Argument",
      FRAGMENT_SPREAD: "FragmentSpread",
      INLINE_FRAGMENT: "InlineFragment",
      FRAGMENT_DEFINITION: "FragmentDefinition",
      VARIABLE: "Variable",
      INT: "IntValue",
      FLOAT: "FloatValue",
      STRING: "StringValue",
      BOOLEAN: "BooleanValue",
      NULL: "NullValue",
      ENUM: "EnumValue",
      LIST: "ListValue",
      OBJECT: "ObjectValue",
      OBJECT_FIELD: "ObjectField",
      DIRECTIVE: "Directive",
      NAMED_TYPE: "NamedType",
      LIST_TYPE: "ListType",
      NON_NULL_TYPE: "NonNullType",
      SCHEMA_DEFINITION: "SchemaDefinition",
      OPERATION_TYPE_DEFINITION: "OperationTypeDefinition",
      SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition",
      OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition",
      FIELD_DEFINITION: "FieldDefinition",
      INPUT_VALUE_DEFINITION: "InputValueDefinition",
      INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition",
      UNION_TYPE_DEFINITION: "UnionTypeDefinition",
      ENUM_TYPE_DEFINITION: "EnumTypeDefinition",
      ENUM_VALUE_DEFINITION: "EnumValueDefinition",
      INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition",
      DIRECTIVE_DEFINITION: "DirectiveDefinition",
      SCHEMA_EXTENSION: "SchemaExtension",
      SCALAR_TYPE_EXTENSION: "ScalarTypeExtension",
      OBJECT_TYPE_EXTENSION: "ObjectTypeExtension",
      INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension",
      UNION_TYPE_EXTENSION: "UnionTypeExtension",
      ENUM_TYPE_EXTENSION: "EnumTypeExtension",
      INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension"
    }),
    p = Object.freeze({
      SOF: "<SOF>",
      EOF: "<EOF>",
      BANG: "!",
      DOLLAR: "$",
      AMP: "&",
      PAREN_L: "(",
      PAREN_R: ")",
      SPREAD: "...",
      COLON: ":",
      EQUALS: "=",
      AT: "@",
      BRACKET_L: "[",
      BRACKET_R: "]",
      BRACE_L: "{",
      PIPE: "|",
      BRACE_R: "}",
      NAME: "Name",
      INT: "Int",
      FLOAT: "Float",
      STRING: "String",
      BLOCK_STRING: "BlockString",
      COMMENT: "Comment"
    });

  function f(e) {
    return (f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
      return typeof e
    } : function(e) {
      return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
  }

  function g(e) {
    return (g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
      return typeof e
    } : function(e) {
      return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
  }

  function m(e, t) {
    for (var r = 0; r < t.length; r++) {
      var n = t[r];
      n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
    }
  }

  function y(e, t) {
    return !t || "object" !== g(t) && "function" != typeof t ? b(e) : t
  }

  function b(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e
  }

  function _(e) {
    var t = "function" == typeof Map ? new Map : void 0;
    return (_ = function(e) {
      if (null === e || (r = e, -1 === Function.toString.call(r).indexOf("[native code]"))) return e;
      var r;
      if ("function" != typeof e) throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== t) {
        if (t.has(e)) return t.get(e);
        t.set(e, n)
      }

      function n() {
        return v(e, arguments, T(this).constructor)
      }
      return n.prototype = Object.create(e.prototype, {
        constructor: {
          value: n,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), S(n, e)
    })(e)
  }

  function v(e, t, r) {
    return (v = w() ? Reflect.construct : function(e, t, r) {
      var n = [null];
      n.push.apply(n, t);
      var i = new(Function.bind.apply(e, n));
      return r && S(i, r.prototype), i
    }).apply(null, arguments)
  }

  function w() {
    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
    if (Reflect.construct.sham) return !1;
    if ("function" == typeof Proxy) return !0;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), !0
    } catch (e) {
      return !1
    }
  }

  function S(e, t) {
    return (S = Object.setPrototypeOf || function(e, t) {
      return e.__proto__ = t, e
    })(e, t)
  }

  function T(e) {
    return (T = Object.setPrototypeOf ? Object.getPrototypeOf : function(e) {
      return e.__proto__ || Object.getPrototypeOf(e)
    })(e)
  }
  var E = function(e) {
    ! function(e, t) {
      if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function");
      e.prototype = Object.create(t && t.prototype, {
        constructor: {
          value: e,
          writable: !0,
          configurable: !0
        }
      }), t && S(e, t)
    }(h, e);
    var t, r, i, a, s, l = (t = h, r = w(), function() {
      var e, n = T(t);
      if (r) {
        var i = T(this).constructor;
        e = Reflect.construct(n, arguments, i)
      } else e = n.apply(this, arguments);
      return y(this, e)
    });

    function h(e, t, r, n, i, a, s) {
      var u, c, d, p, g;
      ! function(e, t) {
        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
      }(this, h), g = l.call(this, e);
      var m, _ = Array.isArray(t) ? 0 !== t.length ? t : void 0 : t ? [t] : void 0,
        v = r;
      !v && _ && (v = null === (m = _[0].loc) || void 0 === m ? void 0 : m.source);
      var w, S = n;
      !S && _ && (S = _.reduce((function(e, t) {
        return t.loc && e.push(t.loc.start), e
      }), [])), S && 0 === S.length && (S = void 0), n && r ? w = n.map((function(e) {
        return o(r, e)
      })) : _ && (w = _.reduce((function(e, t) {
        return t.loc && e.push(o(t.loc.source, t.loc.start)), e
      }), []));
      var T, E = s;
      if (null == E && null != a) {
        var x = a.extensions;
        "object" == f(T = x) && null !== T && (E = x)
      }
      return Object.defineProperties(b(g), {
        name: {
          value: "GraphQLError"
        },
        message: {
          value: e,
          enumerable: !0,
          writable: !0
        },
        locations: {
          value: null !== (u = w) && void 0 !== u ? u : void 0,
          enumerable: null != w
        },
        path: {
          value: null != i ? i : void 0,
          enumerable: null != i
        },
        nodes: {
          value: null != _ ? _ : void 0
        },
        source: {
          value: null !== (c = v) && void 0 !== c ? c : void 0
        },
        positions: {
          value: null !== (d = S) && void 0 !== d ? d : void 0
        },
        originalError: {
          value: a
        },
        extensions: {
          value: null !== (p = E) && void 0 !== p ? p : void 0,
          enumerable: null != E
        }
      }), (null == a ? void 0 : a.stack) ? (Object.defineProperty(b(g), "stack", {
        value: a.stack,
        writable: !0,
        configurable: !0
      }), y(g)) : (Error.captureStackTrace ? Error.captureStackTrace(b(g), h) : Object.defineProperty(b(g), "stack", {
        value: Error().stack,
        writable: !0,
        configurable: !0
      }), g)
    }
    return i = h, (a = [{
      key: "toString",
      value: function() {
        return function(e) {
          var t = e.message;
          if (e.nodes)
            for (var r = 0, n = e.nodes; r < n.length; r++) {
              var i = n[r];
              i.loc && (t += "\n\n" + u(i.loc))
            } else if (e.source && e.locations)
            for (var a = 0, s = e.locations; a < s.length; a++) {
              var o = s[a];
              t += "\n\n" + c(e.source, o)
            }
          return t
        }(this)
      }
    }, {
      key: n,
      get: function() {
        return "Object"
      }
    }]) && m(i.prototype, a), s && m(i, s), h
  }(_(Error));

  function x(e, t, r) {
    return new E("Syntax Error: ".concat(r), void 0, e, [t])
  }
  var O = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : void 0;

  function A(e) {
    var t = e.prototype.toJSON;
    "function" == typeof t || function(e, t) {
      if (!Boolean(e)) throw new Error(null != t ? t : "Unexpected invariant triggered.")
    }(0), e.prototype.inspect = t, O && (e.prototype[O] = t)
  }
  var R = function() {
    function e(e, t, r) {
      this.start = e.start, this.end = t.end, this.startToken = e, this.endToken = t, this.source = r
    }
    return e.prototype.toJSON = function() {
      return {
        start: this.start,
        end: this.end
      }
    }, e
  }();
  A(R);
  var I = function() {
    function e(e, t, r, n, i, a, s) {
      this.kind = e, this.start = t, this.end = r, this.line = n, this.column = i, this.value = s, this.prev = a, this.next = null
    }
    return e.prototype.toJSON = function() {
      return {
        kind: this.kind,
        value: this.value,
        line: this.line,
        column: this.column
      }
    }, e
  }();

  function N(e) {
    return null != e && "string" == typeof e.kind
  }

  function P(e) {
    var t = e.split(/\r\n|[\n\r]/g),
      r = function(e) {
        for (var t = null, r = 1; r < e.length; r++) {
          var n = e[r],
            i = C(n);
          if (i !== n.length && ((null === t || i < t) && 0 === (t = i))) break
        }
        return null === t ? 0 : t
      }(t);
    if (0 !== r)
      for (var n = 1; n < t.length; n++) t[n] = t[n].slice(r);
    for (; t.length > 0 && D(t[0]);) t.shift();
    for (; t.length > 0 && D(t[t.length - 1]);) t.pop();
    return t.join("\n")
  }

  function C(e) {
    for (var t = 0; t < e.length && (" " === e[t] || "\t" === e[t]);) t++;
    return t
  }

  function D(e) {
    return C(e) === e.length
  }
  A(I);
  var j = function() {
    function e(e) {
      var t = new I(p.SOF, 0, 0, 0, 0, null);
      this.source = e, this.lastToken = t, this.token = t, this.line = 1, this.lineStart = 0
    }
    var t = e.prototype;
    return t.advance = function() {
      return this.lastToken = this.token, this.token = this.lookahead()
    }, t.lookahead = function() {
      var e = this.token;
      if (e.kind !== p.EOF)
        do {
          var t;
          e = null !== (t = e.next) && void 0 !== t ? t : e.next = L(this, e)
        } while (e.kind === p.COMMENT);
      return e
    }, e
  }();

  function k(e) {
    return isNaN(e) ? p.EOF : e < 127 ? JSON.stringify(String.fromCharCode(e)) : '"\\u'.concat(("00" + e.toString(16).toUpperCase()).slice(-4), '"')
  }

  function L(e, t) {
    var r = e.source,
      n = r.body,
      i = n.length,
      a = function(e, t, r) {
        var n = e.length,
          i = t;
        for (; i < n;) {
          var a = e.charCodeAt(i);
          if (9 === a || 32 === a || 44 === a || 65279 === a) ++i;
          else if (10 === a) ++i, ++r.line, r.lineStart = i;
          else {
            if (13 !== a) break;
            10 === e.charCodeAt(i + 1) ? i += 2 : ++i, ++r.line, r.lineStart = i
          }
        }
        return i
      }(n, t.end, e),
      s = e.line,
      o = 1 + a - e.lineStart;
    if (a >= i) return new I(p.EOF, i, i, s, o, t);
    var u = n.charCodeAt(a);
    switch (u) {
      case 33:
        return new I(p.BANG, a, a + 1, s, o, t);
      case 35:
        return function(e, t, r, n, i) {
          var a, s = e.body,
            o = t;
          do {
            a = s.charCodeAt(++o)
          } while (!isNaN(a) && (a > 31 || 9 === a));
          return new I(p.COMMENT, t, o, r, n, i, s.slice(t + 1, o))
        }(r, a, s, o, t);
      case 36:
        return new I(p.DOLLAR, a, a + 1, s, o, t);
      case 38:
        return new I(p.AMP, a, a + 1, s, o, t);
      case 40:
        return new I(p.PAREN_L, a, a + 1, s, o, t);
      case 41:
        return new I(p.PAREN_R, a, a + 1, s, o, t);
      case 46:
        if (46 === n.charCodeAt(a + 1) && 46 === n.charCodeAt(a + 2)) return new I(p.SPREAD, a, a + 3, s, o, t);
        break;
      case 58:
        return new I(p.COLON, a, a + 1, s, o, t);
      case 61:
        return new I(p.EQUALS, a, a + 1, s, o, t);
      case 64:
        return new I(p.AT, a, a + 1, s, o, t);
      case 91:
        return new I(p.BRACKET_L, a, a + 1, s, o, t);
      case 93:
        return new I(p.BRACKET_R, a, a + 1, s, o, t);
      case 123:
        return new I(p.BRACE_L, a, a + 1, s, o, t);
      case 124:
        return new I(p.PIPE, a, a + 1, s, o, t);
      case 125:
        return new I(p.BRACE_R, a, a + 1, s, o, t);
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 74:
      case 75:
      case 76:
      case 77:
      case 78:
      case 79:
      case 80:
      case 81:
      case 82:
      case 83:
      case 84:
      case 85:
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      case 95:
      case 97:
      case 98:
      case 99:
      case 100:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
        return function(e, t, r, n, i) {
          var a = e.body,
            s = a.length,
            o = t + 1,
            u = 0;
          for (; o !== s && !isNaN(u = a.charCodeAt(o)) && (95 === u || u >= 48 && u <= 57 || u >= 65 && u <= 90 || u >= 97 && u <= 122);) ++o;
          return new I(p.NAME, t, o, r, n, i, a.slice(t, o))
        }(r, a, s, o, t);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return function(e, t, r, n, i, a) {
          var s = e.body,
            o = r,
            u = t,
            c = !1;
          45 === o && (o = s.charCodeAt(++u));
          if (48 === o) {
            if ((o = s.charCodeAt(++u)) >= 48 && o <= 57) throw x(e, u, "Invalid number, unexpected digit after 0: ".concat(k(o), "."))
          } else u = M(e, u, o), o = s.charCodeAt(u);
          46 === o && (c = !0, o = s.charCodeAt(++u), u = M(e, u, o), o = s.charCodeAt(u));
          69 !== o && 101 !== o || (c = !0, 43 !== (o = s.charCodeAt(++u)) && 45 !== o || (o = s.charCodeAt(++u)), u = M(e, u, o), o = s.charCodeAt(u));
          if (46 === o || function(e) {
            return 95 === e || e >= 65 && e <= 90 || e >= 97 && e <= 122
          }(o)) throw x(e, u, "Invalid number, expected digit but got: ".concat(k(o), "."));
          return new I(c ? p.FLOAT : p.INT, t, u, n, i, a, s.slice(t, u))
        }(r, a, u, s, o, t);
      case 34:
        return 34 === n.charCodeAt(a + 1) && 34 === n.charCodeAt(a + 2) ? function(e, t, r, n, i, a) {
          var s = e.body,
            o = t + 3,
            u = o,
            c = 0,
            l = "";
          for (; o < s.length && !isNaN(c = s.charCodeAt(o));) {
            if (34 === c && 34 === s.charCodeAt(o + 1) && 34 === s.charCodeAt(o + 2)) return l += s.slice(u, o), new I(p.BLOCK_STRING, t, o + 3, r, n, i, P(l));
            if (c < 32 && 9 !== c && 10 !== c && 13 !== c) throw x(e, o, "Invalid character within String: ".concat(k(c), "."));
            10 === c ? (++o, ++a.line, a.lineStart = o) : 13 === c ? (10 === s.charCodeAt(o + 1) ? o += 2 : ++o, ++a.line, a.lineStart = o) : 92 === c && 34 === s.charCodeAt(o + 1) && 34 === s.charCodeAt(o + 2) && 34 === s.charCodeAt(o + 3) ? (l += s.slice(u, o) + '"""', u = o += 4) : ++o
          }
          throw x(e, o, "Unterminated string.")
        }(r, a, s, o, t, e) : function(e, t, r, n, i) {
          var a = e.body,
            s = t + 1,
            o = s,
            u = 0,
            c = "";
          for (; s < a.length && !isNaN(u = a.charCodeAt(s)) && 10 !== u && 13 !== u;) {
            if (34 === u) return c += a.slice(o, s), new I(p.STRING, t, s + 1, r, n, i, c);
            if (u < 32 && 9 !== u) throw x(e, s, "Invalid character within String: ".concat(k(u), "."));
            if (++s, 92 === u) {
              switch (c += a.slice(o, s - 1), u = a.charCodeAt(s)) {
                case 34:
                  c += '"';
                  break;
                case 47:
                  c += "/";
                  break;
                case 92:
                  c += "\\";
                  break;
                case 98:
                  c += "\b";
                  break;
                case 102:
                  c += "\f";
                  break;
                case 110:
                  c += "\n";
                  break;
                case 114:
                  c += "\r";
                  break;
                case 116:
                  c += "\t";
                  break;
                case 117:
                  var l = (d = a.charCodeAt(s + 1), f = a.charCodeAt(s + 2), g = a.charCodeAt(s + 3), m = a.charCodeAt(s + 4), F(d) << 12 | F(f) << 8 | F(g) << 4 | F(m));
                  if (l < 0) {
                    var h = a.slice(s + 1, s + 5);
                    throw x(e, s, "Invalid character escape sequence: \\u".concat(h, "."))
                  }
                  c += String.fromCharCode(l), s += 4;
                  break;
                default:
                  throw x(e, s, "Invalid character escape sequence: \\".concat(String.fromCharCode(u), "."))
              }++s, o = s
            }
          }
          var d, f, g, m;
          throw x(e, s, "Unterminated string.")
        }(r, a, s, o, t)
    }
    throw x(r, a, function(e) {
      if (e < 32 && 9 !== e && 10 !== e && 13 !== e) return "Cannot contain the invalid character ".concat(k(e), ".");
      if (39 === e) return "Unexpected single quote character ('), did you mean to use a double quote (\")?";
      return "Cannot parse the unexpected character ".concat(k(e), ".")
    }(u))
  }

  function M(e, t, r) {
    var n = e.body,
      i = t,
      a = r;
    if (a >= 48 && a <= 57) {
      do {
        a = n.charCodeAt(++i)
      } while (a >= 48 && a <= 57);
      return i
    }
    throw x(e, i, "Invalid number, expected digit but got: ".concat(k(a), "."))
  }

  function F(e) {
    return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1
  }

  function B(e) {
    return (B = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e) {
      return typeof e
    } : function(e) {
      return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    })(e)
  }

  function q(e) {
    return U(e, [])
  }

  function U(e, t) {
    switch (B(e)) {
      case "string":
        return JSON.stringify(e);
      case "function":
        return e.name ? "[function ".concat(e.name, "]") : "[function]";
      case "object":
        return null === e ? "null" : function(e, t) {
          if (-1 !== t.indexOf(e)) return "[Circular]";
          var r = [].concat(t, [e]),
            n = function(e) {
              var t = e[String(O)];
              if ("function" == typeof t) return t;
              if ("function" == typeof e.inspect) return e.inspect
            }(e);
          if (void 0 !== n) {
            var i = n.call(e);
            if (i !== e) return "string" == typeof i ? i : U(i, r)
          } else if (Array.isArray(e)) return function(e, t) {
            if (0 === e.length) return "[]";
            if (t.length > 2) return "[Array]";
            for (var r = Math.min(10, e.length), n = e.length - r, i = [], a = 0; a < r; ++a) i.push(U(e[a], t));
            1 === n ? i.push("... 1 more item") : n > 1 && i.push("... ".concat(n, " more items"));
            return "[" + i.join(", ") + "]"
          }(e, r);
          return function(e, t) {
            var r = Object.keys(e);
            if (0 === r.length) return "{}";
            if (t.length > 2) return "[" + function(e) {
              var t = Object.prototype.toString.call(e).replace(/^\[object /, "").replace(/]$/, "");
              if ("Object" === t && "function" == typeof e.constructor) {
                var r = e.constructor.name;
                if ("string" == typeof r && "" !== r) return r
              }
              return t
            }(e) + "]";
            return "{ " + r.map((function(r) {
              return r + ": " + U(e[r], t)
            })).join(", ") + " }"
          }(e, r)
        }(e, t);
      default:
        return String(e)
    }
  }
  var V = Object.freeze({
    QUERY: "QUERY",
    MUTATION: "MUTATION",
    SUBSCRIPTION: "SUBSCRIPTION",
    FIELD: "FIELD",
    FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
    FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
    INLINE_FRAGMENT: "INLINE_FRAGMENT",
    VARIABLE_DEFINITION: "VARIABLE_DEFINITION",
    SCHEMA: "SCHEMA",
    SCALAR: "SCALAR",
    OBJECT: "OBJECT",
    FIELD_DEFINITION: "FIELD_DEFINITION",
    ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
    INTERFACE: "INTERFACE",
    UNION: "UNION",
    ENUM: "ENUM",
    ENUM_VALUE: "ENUM_VALUE",
    INPUT_OBJECT: "INPUT_OBJECT",
    INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
  });

  function H(e, t) {
    return new Q(e, t).parseDocument()
  }

  function G(e, t) {
    var r = new Q(e, t);
    r.expectToken(p.SOF);
    var n = r.parseValueLiteral(!1);
    return r.expectToken(p.EOF), n
  }

  function z(e, t) {
    var r = new Q(e, t);
    r.expectToken(p.SOF);
    var n = r.parseTypeReference();
    return r.expectToken(p.EOF), n
  }
  var Q = function() {
    function e(e, t) {
      var r = "string" == typeof e ? new s(e) : e;
      r instanceof s || i(0, "Must provide Source. Received: ".concat(q(r), ".")), this._lexer = new j(r), this._options = t
    }
    var t = e.prototype;
    return t.parseName = function() {
      var e = this.expectToken(p.NAME);
      return {
        kind: d.NAME,
        value: e.value,
        loc: this.loc(e)
      }
    }, t.parseDocument = function() {
      var e = this._lexer.token;
      return {
        kind: d.DOCUMENT,
        definitions: this.many(p.SOF, this.parseDefinition, p.EOF),
        loc: this.loc(e)
      }
    }, t.parseDefinition = function() {
      if (this.peek(p.NAME)) switch (this._lexer.token.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "schema":
        case "scalar":
        case "type":
        case "interface":
        case "union":
        case "enum":
        case "input":
        case "directive":
          return this.parseTypeSystemDefinition();
        case "extend":
          return this.parseTypeSystemExtension()
      } else {
        if (this.peek(p.BRACE_L)) return this.parseOperationDefinition();
        if (this.peekDescription()) return this.parseTypeSystemDefinition()
      }
      throw this.unexpected()
    }, t.parseOperationDefinition = function() {
      var e = this._lexer.token;
      if (this.peek(p.BRACE_L)) return {
        kind: d.OPERATION_DEFINITION,
        operation: "query",
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(e)
      };
      var t, r = this.parseOperationType();
      return this.peek(p.NAME) && (t = this.parseName()), {
        kind: d.OPERATION_DEFINITION,
        operation: r,
        name: t,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(e)
      }
    }, t.parseOperationType = function() {
      var e = this.expectToken(p.NAME);
      switch (e.value) {
        case "query":
          return "query";
        case "mutation":
          return "mutation";
        case "subscription":
          return "subscription"
      }
      throw this.unexpected(e)
    }, t.parseVariableDefinitions = function() {
      return this.optionalMany(p.PAREN_L, this.parseVariableDefinition, p.PAREN_R)
    }, t.parseVariableDefinition = function() {
      var e = this._lexer.token;
      return {
        kind: d.VARIABLE_DEFINITION,
        variable: this.parseVariable(),
        type: (this.expectToken(p.COLON), this.parseTypeReference()),
        defaultValue: this.expectOptionalToken(p.EQUALS) ? this.parseValueLiteral(!0) : void 0,
        directives: this.parseDirectives(!0),
        loc: this.loc(e)
      }
    }, t.parseVariable = function() {
      var e = this._lexer.token;
      return this.expectToken(p.DOLLAR), {
        kind: d.VARIABLE,
        name: this.parseName(),
        loc: this.loc(e)
      }
    }, t.parseSelectionSet = function() {
      var e = this._lexer.token;
      return {
        kind: d.SELECTION_SET,
        selections: this.many(p.BRACE_L, this.parseSelection, p.BRACE_R),
        loc: this.loc(e)
      }
    }, t.parseSelection = function() {
      return this.peek(p.SPREAD) ? this.parseFragment() : this.parseField()
    }, t.parseField = function() {
      var e, t, r = this._lexer.token,
        n = this.parseName();
      return this.expectOptionalToken(p.COLON) ? (e = n, t = this.parseName()) : t = n, {
        kind: d.FIELD,
        alias: e,
        name: t,
        arguments: this.parseArguments(!1),
        directives: this.parseDirectives(!1),
        selectionSet: this.peek(p.BRACE_L) ? this.parseSelectionSet() : void 0,
        loc: this.loc(r)
      }
    }, t.parseArguments = function(e) {
      var t = e ? this.parseConstArgument : this.parseArgument;
      return this.optionalMany(p.PAREN_L, t, p.PAREN_R)
    }, t.parseArgument = function() {
      var e = this._lexer.token,
        t = this.parseName();
      return this.expectToken(p.COLON), {
        kind: d.ARGUMENT,
        name: t,
        value: this.parseValueLiteral(!1),
        loc: this.loc(e)
      }
    }, t.parseConstArgument = function() {
      var e = this._lexer.token;
      return {
        kind: d.ARGUMENT,
        name: this.parseName(),
        value: (this.expectToken(p.COLON), this.parseValueLiteral(!0)),
        loc: this.loc(e)
      }
    }, t.parseFragment = function() {
      var e = this._lexer.token;
      this.expectToken(p.SPREAD);
      var t = this.expectOptionalKeyword("on");
      return !t && this.peek(p.NAME) ? {
        kind: d.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(!1),
        loc: this.loc(e)
      } : {
        kind: d.INLINE_FRAGMENT,
        typeCondition: t ? this.parseNamedType() : void 0,
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(e)
      }
    }, t.parseFragmentDefinition = function() {
      var e, t = this._lexer.token;
      return this.expectKeyword("fragment"), !0 === (null === (e = this._options) || void 0 === e ? void 0 : e.experimentalFragmentVariables) ? {
        kind: d.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(t)
      } : {
        kind: d.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(!1),
        selectionSet: this.parseSelectionSet(),
        loc: this.loc(t)
      }
    }, t.parseFragmentName = function() {
      if ("on" === this._lexer.token.value) throw this.unexpected();
      return this.parseName()
    }, t.parseValueLiteral = function(e) {
      var t = this._lexer.token;
      switch (t.kind) {
        case p.BRACKET_L:
          return this.parseList(e);
        case p.BRACE_L:
          return this.parseObject(e);
        case p.INT:
          return this._lexer.advance(), {
            kind: d.INT,
            value: t.value,
            loc: this.loc(t)
          };
        case p.FLOAT:
          return this._lexer.advance(), {
            kind: d.FLOAT,
            value: t.value,
            loc: this.loc(t)
          };
        case p.STRING:
        case p.BLOCK_STRING:
          return this.parseStringLiteral();
        case p.NAME:
          switch (this._lexer.advance(), t.value) {
            case "true":
              return {
                kind: d.BOOLEAN, value: !0, loc: this.loc(t)
              };
            case "false":
              return {
                kind: d.BOOLEAN, value: !1, loc: this.loc(t)
              };
            case "null":
              return {
                kind: d.NULL, loc: this.loc(t)
              };
            default:
              return {
                kind: d.ENUM, value: t.value, loc: this.loc(t)
              }
          }
        case p.DOLLAR:
          if (!e) return this.parseVariable()
      }
      throw this.unexpected()
    }, t.parseStringLiteral = function() {
      var e = this._lexer.token;
      return this._lexer.advance(), {
        kind: d.STRING,
        value: e.value,
        block: e.kind === p.BLOCK_STRING,
        loc: this.loc(e)
      }
    }, t.parseList = function(e) {
      var t = this,
        r = this._lexer.token;
      return {
        kind: d.LIST,
        values: this.any(p.BRACKET_L, (function() {
          return t.parseValueLiteral(e)
        }), p.BRACKET_R),
        loc: this.loc(r)
      }
    }, t.parseObject = function(e) {
      var t = this,
        r = this._lexer.token;
      return {
        kind: d.OBJECT,
        fields: this.any(p.BRACE_L, (function() {
          return t.parseObjectField(e)
        }), p.BRACE_R),
        loc: this.loc(r)
      }
    }, t.parseObjectField = function(e) {
      var t = this._lexer.token,
        r = this.parseName();
      return this.expectToken(p.COLON), {
        kind: d.OBJECT_FIELD,
        name: r,
        value: this.parseValueLiteral(e),
        loc: this.loc(t)
      }
    }, t.parseDirectives = function(e) {
      for (var t = []; this.peek(p.AT);) t.push(this.parseDirective(e));
      return t
    }, t.parseDirective = function(e) {
      var t = this._lexer.token;
      return this.expectToken(p.AT), {
        kind: d.DIRECTIVE,
        name: this.parseName(),
        arguments: this.parseArguments(e),
        loc: this.loc(t)
      }
    }, t.parseTypeReference = function() {
      var e, t = this._lexer.token;
      return this.expectOptionalToken(p.BRACKET_L) ? (e = this.parseTypeReference(), this.expectToken(p.BRACKET_R), e = {
        kind: d.LIST_TYPE,
        type: e,
        loc: this.loc(t)
      }) : e = this.parseNamedType(), this.expectOptionalToken(p.BANG) ? {
        kind: d.NON_NULL_TYPE,
        type: e,
        loc: this.loc(t)
      } : e
    }, t.parseNamedType = function() {
      var e = this._lexer.token;
      return {
        kind: d.NAMED_TYPE,
        name: this.parseName(),
        loc: this.loc(e)
      }
    }, t.parseTypeSystemDefinition = function() {
      var e = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
      if (e.kind === p.NAME) switch (e.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition()
      }
      throw this.unexpected(e)
    }, t.peekDescription = function() {
      return this.peek(p.STRING) || this.peek(p.BLOCK_STRING)
    }, t.parseDescription = function() {
      if (this.peekDescription()) return this.parseStringLiteral()
    }, t.parseSchemaDefinition = function() {
      var e = this._lexer.token,
        t = this.parseDescription();
      this.expectKeyword("schema");
      var r = this.parseDirectives(!0),
        n = this.many(p.BRACE_L, this.parseOperationTypeDefinition, p.BRACE_R);
      return {
        kind: d.SCHEMA_DEFINITION,
        description: t,
        directives: r,
        operationTypes: n,
        loc: this.loc(e)
      }
    }, t.parseOperationTypeDefinition = function() {
      var e = this._lexer.token,
        t = this.parseOperationType();
      this.expectToken(p.COLON);
      var r = this.parseNamedType();
      return {
        kind: d.OPERATION_TYPE_DEFINITION,
        operation: t,
        type: r,
        loc: this.loc(e)
      }
    }, t.parseScalarTypeDefinition = function() {
      var e = this._lexer.token,
        t = this.parseDescription();
      this.expectKeyword("scalar");
      var r = this.parseName(),
        n = this.parseDirectives(!0);
      return {
        kind: d.SCALAR_TYPE_DEFINITION,
        description: t,
        name: r,
        directives: n,
        loc: this.loc(e)
      }
    }, t.parseObjectTypeDefinition = function() {
      var e = this._lexer.token,
        t = this.parseDescription();
      this.expectKeyword("type");
      var r = this.parseName(),
        n = this.parseImplementsInterfaces(),
        i = this.parseDirectives(!0),
        a = this.parseFieldsDefinition();
      return {
        kind: d.OBJECT_TYPE_DEFINITION,
        description: t,
        name: r,
        interfaces: n,
        directives: i,
        fields: a,
        loc: this.loc(e)
      }
    }, t.parseImplementsInterfaces = function() {
      var e = [];
      if (this.expectOptionalKeyword("implements")) {
        this.expectOptionalToken(p.AMP);
        do {
          var t;
          e.push(this.parseNamedType())
        } while (this.expectOptionalToken(p.AMP) || !0 === (null === (t = this._options) || void 0 === t ? void 0 : t.allowLegacySDLImplementsInterfaces) && this.peek(p.NAME))
      }
      return e
    }, t.parseFieldsDefinition = function() {
      var e;
      return !0 === (null === (e = this._options) || void 0 === e ? void 0 : e.allowLegacySDLEmptyFields) && this.peek(p.BRACE_L) && this._lexer.lookahead().kind === p.BRACE_R ? (this._lexer.advance(), this._lexer.advance(), []) : this.optionalMany(p.BRACE_L, this.parseFieldDefinition, p.BRACE_R)
    }, t.parseFieldDefinition = function() {
      var e = this._lexer.token,
        t = this.parseDescription(),
        r = this.parseName(),
        n = this.parseArgumentDefs();
      this.expectToken(p.COLON);
      var i = this.parseTypeReference(),
        a = this.parseDirectives(!0);
      return {
        kind: d.FIELD_DEFINITION,
        description: t,
        name: r,
        arguments: n,
        type: i,
        directives: a,
        loc: this.loc(e)
      }
    }, t.parseArgumentDefs = function() {
      return this.optionalMany(p.PAREN_L, this.parseInputValueDef, p.PAREN_R)
    }, t.parseInputValueDef = function() {
      var e = this._lexer.token,
        t = this.parseDescription(),
        r = this.parseName();
      this.expectToken(p.COLON);
      var n, i = this.parseTypeReference();
      this.expectOptionalToken(p.EQUALS) && (n = this.parseValueLiteral(!0));
      var a = this.parseDirectives(!0);
      return {
        kind: d.INPUT_VALUE_DEFINITION,
        description: t,
        name: r,
        type: i,
        defaultValue: n,
        directives: a,
        loc: this.loc(e)
      }
    }, t.parseInterfaceTypeDefinition = function() {
      var e = this._lexer.token,
        t = this.parseDescription();
      this.expectKeyword("interface");
      var r = this.parseName(),
        n = this.parseImplementsInterfaces(),
        i = this.parseDirectives(!0),
        a = this.parseFieldsDefinition();
      return {
        kind: d.INTERFACE_TYPE_DEFINITION,
        description: t,
        name: r,
        interfaces: n,
        directives: i,
        fields: a,
        loc: this.loc(e)
      }
    }, t.parseUnionTypeDefinition = function() {
      var e = this._lexer.token,
        t = this.parseDescription();
      this.expectKeyword("union");
      var r = this.parseName(),
        n = this.parseDirectives(!0),
        i = this.parseUnionMemberTypes();
      return {
        kind: d.UNION_TYPE_DEFINITION,
        description: t,
        name: r,
        directives: n,
        types: i,
        loc: this.loc(e)
      }
    }, t.parseUnionMemberTypes = function() {
      var e = [];
      if (this.expectOptionalToken(p.EQUALS)) {
        this.expectOptionalToken(p.PIPE);
        do {
          e.push(this.parseNamedType())
        } while (this.expectOptionalToken(p.PIPE))
      }
      return e
    }, t.parseEnumTypeDefinition = function() {
      var e = this._lexer.token,
        t = this.parseDescription();
      this.expectKeyword("enum");
      var r = this.parseName(),
        n = this.parseDirectives(!0),
        i = this.parseEnumValuesDefinition();
      return {
        kind: d.ENUM_TYPE_DEFINITION,
        description: t,
        name: r,
        directives: n,
        values: i,
        loc: this.loc(e)
      }
    }, t.parseEnumValuesDefinition = function() {
      return this.optionalMany(p.BRACE_L, this.parseEnumValueDefinition, p.BRACE_R)
    }, t.parseEnumValueDefinition = function() {
      var e = this._lexer.token,
        t = this.parseDescription(),
        r = this.parseName(),
        n = this.parseDirectives(!0);
      return {
        kind: d.ENUM_VALUE_DEFINITION,
        description: t,
        name: r,
        directives: n,
        loc: this.loc(e)
      }
    }, t.parseInputObjectTypeDefinition = function() {
      var e = this._lexer.token,
        t = this.parseDescription();
      this.expectKeyword("input");
      var r = this.parseName(),
        n = this.parseDirectives(!0),
        i = this.parseInputFieldsDefinition();
      return {
        kind: d.INPUT_OBJECT_TYPE_DEFINITION,
        description: t,
        name: r,
        directives: n,
        fields: i,
        loc: this.loc(e)
      }
    }, t.parseInputFieldsDefinition = function() {
      return this.optionalMany(p.BRACE_L, this.parseInputValueDef, p.BRACE_R)
    }, t.parseTypeSystemExtension = function() {
      var e = this._lexer.lookahead();
      if (e.kind === p.NAME) switch (e.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension()
      }
      throw this.unexpected(e)
    }, t.parseSchemaExtension = function() {
      var e = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("schema");
      var t = this.parseDirectives(!0),
        r = this.optionalMany(p.BRACE_L, this.parseOperationTypeDefinition, p.BRACE_R);
      if (0 === t.length && 0 === r.length) throw this.unexpected();
      return {
        kind: d.SCHEMA_EXTENSION,
        directives: t,
        operationTypes: r,
        loc: this.loc(e)
      }
    }, t.parseScalarTypeExtension = function() {
      var e = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("scalar");
      var t = this.parseName(),
        r = this.parseDirectives(!0);
      if (0 === r.length) throw this.unexpected();
      return {
        kind: d.SCALAR_TYPE_EXTENSION,
        name: t,
        directives: r,
        loc: this.loc(e)
      }
    }, t.parseObjectTypeExtension = function() {
      var e = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("type");
      var t = this.parseName(),
        r = this.parseImplementsInterfaces(),
        n = this.parseDirectives(!0),
        i = this.parseFieldsDefinition();
      if (0 === r.length && 0 === n.length && 0 === i.length) throw this.unexpected();
      return {
        kind: d.OBJECT_TYPE_EXTENSION,
        name: t,
        interfaces: r,
        directives: n,
        fields: i,
        loc: this.loc(e)
      }
    }, t.parseInterfaceTypeExtension = function() {
      var e = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("interface");
      var t = this.parseName(),
        r = this.parseImplementsInterfaces(),
        n = this.parseDirectives(!0),
        i = this.parseFieldsDefinition();
      if (0 === r.length && 0 === n.length && 0 === i.length) throw this.unexpected();
      return {
        kind: d.INTERFACE_TYPE_EXTENSION,
        name: t,
        interfaces: r,
        directives: n,
        fields: i,
        loc: this.loc(e)
      }
    }, t.parseUnionTypeExtension = function() {
      var e = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("union");
      var t = this.parseName(),
        r = this.parseDirectives(!0),
        n = this.parseUnionMemberTypes();
      if (0 === r.length && 0 === n.length) throw this.unexpected();
      return {
        kind: d.UNION_TYPE_EXTENSION,
        name: t,
        directives: r,
        types: n,
        loc: this.loc(e)
      }
    }, t.parseEnumTypeExtension = function() {
      var e = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("enum");
      var t = this.parseName(),
        r = this.parseDirectives(!0),
        n = this.parseEnumValuesDefinition();
      if (0 === r.length && 0 === n.length) throw this.unexpected();
      return {
        kind: d.ENUM_TYPE_EXTENSION,
        name: t,
        directives: r,
        values: n,
        loc: this.loc(e)
      }
    }, t.parseInputObjectTypeExtension = function() {
      var e = this._lexer.token;
      this.expectKeyword("extend"), this.expectKeyword("input");
      var t = this.parseName(),
        r = this.parseDirectives(!0),
        n = this.parseInputFieldsDefinition();
      if (0 === r.length && 0 === n.length) throw this.unexpected();
      return {
        kind: d.INPUT_OBJECT_TYPE_EXTENSION,
        name: t,
        directives: r,
        fields: n,
        loc: this.loc(e)
      }
    }, t.parseDirectiveDefinition = function() {
      var e = this._lexer.token,
        t = this.parseDescription();
      this.expectKeyword("directive"), this.expectToken(p.AT);
      var r = this.parseName(),
        n = this.parseArgumentDefs(),
        i = this.expectOptionalKeyword("repeatable");
      this.expectKeyword("on");
      var a = this.parseDirectiveLocations();
      return {
        kind: d.DIRECTIVE_DEFINITION,
        description: t,
        name: r,
        arguments: n,
        repeatable: i,
        locations: a,
        loc: this.loc(e)
      }
    }, t.parseDirectiveLocations = function() {
      this.expectOptionalToken(p.PIPE);
      var e = [];
      do {
        e.push(this.parseDirectiveLocation())
      } while (this.expectOptionalToken(p.PIPE));
      return e
    }, t.parseDirectiveLocation = function() {
      var e = this._lexer.token,
        t = this.parseName();
      if (void 0 !== V[t.value]) return t;
      throw this.unexpected(e)
    }, t.loc = function(e) {
      var t;
      if (!0 !== (null === (t = this._options) || void 0 === t ? void 0 : t.noLocation)) return new R(e, this._lexer.lastToken, this._lexer.source)
    }, t.peek = function(e) {
      return this._lexer.token.kind === e
    }, t.expectToken = function(e) {
      var t = this._lexer.token;
      if (t.kind === e) return this._lexer.advance(), t;
      throw x(this._lexer.source, t.start, "Expected ".concat($(e), ", found ").concat(X(t), "."))
    }, t.expectOptionalToken = function(e) {
      var t = this._lexer.token;
      if (t.kind === e) return this._lexer.advance(), t
    }, t.expectKeyword = function(e) {
      var t = this._lexer.token;
      if (t.kind !== p.NAME || t.value !== e) throw x(this._lexer.source, t.start, 'Expected "'.concat(e, '", found ').concat(X(t), "."));
      this._lexer.advance()
    }, t.expectOptionalKeyword = function(e) {
      var t = this._lexer.token;
      return t.kind === p.NAME && t.value === e && (this._lexer.advance(), !0)
    }, t.unexpected = function(e) {
      var t = null != e ? e : this._lexer.token;
      return x(this._lexer.source, t.start, "Unexpected ".concat(X(t), "."))
    }, t.any = function(e, t, r) {
      this.expectToken(e);
      for (var n = []; !this.expectOptionalToken(r);) n.push(t.call(this));
      return n
    }, t.optionalMany = function(e, t, r) {
      if (this.expectOptionalToken(e)) {
        var n = [];
        do {
          n.push(t.call(this))
        } while (!this.expectOptionalToken(r));
        return n
      }
      return []
    }, t.many = function(e, t, r) {
      this.expectToken(e);
      var n = [];
      do {
        n.push(t.call(this))
      } while (!this.expectOptionalToken(r));
      return n
    }, e
  }();

  function X(e) {
    var t = e.value;
    return $(e.kind) + (null != t ? ' "'.concat(t, '"') : "")
  }

  function $(e) {
    return function(e) {
      return e === p.BANG || e === p.DOLLAR || e === p.AMP || e === p.PAREN_L || e === p.PAREN_R || e === p.SPREAD || e === p.COLON || e === p.EQUALS || e === p.AT || e === p.BRACKET_L || e === p.BRACKET_R || e === p.BRACE_L || e === p.PIPE || e === p.BRACE_R
    }(e) ? '"'.concat(e, '"') : e
  }
  var Y = {
      Name: [],
      Document: ["definitions"],
      OperationDefinition: ["name", "variableDefinitions", "directives", "selectionSet"],
      VariableDefinition: ["variable", "type", "defaultValue", "directives"],
      Variable: ["name"],
      SelectionSet: ["selections"],
      Field: ["alias", "name", "arguments", "directives", "selectionSet"],
      Argument: ["name", "value"],
      FragmentSpread: ["name", "directives"],
      InlineFragment: ["typeCondition", "directives", "selectionSet"],
      FragmentDefinition: ["name", "variableDefinitions", "typeCondition", "directives", "selectionSet"],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ["values"],
      ObjectValue: ["fields"],
      ObjectField: ["name", "value"],
      Directive: ["name", "arguments"],
      NamedType: ["name"],
      ListType: ["type"],
      NonNullType: ["type"],
      SchemaDefinition: ["description", "directives", "operationTypes"],
      OperationTypeDefinition: ["type"],
      ScalarTypeDefinition: ["description", "name", "directives"],
      ObjectTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
      FieldDefinition: ["description", "name", "arguments", "type", "directives"],
      InputValueDefinition: ["description", "name", "type", "defaultValue", "directives"],
      InterfaceTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
      UnionTypeDefinition: ["description", "name", "directives", "types"],
      EnumTypeDefinition: ["description", "name", "directives", "values"],
      EnumValueDefinition: ["description", "name", "directives"],
      InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
      DirectiveDefinition: ["description", "name", "arguments", "locations"],
      SchemaExtension: ["directives", "operationTypes"],
      ScalarTypeExtension: ["name", "directives"],
      ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
      InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
      UnionTypeExtension: ["name", "directives", "types"],
      EnumTypeExtension: ["name", "directives", "values"],
      InputObjectTypeExtension: ["name", "directives", "fields"]
    },
    J = Object.freeze({});

  function W(e, t) {
    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Y,
      n = void 0,
      i = Array.isArray(e),
      a = [e],
      s = -1,
      o = [],
      u = void 0,
      c = void 0,
      l = void 0,
      h = [],
      d = [],
      p = e;
    do {
      var f = ++s === a.length,
        g = f && 0 !== o.length;
      if (f) {
        if (c = 0 === d.length ? void 0 : h[h.length - 1], u = l, l = d.pop(), g) {
          if (i) u = u.slice();
          else {
            for (var m = {}, y = 0, b = Object.keys(u); y < b.length; y++) {
              var _ = b[y];
              m[_] = u[_]
            }
            u = m
          }
          for (var v = 0, w = 0; w < o.length; w++) {
            var S = o[w][0],
              T = o[w][1];
            i && (S -= v), i && null === T ? (u.splice(S, 1), v++) : u[S] = T
          }
        }
        s = n.index, a = n.keys, o = n.edits, i = n.inArray, n = n.prev
      } else {
        if (c = l ? i ? s : a[s] : void 0, null == (u = l ? l[c] : p)) continue;
        l && h.push(c)
      }
      var E, x = void 0;
      if (!Array.isArray(u)) {
        if (!N(u)) throw new Error("Invalid AST Node: ".concat(q(u), "."));
        var O = Z(t, u.kind, f);
        if (O) {
          if ((x = O.call(t, u, c, l, h, d)) === J) break;
          if (!1 === x) {
            if (!f) {
              h.pop();
              continue
            }
          } else if (void 0 !== x && (o.push([c, x]), !f)) {
            if (!N(x)) {
              h.pop();
              continue
            }
            u = x
          }
        }
      }
      if (void 0 === x && g && o.push([c, u]), f) h.pop();
      else n = {
        inArray: i,
        index: s,
        keys: a,
        edits: o,
        prev: n
      }, a = (i = Array.isArray(u)) ? u : null !== (E = r[u.kind]) && void 0 !== E ? E : [], s = -1, o = [], l && d.push(l), l = u
    } while (void 0 !== n);
    return 0 !== o.length && (p = o[o.length - 1][1]), p
  }

  function K(e) {
    var t = new Array(e.length);
    return {
      enter: function(r) {
        for (var n = 0; n < e.length; n++)
          if (null == t[n]) {
            var i = Z(e[n], r.kind, !1);
            if (i) {
              var a = i.apply(e[n], arguments);
              if (!1 === a) t[n] = r;
              else if (a === J) t[n] = J;
              else if (void 0 !== a) return a
            }
          }
      },
      leave: function(r) {
        for (var n = 0; n < e.length; n++)
          if (null == t[n]) {
            var i = Z(e[n], r.kind, !0);
            if (i) {
              var a = i.apply(e[n], arguments);
              if (a === J) t[n] = J;
              else if (void 0 !== a && !1 !== a) return a
            }
          } else t[n] === r && (t[n] = null)
      }
    }
  }

  function Z(e, t, r) {
    var n = e[t];
    if (n) {
      if (!r && "function" == typeof n) return n;
      var i = r ? n.leave : n.enter;
      if ("function" == typeof i) return i
    } else {
      var a = r ? e.leave : e.enter;
      if (a) {
        if ("function" == typeof a) return a;
        var s = a[t];
        if ("function" == typeof s) return s
      }
    }
  }

  function ee(e) {
    return W(e, {
      leave: te
    })
  }
  var te = {
    Name: function(e) {
      return e.value
    },
    Variable: function(e) {
      return "$" + e.name
    },
    Document: function(e) {
      return ne(e.definitions, "\n\n") + "\n"
    },
    OperationDefinition: function(e) {
      var t = e.operation,
        r = e.name,
        n = ae("(", ne(e.variableDefinitions, ", "), ")"),
        i = ne(e.directives, " "),
        a = e.selectionSet;
      return r || i || n || "query" !== t ? ne([t, ne([r, n]), i, a], " ") : a
    },
    VariableDefinition: function(e) {
      var t = e.variable,
        r = e.type,
        n = e.defaultValue,
        i = e.directives;
      return t + ": " + r + ae(" = ", n) + ae(" ", ne(i, " "))
    },
    SelectionSet: function(e) {
      return ie(e.selections)
    },
    Field: function(e) {
      var t = e.alias,
        r = e.name,
        n = e.arguments,
        i = e.directives,
        a = e.selectionSet;
      return ne([ae("", t, ": ") + r + ae("(", ne(n, ", "), ")"), ne(i, " "), a], " ")
    },
    Argument: function(e) {
      return e.name + ": " + e.value
    },
    FragmentSpread: function(e) {
      return "..." + e.name + ae(" ", ne(e.directives, " "))
    },
    InlineFragment: function(e) {
      var t = e.typeCondition,
        r = e.directives,
        n = e.selectionSet;
      return ne(["...", ae("on ", t), ne(r, " "), n], " ")
    },
    FragmentDefinition: function(e) {
      var t = e.name,
        r = e.typeCondition,
        n = e.variableDefinitions,
        i = e.directives,
        a = e.selectionSet;
      return "fragment ".concat(t).concat(ae("(", ne(n, ", "), ")"), " ") + "on ".concat(r, " ").concat(ae("", ne(i, " "), " ")) + a
    },
    IntValue: function(e) {
      return e.value
    },
    FloatValue: function(e) {
      return e.value
    },
    StringValue: function(e, t) {
      var r = e.value;
      return e.block ? function(e) {
        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "",
          r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
          n = -1 === e.indexOf("\n"),
          i = " " === e[0] || "\t" === e[0],
          a = '"' === e[e.length - 1],
          s = "\\" === e[e.length - 1],
          o = !n || a || s || r,
          u = "";
        return !o || n && i || (u += "\n" + t), u += t ? e.replace(/\n/g, "\n" + t) : e, o && (u += "\n"), '"""' + u.replace(/"""/g, '\\"""') + '"""'
      }(r, "description" === t ? "" : "  ") : JSON.stringify(r)
    },
    BooleanValue: function(e) {
      return e.value ? "true" : "false"
    },
    NullValue: function() {
      return "null"
    },
    EnumValue: function(e) {
      return e.value
    },
    ListValue: function(e) {
      return "[" + ne(e.values, ", ") + "]"
    },
    ObjectValue: function(e) {
      return "{" + ne(e.fields, ", ") + "}"
    },
    ObjectField: function(e) {
      return e.name + ": " + e.value
    },
    Directive: function(e) {
      return "@" + e.name + ae("(", ne(e.arguments, ", "), ")")
    },
    NamedType: function(e) {
      return e.name
    },
    ListType: function(e) {
      return "[" + e.type + "]"
    },
    NonNullType: function(e) {
      return e.type + "!"
    },
    SchemaDefinition: re((function(e) {
      var t = e.directives,
        r = e.operationTypes;
      return ne(["schema", ne(t, " "), ie(r)], " ")
    })),
    OperationTypeDefinition: function(e) {
      return e.operation + ": " + e.type
    },
    ScalarTypeDefinition: re((function(e) {
      return ne(["scalar", e.name, ne(e.directives, " ")], " ")
    })),
    ObjectTypeDefinition: re((function(e) {
      var t = e.name,
        r = e.interfaces,
        n = e.directives,
        i = e.fields;
      return ne(["type", t, ae("implements ", ne(r, " & ")), ne(n, " "), ie(i)], " ")
    })),
    FieldDefinition: re((function(e) {
      var t = e.name,
        r = e.arguments,
        n = e.type,
        i = e.directives;
      return t + (ue(r) ? ae("(\n", se(ne(r, "\n")), "\n)") : ae("(", ne(r, ", "), ")")) + ": " + n + ae(" ", ne(i, " "))
    })),
    InputValueDefinition: re((function(e) {
      var t = e.name,
        r = e.type,
        n = e.defaultValue,
        i = e.directives;
      return ne([t + ": " + r, ae("= ", n), ne(i, " ")], " ")
    })),
    InterfaceTypeDefinition: re((function(e) {
      var t = e.name,
        r = e.interfaces,
        n = e.directives,
        i = e.fields;
      return ne(["interface", t, ae("implements ", ne(r, " & ")), ne(n, " "), ie(i)], " ")
    })),
    UnionTypeDefinition: re((function(e) {
      var t = e.name,
        r = e.directives,
        n = e.types;
      return ne(["union", t, ne(r, " "), n && 0 !== n.length ? "= " + ne(n, " | ") : ""], " ")
    })),
    EnumTypeDefinition: re((function(e) {
      var t = e.name,
        r = e.directives,
        n = e.values;
      return ne(["enum", t, ne(r, " "), ie(n)], " ")
    })),
    EnumValueDefinition: re((function(e) {
      return ne([e.name, ne(e.directives, " ")], " ")
    })),
    InputObjectTypeDefinition: re((function(e) {
      var t = e.name,
        r = e.directives,
        n = e.fields;
      return ne(["input", t, ne(r, " "), ie(n)], " ")
    })),
    DirectiveDefinition: re((function(e) {
      var t = e.name,
        r = e.arguments,
        n = e.repeatable,
        i = e.locations;
      return "directive @" + t + (ue(r) ? ae("(\n", se(ne(r, "\n")), "\n)") : ae("(", ne(r, ", "), ")")) + (n ? " repeatable" : "") + " on " + ne(i, " | ")
    })),
    SchemaExtension: function(e) {
      var t = e.directives,
        r = e.operationTypes;
      return ne(["extend schema", ne(t, " "), ie(r)], " ")
    },
    ScalarTypeExtension: function(e) {
      return ne(["extend scalar", e.name, ne(e.directives, " ")], " ")
    },
    ObjectTypeExtension: function(e) {
      var t = e.name,
        r = e.interfaces,
        n = e.directives,
        i = e.fields;
      return ne(["extend type", t, ae("implements ", ne(r, " & ")), ne(n, " "), ie(i)], " ")
    },
    InterfaceTypeExtension: function(e) {
      var t = e.name,
        r = e.interfaces,
        n = e.directives,
        i = e.fields;
      return ne(["extend interface", t, ae("implements ", ne(r, " & ")), ne(n, " "), ie(i)], " ")
    },
    UnionTypeExtension: function(e) {
      var t = e.name,
        r = e.directives,
        n = e.types;
      return ne(["extend union", t, ne(r, " "), n && 0 !== n.length ? "= " + ne(n, " | ") : ""], " ")
    },
    EnumTypeExtension: function(e) {
      var t = e.name,
        r = e.directives,
        n = e.values;
      return ne(["extend enum", t, ne(r, " "), ie(n)], " ")
    },
    InputObjectTypeExtension: function(e) {
      var t = e.name,
        r = e.directives,
        n = e.fields;
      return ne(["extend input", t, ne(r, " "), ie(n)], " ")
    }
  };

  function re(e) {
    return function(t) {
      return ne([t.description, e(t)], "\n")
    }
  }

  function ne(e) {
    var t, r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
    return null !== (t = null == e ? void 0 : e.filter((function(e) {
      return e
    })).join(r)) && void 0 !== t ? t : ""
  }

  function ie(e) {
    return e && 0 !== e.length ? "{\n" + se(ne(e, "\n")) + "\n}" : ""
  }

  function ae(e, t) {
    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
    return t ? e + t + r : ""
  }

  function se(e) {
    return e && "  " + e.replace(/\n/g, "\n  ")
  }

  function oe(e) {
    return -1 !== e.indexOf("\n")
  }

  function ue(e) {
    return e && e.some(oe)
  }

  function ce(e) {
    return le(e) || fe(e) || me(e)
  }

  function le(e) {
    return e.kind === d.OPERATION_DEFINITION || e.kind === d.FRAGMENT_DEFINITION
  }

  function he(e) {
    return e.kind === d.FIELD || e.kind === d.FRAGMENT_SPREAD || e.kind === d.INLINE_FRAGMENT
  }

  function de(e) {
    return e.kind === d.VARIABLE || e.kind === d.INT || e.kind === d.FLOAT || e.kind === d.STRING || e.kind === d.BOOLEAN || e.kind === d.NULL || e.kind === d.ENUM || e.kind === d.LIST || e.kind === d.OBJECT
  }

  function pe(e) {
    return e.kind === d.NAMED_TYPE || e.kind === d.LIST_TYPE || e.kind === d.NON_NULL_TYPE
  }

  function fe(e) {
    return e.kind === d.SCHEMA_DEFINITION || ge(e) || e.kind === d.DIRECTIVE_DEFINITION
  }

  function ge(e) {
    return e.kind === d.SCALAR_TYPE_DEFINITION || e.kind === d.OBJECT_TYPE_DEFINITION || e.kind === d.INTERFACE_TYPE_DEFINITION || e.kind === d.UNION_TYPE_DEFINITION || e.kind === d.ENUM_TYPE_DEFINITION || e.kind === d.INPUT_OBJECT_TYPE_DEFINITION
  }

  function me(e) {
    return e.kind === d.SCHEMA_EXTENSION || ye(e)
  }

  function ye(e) {
    return e.kind === d.SCALAR_TYPE_EXTENSION || e.kind === d.OBJECT_TYPE_EXTENSION || e.kind === d.INTERFACE_TYPE_EXTENSION || e.kind === d.UNION_TYPE_EXTENSION || e.kind === d.ENUM_TYPE_EXTENSION || e.kind === d.INPUT_OBJECT_TYPE_EXTENSION
  }
}]);
exports.Comunica = Comunica;
